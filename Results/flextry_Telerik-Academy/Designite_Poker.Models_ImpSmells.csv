Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,Cyclomatic complexity of the method is 17
Complex Method,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,Cyclomatic complexity of the method is 12
Long Statement,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The length of the statement  "			var secondOtherCards = secondGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray (); " is 120.
Long Statement,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,IsStraight,The length of the statement  "	bool isStraight = cardsSortedByFace [cardsSortedByFace.Length - 1].Face - cardsSortedByFace [0].Face == 4 || (cardsSortedByFace [cardsSortedByFace.Length - 1].Face == CardFace.Ace && cardsSortedByFace [cardsSortedByFace.Length - 2].Face == CardFace.Five); " is 255.
Long Statement,Poker.Models.Utils,EnumExtension,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\Utils\EnumExtension.cs,Description,The length of the statement  "	var element = (DescriptionAttribute[])(value.GetType ().GetField (value.ToString ())).GetCustomAttributes (typeof(DescriptionAttribute)' false); " is 144.
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: if (firstHandType > secondHandType) {  	comparisonResult = 1;  } else if (firstHandType < secondHandType) {  	comparisonResult = -1;  } else if (firstHandType == HandType.OnePair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  	if (comparisonResult == 0) {  		var firstOtherCards = firstGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray ();  		var secondOtherCards = secondGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray ();  		for (int i = 0; i < firstOtherCards.Length; i++) {  			var comparison = firstOtherCards [i].Face.CompareTo (secondOtherCards [i].Face);  			if (comparison != 0) {  				comparisonResult = comparison;  				break;  			}  		}  	}  } else if (firstHandType == HandType.TwoPair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var firstHandCards = new List<ICard> ();  	firstHandCards.Add (firstGroupedByFace [0].First ());  	firstHandCards.Add (firstGroupedByFace [1].First ());  	firstHandCards = firstHandCards.OrderByDescending (c => c.Face).ToList ();  	firstHandCards.Add (firstGroupedByFace [2].First ());  	var secondHandCards = new List<ICard> ();  	secondHandCards.Add (secondGroupedByFace [0].First ());  	secondHandCards.Add (secondGroupedByFace [1].First ());  	secondHandCards = secondHandCards.OrderByDescending (c => c.Face).ToList ();  	secondHandCards.Add (secondGroupedByFace [2].First ());  	comparisonResult = firstHandCards [0].Face.CompareTo (secondHandCards [0].Face);  	if (comparisonResult == 0) {  		comparisonResult = firstHandCards [1].Face.CompareTo (secondHandCards [1].Face);  		if (comparisonResult == 0) {  			comparisonResult = firstHandCards [2].Face.CompareTo (secondHandCards [2].Face);  		}  	}  } else if (firstHandType == HandType.FullHouse) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Flush || firstHandType == HandType.HighCard) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	for (int i = 0; i < firstSortedByFace.Length; i++) {  		var comparison = firstSortedByFace [i].Face.CompareTo (secondSortedByFace [i].Face);  		if (comparison != 0) {  			comparisonResult = comparison;  			break;  		}  	}  } else if (firstHandType == HandType.ThreeOfAKind || firstHandType == HandType.FourOfAKind) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Straight || firstHandType == HandType.StraightFlush) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	comparisonResult = firstSortedByFace [0].Face.CompareTo (secondSortedByFace [0].Face);  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: if (firstHandType > secondHandType) {  	comparisonResult = 1;  } else if (firstHandType < secondHandType) {  	comparisonResult = -1;  } else if (firstHandType == HandType.OnePair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  	if (comparisonResult == 0) {  		var firstOtherCards = firstGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray ();  		var secondOtherCards = secondGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray ();  		for (int i = 0; i < firstOtherCards.Length; i++) {  			var comparison = firstOtherCards [i].Face.CompareTo (secondOtherCards [i].Face);  			if (comparison != 0) {  				comparisonResult = comparison;  				break;  			}  		}  	}  } else if (firstHandType == HandType.TwoPair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var firstHandCards = new List<ICard> ();  	firstHandCards.Add (firstGroupedByFace [0].First ());  	firstHandCards.Add (firstGroupedByFace [1].First ());  	firstHandCards = firstHandCards.OrderByDescending (c => c.Face).ToList ();  	firstHandCards.Add (firstGroupedByFace [2].First ());  	var secondHandCards = new List<ICard> ();  	secondHandCards.Add (secondGroupedByFace [0].First ());  	secondHandCards.Add (secondGroupedByFace [1].First ());  	secondHandCards = secondHandCards.OrderByDescending (c => c.Face).ToList ();  	secondHandCards.Add (secondGroupedByFace [2].First ());  	comparisonResult = firstHandCards [0].Face.CompareTo (secondHandCards [0].Face);  	if (comparisonResult == 0) {  		comparisonResult = firstHandCards [1].Face.CompareTo (secondHandCards [1].Face);  		if (comparisonResult == 0) {  			comparisonResult = firstHandCards [2].Face.CompareTo (secondHandCards [2].Face);  		}  	}  } else if (firstHandType == HandType.FullHouse) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Flush || firstHandType == HandType.HighCard) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	for (int i = 0; i < firstSortedByFace.Length; i++) {  		var comparison = firstSortedByFace [i].Face.CompareTo (secondSortedByFace [i].Face);  		if (comparison != 0) {  			comparisonResult = comparison;  			break;  		}  	}  } else if (firstHandType == HandType.ThreeOfAKind || firstHandType == HandType.FourOfAKind) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Straight || firstHandType == HandType.StraightFlush) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	comparisonResult = firstSortedByFace [0].Face.CompareTo (secondSortedByFace [0].Face);  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: if (firstHandType > secondHandType) {  	comparisonResult = 1;  } else if (firstHandType < secondHandType) {  	comparisonResult = -1;  } else if (firstHandType == HandType.OnePair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  	if (comparisonResult == 0) {  		var firstOtherCards = firstGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray ();  		var secondOtherCards = secondGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray ();  		for (int i = 0; i < firstOtherCards.Length; i++) {  			var comparison = firstOtherCards [i].Face.CompareTo (secondOtherCards [i].Face);  			if (comparison != 0) {  				comparisonResult = comparison;  				break;  			}  		}  	}  } else if (firstHandType == HandType.TwoPair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var firstHandCards = new List<ICard> ();  	firstHandCards.Add (firstGroupedByFace [0].First ());  	firstHandCards.Add (firstGroupedByFace [1].First ());  	firstHandCards = firstHandCards.OrderByDescending (c => c.Face).ToList ();  	firstHandCards.Add (firstGroupedByFace [2].First ());  	var secondHandCards = new List<ICard> ();  	secondHandCards.Add (secondGroupedByFace [0].First ());  	secondHandCards.Add (secondGroupedByFace [1].First ());  	secondHandCards = secondHandCards.OrderByDescending (c => c.Face).ToList ();  	secondHandCards.Add (secondGroupedByFace [2].First ());  	comparisonResult = firstHandCards [0].Face.CompareTo (secondHandCards [0].Face);  	if (comparisonResult == 0) {  		comparisonResult = firstHandCards [1].Face.CompareTo (secondHandCards [1].Face);  		if (comparisonResult == 0) {  			comparisonResult = firstHandCards [2].Face.CompareTo (secondHandCards [2].Face);  		}  	}  } else if (firstHandType == HandType.FullHouse) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Flush || firstHandType == HandType.HighCard) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	for (int i = 0; i < firstSortedByFace.Length; i++) {  		var comparison = firstSortedByFace [i].Face.CompareTo (secondSortedByFace [i].Face);  		if (comparison != 0) {  			comparisonResult = comparison;  			break;  		}  	}  } else if (firstHandType == HandType.ThreeOfAKind || firstHandType == HandType.FourOfAKind) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Straight || firstHandType == HandType.StraightFlush) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	comparisonResult = firstSortedByFace [0].Face.CompareTo (secondSortedByFace [0].Face);  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: if (firstHandType > secondHandType) {  	comparisonResult = 1;  } else if (firstHandType < secondHandType) {  	comparisonResult = -1;  } else if (firstHandType == HandType.OnePair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  	if (comparisonResult == 0) {  		var firstOtherCards = firstGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray ();  		var secondOtherCards = secondGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray ();  		for (int i = 0; i < firstOtherCards.Length; i++) {  			var comparison = firstOtherCards [i].Face.CompareTo (secondOtherCards [i].Face);  			if (comparison != 0) {  				comparisonResult = comparison;  				break;  			}  		}  	}  } else if (firstHandType == HandType.TwoPair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var firstHandCards = new List<ICard> ();  	firstHandCards.Add (firstGroupedByFace [0].First ());  	firstHandCards.Add (firstGroupedByFace [1].First ());  	firstHandCards = firstHandCards.OrderByDescending (c => c.Face).ToList ();  	firstHandCards.Add (firstGroupedByFace [2].First ());  	var secondHandCards = new List<ICard> ();  	secondHandCards.Add (secondGroupedByFace [0].First ());  	secondHandCards.Add (secondGroupedByFace [1].First ());  	secondHandCards = secondHandCards.OrderByDescending (c => c.Face).ToList ();  	secondHandCards.Add (secondGroupedByFace [2].First ());  	comparisonResult = firstHandCards [0].Face.CompareTo (secondHandCards [0].Face);  	if (comparisonResult == 0) {  		comparisonResult = firstHandCards [1].Face.CompareTo (secondHandCards [1].Face);  		if (comparisonResult == 0) {  			comparisonResult = firstHandCards [2].Face.CompareTo (secondHandCards [2].Face);  		}  	}  } else if (firstHandType == HandType.FullHouse) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Flush || firstHandType == HandType.HighCard) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	for (int i = 0; i < firstSortedByFace.Length; i++) {  		var comparison = firstSortedByFace [i].Face.CompareTo (secondSortedByFace [i].Face);  		if (comparison != 0) {  			comparisonResult = comparison;  			break;  		}  	}  } else if (firstHandType == HandType.ThreeOfAKind || firstHandType == HandType.FourOfAKind) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Straight || firstHandType == HandType.StraightFlush) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	comparisonResult = firstSortedByFace [0].Face.CompareTo (secondSortedByFace [0].Face);  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: if (firstHandType < secondHandType) {  	comparisonResult = -1;  } else if (firstHandType == HandType.OnePair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  	if (comparisonResult == 0) {  		var firstOtherCards = firstGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray ();  		var secondOtherCards = secondGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray ();  		for (int i = 0; i < firstOtherCards.Length; i++) {  			var comparison = firstOtherCards [i].Face.CompareTo (secondOtherCards [i].Face);  			if (comparison != 0) {  				comparisonResult = comparison;  				break;  			}  		}  	}  } else if (firstHandType == HandType.TwoPair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var firstHandCards = new List<ICard> ();  	firstHandCards.Add (firstGroupedByFace [0].First ());  	firstHandCards.Add (firstGroupedByFace [1].First ());  	firstHandCards = firstHandCards.OrderByDescending (c => c.Face).ToList ();  	firstHandCards.Add (firstGroupedByFace [2].First ());  	var secondHandCards = new List<ICard> ();  	secondHandCards.Add (secondGroupedByFace [0].First ());  	secondHandCards.Add (secondGroupedByFace [1].First ());  	secondHandCards = secondHandCards.OrderByDescending (c => c.Face).ToList ();  	secondHandCards.Add (secondGroupedByFace [2].First ());  	comparisonResult = firstHandCards [0].Face.CompareTo (secondHandCards [0].Face);  	if (comparisonResult == 0) {  		comparisonResult = firstHandCards [1].Face.CompareTo (secondHandCards [1].Face);  		if (comparisonResult == 0) {  			comparisonResult = firstHandCards [2].Face.CompareTo (secondHandCards [2].Face);  		}  	}  } else if (firstHandType == HandType.FullHouse) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Flush || firstHandType == HandType.HighCard) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	for (int i = 0; i < firstSortedByFace.Length; i++) {  		var comparison = firstSortedByFace [i].Face.CompareTo (secondSortedByFace [i].Face);  		if (comparison != 0) {  			comparisonResult = comparison;  			break;  		}  	}  } else if (firstHandType == HandType.ThreeOfAKind || firstHandType == HandType.FourOfAKind) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Straight || firstHandType == HandType.StraightFlush) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	comparisonResult = firstSortedByFace [0].Face.CompareTo (secondSortedByFace [0].Face);  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: if (firstHandType < secondHandType) {  	comparisonResult = -1;  } else if (firstHandType == HandType.OnePair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  	if (comparisonResult == 0) {  		var firstOtherCards = firstGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray ();  		var secondOtherCards = secondGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray ();  		for (int i = 0; i < firstOtherCards.Length; i++) {  			var comparison = firstOtherCards [i].Face.CompareTo (secondOtherCards [i].Face);  			if (comparison != 0) {  				comparisonResult = comparison;  				break;  			}  		}  	}  } else if (firstHandType == HandType.TwoPair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var firstHandCards = new List<ICard> ();  	firstHandCards.Add (firstGroupedByFace [0].First ());  	firstHandCards.Add (firstGroupedByFace [1].First ());  	firstHandCards = firstHandCards.OrderByDescending (c => c.Face).ToList ();  	firstHandCards.Add (firstGroupedByFace [2].First ());  	var secondHandCards = new List<ICard> ();  	secondHandCards.Add (secondGroupedByFace [0].First ());  	secondHandCards.Add (secondGroupedByFace [1].First ());  	secondHandCards = secondHandCards.OrderByDescending (c => c.Face).ToList ();  	secondHandCards.Add (secondGroupedByFace [2].First ());  	comparisonResult = firstHandCards [0].Face.CompareTo (secondHandCards [0].Face);  	if (comparisonResult == 0) {  		comparisonResult = firstHandCards [1].Face.CompareTo (secondHandCards [1].Face);  		if (comparisonResult == 0) {  			comparisonResult = firstHandCards [2].Face.CompareTo (secondHandCards [2].Face);  		}  	}  } else if (firstHandType == HandType.FullHouse) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Flush || firstHandType == HandType.HighCard) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	for (int i = 0; i < firstSortedByFace.Length; i++) {  		var comparison = firstSortedByFace [i].Face.CompareTo (secondSortedByFace [i].Face);  		if (comparison != 0) {  			comparisonResult = comparison;  			break;  		}  	}  } else if (firstHandType == HandType.ThreeOfAKind || firstHandType == HandType.FourOfAKind) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Straight || firstHandType == HandType.StraightFlush) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	comparisonResult = firstSortedByFace [0].Face.CompareTo (secondSortedByFace [0].Face);  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: if (firstHandType < secondHandType) {  	comparisonResult = -1;  } else if (firstHandType == HandType.OnePair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  	if (comparisonResult == 0) {  		var firstOtherCards = firstGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray ();  		var secondOtherCards = secondGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray ();  		for (int i = 0; i < firstOtherCards.Length; i++) {  			var comparison = firstOtherCards [i].Face.CompareTo (secondOtherCards [i].Face);  			if (comparison != 0) {  				comparisonResult = comparison;  				break;  			}  		}  	}  } else if (firstHandType == HandType.TwoPair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var firstHandCards = new List<ICard> ();  	firstHandCards.Add (firstGroupedByFace [0].First ());  	firstHandCards.Add (firstGroupedByFace [1].First ());  	firstHandCards = firstHandCards.OrderByDescending (c => c.Face).ToList ();  	firstHandCards.Add (firstGroupedByFace [2].First ());  	var secondHandCards = new List<ICard> ();  	secondHandCards.Add (secondGroupedByFace [0].First ());  	secondHandCards.Add (secondGroupedByFace [1].First ());  	secondHandCards = secondHandCards.OrderByDescending (c => c.Face).ToList ();  	secondHandCards.Add (secondGroupedByFace [2].First ());  	comparisonResult = firstHandCards [0].Face.CompareTo (secondHandCards [0].Face);  	if (comparisonResult == 0) {  		comparisonResult = firstHandCards [1].Face.CompareTo (secondHandCards [1].Face);  		if (comparisonResult == 0) {  			comparisonResult = firstHandCards [2].Face.CompareTo (secondHandCards [2].Face);  		}  	}  } else if (firstHandType == HandType.FullHouse) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Flush || firstHandType == HandType.HighCard) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	for (int i = 0; i < firstSortedByFace.Length; i++) {  		var comparison = firstSortedByFace [i].Face.CompareTo (secondSortedByFace [i].Face);  		if (comparison != 0) {  			comparisonResult = comparison;  			break;  		}  	}  } else if (firstHandType == HandType.ThreeOfAKind || firstHandType == HandType.FourOfAKind) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Straight || firstHandType == HandType.StraightFlush) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	comparisonResult = firstSortedByFace [0].Face.CompareTo (secondSortedByFace [0].Face);  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: if (firstHandType < secondHandType) {  	comparisonResult = -1;  } else if (firstHandType == HandType.OnePair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  	if (comparisonResult == 0) {  		var firstOtherCards = firstGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray ();  		var secondOtherCards = secondGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray ();  		for (int i = 0; i < firstOtherCards.Length; i++) {  			var comparison = firstOtherCards [i].Face.CompareTo (secondOtherCards [i].Face);  			if (comparison != 0) {  				comparisonResult = comparison;  				break;  			}  		}  	}  } else if (firstHandType == HandType.TwoPair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var firstHandCards = new List<ICard> ();  	firstHandCards.Add (firstGroupedByFace [0].First ());  	firstHandCards.Add (firstGroupedByFace [1].First ());  	firstHandCards = firstHandCards.OrderByDescending (c => c.Face).ToList ();  	firstHandCards.Add (firstGroupedByFace [2].First ());  	var secondHandCards = new List<ICard> ();  	secondHandCards.Add (secondGroupedByFace [0].First ());  	secondHandCards.Add (secondGroupedByFace [1].First ());  	secondHandCards = secondHandCards.OrderByDescending (c => c.Face).ToList ();  	secondHandCards.Add (secondGroupedByFace [2].First ());  	comparisonResult = firstHandCards [0].Face.CompareTo (secondHandCards [0].Face);  	if (comparisonResult == 0) {  		comparisonResult = firstHandCards [1].Face.CompareTo (secondHandCards [1].Face);  		if (comparisonResult == 0) {  			comparisonResult = firstHandCards [2].Face.CompareTo (secondHandCards [2].Face);  		}  	}  } else if (firstHandType == HandType.FullHouse) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Flush || firstHandType == HandType.HighCard) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	for (int i = 0; i < firstSortedByFace.Length; i++) {  		var comparison = firstSortedByFace [i].Face.CompareTo (secondSortedByFace [i].Face);  		if (comparison != 0) {  			comparisonResult = comparison;  			break;  		}  	}  } else if (firstHandType == HandType.ThreeOfAKind || firstHandType == HandType.FourOfAKind) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Straight || firstHandType == HandType.StraightFlush) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	comparisonResult = firstSortedByFace [0].Face.CompareTo (secondSortedByFace [0].Face);  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: if (firstHandType == HandType.OnePair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  	if (comparisonResult == 0) {  		var firstOtherCards = firstGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray ();  		var secondOtherCards = secondGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray ();  		for (int i = 0; i < firstOtherCards.Length; i++) {  			var comparison = firstOtherCards [i].Face.CompareTo (secondOtherCards [i].Face);  			if (comparison != 0) {  				comparisonResult = comparison;  				break;  			}  		}  	}  } else if (firstHandType == HandType.TwoPair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var firstHandCards = new List<ICard> ();  	firstHandCards.Add (firstGroupedByFace [0].First ());  	firstHandCards.Add (firstGroupedByFace [1].First ());  	firstHandCards = firstHandCards.OrderByDescending (c => c.Face).ToList ();  	firstHandCards.Add (firstGroupedByFace [2].First ());  	var secondHandCards = new List<ICard> ();  	secondHandCards.Add (secondGroupedByFace [0].First ());  	secondHandCards.Add (secondGroupedByFace [1].First ());  	secondHandCards = secondHandCards.OrderByDescending (c => c.Face).ToList ();  	secondHandCards.Add (secondGroupedByFace [2].First ());  	comparisonResult = firstHandCards [0].Face.CompareTo (secondHandCards [0].Face);  	if (comparisonResult == 0) {  		comparisonResult = firstHandCards [1].Face.CompareTo (secondHandCards [1].Face);  		if (comparisonResult == 0) {  			comparisonResult = firstHandCards [2].Face.CompareTo (secondHandCards [2].Face);  		}  	}  } else if (firstHandType == HandType.FullHouse) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Flush || firstHandType == HandType.HighCard) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	for (int i = 0; i < firstSortedByFace.Length; i++) {  		var comparison = firstSortedByFace [i].Face.CompareTo (secondSortedByFace [i].Face);  		if (comparison != 0) {  			comparisonResult = comparison;  			break;  		}  	}  } else if (firstHandType == HandType.ThreeOfAKind || firstHandType == HandType.FourOfAKind) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Straight || firstHandType == HandType.StraightFlush) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	comparisonResult = firstSortedByFace [0].Face.CompareTo (secondSortedByFace [0].Face);  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: if (firstHandType == HandType.OnePair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  	if (comparisonResult == 0) {  		var firstOtherCards = firstGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray ();  		var secondOtherCards = secondGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray ();  		for (int i = 0; i < firstOtherCards.Length; i++) {  			var comparison = firstOtherCards [i].Face.CompareTo (secondOtherCards [i].Face);  			if (comparison != 0) {  				comparisonResult = comparison;  				break;  			}  		}  	}  } else if (firstHandType == HandType.TwoPair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var firstHandCards = new List<ICard> ();  	firstHandCards.Add (firstGroupedByFace [0].First ());  	firstHandCards.Add (firstGroupedByFace [1].First ());  	firstHandCards = firstHandCards.OrderByDescending (c => c.Face).ToList ();  	firstHandCards.Add (firstGroupedByFace [2].First ());  	var secondHandCards = new List<ICard> ();  	secondHandCards.Add (secondGroupedByFace [0].First ());  	secondHandCards.Add (secondGroupedByFace [1].First ());  	secondHandCards = secondHandCards.OrderByDescending (c => c.Face).ToList ();  	secondHandCards.Add (secondGroupedByFace [2].First ());  	comparisonResult = firstHandCards [0].Face.CompareTo (secondHandCards [0].Face);  	if (comparisonResult == 0) {  		comparisonResult = firstHandCards [1].Face.CompareTo (secondHandCards [1].Face);  		if (comparisonResult == 0) {  			comparisonResult = firstHandCards [2].Face.CompareTo (secondHandCards [2].Face);  		}  	}  } else if (firstHandType == HandType.FullHouse) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Flush || firstHandType == HandType.HighCard) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	for (int i = 0; i < firstSortedByFace.Length; i++) {  		var comparison = firstSortedByFace [i].Face.CompareTo (secondSortedByFace [i].Face);  		if (comparison != 0) {  			comparisonResult = comparison;  			break;  		}  	}  } else if (firstHandType == HandType.ThreeOfAKind || firstHandType == HandType.FourOfAKind) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Straight || firstHandType == HandType.StraightFlush) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	comparisonResult = firstSortedByFace [0].Face.CompareTo (secondSortedByFace [0].Face);  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: if (firstHandType == HandType.OnePair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  	if (comparisonResult == 0) {  		var firstOtherCards = firstGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray ();  		var secondOtherCards = secondGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray ();  		for (int i = 0; i < firstOtherCards.Length; i++) {  			var comparison = firstOtherCards [i].Face.CompareTo (secondOtherCards [i].Face);  			if (comparison != 0) {  				comparisonResult = comparison;  				break;  			}  		}  	}  } else if (firstHandType == HandType.TwoPair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var firstHandCards = new List<ICard> ();  	firstHandCards.Add (firstGroupedByFace [0].First ());  	firstHandCards.Add (firstGroupedByFace [1].First ());  	firstHandCards = firstHandCards.OrderByDescending (c => c.Face).ToList ();  	firstHandCards.Add (firstGroupedByFace [2].First ());  	var secondHandCards = new List<ICard> ();  	secondHandCards.Add (secondGroupedByFace [0].First ());  	secondHandCards.Add (secondGroupedByFace [1].First ());  	secondHandCards = secondHandCards.OrderByDescending (c => c.Face).ToList ();  	secondHandCards.Add (secondGroupedByFace [2].First ());  	comparisonResult = firstHandCards [0].Face.CompareTo (secondHandCards [0].Face);  	if (comparisonResult == 0) {  		comparisonResult = firstHandCards [1].Face.CompareTo (secondHandCards [1].Face);  		if (comparisonResult == 0) {  			comparisonResult = firstHandCards [2].Face.CompareTo (secondHandCards [2].Face);  		}  	}  } else if (firstHandType == HandType.FullHouse) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Flush || firstHandType == HandType.HighCard) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	for (int i = 0; i < firstSortedByFace.Length; i++) {  		var comparison = firstSortedByFace [i].Face.CompareTo (secondSortedByFace [i].Face);  		if (comparison != 0) {  			comparisonResult = comparison;  			break;  		}  	}  } else if (firstHandType == HandType.ThreeOfAKind || firstHandType == HandType.FourOfAKind) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Straight || firstHandType == HandType.StraightFlush) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	comparisonResult = firstSortedByFace [0].Face.CompareTo (secondSortedByFace [0].Face);  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: if (firstHandType == HandType.OnePair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  	if (comparisonResult == 0) {  		var firstOtherCards = firstGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray ();  		var secondOtherCards = secondGroupedByFace.Skip (1).Select (g => g.First ()).OrderByDescending (c => c.Face).ToArray ();  		for (int i = 0; i < firstOtherCards.Length; i++) {  			var comparison = firstOtherCards [i].Face.CompareTo (secondOtherCards [i].Face);  			if (comparison != 0) {  				comparisonResult = comparison;  				break;  			}  		}  	}  } else if (firstHandType == HandType.TwoPair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var firstHandCards = new List<ICard> ();  	firstHandCards.Add (firstGroupedByFace [0].First ());  	firstHandCards.Add (firstGroupedByFace [1].First ());  	firstHandCards = firstHandCards.OrderByDescending (c => c.Face).ToList ();  	firstHandCards.Add (firstGroupedByFace [2].First ());  	var secondHandCards = new List<ICard> ();  	secondHandCards.Add (secondGroupedByFace [0].First ());  	secondHandCards.Add (secondGroupedByFace [1].First ());  	secondHandCards = secondHandCards.OrderByDescending (c => c.Face).ToList ();  	secondHandCards.Add (secondGroupedByFace [2].First ());  	comparisonResult = firstHandCards [0].Face.CompareTo (secondHandCards [0].Face);  	if (comparisonResult == 0) {  		comparisonResult = firstHandCards [1].Face.CompareTo (secondHandCards [1].Face);  		if (comparisonResult == 0) {  			comparisonResult = firstHandCards [2].Face.CompareTo (secondHandCards [2].Face);  		}  	}  } else if (firstHandType == HandType.FullHouse) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Flush || firstHandType == HandType.HighCard) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	for (int i = 0; i < firstSortedByFace.Length; i++) {  		var comparison = firstSortedByFace [i].Face.CompareTo (secondSortedByFace [i].Face);  		if (comparison != 0) {  			comparisonResult = comparison;  			break;  		}  	}  } else if (firstHandType == HandType.ThreeOfAKind || firstHandType == HandType.FourOfAKind) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Straight || firstHandType == HandType.StraightFlush) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	comparisonResult = firstSortedByFace [0].Face.CompareTo (secondSortedByFace [0].Face);  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: if (firstHandType == HandType.TwoPair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var firstHandCards = new List<ICard> ();  	firstHandCards.Add (firstGroupedByFace [0].First ());  	firstHandCards.Add (firstGroupedByFace [1].First ());  	firstHandCards = firstHandCards.OrderByDescending (c => c.Face).ToList ();  	firstHandCards.Add (firstGroupedByFace [2].First ());  	var secondHandCards = new List<ICard> ();  	secondHandCards.Add (secondGroupedByFace [0].First ());  	secondHandCards.Add (secondGroupedByFace [1].First ());  	secondHandCards = secondHandCards.OrderByDescending (c => c.Face).ToList ();  	secondHandCards.Add (secondGroupedByFace [2].First ());  	comparisonResult = firstHandCards [0].Face.CompareTo (secondHandCards [0].Face);  	if (comparisonResult == 0) {  		comparisonResult = firstHandCards [1].Face.CompareTo (secondHandCards [1].Face);  		if (comparisonResult == 0) {  			comparisonResult = firstHandCards [2].Face.CompareTo (secondHandCards [2].Face);  		}  	}  } else if (firstHandType == HandType.FullHouse) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Flush || firstHandType == HandType.HighCard) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	for (int i = 0; i < firstSortedByFace.Length; i++) {  		var comparison = firstSortedByFace [i].Face.CompareTo (secondSortedByFace [i].Face);  		if (comparison != 0) {  			comparisonResult = comparison;  			break;  		}  	}  } else if (firstHandType == HandType.ThreeOfAKind || firstHandType == HandType.FourOfAKind) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Straight || firstHandType == HandType.StraightFlush) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	comparisonResult = firstSortedByFace [0].Face.CompareTo (secondSortedByFace [0].Face);  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: if (firstHandType == HandType.TwoPair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var firstHandCards = new List<ICard> ();  	firstHandCards.Add (firstGroupedByFace [0].First ());  	firstHandCards.Add (firstGroupedByFace [1].First ());  	firstHandCards = firstHandCards.OrderByDescending (c => c.Face).ToList ();  	firstHandCards.Add (firstGroupedByFace [2].First ());  	var secondHandCards = new List<ICard> ();  	secondHandCards.Add (secondGroupedByFace [0].First ());  	secondHandCards.Add (secondGroupedByFace [1].First ());  	secondHandCards = secondHandCards.OrderByDescending (c => c.Face).ToList ();  	secondHandCards.Add (secondGroupedByFace [2].First ());  	comparisonResult = firstHandCards [0].Face.CompareTo (secondHandCards [0].Face);  	if (comparisonResult == 0) {  		comparisonResult = firstHandCards [1].Face.CompareTo (secondHandCards [1].Face);  		if (comparisonResult == 0) {  			comparisonResult = firstHandCards [2].Face.CompareTo (secondHandCards [2].Face);  		}  	}  } else if (firstHandType == HandType.FullHouse) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Flush || firstHandType == HandType.HighCard) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	for (int i = 0; i < firstSortedByFace.Length; i++) {  		var comparison = firstSortedByFace [i].Face.CompareTo (secondSortedByFace [i].Face);  		if (comparison != 0) {  			comparisonResult = comparison;  			break;  		}  	}  } else if (firstHandType == HandType.ThreeOfAKind || firstHandType == HandType.FourOfAKind) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Straight || firstHandType == HandType.StraightFlush) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	comparisonResult = firstSortedByFace [0].Face.CompareTo (secondSortedByFace [0].Face);  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: if (firstHandType == HandType.TwoPair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var firstHandCards = new List<ICard> ();  	firstHandCards.Add (firstGroupedByFace [0].First ());  	firstHandCards.Add (firstGroupedByFace [1].First ());  	firstHandCards = firstHandCards.OrderByDescending (c => c.Face).ToList ();  	firstHandCards.Add (firstGroupedByFace [2].First ());  	var secondHandCards = new List<ICard> ();  	secondHandCards.Add (secondGroupedByFace [0].First ());  	secondHandCards.Add (secondGroupedByFace [1].First ());  	secondHandCards = secondHandCards.OrderByDescending (c => c.Face).ToList ();  	secondHandCards.Add (secondGroupedByFace [2].First ());  	comparisonResult = firstHandCards [0].Face.CompareTo (secondHandCards [0].Face);  	if (comparisonResult == 0) {  		comparisonResult = firstHandCards [1].Face.CompareTo (secondHandCards [1].Face);  		if (comparisonResult == 0) {  			comparisonResult = firstHandCards [2].Face.CompareTo (secondHandCards [2].Face);  		}  	}  } else if (firstHandType == HandType.FullHouse) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Flush || firstHandType == HandType.HighCard) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	for (int i = 0; i < firstSortedByFace.Length; i++) {  		var comparison = firstSortedByFace [i].Face.CompareTo (secondSortedByFace [i].Face);  		if (comparison != 0) {  			comparisonResult = comparison;  			break;  		}  	}  } else if (firstHandType == HandType.ThreeOfAKind || firstHandType == HandType.FourOfAKind) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Straight || firstHandType == HandType.StraightFlush) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	comparisonResult = firstSortedByFace [0].Face.CompareTo (secondSortedByFace [0].Face);  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: if (firstHandType == HandType.TwoPair) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var firstHandCards = new List<ICard> ();  	firstHandCards.Add (firstGroupedByFace [0].First ());  	firstHandCards.Add (firstGroupedByFace [1].First ());  	firstHandCards = firstHandCards.OrderByDescending (c => c.Face).ToList ();  	firstHandCards.Add (firstGroupedByFace [2].First ());  	var secondHandCards = new List<ICard> ();  	secondHandCards.Add (secondGroupedByFace [0].First ());  	secondHandCards.Add (secondGroupedByFace [1].First ());  	secondHandCards = secondHandCards.OrderByDescending (c => c.Face).ToList ();  	secondHandCards.Add (secondGroupedByFace [2].First ());  	comparisonResult = firstHandCards [0].Face.CompareTo (secondHandCards [0].Face);  	if (comparisonResult == 0) {  		comparisonResult = firstHandCards [1].Face.CompareTo (secondHandCards [1].Face);  		if (comparisonResult == 0) {  			comparisonResult = firstHandCards [2].Face.CompareTo (secondHandCards [2].Face);  		}  	}  } else if (firstHandType == HandType.FullHouse) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Flush || firstHandType == HandType.HighCard) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	for (int i = 0; i < firstSortedByFace.Length; i++) {  		var comparison = firstSortedByFace [i].Face.CompareTo (secondSortedByFace [i].Face);  		if (comparison != 0) {  			comparisonResult = comparison;  			break;  		}  	}  } else if (firstHandType == HandType.ThreeOfAKind || firstHandType == HandType.FourOfAKind) {  	var firstGroupedByFace = firstHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	var secondGroupedByFace = secondHand.Cards.GroupBy (c => c.Face).OrderByDescending (g => g.Count ()).ToArray ();  	comparisonResult = firstGroupedByFace [0].First ().Face.CompareTo (secondGroupedByFace [0].First ().Face);  } else if (firstHandType == HandType.Straight || firstHandType == HandType.StraightFlush) {  	var firstSortedByFace = firstHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	var secondSortedByFace = secondHand.Cards.OrderByDescending (c => c.Face).ToArray ();  	comparisonResult = firstSortedByFace [0].Face.CompareTo (secondSortedByFace [0].Face);  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: firstHandCards.Add (firstGroupedByFace [2].First ());  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: secondHandCards.Add (secondGroupedByFace [2].First ());  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: if (comparisonResult == 0) {  	comparisonResult = firstHandCards [1].Face.CompareTo (secondHandCards [1].Face);  	if (comparisonResult == 0) {  		comparisonResult = firstHandCards [2].Face.CompareTo (secondHandCards [2].Face);  	}  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: if (comparisonResult == 0) {  	comparisonResult = firstHandCards [1].Face.CompareTo (secondHandCards [1].Face);  	if (comparisonResult == 0) {  		comparisonResult = firstHandCards [2].Face.CompareTo (secondHandCards [2].Face);  	}  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: if (comparisonResult == 0) {  	comparisonResult = firstHandCards [2].Face.CompareTo (secondHandCards [2].Face);  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: if (comparisonResult == 0) {  	comparisonResult = firstHandCards [2].Face.CompareTo (secondHandCards [2].Face);  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: comparisonResult = firstHandCards [2].Face.CompareTo (secondHandCards [2].Face);  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,CompareHands,The following statement contains a magic number: comparisonResult = firstHandCards [2].Face.CompareTo (secondHandCards [2].Face);  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace.Length == 2) {  	if (groupedByCardFace [0].Count () == 4) {  		return HandType.FourOfAKind;  	} else if (groupedByCardFace [0].Count () == 3 && groupedByCardFace [1].Count () == 2) {  		return HandType.FullHouse;  	}  } else if (groupedByCardFace.Length == 3) {  	if (groupedByCardFace [0].Count () == 3) {  		return HandType.ThreeOfAKind;  	} else if (groupedByCardFace [0].Count () == 2 && groupedByCardFace [1].Count () == 2) {  		return HandType.TwoPair;  	}  } else if (groupedByCardFace.Length == 4) {  	return HandType.OnePair;  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace.Length == 2) {  	if (groupedByCardFace [0].Count () == 4) {  		return HandType.FourOfAKind;  	} else if (groupedByCardFace [0].Count () == 3 && groupedByCardFace [1].Count () == 2) {  		return HandType.FullHouse;  	}  } else if (groupedByCardFace.Length == 3) {  	if (groupedByCardFace [0].Count () == 3) {  		return HandType.ThreeOfAKind;  	} else if (groupedByCardFace [0].Count () == 2 && groupedByCardFace [1].Count () == 2) {  		return HandType.TwoPair;  	}  } else if (groupedByCardFace.Length == 4) {  	return HandType.OnePair;  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace.Length == 2) {  	if (groupedByCardFace [0].Count () == 4) {  		return HandType.FourOfAKind;  	} else if (groupedByCardFace [0].Count () == 3 && groupedByCardFace [1].Count () == 2) {  		return HandType.FullHouse;  	}  } else if (groupedByCardFace.Length == 3) {  	if (groupedByCardFace [0].Count () == 3) {  		return HandType.ThreeOfAKind;  	} else if (groupedByCardFace [0].Count () == 2 && groupedByCardFace [1].Count () == 2) {  		return HandType.TwoPair;  	}  } else if (groupedByCardFace.Length == 4) {  	return HandType.OnePair;  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace.Length == 2) {  	if (groupedByCardFace [0].Count () == 4) {  		return HandType.FourOfAKind;  	} else if (groupedByCardFace [0].Count () == 3 && groupedByCardFace [1].Count () == 2) {  		return HandType.FullHouse;  	}  } else if (groupedByCardFace.Length == 3) {  	if (groupedByCardFace [0].Count () == 3) {  		return HandType.ThreeOfAKind;  	} else if (groupedByCardFace [0].Count () == 2 && groupedByCardFace [1].Count () == 2) {  		return HandType.TwoPair;  	}  } else if (groupedByCardFace.Length == 4) {  	return HandType.OnePair;  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace.Length == 2) {  	if (groupedByCardFace [0].Count () == 4) {  		return HandType.FourOfAKind;  	} else if (groupedByCardFace [0].Count () == 3 && groupedByCardFace [1].Count () == 2) {  		return HandType.FullHouse;  	}  } else if (groupedByCardFace.Length == 3) {  	if (groupedByCardFace [0].Count () == 3) {  		return HandType.ThreeOfAKind;  	} else if (groupedByCardFace [0].Count () == 2 && groupedByCardFace [1].Count () == 2) {  		return HandType.TwoPair;  	}  } else if (groupedByCardFace.Length == 4) {  	return HandType.OnePair;  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace.Length == 2) {  	if (groupedByCardFace [0].Count () == 4) {  		return HandType.FourOfAKind;  	} else if (groupedByCardFace [0].Count () == 3 && groupedByCardFace [1].Count () == 2) {  		return HandType.FullHouse;  	}  } else if (groupedByCardFace.Length == 3) {  	if (groupedByCardFace [0].Count () == 3) {  		return HandType.ThreeOfAKind;  	} else if (groupedByCardFace [0].Count () == 2 && groupedByCardFace [1].Count () == 2) {  		return HandType.TwoPair;  	}  } else if (groupedByCardFace.Length == 4) {  	return HandType.OnePair;  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace.Length == 2) {  	if (groupedByCardFace [0].Count () == 4) {  		return HandType.FourOfAKind;  	} else if (groupedByCardFace [0].Count () == 3 && groupedByCardFace [1].Count () == 2) {  		return HandType.FullHouse;  	}  } else if (groupedByCardFace.Length == 3) {  	if (groupedByCardFace [0].Count () == 3) {  		return HandType.ThreeOfAKind;  	} else if (groupedByCardFace [0].Count () == 2 && groupedByCardFace [1].Count () == 2) {  		return HandType.TwoPair;  	}  } else if (groupedByCardFace.Length == 4) {  	return HandType.OnePair;  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace.Length == 2) {  	if (groupedByCardFace [0].Count () == 4) {  		return HandType.FourOfAKind;  	} else if (groupedByCardFace [0].Count () == 3 && groupedByCardFace [1].Count () == 2) {  		return HandType.FullHouse;  	}  } else if (groupedByCardFace.Length == 3) {  	if (groupedByCardFace [0].Count () == 3) {  		return HandType.ThreeOfAKind;  	} else if (groupedByCardFace [0].Count () == 2 && groupedByCardFace [1].Count () == 2) {  		return HandType.TwoPair;  	}  } else if (groupedByCardFace.Length == 4) {  	return HandType.OnePair;  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace.Length == 2) {  	if (groupedByCardFace [0].Count () == 4) {  		return HandType.FourOfAKind;  	} else if (groupedByCardFace [0].Count () == 3 && groupedByCardFace [1].Count () == 2) {  		return HandType.FullHouse;  	}  } else if (groupedByCardFace.Length == 3) {  	if (groupedByCardFace [0].Count () == 3) {  		return HandType.ThreeOfAKind;  	} else if (groupedByCardFace [0].Count () == 2 && groupedByCardFace [1].Count () == 2) {  		return HandType.TwoPair;  	}  } else if (groupedByCardFace.Length == 4) {  	return HandType.OnePair;  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace [0].Count () == 4) {  	return HandType.FourOfAKind;  } else if (groupedByCardFace [0].Count () == 3 && groupedByCardFace [1].Count () == 2) {  	return HandType.FullHouse;  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace [0].Count () == 4) {  	return HandType.FourOfAKind;  } else if (groupedByCardFace [0].Count () == 3 && groupedByCardFace [1].Count () == 2) {  	return HandType.FullHouse;  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace [0].Count () == 4) {  	return HandType.FourOfAKind;  } else if (groupedByCardFace [0].Count () == 3 && groupedByCardFace [1].Count () == 2) {  	return HandType.FullHouse;  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace [0].Count () == 3 && groupedByCardFace [1].Count () == 2) {  	return HandType.FullHouse;  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace [0].Count () == 3 && groupedByCardFace [1].Count () == 2) {  	return HandType.FullHouse;  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace.Length == 3) {  	if (groupedByCardFace [0].Count () == 3) {  		return HandType.ThreeOfAKind;  	} else if (groupedByCardFace [0].Count () == 2 && groupedByCardFace [1].Count () == 2) {  		return HandType.TwoPair;  	}  } else if (groupedByCardFace.Length == 4) {  	return HandType.OnePair;  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace.Length == 3) {  	if (groupedByCardFace [0].Count () == 3) {  		return HandType.ThreeOfAKind;  	} else if (groupedByCardFace [0].Count () == 2 && groupedByCardFace [1].Count () == 2) {  		return HandType.TwoPair;  	}  } else if (groupedByCardFace.Length == 4) {  	return HandType.OnePair;  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace.Length == 3) {  	if (groupedByCardFace [0].Count () == 3) {  		return HandType.ThreeOfAKind;  	} else if (groupedByCardFace [0].Count () == 2 && groupedByCardFace [1].Count () == 2) {  		return HandType.TwoPair;  	}  } else if (groupedByCardFace.Length == 4) {  	return HandType.OnePair;  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace.Length == 3) {  	if (groupedByCardFace [0].Count () == 3) {  		return HandType.ThreeOfAKind;  	} else if (groupedByCardFace [0].Count () == 2 && groupedByCardFace [1].Count () == 2) {  		return HandType.TwoPair;  	}  } else if (groupedByCardFace.Length == 4) {  	return HandType.OnePair;  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace.Length == 3) {  	if (groupedByCardFace [0].Count () == 3) {  		return HandType.ThreeOfAKind;  	} else if (groupedByCardFace [0].Count () == 2 && groupedByCardFace [1].Count () == 2) {  		return HandType.TwoPair;  	}  } else if (groupedByCardFace.Length == 4) {  	return HandType.OnePair;  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace [0].Count () == 3) {  	return HandType.ThreeOfAKind;  } else if (groupedByCardFace [0].Count () == 2 && groupedByCardFace [1].Count () == 2) {  	return HandType.TwoPair;  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace [0].Count () == 3) {  	return HandType.ThreeOfAKind;  } else if (groupedByCardFace [0].Count () == 2 && groupedByCardFace [1].Count () == 2) {  	return HandType.TwoPair;  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace [0].Count () == 3) {  	return HandType.ThreeOfAKind;  } else if (groupedByCardFace [0].Count () == 2 && groupedByCardFace [1].Count () == 2) {  	return HandType.TwoPair;  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace [0].Count () == 2 && groupedByCardFace [1].Count () == 2) {  	return HandType.TwoPair;  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace [0].Count () == 2 && groupedByCardFace [1].Count () == 2) {  	return HandType.TwoPair;  }  
Magic Number,Poker.Models,PokerHandsChecker,F:\newReposMay17\flextry_Telerik-Academy\Programming with C#\4. C# High-Quality Code\11. Test-Driven-Development\Poker.Models\PokerHandsChecker.cs,TryGetHandTypeOrThrowException,The following statement contains a magic number: if (groupedByCardFace.Length == 4) {  	return HandType.OnePair;  }  
