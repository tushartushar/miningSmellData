Implementation smell,Namespace,Class,File,Method,Description
Long Method,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderToTexture,The method has 207 lines of code.
Long Method,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderEngineThrusts,The method has 146 lines of code.
Long Method,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderGround,The method has 130 lines of code.
Long Method,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderPart,The method has 245 lines of code.
Long Method,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderIcon,The method has 109 lines of code.
Long Method,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,genTransMatrix,The method has 130 lines of code.
Long Method,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,getPartColor,The method has 195 lines of code.
Complex Method,VesselView,ViewerSettings,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\ViewerSettings.cs,getPropertyDesc,Cyclomatic complexity of the method is 19
Complex Method,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,drawCall,Cyclomatic complexity of the method is 18
Complex Method,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderToTexture,Cyclomatic complexity of the method is 43
Complex Method,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderEngineThrusts,Cyclomatic complexity of the method is 38
Complex Method,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderGround,Cyclomatic complexity of the method is 19
Complex Method,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderPart,Cyclomatic complexity of the method is 54
Complex Method,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderIcon,Cyclomatic complexity of the method is 11
Complex Method,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,updateMinMax,Cyclomatic complexity of the method is 8
Complex Method,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,genTransMatrix,Cyclomatic complexity of the method is 18
Complex Method,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,centerise,Cyclomatic complexity of the method is 15
Complex Method,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,getPartColor,Cyclomatic complexity of the method is 44
Long Parameter List,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderCone,The method has 5 parameters. Parameters: thrustTransform' scale' offset' screenMatrix' color
Long Parameter List,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderLine,The method has 5 parameters. Parameters: x1' y1' x2' y2' screenMatrix
Long Statement,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,readyTexture,The length of the statement  "            else if (screenBuffer.height != outputTexture.height | screenBuffer.width != outputTexture.width) createTexture(outputTexture); " is 127.
Long Statement,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderToTexture,The length of the statement  "                Matrix4x4 matrix = Matrix4x4.TRS(new Vector3(basicSettings.scrOffX' basicSettings.scrOffY' 0)' Quaternion.identity' new Vector3(basicSettings.scaleFact' basicSettings.scaleFact' 1)); " is 182.
Long Statement,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderEngineThrusts,The length of the statement  "                    if ((Found_LiquidFuel & Deprived_LiquidFuel) | (Found_SolidFuel & Deprived_SolidFuel) | (Found_MonoPropellant & Deprived_MonoPropellant) | (Found_XenonGas & Deprived_XenonGas) | (Found_Oxidizer & Deprived_Oxidizer)) " is 215.
Long Statement,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderEngineThrusts,The length of the statement  "                        renderIcon(new Rect(-div + posStr.x' -div + posStr.y' 2 * div' 2 * div)' screenMatrix' Color.red' (int)ViewerConstants.ICONS.ENGINE_NOFUEL); " is 140.
Long Statement,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderEngineThrusts,The length of the statement  "                        renderIcon(new Rect(-div + posStr.x' -div + posStr.y' 2 * div' 2 * div)' screenMatrix' Color.cyan' (int)ViewerConstants.ICONS.ENGINE_NOPOWER); " is 142.
Long Statement,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderEngineThrusts,The length of the statement  "                        renderIcon(new Rect(-div + posStr.x' -div + posStr.y' 2 * div' 2 * div)' screenMatrix' Color.cyan' (int)ViewerConstants.ICONS.ENGINE_NOAIR); " is 140.
Long Statement,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderEngineThrusts,The length of the statement  "                        renderIcon(new Rect(-div + posStr.x' -div + posStr.y' 2 * div' 2 * div)' screenMatrix' new Color(1'0.5f'0)' (int)ViewerConstants.ICONS.ENGINE_ACTIVE); " is 150.
Long Statement,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderEngineThrusts,The length of the statement  "                                renderIcon(new Rect(-div + posStr.x' -div + posStr.y' 2 * div' 2 * div)' screenMatrix' Color.yellow' (int)ViewerConstants.ICONS.ENGINE_INACTIVE); " is 145.
Long Statement,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderEngineThrusts,The length of the statement  "                                renderIcon(new Rect(-div + posStr.x' -div + posStr.y' 2 * div' 2 * div)' screenMatrix' Color.green' (int)ViewerConstants.ICONS.ENGINE_READY); " is 141.
Long Statement,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderEngineThrusts,The length of the statement  "                    //renderIcon(new Rect(-div + posEnd.x' -div + posEnd.y' 2 * div' 2 * div)' screenMatrix' Color.yellow' (int)ViewerConstants.ICONS.SQUARE_DIAMOND); " is 146.
Long Statement,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderGround,The length of the statement  "            //Vector3 groundN = FlightGlobals.ActiveVessel.mainBody.GetRelSurfaceNVector(FlightGlobals.ActiveVessel.latitude' FlightGlobals.ActiveVessel.longitude); " is 152.
Long Statement,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderGround,The length of the statement  "            //Vector3d eastUnit = FlightGlobals.ActiveVessel.mainBody.getRFrmVel(position).normalized; //uses the rotation of the body's frame to determine "east" " is 150.
Long Statement,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderGround,The length of the statement  "            Matrix4x4 transMatrix = genTransMatrix(FlightGlobals.ActiveVessel.rootPart.transform' FlightGlobals.ActiveVessel' true); " is 120.
Long Statement,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderGround,The length of the statement  "            renderIcon(new Rect(-div + groundBelow.x' -div + groundBelow.y' 2 * div' 2 * div)' screenMatrix' Color.green' (int)ViewerConstants.ICONS.TRIANGLE_DOWN); " is 152.
Long Statement,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderGround,The length of the statement  "            //renderIcon(new Rect(-div + direction.x' -div + direction.y' 2 * div' 2 * div)' screenMatrix' Color.magenta' (int)ViewerConstants.ICONS.DIAMOND); " is 146.
Long Statement,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderAxes,The length of the statement  "            Matrix4x4 transMatrix = genTransMatrix(FlightGlobals.ActiveVessel.rootPart.transform' FlightGlobals.ActiveVessel' true); " is 120.
Long Statement,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderCOM,The length of the statement  "            Matrix4x4 transMatrix = genTransMatrix(FlightGlobals.ActiveVessel.rootPart.transform' FlightGlobals.ActiveVessel' true); " is 120.
Long Statement,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderCOM,The length of the statement  "            renderIcon(new Rect(-div + COM.x' -div + COM.y' 2 * div' 2 * div)' screenMatrix' Color.magenta' (int)ViewerConstants.ICONS.SQUARE_DIAMOND); " is 139.
Long Statement,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderCOP,The length of the statement  "            Matrix4x4 transMatrix = genTransMatrix(FlightGlobals.ActiveVessel.rootPart.transform' FlightGlobals.ActiveVessel' true); " is 120.
Long Statement,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderCOP,The length of the statement  "            renderIcon(new Rect(-div + COP.x' -div + COP.y' 2 * div' 2 * div)' screenMatrix' Color.cyan' (int)ViewerConstants.ICONS.SQUARE_DIAMOND); " is 136.
Long Statement,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderMOI,The length of the statement  "            Matrix4x4 transMatrix = genTransMatrix(FlightGlobals.ActiveVessel.rootPart.transform' FlightGlobals.ActiveVessel' true); " is 120.
Long Statement,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderMOI,The length of the statement  "            renderIcon(new Rect(-div + MOI.x' -div + MOI.y' 2 * div' 2 * div)' screenMatrix' Color.yellow' (int)ViewerConstants.ICONS.SQUARE_DIAMOND); " is 138.
Long Statement,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderPart,The length of the statement  "                rectQueue.Enqueue(new ViewerConstants.RectColor(new Rect((minVec.x)' (minVec.y)' (maxVec.x - minVec.x)' (maxVec.y - minVec.y))' boxColor)); " is 139.
Long Statement,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,genTransMatrix,The length of the statement  "                    transformTemp.transform.rotation = Quaternion.FromToRotation(vessel.mainBody.GetSurfaceNVector(0' 0)' vessel.mainBody.GetSurfaceNVector(vessel.latitude' vessel.longitude)); " is 172.
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,nilOffset,The following statement contains a magic number: basicSettings.scrOffX = width / 2;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,nilOffset,The following statement contains a magic number: basicSettings.scrOffY = height / 2;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderEngineThrusts,The following statement contains a magic number: color = new Color(1' 0.5f' 0);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderEngineThrusts,The following statement contains a magic number: scale > 0.01f
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderEngineThrusts,The following statement contains a magic number: float div = 6 / basicSettings.scaleFact;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderEngineThrusts,The following statement contains a magic number: renderIcon(new Rect(-div + posStr.x' -div + posStr.y' 2 * div' 2 * div)' screenMatrix' Color.red' (int)ViewerConstants.ICONS.ENGINE_NOFUEL);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderEngineThrusts,The following statement contains a magic number: renderIcon(new Rect(-div + posStr.x' -div + posStr.y' 2 * div' 2 * div)' screenMatrix' Color.red' (int)ViewerConstants.ICONS.ENGINE_NOFUEL);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderGround,The following statement contains a magic number: localSpaceNormal.y > 0.9 | localSpaceNormal.y < -0.9
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderGround,The following statement contains a magic number: localSpaceNormal.y > 0.9 | localSpaceNormal.y < -0.9
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderGround,The following statement contains a magic number: angle = 40;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderGround,The following statement contains a magic number: angle > 40
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderGround,The following statement contains a magic number: Color color = genFractColor(1-(angle / 40f));
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderGround,The following statement contains a magic number: float div = 6 / basicSettings.scaleFact;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderGround,The following statement contains a magic number: renderIcon(new Rect(-div + groundBelow.x' -div + groundBelow.y' 2 * div' 2 * div)' screenMatrix' Color.green' (int)ViewerConstants.ICONS.TRIANGLE_DOWN);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderGround,The following statement contains a magic number: renderIcon(new Rect(-div + groundBelow.x' -div + groundBelow.y' 2 * div' 2 * div)' screenMatrix' Color.green' (int)ViewerConstants.ICONS.TRIANGLE_DOWN);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderAxes,The following statement contains a magic number: Vector3 up = transMatrix.MultiplyPoint3x4(Vector3.up * 10000);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderAxes,The following statement contains a magic number: Vector3 down = transMatrix.MultiplyPoint3x4(Vector3.down * 10000);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderAxes,The following statement contains a magic number: Vector3 left = transMatrix.MultiplyPoint3x4(Vector3.left * 10000);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderAxes,The following statement contains a magic number: Vector3 right = transMatrix.MultiplyPoint3x4(Vector3.right * 10000);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderAxes,The following statement contains a magic number: Vector3 front = transMatrix.MultiplyPoint3x4(Vector3.forward * 10000);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderAxes,The following statement contains a magic number: Vector3 back = transMatrix.MultiplyPoint3x4(Vector3.back * 10000);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderCOM,The following statement contains a magic number: float div = 6 / basicSettings.scaleFact;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderCOM,The following statement contains a magic number: renderIcon(new Rect(-div + COM.x' -div + COM.y' 2 * div' 2 * div)' screenMatrix' Color.magenta' (int)ViewerConstants.ICONS.SQUARE_DIAMOND);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderCOM,The following statement contains a magic number: renderIcon(new Rect(-div + COM.x' -div + COM.y' 2 * div' 2 * div)' screenMatrix' Color.magenta' (int)ViewerConstants.ICONS.SQUARE_DIAMOND);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderCOP,The following statement contains a magic number: float div = 6 / basicSettings.scaleFact;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderCOP,The following statement contains a magic number: renderIcon(new Rect(-div + COP.x' -div + COP.y' 2 * div' 2 * div)' screenMatrix' Color.cyan' (int)ViewerConstants.ICONS.SQUARE_DIAMOND);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderCOP,The following statement contains a magic number: renderIcon(new Rect(-div + COP.x' -div + COP.y' 2 * div' 2 * div)' screenMatrix' Color.cyan' (int)ViewerConstants.ICONS.SQUARE_DIAMOND);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderMOI,The following statement contains a magic number: float div = 6 / basicSettings.scaleFact;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderMOI,The following statement contains a magic number: renderIcon(new Rect(-div + MOI.x' -div + MOI.y' 2 * div' 2 * div)' screenMatrix' Color.yellow' (int)ViewerConstants.ICONS.SQUARE_DIAMOND);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderMOI,The following statement contains a magic number: renderIcon(new Rect(-div + MOI.x' -div + MOI.y' 2 * div' 2 * div)' screenMatrix' Color.yellow' (int)ViewerConstants.ICONS.SQUARE_DIAMOND);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderPart,The following statement contains a magic number: boxColor.r = boxColor.r / 2;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderPart,The following statement contains a magic number: boxColor.g = boxColor.g / 2;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderPart,The following statement contains a magic number: boxColor.b = boxColor.b / 2;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderPart,The following statement contains a magic number: partColor.r = partColor.r / 2;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderPart,The following statement contains a magic number: partColor.g = partColor.g / 2;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderPart,The following statement contains a magic number: partColor.b = partColor.b / 2;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderMesh,The following statement contains a magic number: GL.Vertex(vertices[triangles[i + 2]]);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderCone,The following statement contains a magic number: float timeAdd = (Time.frameCount % 40);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderCone,The following statement contains a magic number: scale += (scale / 100) * timeAdd;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderCone,The following statement contains a magic number: timeAdd < 20
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderCone,The following statement contains a magic number: float sideScale = scale / 4f;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderIcon,The following statement contains a magic number: GL.Vertex(screenMatrix.MultiplyPoint3x4(new Vector3(rect.xMin' rect.yMin' 0.1f)));
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderIcon,The following statement contains a magic number: GL.Vertex(screenMatrix.MultiplyPoint3x4(new Vector3(rect.xMin' rect.yMax' 0.1f)));
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderIcon,The following statement contains a magic number: GL.Vertex(screenMatrix.MultiplyPoint3x4(new Vector3(rect.xMax' rect.yMax' 0.1f)));
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderIcon,The following statement contains a magic number: GL.Vertex(screenMatrix.MultiplyPoint3x4(new Vector3(rect.xMax' rect.yMin' 0.1f)));
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderIcon,The following statement contains a magic number: float xMid = ((rect.xMax - rect.xMin) / 2) + rect.xMin;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderIcon,The following statement contains a magic number: float yMid = ((rect.yMax - rect.yMin) / 2) + rect.yMin;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderIcon,The following statement contains a magic number: float xOneFourth = ((xMid - rect.xMin) / 2) + rect.xMin;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderIcon,The following statement contains a magic number: float yOneFourth = ((yMid - rect.yMin) / 2) + rect.yMin;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderIcon,The following statement contains a magic number: float xThreeFourth = ((rect.xMax - xMid) / 2) + xMid;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderIcon,The following statement contains a magic number: float yThreeFourth = ((rect.yMax - yMid) / 2) + yMid;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderLine,The following statement contains a magic number: Vector3 v1 = screenMatrix.MultiplyPoint3x4(new Vector3(x1' y1' 0.1f));
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderLine,The following statement contains a magic number: Vector3 v2 = screenMatrix.MultiplyPoint3x4(new Vector3(x2' y2' 0.1f));
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,updateMinMax,The following statement contains a magic number: Vector3[] vertices = new Vector3[8];
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,updateMinMax,The following statement contains a magic number: vertices[2] = new Vector3(meshBounds.min.x' meshBounds.max.y' meshBounds.min.z);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,updateMinMax,The following statement contains a magic number: vertices[3] = new Vector3(meshBounds.min.x' meshBounds.min.y' meshBounds.max.z);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,updateMinMax,The following statement contains a magic number: vertices[4] = new Vector3(meshBounds.max.x' meshBounds.max.y' meshBounds.min.z);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,updateMinMax,The following statement contains a magic number: vertices[5] = new Vector3(meshBounds.max.x' meshBounds.min.y' meshBounds.max.z);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,updateMinMax,The following statement contains a magic number: vertices[6] = new Vector3(meshBounds.min.x' meshBounds.max.y' meshBounds.max.z);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,updateMinMax,The following statement contains a magic number: vertices[7] = new Vector3(meshBounds.max.x' meshBounds.max.y' meshBounds.max.z);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,genTransMatrix,The following statement contains a magic number: switch (spinAxis)               {                  case (int)ViewerConstants.AXIS.X:                      extraRot.x += ((Time.time * speed) % 360);                      break;                  case (int)ViewerConstants.AXIS.Y:                      extraRot.y += ((Time.time * speed) % 360);                      break;                  case (int)ViewerConstants.AXIS.Z:                      extraRot.z += ((Time.time * speed) % 360);                      break;              }
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,genTransMatrix,The following statement contains a magic number: switch (spinAxis)               {                  case (int)ViewerConstants.AXIS.X:                      extraRot.x += ((Time.time * speed) % 360);                      break;                  case (int)ViewerConstants.AXIS.Y:                      extraRot.y += ((Time.time * speed) % 360);                      break;                  case (int)ViewerConstants.AXIS.Z:                      extraRot.z += ((Time.time * speed) % 360);                      break;              }
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,genTransMatrix,The following statement contains a magic number: switch (spinAxis)               {                  case (int)ViewerConstants.AXIS.X:                      extraRot.x += ((Time.time * speed) % 360);                      break;                  case (int)ViewerConstants.AXIS.Y:                      extraRot.y += ((Time.time * speed) % 360);                      break;                  case (int)ViewerConstants.AXIS.Z:                      extraRot.z += ((Time.time * speed) % 360);                      break;              }
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,genTransMatrix,The following statement contains a magic number: switch (drawPlane)              {                  case (int)ViewerConstants.PLANE.XY:                      transformTemp.transform.Rotate(extraRot);                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.XZ:                      transformTemp.transform.Rotate(new Vector3(0' 90' 0));                      transformTemp.transform.Rotate(extraRot);                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.YZ:                      transformTemp.transform.Rotate(new Vector3(90' 0' 0));                      transformTemp.transform.Rotate(extraRot);                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.ISO:                      transformTemp.transform.Rotate(new Vector3(0' -30' 0));                      transformTemp.transform.Rotate(new Vector3(15' 0' 0));                                            transformTemp.transform.Rotate(extraRot);                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.GRND:                      transformTemp.transform.rotation = vessel.srfRelRotation;                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      transformTemp.transform.rotation = Quaternion.FromToRotation(vessel.mainBody.GetSurfaceNVector(0' 0)' vessel.mainBody.GetSurfaceNVector(vessel.latitude' vessel.longitude));                      meshTransMatrix = transformTemp.transform.localToWorldMatrix.inverse * meshTransMatrix;                      transformTemp.transform.rotation = Quaternion.identity;                      transformTemp.transform.Rotate(new Vector3(0' 0' 90));                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.REAL:                      transformTemp.transform.rotation = vessel.vesselTransform.rotation;                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;              }
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,genTransMatrix,The following statement contains a magic number: switch (drawPlane)              {                  case (int)ViewerConstants.PLANE.XY:                      transformTemp.transform.Rotate(extraRot);                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.XZ:                      transformTemp.transform.Rotate(new Vector3(0' 90' 0));                      transformTemp.transform.Rotate(extraRot);                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.YZ:                      transformTemp.transform.Rotate(new Vector3(90' 0' 0));                      transformTemp.transform.Rotate(extraRot);                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.ISO:                      transformTemp.transform.Rotate(new Vector3(0' -30' 0));                      transformTemp.transform.Rotate(new Vector3(15' 0' 0));                                            transformTemp.transform.Rotate(extraRot);                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.GRND:                      transformTemp.transform.rotation = vessel.srfRelRotation;                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      transformTemp.transform.rotation = Quaternion.FromToRotation(vessel.mainBody.GetSurfaceNVector(0' 0)' vessel.mainBody.GetSurfaceNVector(vessel.latitude' vessel.longitude));                      meshTransMatrix = transformTemp.transform.localToWorldMatrix.inverse * meshTransMatrix;                      transformTemp.transform.rotation = Quaternion.identity;                      transformTemp.transform.Rotate(new Vector3(0' 0' 90));                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.REAL:                      transformTemp.transform.rotation = vessel.vesselTransform.rotation;                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;              }
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,genTransMatrix,The following statement contains a magic number: switch (drawPlane)              {                  case (int)ViewerConstants.PLANE.XY:                      transformTemp.transform.Rotate(extraRot);                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.XZ:                      transformTemp.transform.Rotate(new Vector3(0' 90' 0));                      transformTemp.transform.Rotate(extraRot);                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.YZ:                      transformTemp.transform.Rotate(new Vector3(90' 0' 0));                      transformTemp.transform.Rotate(extraRot);                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.ISO:                      transformTemp.transform.Rotate(new Vector3(0' -30' 0));                      transformTemp.transform.Rotate(new Vector3(15' 0' 0));                                            transformTemp.transform.Rotate(extraRot);                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.GRND:                      transformTemp.transform.rotation = vessel.srfRelRotation;                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      transformTemp.transform.rotation = Quaternion.FromToRotation(vessel.mainBody.GetSurfaceNVector(0' 0)' vessel.mainBody.GetSurfaceNVector(vessel.latitude' vessel.longitude));                      meshTransMatrix = transformTemp.transform.localToWorldMatrix.inverse * meshTransMatrix;                      transformTemp.transform.rotation = Quaternion.identity;                      transformTemp.transform.Rotate(new Vector3(0' 0' 90));                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.REAL:                      transformTemp.transform.rotation = vessel.vesselTransform.rotation;                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;              }
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,genTransMatrix,The following statement contains a magic number: switch (drawPlane)              {                  case (int)ViewerConstants.PLANE.XY:                      transformTemp.transform.Rotate(extraRot);                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.XZ:                      transformTemp.transform.Rotate(new Vector3(0' 90' 0));                      transformTemp.transform.Rotate(extraRot);                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.YZ:                      transformTemp.transform.Rotate(new Vector3(90' 0' 0));                      transformTemp.transform.Rotate(extraRot);                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.ISO:                      transformTemp.transform.Rotate(new Vector3(0' -30' 0));                      transformTemp.transform.Rotate(new Vector3(15' 0' 0));                                            transformTemp.transform.Rotate(extraRot);                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.GRND:                      transformTemp.transform.rotation = vessel.srfRelRotation;                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      transformTemp.transform.rotation = Quaternion.FromToRotation(vessel.mainBody.GetSurfaceNVector(0' 0)' vessel.mainBody.GetSurfaceNVector(vessel.latitude' vessel.longitude));                      meshTransMatrix = transformTemp.transform.localToWorldMatrix.inverse * meshTransMatrix;                      transformTemp.transform.rotation = Quaternion.identity;                      transformTemp.transform.Rotate(new Vector3(0' 0' 90));                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.REAL:                      transformTemp.transform.rotation = vessel.vesselTransform.rotation;                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;              }
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,genTransMatrix,The following statement contains a magic number: switch (drawPlane)              {                  case (int)ViewerConstants.PLANE.XY:                      transformTemp.transform.Rotate(extraRot);                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.XZ:                      transformTemp.transform.Rotate(new Vector3(0' 90' 0));                      transformTemp.transform.Rotate(extraRot);                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.YZ:                      transformTemp.transform.Rotate(new Vector3(90' 0' 0));                      transformTemp.transform.Rotate(extraRot);                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.ISO:                      transformTemp.transform.Rotate(new Vector3(0' -30' 0));                      transformTemp.transform.Rotate(new Vector3(15' 0' 0));                                            transformTemp.transform.Rotate(extraRot);                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.GRND:                      transformTemp.transform.rotation = vessel.srfRelRotation;                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      transformTemp.transform.rotation = Quaternion.FromToRotation(vessel.mainBody.GetSurfaceNVector(0' 0)' vessel.mainBody.GetSurfaceNVector(vessel.latitude' vessel.longitude));                      meshTransMatrix = transformTemp.transform.localToWorldMatrix.inverse * meshTransMatrix;                      transformTemp.transform.rotation = Quaternion.identity;                      transformTemp.transform.Rotate(new Vector3(0' 0' 90));                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.REAL:                      transformTemp.transform.rotation = vessel.vesselTransform.rotation;                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;              }
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,centerise,The following statement contains a magic number: maxDiff = 0.5f;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,centerise,The following statement contains a magic number: maxDiff = 0.85f;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,centerise,The following statement contains a magic number: basicSettings.scaleFact = 1000;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,centerise,The following statement contains a magic number: basicSettings.scaleFact > 1000
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,centerise,The following statement contains a magic number: basicSettings.scrOffX = screenWidth / 2 - (int)((minVecG.x + xDiff / 2) * basicSettings.scaleFact);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,centerise,The following statement contains a magic number: basicSettings.scrOffX = screenWidth / 2 - (int)((minVecG.x + xDiff / 2) * basicSettings.scaleFact);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,centerise,The following statement contains a magic number: basicSettings.scrOffY = screenHeight / 2 - (int)((minVecG.y + yDiff / 2) * basicSettings.scaleFact);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,centerise,The following statement contains a magic number: basicSettings.scrOffY = screenHeight / 2 - (int)((minVecG.y + yDiff / 2) * basicSettings.scaleFact);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,getPartColor,The following statement contains a magic number: switch (mode)              {                  case (int)ViewerConstants.COLORMODE.NONE:                      return Color.white;                  case (int)ViewerConstants.COLORMODE.STATE:                      //it seems most of these are unused' but it does at least                      //make it (semi-)clear what is the root part and which parts belong                      //to activated stages                      if (part.parent == null) { return Color.magenta; }                      switch (part.State)                      {                          case PartStates.ACTIVE:                              return Color.blue;                          case PartStates.DEACTIVATED:                              return Color.red;                          case PartStates.DEAD:                              return Color.gray;                          case PartStates.IDLE:                              return Color.green;                          default:                              return Color.red;                      }                  case (int)ViewerConstants.COLORMODE.STAGE:                      //colors the parts by their inverse stage.                      //first we need an appropriate gradient' so check if we have it                      //and make it if we dont' or if its too small                      if (stagesThisTimeMax < part.inverseStage) stagesThisTimeMax = part.inverseStage;                        int neededColors = Math.Max(stagesLastTime' Math.Max(Staging.StageCount' stagesThisTimeMax)) + 1;                      if (stageGradient == null)                      {                          stageGradient = genColorGradient(neededColors);                      }                      else if (stageGradient.Length != neededColors)                      {                          stageGradient = genColorGradient(neededColors);                      }                      //now return the color                       //print("part " + part.name + " inv. stage " + part.inverseStage);                      if (part.inverseStage >= stageGradient.Length) return Color.magenta;                      return stageGradient[part.inverseStage];                  case (int)ViewerConstants.COLORMODE.HEAT:                      //colors the part according to how close its to exploding due to overheat                      Color color = new Color(0.2f' 0.2f' 0.2f);                      if (part.maxTemp != 0)                      {                          double tempDiff = part.temperature / part.maxTemp;                          //to power of THREE to emphasise overheating parts MORE                          tempDiff = Math.Pow(tempDiff' 3);                          //color.g = 0.2f;                          color.b = (float)(0.2f * (1 - tempDiff));                          color.r = (float)(0.2f + tempDiff * 0.8f);                          return color;                      }                      else                      {                          return color;                      }                  case (int)ViewerConstants.COLORMODE.FUEL:                      Color color2 = Color.red;                      List<PartResource> resList = part.Resources.list;                      int resCount = resList.Count;                      int emptyRes = 0;                      double totalResFraction = 0;                      //go through all the resources in the part' add up their fullness                      foreach (PartResource resource in resList)                      {                          //2 is almost empty anyway for all but the smallest tanks                           //and it eliminates things like intakes or power generating engines                          if (resource.amount <= 2f)                          {                              emptyRes++;                          }                          else                          {                              double resourceFraction = (resource.amount / resource.maxAmount);                              totalResFraction += resourceFraction / (double)resCount;                          }                      }                      //now set the part color                      if (resCount == 0 | emptyRes == resCount)                      {                          color2 = new Color(0.2f' 0.2f' 0.2f);                      }                      else                      {                          return genFractColor((float)totalResFraction);                      }                        return color2;                  case (int)ViewerConstants.COLORMODE.DRAG:                      float drag = part.angularDrag;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentDrag"))                              {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentDrag"))                              {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                        else if (part.Modules.Contains("FARBasicDragModel"))                      {                          //MonoBehaviour.print("basic drag");                          PartModule FARmodule = part.Modules["FARBasicDragModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                           {                              if (fieldInList.name.Equals("currentDrag"))                               {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genHeatmapColor(drag);                  case (int)ViewerConstants.COLORMODE.LIFT:                      float lift = 0;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentLift"))                              {                                  lift = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentLift"))                              {                                  lift = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genHeatmapColor(lift);                  case (int)ViewerConstants.COLORMODE.STALL:                      float stall = 0;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("stall"))                              {                                  stall = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("stall"))                              {                                  stall = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genFractColor(1f-stall);                  case (int)ViewerConstants.COLORMODE.HIDE:                      return Color.black;                  default:                      return Color.white;              }
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,getPartColor,The following statement contains a magic number: switch (mode)              {                  case (int)ViewerConstants.COLORMODE.NONE:                      return Color.white;                  case (int)ViewerConstants.COLORMODE.STATE:                      //it seems most of these are unused' but it does at least                      //make it (semi-)clear what is the root part and which parts belong                      //to activated stages                      if (part.parent == null) { return Color.magenta; }                      switch (part.State)                      {                          case PartStates.ACTIVE:                              return Color.blue;                          case PartStates.DEACTIVATED:                              return Color.red;                          case PartStates.DEAD:                              return Color.gray;                          case PartStates.IDLE:                              return Color.green;                          default:                              return Color.red;                      }                  case (int)ViewerConstants.COLORMODE.STAGE:                      //colors the parts by their inverse stage.                      //first we need an appropriate gradient' so check if we have it                      //and make it if we dont' or if its too small                      if (stagesThisTimeMax < part.inverseStage) stagesThisTimeMax = part.inverseStage;                        int neededColors = Math.Max(stagesLastTime' Math.Max(Staging.StageCount' stagesThisTimeMax)) + 1;                      if (stageGradient == null)                      {                          stageGradient = genColorGradient(neededColors);                      }                      else if (stageGradient.Length != neededColors)                      {                          stageGradient = genColorGradient(neededColors);                      }                      //now return the color                       //print("part " + part.name + " inv. stage " + part.inverseStage);                      if (part.inverseStage >= stageGradient.Length) return Color.magenta;                      return stageGradient[part.inverseStage];                  case (int)ViewerConstants.COLORMODE.HEAT:                      //colors the part according to how close its to exploding due to overheat                      Color color = new Color(0.2f' 0.2f' 0.2f);                      if (part.maxTemp != 0)                      {                          double tempDiff = part.temperature / part.maxTemp;                          //to power of THREE to emphasise overheating parts MORE                          tempDiff = Math.Pow(tempDiff' 3);                          //color.g = 0.2f;                          color.b = (float)(0.2f * (1 - tempDiff));                          color.r = (float)(0.2f + tempDiff * 0.8f);                          return color;                      }                      else                      {                          return color;                      }                  case (int)ViewerConstants.COLORMODE.FUEL:                      Color color2 = Color.red;                      List<PartResource> resList = part.Resources.list;                      int resCount = resList.Count;                      int emptyRes = 0;                      double totalResFraction = 0;                      //go through all the resources in the part' add up their fullness                      foreach (PartResource resource in resList)                      {                          //2 is almost empty anyway for all but the smallest tanks                           //and it eliminates things like intakes or power generating engines                          if (resource.amount <= 2f)                          {                              emptyRes++;                          }                          else                          {                              double resourceFraction = (resource.amount / resource.maxAmount);                              totalResFraction += resourceFraction / (double)resCount;                          }                      }                      //now set the part color                      if (resCount == 0 | emptyRes == resCount)                      {                          color2 = new Color(0.2f' 0.2f' 0.2f);                      }                      else                      {                          return genFractColor((float)totalResFraction);                      }                        return color2;                  case (int)ViewerConstants.COLORMODE.DRAG:                      float drag = part.angularDrag;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentDrag"))                              {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentDrag"))                              {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                        else if (part.Modules.Contains("FARBasicDragModel"))                      {                          //MonoBehaviour.print("basic drag");                          PartModule FARmodule = part.Modules["FARBasicDragModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                           {                              if (fieldInList.name.Equals("currentDrag"))                               {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genHeatmapColor(drag);                  case (int)ViewerConstants.COLORMODE.LIFT:                      float lift = 0;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentLift"))                              {                                  lift = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentLift"))                              {                                  lift = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genHeatmapColor(lift);                  case (int)ViewerConstants.COLORMODE.STALL:                      float stall = 0;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("stall"))                              {                                  stall = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("stall"))                              {                                  stall = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genFractColor(1f-stall);                  case (int)ViewerConstants.COLORMODE.HIDE:                      return Color.black;                  default:                      return Color.white;              }
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,getPartColor,The following statement contains a magic number: switch (mode)              {                  case (int)ViewerConstants.COLORMODE.NONE:                      return Color.white;                  case (int)ViewerConstants.COLORMODE.STATE:                      //it seems most of these are unused' but it does at least                      //make it (semi-)clear what is the root part and which parts belong                      //to activated stages                      if (part.parent == null) { return Color.magenta; }                      switch (part.State)                      {                          case PartStates.ACTIVE:                              return Color.blue;                          case PartStates.DEACTIVATED:                              return Color.red;                          case PartStates.DEAD:                              return Color.gray;                          case PartStates.IDLE:                              return Color.green;                          default:                              return Color.red;                      }                  case (int)ViewerConstants.COLORMODE.STAGE:                      //colors the parts by their inverse stage.                      //first we need an appropriate gradient' so check if we have it                      //and make it if we dont' or if its too small                      if (stagesThisTimeMax < part.inverseStage) stagesThisTimeMax = part.inverseStage;                        int neededColors = Math.Max(stagesLastTime' Math.Max(Staging.StageCount' stagesThisTimeMax)) + 1;                      if (stageGradient == null)                      {                          stageGradient = genColorGradient(neededColors);                      }                      else if (stageGradient.Length != neededColors)                      {                          stageGradient = genColorGradient(neededColors);                      }                      //now return the color                       //print("part " + part.name + " inv. stage " + part.inverseStage);                      if (part.inverseStage >= stageGradient.Length) return Color.magenta;                      return stageGradient[part.inverseStage];                  case (int)ViewerConstants.COLORMODE.HEAT:                      //colors the part according to how close its to exploding due to overheat                      Color color = new Color(0.2f' 0.2f' 0.2f);                      if (part.maxTemp != 0)                      {                          double tempDiff = part.temperature / part.maxTemp;                          //to power of THREE to emphasise overheating parts MORE                          tempDiff = Math.Pow(tempDiff' 3);                          //color.g = 0.2f;                          color.b = (float)(0.2f * (1 - tempDiff));                          color.r = (float)(0.2f + tempDiff * 0.8f);                          return color;                      }                      else                      {                          return color;                      }                  case (int)ViewerConstants.COLORMODE.FUEL:                      Color color2 = Color.red;                      List<PartResource> resList = part.Resources.list;                      int resCount = resList.Count;                      int emptyRes = 0;                      double totalResFraction = 0;                      //go through all the resources in the part' add up their fullness                      foreach (PartResource resource in resList)                      {                          //2 is almost empty anyway for all but the smallest tanks                           //and it eliminates things like intakes or power generating engines                          if (resource.amount <= 2f)                          {                              emptyRes++;                          }                          else                          {                              double resourceFraction = (resource.amount / resource.maxAmount);                              totalResFraction += resourceFraction / (double)resCount;                          }                      }                      //now set the part color                      if (resCount == 0 | emptyRes == resCount)                      {                          color2 = new Color(0.2f' 0.2f' 0.2f);                      }                      else                      {                          return genFractColor((float)totalResFraction);                      }                        return color2;                  case (int)ViewerConstants.COLORMODE.DRAG:                      float drag = part.angularDrag;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentDrag"))                              {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentDrag"))                              {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                        else if (part.Modules.Contains("FARBasicDragModel"))                      {                          //MonoBehaviour.print("basic drag");                          PartModule FARmodule = part.Modules["FARBasicDragModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                           {                              if (fieldInList.name.Equals("currentDrag"))                               {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genHeatmapColor(drag);                  case (int)ViewerConstants.COLORMODE.LIFT:                      float lift = 0;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentLift"))                              {                                  lift = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentLift"))                              {                                  lift = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genHeatmapColor(lift);                  case (int)ViewerConstants.COLORMODE.STALL:                      float stall = 0;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("stall"))                              {                                  stall = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("stall"))                              {                                  stall = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genFractColor(1f-stall);                  case (int)ViewerConstants.COLORMODE.HIDE:                      return Color.black;                  default:                      return Color.white;              }
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,getPartColor,The following statement contains a magic number: switch (mode)              {                  case (int)ViewerConstants.COLORMODE.NONE:                      return Color.white;                  case (int)ViewerConstants.COLORMODE.STATE:                      //it seems most of these are unused' but it does at least                      //make it (semi-)clear what is the root part and which parts belong                      //to activated stages                      if (part.parent == null) { return Color.magenta; }                      switch (part.State)                      {                          case PartStates.ACTIVE:                              return Color.blue;                          case PartStates.DEACTIVATED:                              return Color.red;                          case PartStates.DEAD:                              return Color.gray;                          case PartStates.IDLE:                              return Color.green;                          default:                              return Color.red;                      }                  case (int)ViewerConstants.COLORMODE.STAGE:                      //colors the parts by their inverse stage.                      //first we need an appropriate gradient' so check if we have it                      //and make it if we dont' or if its too small                      if (stagesThisTimeMax < part.inverseStage) stagesThisTimeMax = part.inverseStage;                        int neededColors = Math.Max(stagesLastTime' Math.Max(Staging.StageCount' stagesThisTimeMax)) + 1;                      if (stageGradient == null)                      {                          stageGradient = genColorGradient(neededColors);                      }                      else if (stageGradient.Length != neededColors)                      {                          stageGradient = genColorGradient(neededColors);                      }                      //now return the color                       //print("part " + part.name + " inv. stage " + part.inverseStage);                      if (part.inverseStage >= stageGradient.Length) return Color.magenta;                      return stageGradient[part.inverseStage];                  case (int)ViewerConstants.COLORMODE.HEAT:                      //colors the part according to how close its to exploding due to overheat                      Color color = new Color(0.2f' 0.2f' 0.2f);                      if (part.maxTemp != 0)                      {                          double tempDiff = part.temperature / part.maxTemp;                          //to power of THREE to emphasise overheating parts MORE                          tempDiff = Math.Pow(tempDiff' 3);                          //color.g = 0.2f;                          color.b = (float)(0.2f * (1 - tempDiff));                          color.r = (float)(0.2f + tempDiff * 0.8f);                          return color;                      }                      else                      {                          return color;                      }                  case (int)ViewerConstants.COLORMODE.FUEL:                      Color color2 = Color.red;                      List<PartResource> resList = part.Resources.list;                      int resCount = resList.Count;                      int emptyRes = 0;                      double totalResFraction = 0;                      //go through all the resources in the part' add up their fullness                      foreach (PartResource resource in resList)                      {                          //2 is almost empty anyway for all but the smallest tanks                           //and it eliminates things like intakes or power generating engines                          if (resource.amount <= 2f)                          {                              emptyRes++;                          }                          else                          {                              double resourceFraction = (resource.amount / resource.maxAmount);                              totalResFraction += resourceFraction / (double)resCount;                          }                      }                      //now set the part color                      if (resCount == 0 | emptyRes == resCount)                      {                          color2 = new Color(0.2f' 0.2f' 0.2f);                      }                      else                      {                          return genFractColor((float)totalResFraction);                      }                        return color2;                  case (int)ViewerConstants.COLORMODE.DRAG:                      float drag = part.angularDrag;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentDrag"))                              {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentDrag"))                              {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                        else if (part.Modules.Contains("FARBasicDragModel"))                      {                          //MonoBehaviour.print("basic drag");                          PartModule FARmodule = part.Modules["FARBasicDragModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                           {                              if (fieldInList.name.Equals("currentDrag"))                               {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genHeatmapColor(drag);                  case (int)ViewerConstants.COLORMODE.LIFT:                      float lift = 0;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentLift"))                              {                                  lift = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentLift"))                              {                                  lift = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genHeatmapColor(lift);                  case (int)ViewerConstants.COLORMODE.STALL:                      float stall = 0;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("stall"))                              {                                  stall = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("stall"))                              {                                  stall = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genFractColor(1f-stall);                  case (int)ViewerConstants.COLORMODE.HIDE:                      return Color.black;                  default:                      return Color.white;              }
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,getPartColor,The following statement contains a magic number: switch (mode)              {                  case (int)ViewerConstants.COLORMODE.NONE:                      return Color.white;                  case (int)ViewerConstants.COLORMODE.STATE:                      //it seems most of these are unused' but it does at least                      //make it (semi-)clear what is the root part and which parts belong                      //to activated stages                      if (part.parent == null) { return Color.magenta; }                      switch (part.State)                      {                          case PartStates.ACTIVE:                              return Color.blue;                          case PartStates.DEACTIVATED:                              return Color.red;                          case PartStates.DEAD:                              return Color.gray;                          case PartStates.IDLE:                              return Color.green;                          default:                              return Color.red;                      }                  case (int)ViewerConstants.COLORMODE.STAGE:                      //colors the parts by their inverse stage.                      //first we need an appropriate gradient' so check if we have it                      //and make it if we dont' or if its too small                      if (stagesThisTimeMax < part.inverseStage) stagesThisTimeMax = part.inverseStage;                        int neededColors = Math.Max(stagesLastTime' Math.Max(Staging.StageCount' stagesThisTimeMax)) + 1;                      if (stageGradient == null)                      {                          stageGradient = genColorGradient(neededColors);                      }                      else if (stageGradient.Length != neededColors)                      {                          stageGradient = genColorGradient(neededColors);                      }                      //now return the color                       //print("part " + part.name + " inv. stage " + part.inverseStage);                      if (part.inverseStage >= stageGradient.Length) return Color.magenta;                      return stageGradient[part.inverseStage];                  case (int)ViewerConstants.COLORMODE.HEAT:                      //colors the part according to how close its to exploding due to overheat                      Color color = new Color(0.2f' 0.2f' 0.2f);                      if (part.maxTemp != 0)                      {                          double tempDiff = part.temperature / part.maxTemp;                          //to power of THREE to emphasise overheating parts MORE                          tempDiff = Math.Pow(tempDiff' 3);                          //color.g = 0.2f;                          color.b = (float)(0.2f * (1 - tempDiff));                          color.r = (float)(0.2f + tempDiff * 0.8f);                          return color;                      }                      else                      {                          return color;                      }                  case (int)ViewerConstants.COLORMODE.FUEL:                      Color color2 = Color.red;                      List<PartResource> resList = part.Resources.list;                      int resCount = resList.Count;                      int emptyRes = 0;                      double totalResFraction = 0;                      //go through all the resources in the part' add up their fullness                      foreach (PartResource resource in resList)                      {                          //2 is almost empty anyway for all but the smallest tanks                           //and it eliminates things like intakes or power generating engines                          if (resource.amount <= 2f)                          {                              emptyRes++;                          }                          else                          {                              double resourceFraction = (resource.amount / resource.maxAmount);                              totalResFraction += resourceFraction / (double)resCount;                          }                      }                      //now set the part color                      if (resCount == 0 | emptyRes == resCount)                      {                          color2 = new Color(0.2f' 0.2f' 0.2f);                      }                      else                      {                          return genFractColor((float)totalResFraction);                      }                        return color2;                  case (int)ViewerConstants.COLORMODE.DRAG:                      float drag = part.angularDrag;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentDrag"))                              {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentDrag"))                              {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                        else if (part.Modules.Contains("FARBasicDragModel"))                      {                          //MonoBehaviour.print("basic drag");                          PartModule FARmodule = part.Modules["FARBasicDragModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                           {                              if (fieldInList.name.Equals("currentDrag"))                               {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genHeatmapColor(drag);                  case (int)ViewerConstants.COLORMODE.LIFT:                      float lift = 0;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentLift"))                              {                                  lift = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentLift"))                              {                                  lift = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genHeatmapColor(lift);                  case (int)ViewerConstants.COLORMODE.STALL:                      float stall = 0;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("stall"))                              {                                  stall = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("stall"))                              {                                  stall = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genFractColor(1f-stall);                  case (int)ViewerConstants.COLORMODE.HIDE:                      return Color.black;                  default:                      return Color.white;              }
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,getPartColor,The following statement contains a magic number: switch (mode)              {                  case (int)ViewerConstants.COLORMODE.NONE:                      return Color.white;                  case (int)ViewerConstants.COLORMODE.STATE:                      //it seems most of these are unused' but it does at least                      //make it (semi-)clear what is the root part and which parts belong                      //to activated stages                      if (part.parent == null) { return Color.magenta; }                      switch (part.State)                      {                          case PartStates.ACTIVE:                              return Color.blue;                          case PartStates.DEACTIVATED:                              return Color.red;                          case PartStates.DEAD:                              return Color.gray;                          case PartStates.IDLE:                              return Color.green;                          default:                              return Color.red;                      }                  case (int)ViewerConstants.COLORMODE.STAGE:                      //colors the parts by their inverse stage.                      //first we need an appropriate gradient' so check if we have it                      //and make it if we dont' or if its too small                      if (stagesThisTimeMax < part.inverseStage) stagesThisTimeMax = part.inverseStage;                        int neededColors = Math.Max(stagesLastTime' Math.Max(Staging.StageCount' stagesThisTimeMax)) + 1;                      if (stageGradient == null)                      {                          stageGradient = genColorGradient(neededColors);                      }                      else if (stageGradient.Length != neededColors)                      {                          stageGradient = genColorGradient(neededColors);                      }                      //now return the color                       //print("part " + part.name + " inv. stage " + part.inverseStage);                      if (part.inverseStage >= stageGradient.Length) return Color.magenta;                      return stageGradient[part.inverseStage];                  case (int)ViewerConstants.COLORMODE.HEAT:                      //colors the part according to how close its to exploding due to overheat                      Color color = new Color(0.2f' 0.2f' 0.2f);                      if (part.maxTemp != 0)                      {                          double tempDiff = part.temperature / part.maxTemp;                          //to power of THREE to emphasise overheating parts MORE                          tempDiff = Math.Pow(tempDiff' 3);                          //color.g = 0.2f;                          color.b = (float)(0.2f * (1 - tempDiff));                          color.r = (float)(0.2f + tempDiff * 0.8f);                          return color;                      }                      else                      {                          return color;                      }                  case (int)ViewerConstants.COLORMODE.FUEL:                      Color color2 = Color.red;                      List<PartResource> resList = part.Resources.list;                      int resCount = resList.Count;                      int emptyRes = 0;                      double totalResFraction = 0;                      //go through all the resources in the part' add up their fullness                      foreach (PartResource resource in resList)                      {                          //2 is almost empty anyway for all but the smallest tanks                           //and it eliminates things like intakes or power generating engines                          if (resource.amount <= 2f)                          {                              emptyRes++;                          }                          else                          {                              double resourceFraction = (resource.amount / resource.maxAmount);                              totalResFraction += resourceFraction / (double)resCount;                          }                      }                      //now set the part color                      if (resCount == 0 | emptyRes == resCount)                      {                          color2 = new Color(0.2f' 0.2f' 0.2f);                      }                      else                      {                          return genFractColor((float)totalResFraction);                      }                        return color2;                  case (int)ViewerConstants.COLORMODE.DRAG:                      float drag = part.angularDrag;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentDrag"))                              {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentDrag"))                              {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                        else if (part.Modules.Contains("FARBasicDragModel"))                      {                          //MonoBehaviour.print("basic drag");                          PartModule FARmodule = part.Modules["FARBasicDragModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                           {                              if (fieldInList.name.Equals("currentDrag"))                               {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genHeatmapColor(drag);                  case (int)ViewerConstants.COLORMODE.LIFT:                      float lift = 0;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentLift"))                              {                                  lift = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentLift"))                              {                                  lift = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genHeatmapColor(lift);                  case (int)ViewerConstants.COLORMODE.STALL:                      float stall = 0;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("stall"))                              {                                  stall = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("stall"))                              {                                  stall = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genFractColor(1f-stall);                  case (int)ViewerConstants.COLORMODE.HIDE:                      return Color.black;                  default:                      return Color.white;              }
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,getPartColor,The following statement contains a magic number: switch (mode)              {                  case (int)ViewerConstants.COLORMODE.NONE:                      return Color.white;                  case (int)ViewerConstants.COLORMODE.STATE:                      //it seems most of these are unused' but it does at least                      //make it (semi-)clear what is the root part and which parts belong                      //to activated stages                      if (part.parent == null) { return Color.magenta; }                      switch (part.State)                      {                          case PartStates.ACTIVE:                              return Color.blue;                          case PartStates.DEACTIVATED:                              return Color.red;                          case PartStates.DEAD:                              return Color.gray;                          case PartStates.IDLE:                              return Color.green;                          default:                              return Color.red;                      }                  case (int)ViewerConstants.COLORMODE.STAGE:                      //colors the parts by their inverse stage.                      //first we need an appropriate gradient' so check if we have it                      //and make it if we dont' or if its too small                      if (stagesThisTimeMax < part.inverseStage) stagesThisTimeMax = part.inverseStage;                        int neededColors = Math.Max(stagesLastTime' Math.Max(Staging.StageCount' stagesThisTimeMax)) + 1;                      if (stageGradient == null)                      {                          stageGradient = genColorGradient(neededColors);                      }                      else if (stageGradient.Length != neededColors)                      {                          stageGradient = genColorGradient(neededColors);                      }                      //now return the color                       //print("part " + part.name + " inv. stage " + part.inverseStage);                      if (part.inverseStage >= stageGradient.Length) return Color.magenta;                      return stageGradient[part.inverseStage];                  case (int)ViewerConstants.COLORMODE.HEAT:                      //colors the part according to how close its to exploding due to overheat                      Color color = new Color(0.2f' 0.2f' 0.2f);                      if (part.maxTemp != 0)                      {                          double tempDiff = part.temperature / part.maxTemp;                          //to power of THREE to emphasise overheating parts MORE                          tempDiff = Math.Pow(tempDiff' 3);                          //color.g = 0.2f;                          color.b = (float)(0.2f * (1 - tempDiff));                          color.r = (float)(0.2f + tempDiff * 0.8f);                          return color;                      }                      else                      {                          return color;                      }                  case (int)ViewerConstants.COLORMODE.FUEL:                      Color color2 = Color.red;                      List<PartResource> resList = part.Resources.list;                      int resCount = resList.Count;                      int emptyRes = 0;                      double totalResFraction = 0;                      //go through all the resources in the part' add up their fullness                      foreach (PartResource resource in resList)                      {                          //2 is almost empty anyway for all but the smallest tanks                           //and it eliminates things like intakes or power generating engines                          if (resource.amount <= 2f)                          {                              emptyRes++;                          }                          else                          {                              double resourceFraction = (resource.amount / resource.maxAmount);                              totalResFraction += resourceFraction / (double)resCount;                          }                      }                      //now set the part color                      if (resCount == 0 | emptyRes == resCount)                      {                          color2 = new Color(0.2f' 0.2f' 0.2f);                      }                      else                      {                          return genFractColor((float)totalResFraction);                      }                        return color2;                  case (int)ViewerConstants.COLORMODE.DRAG:                      float drag = part.angularDrag;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentDrag"))                              {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentDrag"))                              {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                        else if (part.Modules.Contains("FARBasicDragModel"))                      {                          //MonoBehaviour.print("basic drag");                          PartModule FARmodule = part.Modules["FARBasicDragModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                           {                              if (fieldInList.name.Equals("currentDrag"))                               {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genHeatmapColor(drag);                  case (int)ViewerConstants.COLORMODE.LIFT:                      float lift = 0;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentLift"))                              {                                  lift = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentLift"))                              {                                  lift = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genHeatmapColor(lift);                  case (int)ViewerConstants.COLORMODE.STALL:                      float stall = 0;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("stall"))                              {                                  stall = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("stall"))                              {                                  stall = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genFractColor(1f-stall);                  case (int)ViewerConstants.COLORMODE.HIDE:                      return Color.black;                  default:                      return Color.white;              }
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,getPartColor,The following statement contains a magic number: switch (mode)              {                  case (int)ViewerConstants.COLORMODE.NONE:                      return Color.white;                  case (int)ViewerConstants.COLORMODE.STATE:                      //it seems most of these are unused' but it does at least                      //make it (semi-)clear what is the root part and which parts belong                      //to activated stages                      if (part.parent == null) { return Color.magenta; }                      switch (part.State)                      {                          case PartStates.ACTIVE:                              return Color.blue;                          case PartStates.DEACTIVATED:                              return Color.red;                          case PartStates.DEAD:                              return Color.gray;                          case PartStates.IDLE:                              return Color.green;                          default:                              return Color.red;                      }                  case (int)ViewerConstants.COLORMODE.STAGE:                      //colors the parts by their inverse stage.                      //first we need an appropriate gradient' so check if we have it                      //and make it if we dont' or if its too small                      if (stagesThisTimeMax < part.inverseStage) stagesThisTimeMax = part.inverseStage;                        int neededColors = Math.Max(stagesLastTime' Math.Max(Staging.StageCount' stagesThisTimeMax)) + 1;                      if (stageGradient == null)                      {                          stageGradient = genColorGradient(neededColors);                      }                      else if (stageGradient.Length != neededColors)                      {                          stageGradient = genColorGradient(neededColors);                      }                      //now return the color                       //print("part " + part.name + " inv. stage " + part.inverseStage);                      if (part.inverseStage >= stageGradient.Length) return Color.magenta;                      return stageGradient[part.inverseStage];                  case (int)ViewerConstants.COLORMODE.HEAT:                      //colors the part according to how close its to exploding due to overheat                      Color color = new Color(0.2f' 0.2f' 0.2f);                      if (part.maxTemp != 0)                      {                          double tempDiff = part.temperature / part.maxTemp;                          //to power of THREE to emphasise overheating parts MORE                          tempDiff = Math.Pow(tempDiff' 3);                          //color.g = 0.2f;                          color.b = (float)(0.2f * (1 - tempDiff));                          color.r = (float)(0.2f + tempDiff * 0.8f);                          return color;                      }                      else                      {                          return color;                      }                  case (int)ViewerConstants.COLORMODE.FUEL:                      Color color2 = Color.red;                      List<PartResource> resList = part.Resources.list;                      int resCount = resList.Count;                      int emptyRes = 0;                      double totalResFraction = 0;                      //go through all the resources in the part' add up their fullness                      foreach (PartResource resource in resList)                      {                          //2 is almost empty anyway for all but the smallest tanks                           //and it eliminates things like intakes or power generating engines                          if (resource.amount <= 2f)                          {                              emptyRes++;                          }                          else                          {                              double resourceFraction = (resource.amount / resource.maxAmount);                              totalResFraction += resourceFraction / (double)resCount;                          }                      }                      //now set the part color                      if (resCount == 0 | emptyRes == resCount)                      {                          color2 = new Color(0.2f' 0.2f' 0.2f);                      }                      else                      {                          return genFractColor((float)totalResFraction);                      }                        return color2;                  case (int)ViewerConstants.COLORMODE.DRAG:                      float drag = part.angularDrag;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentDrag"))                              {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentDrag"))                              {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                        else if (part.Modules.Contains("FARBasicDragModel"))                      {                          //MonoBehaviour.print("basic drag");                          PartModule FARmodule = part.Modules["FARBasicDragModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                           {                              if (fieldInList.name.Equals("currentDrag"))                               {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genHeatmapColor(drag);                  case (int)ViewerConstants.COLORMODE.LIFT:                      float lift = 0;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentLift"))                              {                                  lift = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentLift"))                              {                                  lift = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genHeatmapColor(lift);                  case (int)ViewerConstants.COLORMODE.STALL:                      float stall = 0;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("stall"))                              {                                  stall = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("stall"))                              {                                  stall = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genFractColor(1f-stall);                  case (int)ViewerConstants.COLORMODE.HIDE:                      return Color.black;                  default:                      return Color.white;              }
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,getPartColor,The following statement contains a magic number: switch (mode)              {                  case (int)ViewerConstants.COLORMODE.NONE:                      return Color.white;                  case (int)ViewerConstants.COLORMODE.STATE:                      //it seems most of these are unused' but it does at least                      //make it (semi-)clear what is the root part and which parts belong                      //to activated stages                      if (part.parent == null) { return Color.magenta; }                      switch (part.State)                      {                          case PartStates.ACTIVE:                              return Color.blue;                          case PartStates.DEACTIVATED:                              return Color.red;                          case PartStates.DEAD:                              return Color.gray;                          case PartStates.IDLE:                              return Color.green;                          default:                              return Color.red;                      }                  case (int)ViewerConstants.COLORMODE.STAGE:                      //colors the parts by their inverse stage.                      //first we need an appropriate gradient' so check if we have it                      //and make it if we dont' or if its too small                      if (stagesThisTimeMax < part.inverseStage) stagesThisTimeMax = part.inverseStage;                        int neededColors = Math.Max(stagesLastTime' Math.Max(Staging.StageCount' stagesThisTimeMax)) + 1;                      if (stageGradient == null)                      {                          stageGradient = genColorGradient(neededColors);                      }                      else if (stageGradient.Length != neededColors)                      {                          stageGradient = genColorGradient(neededColors);                      }                      //now return the color                       //print("part " + part.name + " inv. stage " + part.inverseStage);                      if (part.inverseStage >= stageGradient.Length) return Color.magenta;                      return stageGradient[part.inverseStage];                  case (int)ViewerConstants.COLORMODE.HEAT:                      //colors the part according to how close its to exploding due to overheat                      Color color = new Color(0.2f' 0.2f' 0.2f);                      if (part.maxTemp != 0)                      {                          double tempDiff = part.temperature / part.maxTemp;                          //to power of THREE to emphasise overheating parts MORE                          tempDiff = Math.Pow(tempDiff' 3);                          //color.g = 0.2f;                          color.b = (float)(0.2f * (1 - tempDiff));                          color.r = (float)(0.2f + tempDiff * 0.8f);                          return color;                      }                      else                      {                          return color;                      }                  case (int)ViewerConstants.COLORMODE.FUEL:                      Color color2 = Color.red;                      List<PartResource> resList = part.Resources.list;                      int resCount = resList.Count;                      int emptyRes = 0;                      double totalResFraction = 0;                      //go through all the resources in the part' add up their fullness                      foreach (PartResource resource in resList)                      {                          //2 is almost empty anyway for all but the smallest tanks                           //and it eliminates things like intakes or power generating engines                          if (resource.amount <= 2f)                          {                              emptyRes++;                          }                          else                          {                              double resourceFraction = (resource.amount / resource.maxAmount);                              totalResFraction += resourceFraction / (double)resCount;                          }                      }                      //now set the part color                      if (resCount == 0 | emptyRes == resCount)                      {                          color2 = new Color(0.2f' 0.2f' 0.2f);                      }                      else                      {                          return genFractColor((float)totalResFraction);                      }                        return color2;                  case (int)ViewerConstants.COLORMODE.DRAG:                      float drag = part.angularDrag;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentDrag"))                              {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentDrag"))                              {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                        else if (part.Modules.Contains("FARBasicDragModel"))                      {                          //MonoBehaviour.print("basic drag");                          PartModule FARmodule = part.Modules["FARBasicDragModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                           {                              if (fieldInList.name.Equals("currentDrag"))                               {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genHeatmapColor(drag);                  case (int)ViewerConstants.COLORMODE.LIFT:                      float lift = 0;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentLift"))                              {                                  lift = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentLift"))                              {                                  lift = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genHeatmapColor(lift);                  case (int)ViewerConstants.COLORMODE.STALL:                      float stall = 0;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("stall"))                              {                                  stall = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("stall"))                              {                                  stall = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genFractColor(1f-stall);                  case (int)ViewerConstants.COLORMODE.HIDE:                      return Color.black;                  default:                      return Color.white;              }
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,getPartColor,The following statement contains a magic number: switch (mode)              {                  case (int)ViewerConstants.COLORMODE.NONE:                      return Color.white;                  case (int)ViewerConstants.COLORMODE.STATE:                      //it seems most of these are unused' but it does at least                      //make it (semi-)clear what is the root part and which parts belong                      //to activated stages                      if (part.parent == null) { return Color.magenta; }                      switch (part.State)                      {                          case PartStates.ACTIVE:                              return Color.blue;                          case PartStates.DEACTIVATED:                              return Color.red;                          case PartStates.DEAD:                              return Color.gray;                          case PartStates.IDLE:                              return Color.green;                          default:                              return Color.red;                      }                  case (int)ViewerConstants.COLORMODE.STAGE:                      //colors the parts by their inverse stage.                      //first we need an appropriate gradient' so check if we have it                      //and make it if we dont' or if its too small                      if (stagesThisTimeMax < part.inverseStage) stagesThisTimeMax = part.inverseStage;                        int neededColors = Math.Max(stagesLastTime' Math.Max(Staging.StageCount' stagesThisTimeMax)) + 1;                      if (stageGradient == null)                      {                          stageGradient = genColorGradient(neededColors);                      }                      else if (stageGradient.Length != neededColors)                      {                          stageGradient = genColorGradient(neededColors);                      }                      //now return the color                       //print("part " + part.name + " inv. stage " + part.inverseStage);                      if (part.inverseStage >= stageGradient.Length) return Color.magenta;                      return stageGradient[part.inverseStage];                  case (int)ViewerConstants.COLORMODE.HEAT:                      //colors the part according to how close its to exploding due to overheat                      Color color = new Color(0.2f' 0.2f' 0.2f);                      if (part.maxTemp != 0)                      {                          double tempDiff = part.temperature / part.maxTemp;                          //to power of THREE to emphasise overheating parts MORE                          tempDiff = Math.Pow(tempDiff' 3);                          //color.g = 0.2f;                          color.b = (float)(0.2f * (1 - tempDiff));                          color.r = (float)(0.2f + tempDiff * 0.8f);                          return color;                      }                      else                      {                          return color;                      }                  case (int)ViewerConstants.COLORMODE.FUEL:                      Color color2 = Color.red;                      List<PartResource> resList = part.Resources.list;                      int resCount = resList.Count;                      int emptyRes = 0;                      double totalResFraction = 0;                      //go through all the resources in the part' add up their fullness                      foreach (PartResource resource in resList)                      {                          //2 is almost empty anyway for all but the smallest tanks                           //and it eliminates things like intakes or power generating engines                          if (resource.amount <= 2f)                          {                              emptyRes++;                          }                          else                          {                              double resourceFraction = (resource.amount / resource.maxAmount);                              totalResFraction += resourceFraction / (double)resCount;                          }                      }                      //now set the part color                      if (resCount == 0 | emptyRes == resCount)                      {                          color2 = new Color(0.2f' 0.2f' 0.2f);                      }                      else                      {                          return genFractColor((float)totalResFraction);                      }                        return color2;                  case (int)ViewerConstants.COLORMODE.DRAG:                      float drag = part.angularDrag;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentDrag"))                              {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentDrag"))                              {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                        else if (part.Modules.Contains("FARBasicDragModel"))                      {                          //MonoBehaviour.print("basic drag");                          PartModule FARmodule = part.Modules["FARBasicDragModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                           {                              if (fieldInList.name.Equals("currentDrag"))                               {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genHeatmapColor(drag);                  case (int)ViewerConstants.COLORMODE.LIFT:                      float lift = 0;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentLift"))                              {                                  lift = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentLift"))                              {                                  lift = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genHeatmapColor(lift);                  case (int)ViewerConstants.COLORMODE.STALL:                      float stall = 0;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("stall"))                              {                                  stall = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("stall"))                              {                                  stall = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genFractColor(1f-stall);                  case (int)ViewerConstants.COLORMODE.HIDE:                      return Color.black;                  default:                      return Color.white;              }
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,getPartColor,The following statement contains a magic number: switch (mode)              {                  case (int)ViewerConstants.COLORMODE.NONE:                      return Color.white;                  case (int)ViewerConstants.COLORMODE.STATE:                      //it seems most of these are unused' but it does at least                      //make it (semi-)clear what is the root part and which parts belong                      //to activated stages                      if (part.parent == null) { return Color.magenta; }                      switch (part.State)                      {                          case PartStates.ACTIVE:                              return Color.blue;                          case PartStates.DEACTIVATED:                              return Color.red;                          case PartStates.DEAD:                              return Color.gray;                          case PartStates.IDLE:                              return Color.green;                          default:                              return Color.red;                      }                  case (int)ViewerConstants.COLORMODE.STAGE:                      //colors the parts by their inverse stage.                      //first we need an appropriate gradient' so check if we have it                      //and make it if we dont' or if its too small                      if (stagesThisTimeMax < part.inverseStage) stagesThisTimeMax = part.inverseStage;                        int neededColors = Math.Max(stagesLastTime' Math.Max(Staging.StageCount' stagesThisTimeMax)) + 1;                      if (stageGradient == null)                      {                          stageGradient = genColorGradient(neededColors);                      }                      else if (stageGradient.Length != neededColors)                      {                          stageGradient = genColorGradient(neededColors);                      }                      //now return the color                       //print("part " + part.name + " inv. stage " + part.inverseStage);                      if (part.inverseStage >= stageGradient.Length) return Color.magenta;                      return stageGradient[part.inverseStage];                  case (int)ViewerConstants.COLORMODE.HEAT:                      //colors the part according to how close its to exploding due to overheat                      Color color = new Color(0.2f' 0.2f' 0.2f);                      if (part.maxTemp != 0)                      {                          double tempDiff = part.temperature / part.maxTemp;                          //to power of THREE to emphasise overheating parts MORE                          tempDiff = Math.Pow(tempDiff' 3);                          //color.g = 0.2f;                          color.b = (float)(0.2f * (1 - tempDiff));                          color.r = (float)(0.2f + tempDiff * 0.8f);                          return color;                      }                      else                      {                          return color;                      }                  case (int)ViewerConstants.COLORMODE.FUEL:                      Color color2 = Color.red;                      List<PartResource> resList = part.Resources.list;                      int resCount = resList.Count;                      int emptyRes = 0;                      double totalResFraction = 0;                      //go through all the resources in the part' add up their fullness                      foreach (PartResource resource in resList)                      {                          //2 is almost empty anyway for all but the smallest tanks                           //and it eliminates things like intakes or power generating engines                          if (resource.amount <= 2f)                          {                              emptyRes++;                          }                          else                          {                              double resourceFraction = (resource.amount / resource.maxAmount);                              totalResFraction += resourceFraction / (double)resCount;                          }                      }                      //now set the part color                      if (resCount == 0 | emptyRes == resCount)                      {                          color2 = new Color(0.2f' 0.2f' 0.2f);                      }                      else                      {                          return genFractColor((float)totalResFraction);                      }                        return color2;                  case (int)ViewerConstants.COLORMODE.DRAG:                      float drag = part.angularDrag;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentDrag"))                              {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentDrag"))                              {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                        else if (part.Modules.Contains("FARBasicDragModel"))                      {                          //MonoBehaviour.print("basic drag");                          PartModule FARmodule = part.Modules["FARBasicDragModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                           {                              if (fieldInList.name.Equals("currentDrag"))                               {                                  drag = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genHeatmapColor(drag);                  case (int)ViewerConstants.COLORMODE.LIFT:                      float lift = 0;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentLift"))                              {                                  lift = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("currentLift"))                              {                                  lift = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genHeatmapColor(lift);                  case (int)ViewerConstants.COLORMODE.STALL:                      float stall = 0;                      if (part.Modules.Contains("FARControllableSurface"))                      {                          //MonoBehaviour.print("cont. surf.");                          PartModule FARmodule = part.Modules["FARControllableSurface"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("stall"))                              {                                  stall = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      else if (part.Modules.Contains("FARWingAerodynamicModel"))                      {                          //MonoBehaviour.print("wing");                          PartModule FARmodule = part.Modules["FARWingAerodynamicModel"];                          foreach (BaseField fieldInList in FARmodule.Fields)                          {                              if (fieldInList.name.Equals("stall"))                              {                                  stall = (float)fieldInList.GetValue(FARmodule);                                  break;                              }                          }                      }                      return genFractColor(1f-stall);                  case (int)ViewerConstants.COLORMODE.HIDE:                      return Color.black;                  default:                      return Color.white;              }
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,genHeatmapColor,The following statement contains a magic number: Color color = new Color(0.1f'0.1f'0.1f);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,genHeatmapColor,The following statement contains a magic number: Color color = new Color(0.1f'0.1f'0.1f);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,genHeatmapColor,The following statement contains a magic number: Color color = new Color(0.1f'0.1f'0.1f);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,genHeatmapColor,The following statement contains a magic number: color.b += value * 0.9f;
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,genFractColor,The following statement contains a magic number: color.g = (float)(fraction * 2);
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,genFractColor,The following statement contains a magic number: fraction <= 0.5f
Magic Number,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,genColorGradient,The following statement contains a magic number: float perStep = 4f / ((float)(numberOfColors - 1));
Missing Default,VesselView,ViewerSettings,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\ViewerSettings.cs,getPropertyDesc,The following switch statement is missing a default case: switch (propertyName)               {                  case "colorModeFill":                      return ViewerConstants.COLORMODES[colorModeFill];                  case "colorModeWire":                      return ViewerConstants.COLORMODES[colorModeWire];                  case "colorModeBox":                      return ViewerConstants.COLORMODES[colorModeBox];                  case "centerOnRootH":                      return ViewerConstants.boolAsString(centerOnRootH);                  case "centerOnRootV":                      return ViewerConstants.boolAsString(centerOnRootV);                  case "displayCOM":                      return ViewerConstants.boolAsString(displayCOM);                  case "displayEngines":                      return ViewerConstants.boolAsString(displayEngines);                  case "displayGround":                      return ViewerConstants.GROUND_DISPMODES[displayGround];                  case "displayAxes":                      return ViewerConstants.boolAsString(displayAxes);                  /*case "displayCOP":                      return boolAsString(displayCOP);*/                  case "centerRescale":                      return ViewerConstants.RESCALEMODES[centerRescale];                  case "autoCenter":                      return ViewerConstants.boolAsString(autoCenter);                  case "latency":                      return ViewerConstants.LATENCIES[latency];                  case "drawPlane":                      return ViewerConstants.PLANES[drawPlane];                  case "scalePos":                      return ViewerConstants.SCALE_FACTS[scalePos] + " predefined";                  case "colorModeFillDull":                      return ViewerConstants.boolAsString(colorModeFillDull);                  case "colorModeBoxDull":                      return ViewerConstants.boolAsString(colorModeBoxDull);                  case "colorModeWireDull":                      return ViewerConstants.boolAsString(colorModeWireDull);                  /*case "partSelectMode":                      return boolAsString(partSelectMode);                  case "selectionSymmetry":                      return boolAsString(selectionSymmetry);                  case "selectionCenter":                      return boolAsString(selectionCenter);*/                  case "spinAxis":                      return ViewerConstants.AXES[spinAxis];                  case "spinSpeed":                      return ViewerConstants.SPIN_SPEEDS[spinSpeed];              }
Missing Default,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,drawCall,The following switch statement is missing a default case: switch (customMode.CenteringOverride)                       {                          case (int)CustomModeSettings.OVERRIDE_TYPES.AS_BASIC:                              if (basicSettings.autoCenter)                              {                                  centerise(screen.width' screen.height);                              }break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.STATIC:                              if (customMode.staticSettings.autoCenter)                              {                                  centerise(screen.width' screen.height);                              }break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.FUNCTION:                              if (customMode.autoCenterDelegate(customMode))                              {                                  centerise(screen.width' screen.height);                              }break;                        }
Missing Default,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderToTexture,The following switch statement is missing a default case: switch (customMode.MinimodesOverride)                      {                          case (int)CustomModeSettings.OVERRIDE_TYPES.AS_BASIC:                              if (basicSettings.displayEngines)                              {                                  renderEngineThrusts(matrix);                                  } break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.STATIC:                              if (customMode.staticSettings.displayEngines)                              {                                  renderEngineThrusts(matrix);                                  } break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.FUNCTION:                              if (customMode.displayEnginesDelegate(customMode))                              {                                  renderEngineThrusts(matrix);                               } break;                      }
Missing Default,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderToTexture,The following switch statement is missing a default case: switch (customMode.ColorModeOverride)                      {                          case (int)CustomModeSettings.OVERRIDE_TYPES.AS_BASIC:                              if (basicSettings.colorModeBox != (int)ViewerConstants.COLORMODE.HIDE)                              {                                  renderRects(matrix);                              }break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.STATIC:                              if (customMode.staticSettings.colorModeBox != (int)ViewerConstants.COLORMODE.HIDE)                              {                                  renderRects(matrix);                              }break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.FUNCTION:                              renderRects(matrix);                              break;                      }
Missing Default,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderToTexture,The following switch statement is missing a default case: switch (customMode.MinimodesOverride)                      {                          case (int)CustomModeSettings.OVERRIDE_TYPES.AS_BASIC:                              if (basicSettings.displayCOM)                               {                                  renderCOM(matrix);                              } break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.STATIC:                              if (customMode.staticSettings.displayCOM)                              {                                  renderCOM(matrix);                              } break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.FUNCTION:                              if (customMode.displayCOMDelegate(customMode))                              {                                  renderCOM(matrix);                              } break;                      }
Missing Default,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderToTexture,The following switch statement is missing a default case: switch (customMode.MinimodesOverride)                      {                          case (int)CustomModeSettings.OVERRIDE_TYPES.AS_BASIC:                              if (basicSettings.displayGround != (int)ViewerConstants.GROUND_DISPMODE.OFF)                              {                                  renderGround(matrix);                              } break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.STATIC:                              if (customMode.staticSettings.displayGround != (int)ViewerConstants.GROUND_DISPMODE.OFF)                              {                                  renderGround(matrix);                              } break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.FUNCTION:                              if (customMode.displayGroundDelegate(customMode) != (int)ViewerConstants.GROUND_DISPMODE.OFF)                              {                                  renderGround(matrix);                              } break;                      }
Missing Default,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderToTexture,The following switch statement is missing a default case: switch (customMode.MinimodesOverride)                      {                          case (int)CustomModeSettings.OVERRIDE_TYPES.AS_BASIC:                              if (basicSettings.displayAxes)                              {                                  renderAxes(matrix);                              } break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.STATIC:                              if (customMode.staticSettings.displayAxes)                              {                                  renderAxes(matrix);                              } break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.FUNCTION:                              if (customMode.displayAxesDelegate(customMode))                              {                                  renderAxes(matrix);                              } break;                      }
Missing Default,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderGround,The following switch statement is missing a default case: switch (customMode.MinimodesOverride)                      {                          case (int)CustomModeSettings.OVERRIDE_TYPES.AS_BASIC:                              if (basicSettings.displayGround == (int)ViewerConstants.GROUND_DISPMODE.PLANE)                               {                                  angle = Vector3.Angle(Vector3.back' localSpaceNormal);                              } break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.STATIC:                              if (customMode.staticSettings.displayGround == (int)ViewerConstants.GROUND_DISPMODE.PLANE)                               {                                  angle = Vector3.Angle(Vector3.back' localSpaceNormal);                              } break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.FUNCTION:                              if (customMode.displayGroundDelegate(customMode) == (int)ViewerConstants.GROUND_DISPMODE.PLANE)                              {                                  angle = Vector3.Angle(Vector3.back' localSpaceNormal);                              } break;                      }
Missing Default,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderPart,The following switch statement is missing a default case: switch (customMode.ColorModeOverride)                      {                          case (int)CustomModeSettings.OVERRIDE_TYPES.AS_BASIC:                              if (!fill)  partColor = getPartColor(part' basicSettings.colorModeWire);                              else        partColor = getPartColor(part' basicSettings.colorModeFill);                               break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.STATIC:                              if (!fill)  partColor = getPartColor(part' customMode.staticSettings.colorModeWire);                              else        partColor = getPartColor(part' customMode.staticSettings.colorModeFill);                                break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.FUNCTION:                              if (fill)   partColor = customMode.fillColorDelegate(customMode'part);                              else partColor = customMode.wireColorDelegate(customMode' part);                              break;                      }
Missing Default,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderPart,The following switch statement is missing a default case: switch (customMode.ColorModeOverride)                      {                          case (int)CustomModeSettings.OVERRIDE_TYPES.AS_BASIC:                              boxColor = getPartColor(part' basicSettings.colorModeBox);                              break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.STATIC:                              boxColor = getPartColor(part' customMode.staticSettings.colorModeBox);                              break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.FUNCTION:                              boxColor = customMode.boxColorDelegate(customMode' part);                              break;                      }
Missing Default,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderPart,The following switch statement is missing a default case: switch (customMode.ColorModeOverride)                      {                          case (int)CustomModeSettings.OVERRIDE_TYPES.AS_BASIC:                              if (basicSettings.colorModeBoxDull) {                                  boxColor.r = boxColor.r / 2;                                  boxColor.g = boxColor.g / 2;                                  boxColor.b = boxColor.b / 2;                              }break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.STATIC:                              if (customMode.staticSettings.colorModeBoxDull) {                                  boxColor.r = boxColor.r / 2;                                  boxColor.g = boxColor.g / 2;                                  boxColor.b = boxColor.b / 2;                              }break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.FUNCTION:                              if (customMode.boxColorDullDelegate(customMode)) {                                  boxColor.r = boxColor.r / 2;                                  boxColor.g = boxColor.g / 2;                                  boxColor.b = boxColor.b / 2;                              }break;                      }
Missing Default,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderPart,The following switch statement is missing a default case: switch (customMode.ColorModeOverride)                      {                          case (int)CustomModeSettings.OVERRIDE_TYPES.AS_BASIC:                              if (basicSettings.colorModeFillDull)                              {                                  partColor.r = partColor.r / 2;                                  partColor.g = partColor.g / 2;                                  partColor.b = partColor.b / 2;                              }break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.STATIC:                              if (customMode.staticSettings.colorModeFillDull)                              {                                  partColor.r = partColor.r / 2;                                  partColor.g = partColor.g / 2;                                  partColor.b = partColor.b / 2;                              }break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.FUNCTION:                              if (customMode.fillColorDullDelegate(customMode))                              {                                  partColor.r = partColor.r / 2;                                  partColor.g = partColor.g / 2;                                  partColor.b = partColor.b / 2;                              }break;                      }
Missing Default,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderPart,The following switch statement is missing a default case: switch (customMode.ColorModeOverride)                      {                          case (int)CustomModeSettings.OVERRIDE_TYPES.AS_BASIC:                              if (basicSettings.colorModeWireDull)                              {                                  partColor.r = partColor.r / 2;                                  partColor.g = partColor.g / 2;                                  partColor.b = partColor.b / 2;                              } break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.STATIC:                              if (customMode.staticSettings.colorModeWireDull)                              {                                  partColor.r = partColor.r / 2;                                  partColor.g = partColor.g / 2;                                  partColor.b = partColor.b / 2;                              } break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.FUNCTION:                              if (customMode.wireColorDullDelegate(customMode))                              {                                  partColor.r = partColor.r / 2;                                  partColor.g = partColor.g / 2;                                  partColor.b = partColor.b / 2;                              } break;                      }
Missing Default,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,renderIcon,The following switch statement is missing a default case: switch (type)               {                  case (int)ViewerConstants.ICONS.SQUARE:                      renderLine(rect.xMin' rect.yMin' rect.xMax' rect.yMin' screenMatrix);                      renderLine(rect.xMax' rect.yMin' rect.xMax' rect.yMax' screenMatrix);                      renderLine(rect.xMax' rect.yMax' rect.xMin' rect.yMax' screenMatrix);                      renderLine(rect.xMin' rect.yMax' rect.xMin' rect.yMin' screenMatrix);                      break;                  case (int)ViewerConstants.ICONS.DIAMOND:                      renderLine(xMid' rect.yMin' rect.xMax' yMid' screenMatrix);                      renderLine(rect.xMax' yMid' xMid' rect.yMax' screenMatrix);                      renderLine(xMid' rect.yMax' rect.xMin' yMid' screenMatrix);                      renderLine(rect.xMin' yMid' xMid' rect.yMin' screenMatrix);                      break;                  case (int)ViewerConstants.ICONS.SQUARE_DIAMOND:                      renderLine(rect.xMin' rect.yMin' rect.xMax' rect.yMin' screenMatrix);                      renderLine(rect.xMax' rect.yMin' rect.xMax' rect.yMax' screenMatrix);                      renderLine(rect.xMax' rect.yMax' rect.xMin' rect.yMax' screenMatrix);                      renderLine(rect.xMin' rect.yMax' rect.xMin' rect.yMin' screenMatrix);                      renderLine(xMid' rect.yMin' rect.xMax' yMid' screenMatrix);                      renderLine(rect.xMax' yMid' xMid' rect.yMax' screenMatrix);                      renderLine(xMid' rect.yMax' rect.xMin' yMid' screenMatrix);                      renderLine(rect.xMin' yMid' xMid' rect.yMin' screenMatrix);                      break;                  case (int)ViewerConstants.ICONS.TRIANGLE_UP:                      renderLine(rect.xMin' rect.yMin' rect.xMax' rect.yMin' screenMatrix);                      renderLine(rect.xMax' rect.yMin' xMid' rect.yMax' screenMatrix);                      renderLine(xMid' rect.yMax' rect.xMin' rect.yMin' screenMatrix);                      break;                  case (int)ViewerConstants.ICONS.TRIANGLE_DOWN:                      renderLine(rect.xMin' rect.yMax' rect.xMax' rect.yMax' screenMatrix);                      renderLine(rect.xMax' rect.yMax' xMid' rect.yMin' screenMatrix);                      renderLine(xMid' rect.yMin' rect.xMin' rect.yMax' screenMatrix);                      break;                  case (int)ViewerConstants.ICONS.ENGINE_READY:                      renderLine(rect.xMin' rect.yMin' rect.xMax' rect.yMin' screenMatrix);                      renderLine(rect.xMax' rect.yMin' rect.xMax' rect.yMax' screenMatrix);                      renderLine(rect.xMax' rect.yMax' rect.xMin' rect.yMax' screenMatrix);                      renderLine(rect.xMin' rect.yMax' rect.xMin' rect.yMin' screenMatrix);                        renderLine(rect.xMin' yMid' xMid' rect.yMin' screenMatrix);                      renderLine(xMid' rect.yMin' rect.xMax' rect.yMax' screenMatrix);                      break;                  case (int)ViewerConstants.ICONS.ENGINE_NOPOWER:                      renderLine(rect.xMin' rect.yMin' rect.xMax' rect.yMin' screenMatrix);                      renderLine(rect.xMax' rect.yMin' rect.xMax' rect.yMax' screenMatrix);                      renderLine(rect.xMax' rect.yMax' rect.xMin' rect.yMax' screenMatrix);                      renderLine(rect.xMin' rect.yMax' rect.xMin' rect.yMin' screenMatrix);                        renderLine(xMid' rect.yMin' xThreeFourth' yMid' screenMatrix);                      renderLine(xOneFourth' yMid' xThreeFourth' yMid' screenMatrix);                      renderLine(xOneFourth' yMid' xMid' rect.yMax' screenMatrix);                      break;                  case (int)ViewerConstants.ICONS.ENGINE_NOFUEL:                      renderLine(rect.xMin' rect.yMin' rect.xMax' rect.yMin' screenMatrix);                      renderLine(rect.xMax' rect.yMin' rect.xMax' rect.yMax' screenMatrix);                      renderLine(rect.xMax' rect.yMax' rect.xMin' rect.yMax' screenMatrix);                      renderLine(rect.xMin' rect.yMax' rect.xMin' rect.yMin' screenMatrix);                        renderLine(rect.xMin' rect.yMin' rect.xMax' rect.yMax' screenMatrix);                      renderLine(rect.xMin' rect.yMax' rect.xMax' rect.yMin' screenMatrix);                      break;                  case (int)ViewerConstants.ICONS.ENGINE_NOAIR:                      renderLine(rect.xMin' rect.yMin' rect.xMax' rect.yMin' screenMatrix);                      renderLine(rect.xMax' rect.yMin' rect.xMax' rect.yMax' screenMatrix);                      renderLine(rect.xMax' rect.yMax' rect.xMin' rect.yMax' screenMatrix);                      renderLine(rect.xMin' rect.yMax' rect.xMin' rect.yMin' screenMatrix);                        renderLine(xOneFourth' yMid' xThreeFourth' yMid' screenMatrix);                      renderLine(xMid' yOneFourth' xMid' yThreeFourth' screenMatrix);                        renderLine(xOneFourth' yOneFourth' xThreeFourth' yThreeFourth' screenMatrix);                      renderLine(xOneFourth' yThreeFourth' xThreeFourth' yOneFourth' screenMatrix);                      break;                  case (int)ViewerConstants.ICONS.ENGINE_ACTIVE:                      renderLine(rect.xMin' rect.yMin' rect.xMax' rect.yMin' screenMatrix);                      renderLine(rect.xMax' rect.yMin' rect.xMax' rect.yMax' screenMatrix);                      renderLine(rect.xMax' rect.yMax' rect.xMin' rect.yMax' screenMatrix);                      renderLine(rect.xMin' rect.yMax' rect.xMin' rect.yMin' screenMatrix);                        renderLine(xMid' rect.yMin' xOneFourth' yThreeFourth' screenMatrix);                      renderLine(xMid' rect.yMin' xThreeFourth' yThreeFourth' screenMatrix);                      renderLine(xMid' rect.yMax' xOneFourth' yThreeFourth' screenMatrix);                      renderLine(xMid' rect.yMax' xThreeFourth' yThreeFourth' screenMatrix);                      break;                  case (int)ViewerConstants.ICONS.ENGINE_INACTIVE:                      renderLine(rect.xMin' rect.yMin' rect.xMax' rect.yMin' screenMatrix);                      renderLine(rect.xMax' rect.yMin' rect.xMax' rect.yMax' screenMatrix);                      renderLine(rect.xMax' rect.yMax' rect.xMin' rect.yMax' screenMatrix);                      renderLine(rect.xMin' rect.yMax' rect.xMin' rect.yMin' screenMatrix);                        renderLine(rect.xMin' rect.yMin' rect.xMax' rect.yMax' screenMatrix);                      break;              }
Missing Default,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,genTransMatrix,The following switch statement is missing a default case: switch (customMode.OrientationOverride)                      {                          case (int)CustomModeSettings.OVERRIDE_TYPES.AS_BASIC:                              speed = ViewerConstants.SPIN_SPEED_VAL[basicSettings.spinSpeed];                              break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.STATIC:                              speed = ViewerConstants.SPIN_SPEED_VAL[customMode.staticSettings.spinSpeed];                              break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.FUNCTION:                              speed = customMode.spinSpeedDelegate(customMode);                              break;                      }
Missing Default,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,genTransMatrix,The following switch statement is missing a default case: switch (customMode.OrientationOverride)                      {                          case (int)CustomModeSettings.OVERRIDE_TYPES.AS_BASIC:                              spinAxis = basicSettings.spinAxis;                              break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.STATIC:                              spinAxis = customMode.staticSettings.spinAxis;                              break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.FUNCTION:                              spinAxis = customMode.spinAxisDelegate(customMode);                              break;                      }
Missing Default,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,genTransMatrix,The following switch statement is missing a default case: switch (spinAxis)               {                  case (int)ViewerConstants.AXIS.X:                      extraRot.x += ((Time.time * speed) % 360);                      break;                  case (int)ViewerConstants.AXIS.Y:                      extraRot.y += ((Time.time * speed) % 360);                      break;                  case (int)ViewerConstants.AXIS.Z:                      extraRot.z += ((Time.time * speed) % 360);                      break;              }
Missing Default,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,genTransMatrix,The following switch statement is missing a default case: switch (customMode.OrientationOverride)                      {                          case (int)CustomModeSettings.OVERRIDE_TYPES.AS_BASIC:                              drawPlane = basicSettings.drawPlane;                              break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.STATIC:                              drawPlane = customMode.staticSettings.drawPlane;                              break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.FUNCTION:                              drawPlane = customMode.drawPlaneDelegate(customMode);                              break;                      }
Missing Default,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,genTransMatrix,The following switch statement is missing a default case: switch (drawPlane)              {                  case (int)ViewerConstants.PLANE.XY:                      transformTemp.transform.Rotate(extraRot);                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.XZ:                      transformTemp.transform.Rotate(new Vector3(0' 90' 0));                      transformTemp.transform.Rotate(extraRot);                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.YZ:                      transformTemp.transform.Rotate(new Vector3(90' 0' 0));                      transformTemp.transform.Rotate(extraRot);                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.ISO:                      transformTemp.transform.Rotate(new Vector3(0' -30' 0));                      transformTemp.transform.Rotate(new Vector3(15' 0' 0));                                            transformTemp.transform.Rotate(extraRot);                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.GRND:                      transformTemp.transform.rotation = vessel.srfRelRotation;                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      transformTemp.transform.rotation = Quaternion.FromToRotation(vessel.mainBody.GetSurfaceNVector(0' 0)' vessel.mainBody.GetSurfaceNVector(vessel.latitude' vessel.longitude));                      meshTransMatrix = transformTemp.transform.localToWorldMatrix.inverse * meshTransMatrix;                      transformTemp.transform.rotation = Quaternion.identity;                      transformTemp.transform.Rotate(new Vector3(0' 0' 90));                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;                  case (int)ViewerConstants.PLANE.REAL:                      transformTemp.transform.rotation = vessel.vesselTransform.rotation;                      meshTransMatrix = transformTemp.transform.localToWorldMatrix * meshTransMatrix;                      break;              }
Missing Default,VesselView,VesselViewer,C:\research\architectureSmells\repos\PeteTimesSix_VesselViewer\VesselView\VesselViewer.cs,centerise,The following switch statement is missing a default case: switch (customMode.CenteringOverride)                      {                          case (int)CustomModeSettings.OVERRIDE_TYPES.AS_BASIC:                              margin = ViewerConstants.MARGIN_MULTIPLIER[basicSettings.margin];                              centerH = basicSettings.centerOnRootH;                              centerV = basicSettings.centerOnRootV;                              rescale = basicSettings.centerRescale;                              break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.STATIC:                              margin = ViewerConstants.MARGIN_MULTIPLIER[customMode.staticSettings.margin];                              centerH = customMode.staticSettings.centerOnRootH;                              centerV = customMode.staticSettings.centerOnRootV;                              rescale = customMode.staticSettings.centerRescale;                              break;                          case (int)CustomModeSettings.OVERRIDE_TYPES.FUNCTION:                              margin = customMode.marginDelegate(customMode);                              centerH = customMode.centerOnRootHDelegate(customMode);                              centerV = customMode.centerOnRootVDelegate(customMode);                              rescale = customMode.centerRescaleDelegate(customMode);                              break;                      }
