Implementation smell,Namespace,Class,File,Method,Description
Long Method,ConsoleFramework.Controls,Grid,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Grid.cs,MeasureOverride,The method has 111 lines of code.
Long Method,ConsoleFramework.Events,KeyConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\KeyConverter.cs,parseKey,The method has 140 lines of code.
Long Method,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,ParseInputEvent,The method has 113 lines of code.
Long Method,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,processRoutedEvent,The method has 138 lines of code.
Long Method,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runLinux,The method has 144 lines of code.
Long Method,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The method has 141 lines of code.
Complex Method,ConsoleFramework.Controls,GridLengthTypeConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Grid.cs,CanConvertFrom,Cyclomatic complexity of the method is 10
Complex Method,ConsoleFramework.Controls,Grid,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Grid.cs,MeasureOverride,Cyclomatic complexity of the method is 35
Complex Method,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,Cyclomatic complexity of the method is 15
Complex Method,ConsoleFramework.Controls,ListBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ListBox.cs,pageUpCore,Cyclomatic complexity of the method is 8
Complex Method,ConsoleFramework.Controls,ListBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ListBox.cs,OnKeyDown,Cyclomatic complexity of the method is 10
Complex Method,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,onContentShouldBeScrolled,Cyclomatic complexity of the method is 9
Complex Method,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,OnMouseDown,Cyclomatic complexity of the method is 19
Complex Method,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,Cyclomatic complexity of the method is 14
Complex Method,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,renderBorderSafe,Cyclomatic complexity of the method is 17
Complex Method,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,Cyclomatic complexity of the method is 9
Complex Method,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,Cyclomatic complexity of the method is 22
Complex Method,ConsoleFramework.Controls,TreeView,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TreeView.cs,itemOnPropertyChanged,Cyclomatic complexity of the method is 9
Complex Method,ConsoleFramework.Controls,TreeView,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TreeView.cs,ItemsOnListChanged,Cyclomatic complexity of the method is 10
Complex Method,ConsoleFramework.Controls,Control,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\UIElementCollection.cs,TranslatePoint,Cyclomatic complexity of the method is 10
Complex Method,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,Cyclomatic complexity of the method is 8
Complex Method,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Window_OnMouseMove,Cyclomatic complexity of the method is 11
Complex Method,ConsoleFramework.Controls,Panel,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Panel.cs,MeasureOverride,Cyclomatic complexity of the method is 9
Complex Method,ConsoleFramework.Controls,Panel,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Panel.cs,ArrangeOverride,Cyclomatic complexity of the method is 8
Complex Method,ConsoleFramework.Events,KeyConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\KeyConverter.cs,parseKey,Cyclomatic complexity of the method is 123
Complex Method,ConsoleFramework.Events,KeyGesture,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\KeyGesture.cs,Matches,Cyclomatic complexity of the method is 10
Complex Method,ConsoleFramework.Events,KeyGestureConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\KeyGestureConverter.cs,ConvertFrom,Cyclomatic complexity of the method is 8
Complex Method,ConsoleFramework.Events,ModifierKeysConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\ModifierKeysConverter.cs,ConvertTo,Cyclomatic complexity of the method is 8
Complex Method,ConsoleFramework.Events,ModifierKeysConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\ModifierKeysConverter.cs,GetModifierKeys,Cyclomatic complexity of the method is 15
Complex Method,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,AddHandler,Cyclomatic complexity of the method is 10
Complex Method,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,RemoveHandler,Cyclomatic complexity of the method is 9
Complex Method,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,ParseInputEvent,Cyclomatic complexity of the method is 20
Complex Method,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,processRoutedEvent,Cyclomatic complexity of the method is 28
Complex Method,ConsoleFramework.Events,FocusManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\FocusManager.cs,tryChangeFocusedElementTo,Cyclomatic complexity of the method is 8
Complex Method,ConsoleFramework.Events,FocusManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\FocusManager.cs,SetFocus,Cyclomatic complexity of the method is 13
Complex Method,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,Cyclomatic complexity of the method is 12
Complex Method,ConsoleFramework.Rendering,Renderer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\Renderer.cs,refreshChildrenLastOverlappedRects,Cyclomatic complexity of the method is 8
Complex Method,ConsoleFramework.Rendering,Renderer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\Renderer.cs,applyChangesToCanvas,Cyclomatic complexity of the method is 10
Complex Method,ConsoleFramework.Rendering,Renderer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\Renderer.cs,updateLayout,Cyclomatic complexity of the method is 14
Complex Method,ConsoleFramework.Rendering,Renderer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\Renderer.cs,processControl,Cyclomatic complexity of the method is 9
Complex Method,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,ConsoleApplication,Cyclomatic complexity of the method is 13
Complex Method,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runLinux,Cyclomatic complexity of the method is 18
Complex Method,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,Cyclomatic complexity of the method is 67
Complex Method,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runWindows,Cyclomatic complexity of the method is 12
Long Parameter List,ConsoleFramework.Controls,MenuItem,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Menu.cs,renderString,The method has 7 parameters.
Long Parameter List,ConsoleFramework.Controls,ContentShouldBeScrolledEventArgs,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,ContentShouldBeScrolledEventArgs,The method has 6 parameters.
Long Parameter List,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,renderBorderSafe,The method has 5 parameters.
Long Parameter List,ConsoleFramework.Controls,Control,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\UIElementCollection.cs,RenderString,The method has 6 parameters.
Long Parameter List,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,RenderBorders,The method has 5 parameters.
Long Parameter List,ConsoleFramework.Events,MouseWheelEventArgs,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\MouseEventArgs.cs,MouseWheelEventArgs,The method has 7 parameters.
Long Parameter List,ConsoleFramework.Events,MouseButtonEventArgs,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\MouseEventArgs.cs,MouseButtonEventArgs,The method has 9 parameters.
Long Parameter List,ConsoleFramework.Events,MouseEventArgs,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\MouseEventArgs.cs,MouseEventArgs,The method has 6 parameters.
Long Parameter List,ConsoleFramework.Native,LibTermKey,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Native\LibTermKey.cs,termkey_interpret_mouse,The method has 6 parameters.
Long Parameter List,ConsoleFramework.Native,LibTermKey,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Native\LibTermKey.cs,termkey_interpret_mouse32,The method has 6 parameters.
Long Parameter List,ConsoleFramework.Native,LibTermKey,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Native\LibTermKey.cs,termkey_interpret_mouse64,The method has 6 parameters.
Long Parameter List,ConsoleFramework.Native,Win32,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Native\Win32.cs,WriteConsoleOutputCore,The method has 5 parameters.
Long Parameter List,ConsoleFramework.Native,Win32,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Native\Win32.cs,FormatMessage,The method has 7 parameters.
Long Parameter List,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The method has 5 parameters.
Long Parameter List,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The method has 6 parameters.
Long Parameter List,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,SetOpacityRect,The method has 5 parameters.
Long Parameter List,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,FillRectangle,The method has 6 parameters.
Long Identifier,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,MeasureOverride,The length of the parameter controlWithChildrenDesiredSize is 30.
Long Statement,ConsoleFramework.Controls,ComboBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ComboBox.cs,openPopup,The length of the statement  "	Window popup = new PopupWindow (Items' SelectedItemIndex ?? 0' shadow' ShownItemsCount != null ? ShownItemsCount.Value - 1 : (int?)null); " is 137.
Long Statement,ConsoleFramework.Controls,ContextMenu,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ContextMenu.cs,OpenMenu,The length of the statement  "	EventManager.AddHandler (windowsHost' MenuItem.Popup.ControlKeyPressedEvent' windowsHostControlKeyPressed = (sender' args) => { " is 127.
Long Statement,ConsoleFramework.Controls,Grid,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Grid.cs,ArrangeOverride,The length of the statement  "				Children [y * columnsWidths.Length + x].Arrange (new Rect (new Point (currentX' currentY)' new Size (columnsWidths [x]' rowsHeights [y]))); " is 139.
Long Statement,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,MeasureOverride,The length of the statement  "	Size needSize = new Size (Math.Max (contentSize.Width + 2' (title ?? string.Empty).Length + 4)' contentSize.Height + 2); " is 120.
Long Statement,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,MeasureOverride,The length of the statement  "	Size constrainedSize = new Size (Math.Min (needSize.Width' availableSize.Width)' Math.Min (needSize.Height' availableSize.Height)); " is 131.
Long Statement,ConsoleFramework.Controls,ListBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ListBox.cs,currentItemShouldBeVisibleAtBottom,The length of the statement  "	this.RaiseEvent (ScrollViewer.ContentShouldBeScrolledEvent' new ContentShouldBeScrolledEventArgs (this' ScrollViewer.ContentShouldBeScrolledEvent' null' null' null' Math.Max (0' SelectedItemIndex.Value))); " is 205.
Long Statement,ConsoleFramework.Controls,ListBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ListBox.cs,currentItemShouldBeVisibleAtTop,The length of the statement  "	this.RaiseEvent (ScrollViewer.ContentShouldBeScrolledEvent' new ContentShouldBeScrolledEventArgs (this' ScrollViewer.ContentShouldBeScrolledEvent' null' null' Math.Max (0' SelectedItemIndex.Value)' null)); " is 205.
Long Statement,ConsoleFramework.Controls,Menu,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Menu.cs,OnParentChanged,The length of the statement  "		EventManager.AddHandler (Parent' MenuItem.ClickEvent' new RoutedEventHandler ((sender' args) => CloseAllSubmenus ())' true); " is 124.
Long Statement,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,onContentShouldBeScrolled,The length of the statement  "		if (this.deltaY <= args.MostBottomVisibleY.Value && this.deltaY + getEffectiveHeight () > args.MostBottomVisibleY.Value) { " is 122.
Long Statement,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,MeasureOverride,The length of the statement  "	// Если горизонтальная прокрутка отключена - то мы должны сообщить контролу' что по горизонтали он будет иметь не int.MaxValue " is 126.
Long Statement,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,MeasureOverride,The length of the statement  "	// пространства' а ровно width. Таким образом мы даём возможность контролу приспособиться к тому' что прокрутки по горизонтали не будет. " is 136.
Long Statement,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,MeasureOverride,The length of the statement  "	// Аналогично и с вертикальной прокруткой. Так как последний вызов Measure должен быть именно с такими размерами' которые реально " is 129.
Long Statement,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,MeasureOverride,The length of the statement  "		Content.Measure (new Size (HorizontalScrollEnabled ? int.MaxValue : width' VerticalScrollEnabled ? int.MaxValue : height)); " is 123.
Long Statement,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,ArrangeOverride,The length of the statement  "	Rect finalRect = new Rect (new Point (-deltaX' -deltaY)' new Size (deltaX + Math.Max (0' verticalScrollVisible ? width - 1 : width)' deltaY + Math.Max (0' horizontalScrollVisible ? height - 1 : height))); " is 204.
Long Statement,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,ArrangeOverride,The length of the statement  "		finalRect = new Rect (new Point (-deltaX' -deltaY)' new Size (deltaX + Math.Max (0' verticalScrollVisible ? width - 1 : width)' deltaY + Math.Max (0' horizontalScrollVisible ? height - 1 : height))); " is 199.
Long Statement,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,ArrangeOverride,The length of the statement  "		finalRect = new Rect (new Point (-deltaX' -deltaY)' new Size (deltaX + Math.Max (0' verticalScrollVisible ? width - 1 : width)' deltaY + Math.Max (0' horizontalScrollVisible ? height - 1 : height))); " is 199.
Long Statement,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,MeasureOverride,The length of the statement  "	Size finalAvailableSize = new Size (Math.Min (availableSize.Width' controlWithChildrenDesiredSize.Width)' Math.Min (availableSize.Height' controlWithChildrenDesiredSize.Height)); " is 178.
Long Statement,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,ArrangeOverride,The length of the statement  "			child.Arrange (new Rect (new Point (1' 3)' new Size (Math.Max (0' finalSize.Width - 2)' Math.Max (0' finalSize.Height - 4)))); " is 126.
Long Statement,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The length of the statement  "			buffer.SetPixelSafe (x' 2' activeTabIndex == 0 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomRightCorner); " is 127.
Long Statement,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The length of the statement  "			buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 2' activeTabIndex == tabDefinitions.Count - 1 && ActualWidth - 1 == x + tabDefinition.Title.Length + 3 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomLeftCorner); " is 239.
Long Statement,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The length of the statement  "	ConsoleKeyInfo keyInfo = new ConsoleKeyInfo (args.UnicodeChar' (ConsoleKey)args.wVirtualKeyCode' (args.dwControlKeyState & ControlKeyState.SHIFT_PRESSED) == ControlKeyState.SHIFT_PRESSED' (args.dwControlKeyState & ControlKeyState.LEFT_ALT_PRESSED) == ControlKeyState.LEFT_ALT_PRESSED' (args.dwControlKeyState & ControlKeyState.LEFT_CTRL_PRESSED) == ControlKeyState.LEFT_CTRL_PRESSED); " is 384.
Long Statement,ConsoleFramework.Controls,Control,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\UIElementCollection.cs,Measure,The length of the statement  "	Size frameworkAvailableSize = new Size (Math.Max (availableSize.Width - marginWidth' 0)' Math.Max (availableSize.Height - marginHeight' 0)); " is 140.
Long Statement,ConsoleFramework.Controls,Control,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\UIElementCollection.cs,Measure,The length of the statement  "		throw new InvalidOperationException ("MeasureOverride should not return int.MaxValue even for" + "availableSize = {int.MaxValue' int.MaxValue} argument."); " is 155.
Long Statement,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,MeasureOverride,The length of the statement  "		return new Size (Math.Min (availableSize.Width' EMPTY_WINDOW_SIZE.Width + 4)' Math.Min (availableSize.Height' EMPTY_WINDOW_SIZE.Height + 3)); " is 141.
Long Statement,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The length of the statement  "	RenderBorders (buffer' new Point (0' 0)' new Point (ActualWidth - 3' ActualHeight - 2)' this.moving || this.resizing' borderAttrs); " is 131.
Long Statement,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The length of the statement  "		buffer.SetPixel (3' 0' showClosingGlyph ? UnicodeTable.WindowClosePressedSymbol : UnicodeTable.WindowCloseSymbol' Colors.Blend (Color.Green' Color.Gray)); " is 154.
Long Statement,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The length of the statement  "			RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs); " is 142.
Long Statement,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The length of the statement  "			RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs); " is 138.
Long Statement,ConsoleFramework.Controls,LayoutInfo,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Control.cs,Equals,The length of the statement  "	return other.measureArgument.Equals (measureArgument) && other.unclippedDesiredSize.Equals (unclippedDesiredSize) && other.desiredSize.Equals (desiredSize) && other.renderSlotRect.Equals (renderSlotRect) && other.renderSize.Equals (renderSize) && other.layoutClip.Equals (layoutClip) && other.actualOffset.Equals (actualOffset); " is 328.
Long Statement,ConsoleFramework.Controls,Panel,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Panel.cs,Render,The length of the statement  "			buffer.SetPixel (x' y' ' '' Attr.BACKGROUND_BLUE | Attr.BACKGROUND_GREEN | Attr.BACKGROUND_RED | Attr.FOREGROUND_BLUE | Attr.FOREGROUND_GREEN | Attr.FOREGROUND_RED | Attr.FOREGROUND_INTENSITY); " is 193.
Long Statement,ConsoleFramework.Controls,WindowsHost,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\WindowsHost.cs,onPreviewMouseEvents,The length of the statement  "			if (windowInfos [modalWindow].OutsideClickClosesWindow && (eventType == 0 || eventType == 2 && args.LeftButton == MouseButtonState.Pressed)) { " is 142.
Long Statement,ConsoleFramework.Core,Rect,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\Rect.cs,Equals,The length of the statement  "	return (((rect1.X.Equals (rect2.X) && rect1.Y.Equals (rect2.Y)) && rect1.Width.Equals (rect2.Width)) && rect1.Height.Equals (rect2.Height)); " is 140.
Long Statement,ConsoleFramework.Core,Rect,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\Rect.cs,ConvertToString,The length of the statement  "	return string.Format (provider' "{1:" + format + "}{0}{2:" + format + "}{0}{3:" + format + "}{0}{4:" + format + "}"' new object[] { " is 131.
Long Statement,ConsoleFramework.Core,Rect,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\Rect.cs,Contains,The length of the statement  "	return ((((this.x <= rect.x) && (this.y <= rect.y)) && ((this.x + this.width) >= (rect.x + rect.width))) && ((this.y + this.height) >= (rect.y + rect.height))); " is 160.
Long Statement,ConsoleFramework.Core,Rect,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\Rect.cs,IntersectsWith,The length of the statement  "	return ((((rect.Left <= this.Right) && (rect.Right >= this.Left)) && (rect.Top <= this.Bottom)) && (rect.Bottom >= this.Top)); " is 126.
Long Statement,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,getLeftButtonState,The length of the statement  "	return (rawState & MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED) == MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED ? MouseButtonState.Pressed : MouseButtonState.Released; " is 174.
Long Statement,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,getMiddleButtonState,The length of the statement  "	return (rawState & MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED) == MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED ? MouseButtonState.Pressed : MouseButtonState.Released; " is 174.
Long Statement,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,getRightButtonState,The length of the statement  "	return (rawState & MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED) == MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED ? MouseButtonState.Pressed : MouseButtonState.Released; " is 166.
Long Statement,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,startAutoRepeatTimer,The length of the statement  "				eventsQueue.Enqueue (new MouseButtonEventArgs (lastMousePressEventArgs.Source' Control.MouseDownEvent' lastMousePosition' lastMousePressEventArgs.LeftButton' lastMousePressEventArgs.MiddleButton' lastMousePressEventArgs.RightButton' MouseButton.Left' 1' true)); " is 261.
Long Statement,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,ParseInputEvent,The length of the statement  "		if (mouseEvent.dwEventFlags != MouseEventFlags.PRESSED_OR_RELEASED && mouseEvent.dwEventFlags != MouseEventFlags.MOUSE_MOVED && mouseEvent.dwEventFlags != MouseEventFlags.DOUBLE_CLICK && mouseEvent.dwEventFlags != MouseEventFlags.MOUSE_WHEELED && mouseEvent.dwEventFlags != MouseEventFlags.MOUSE_HWHEELED) { " is 307.
Long Statement,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,ParseInputEvent,The length of the statement  "		if (mouseEvent.dwEventFlags == MouseEventFlags.MOUSE_MOVED || mouseEvent.dwEventFlags == MouseEventFlags.PRESSED_OR_RELEASED) { " is 127.
Long Statement,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,ParseInputEvent,The length of the statement  "		Control topMost = VisualTreeHelper.FindTopControlUnderMouse (rootElement' Control.TranslatePoint (null' rawPosition' rootElement)); " is 131.
Long Statement,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,ParseInputEvent,The length of the statement  "			MouseEventArgs mouseEventArgs = new MouseEventArgs (source' Control.PreviewMouseMoveEvent' rawPosition' leftMouseButtonState' middleMouseButtonState' rightMouseButtonState); " is 173.
Long Statement,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,ParseInputEvent,The length of the statement  "				MouseEventArgs args = new MouseEventArgs (control' Control.MouseLeaveEvent' rawPosition' leftMouseButtonState' middleMouseButtonState' rightMouseButtonState); " is 158.
Long Statement,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,ParseInputEvent,The length of the statement  "				MouseEventArgs args = new MouseEventArgs (control' Control.MouseEnterEvent' rawPosition' leftMouseButtonState' middleMouseButtonState' rightMouseButtonState); " is 158.
Long Statement,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,ParseInputEvent,The length of the statement  "				eventArgs = new MouseButtonEventArgs (source' leftMouseButtonState == MouseButtonState.Pressed ? Control.PreviewMouseDownEvent : Control.PreviewMouseUpEvent' rawPosition' leftMouseButtonState' lastMiddleMouseButtonState' lastRightMouseButtonState' MouseButton.Left); " is 266.
Long Statement,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,ParseInputEvent,The length of the statement  "				eventArgs = new MouseButtonEventArgs (source' middleMouseButtonState == MouseButtonState.Pressed ? Control.PreviewMouseDownEvent : Control.PreviewMouseUpEvent' rawPosition' lastLeftMouseButtonState' middleMouseButtonState' lastRightMouseButtonState' MouseButton.Middle); " is 270.
Long Statement,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,ParseInputEvent,The length of the statement  "				eventArgs = new MouseButtonEventArgs (source' rightMouseButtonState == MouseButtonState.Pressed ? Control.PreviewMouseDownEvent : Control.PreviewMouseUpEvent' rawPosition' lastLeftMouseButtonState' lastMiddleMouseButtonState' rightMouseButtonState' MouseButton.Right); " is 268.
Long Statement,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,ParseInputEvent,The length of the statement  "			MouseWheelEventArgs args = new MouseWheelEventArgs (topMost' Control.PreviewMouseWheelEvent' rawPosition' lastLeftMouseButtonState' lastMiddleMouseButtonState' lastRightMouseButtonState' mouseEvent.dwButtonState > 0 ? 1 : -1); " is 226.
Long Statement,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,ParseInputEvent,The length of the statement  "		KeyEventArgs eventArgs = new KeyEventArgs (ConsoleApplication.Instance.FocusManager.FocusedElement' keyEvent.bKeyDown ? Control.PreviewKeyDownEvent : Control.PreviewKeyUpEvent); " is 177.
Long Statement,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,processRoutedEvent,The length of the statement  "			MouseButtonEventArgs argsNew = new MouseButtonEventArgs (args.Source' Control.MouseDownEvent' mouseArgs.RawPosition' mouseArgs.LeftButton' mouseArgs.MiddleButton' mouseArgs.RightButton' mouseArgs.ChangedButton); " is 211.
Long Statement,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,processRoutedEvent,The length of the statement  "			MouseButtonEventArgs argsNew = new MouseButtonEventArgs (args.Source' Control.MouseUpEvent' mouseArgs.RawPosition' mouseArgs.LeftButton' mouseArgs.MiddleButton' mouseArgs.RightButton' mouseArgs.ChangedButton); " is 209.
Long Statement,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,processRoutedEvent,The length of the statement  "			MouseEventArgs argsNew = new MouseEventArgs (args.Source' Control.MouseMoveEvent' mouseArgs.RawPosition' mouseArgs.LeftButton' mouseArgs.MiddleButton' mouseArgs.RightButton); " is 174.
Long Statement,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,processRoutedEvent,The length of the statement  "			MouseEventArgs argsNew = new MouseWheelEventArgs (args.Source' Control.MouseWheelEvent' oldArgs.RawPosition' oldArgs.LeftButton' oldArgs.MiddleButton' oldArgs.RightButton' oldArgs.Delta); " is 187.
Long Statement,ConsoleFramework.Events,FocusManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\FocusManager.cs,RefreshMouseCursor,The length of the statement  "	if (null != focusedElement && focusedElement.CursorVisible && focusedElement.IsPointVisible (focusedElement.CursorPosition)) { " is 126.
Long Statement,ConsoleFramework.Events,FocusManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\FocusManager.cs,RefreshMouseCursor,The length of the statement  "		ConsoleApplication.Instance.SetCursorPosition (Control.TranslatePoint (focusedElement' focusedElement.CursorPosition' null)); " is 125.
Long Statement,ConsoleFramework.Events,FocusManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\FocusManager.cs,tryChangeFocusedElementTo,The length of the statement  "		KeyboardFocusChangedEventArgs previewLostArgs = new KeyboardFocusChangedEventArgs (oldFocus' Control.PreviewLostKeyboardFocusEvent' oldFocus' focusedControl); " is 158.
Long Statement,ConsoleFramework.Events,FocusManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\FocusManager.cs,tryChangeFocusedElementTo,The length of the statement  "		KeyboardFocusChangedEventArgs previewGotArgs = new KeyboardFocusChangedEventArgs (focusedControl' Control.PreviewGotKeyboardFocusEvent' oldFocus' focusedControl); " is 162.
Long Statement,ConsoleFramework.Events,FocusManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\FocusManager.cs,tryChangeFocusedElementTo,The length of the statement  "		KeyboardFocusChangedEventArgs lostArgs = new KeyboardFocusChangedEventArgs (oldFocus' Control.LostKeyboardFocusEvent' oldFocus' focusedControl); " is 144.
Long Statement,ConsoleFramework.Events,FocusManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\FocusManager.cs,tryChangeFocusedElementTo,The length of the statement  "		KeyboardFocusChangedEventArgs args = new KeyboardFocusChangedEventArgs (focusedControl' Control.GotKeyboardFocusEvent' oldFocus' focusedControl); " is 145.
Long Statement,ConsoleFramework.Rendering,PhysicalCanvas,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\PhysicalCanvas.cs,Flush,The length of the statement  "		SMALL_RECT rect = new SMALL_RECT ((short)affectedRect.x' (short)affectedRect.y' (short)(affectedRect.width + affectedRect.x)' (short)(affectedRect.height + affectedRect.y)); " is 173.
Long Statement,ConsoleFramework.Rendering,PhysicalCanvas,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\PhysicalCanvas.cs,Flush,The length of the statement  "		if (!Win32.WriteConsoleOutputCore (stdOutputHandle' buffer' new COORD ((short)size.Width' (short)size.Height)' new COORD ((short)affectedRect.x' (short)affectedRect.y)' ref rect)) { " is 181.
Long Statement,ConsoleFramework.Rendering,Renderer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\Renderer.cs,FinallyApplyChangesToCanvas,The length of the statement  "		Rect affectedRectAbsolute = new Rect (affectedRect.x + RootElementRect.x' affectedRect.y + RootElementRect.y' affectedRect.width' affectedRect.height); " is 151.
Long Statement,ConsoleFramework.Rendering,Renderer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\Renderer.cs,applyChangesToCanvas,The length of the statement  "					fullParentBuffer.ApplyChild (childBuffer' child.ActualOffset' child.RenderSize' child.RenderSlotRect' child.LayoutClip); " is 120.
Long Statement,ConsoleFramework.Rendering,Renderer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\Renderer.cs,applyChangesToCanvas,The length of the statement  "				fullParentBuffer.ApplyChild (fullBuffer' control.ActualOffset' control.RenderSize' control.RenderSlotRect' control.LayoutClip); " is 127.
Long Statement,ConsoleFramework.Rendering,Renderer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\Renderer.cs,applyChangesToCanvas,The length of the statement  "				fullParentBuffer.ApplyChild (fullBuffer' control.ActualOffset' control.RenderSize' control.RenderSlotRect' control.LayoutClip' affectedRect); " is 141.
Long Statement,ConsoleFramework.Rendering,Renderer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\Renderer.cs,applyChangesToCanvas,The length of the statement  "			fullParentBuffer.ApplyChild (getOrCreateFullBufferForControl (neighbor)' neighbor.ActualOffset' neighbor.RenderSize' neighbor.RenderSlotRect' neighbor.LayoutClip); " is 163.
Long Statement,ConsoleFramework.Rendering,Renderer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\Renderer.cs,applyChangesToCanvas,The length of the statement  "		parentAffectedRect.Intersect (new Rect (affectedRect.x + control.ActualOffset.x' affectedRect.y + control.ActualOffset.y' affectedRect.width' affectedRect.height)); " is 164.
Long Statement,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runLinux,The length of the statement  "				if ((fds [0].revents & POLL_EVENTS.POLLIN) == POLL_EVENTS.POLLIN || (fds [0].revents & POLL_EVENTS.POLLHUP) == POLL_EVENTS.POLLHUP || (fds [0].revents & POLL_EVENTS.POLLERR) == POLL_EVENTS.POLLERR) { " is 199.
Long Statement,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runWindows,The length of the statement  "	savedWindowRect = new Rect (new Point (Console.WindowLeft' Console.WindowTop)' new Size (Console.WindowWidth' Console.WindowHeight)); " is 133.
Long Statement,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runWindows,The length of the statement  "	canvas = userCanvasSize.IsEmpty ? new PhysicalCanvas (screenBufferInfo.dwSize.X' screenBufferInfo.dwSize.Y' stdOutputHandle) : new PhysicalCanvas (userCanvasSize.Width' userCanvasSize.Height' stdOutputHandle); " is 209.
Long Statement,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runWindows,The length of the statement  "	renderer.RootElementRect = userRootElementRect.IsEmpty ? new Rect (new Point (0' 0)' canvas.Size) : userRootElementRect; " is 120.
Long Statement,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runWindows,The length of the statement  "				savedWindowRect = new Rect (new Point (Console.WindowLeft' Console.WindowTop)' new Size (Console.WindowWidth' Console.WindowHeight)); " is 133.
Long Statement,ConsoleFramework.Xaml,BindingMarkupExtension,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Xaml\BindingMarkupExtension.cs,ProvideValue,The length of the statement  "		BindingBase binding = new BindingBase (context.Object' context.PropertyName' (INotifyPropertyChanged)realSource' Path' mode); " is 125.
Long Statement,ConsoleFramework.Xaml,ConvertMarkupExtension,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Xaml\ConvertMarkupExtension.cs,ProvideValue,The length of the statement  "		throw new InvalidOperationException (string.Format ("Cannot use specified converter to convert {0} to {1}"' valueType.Name' propertyType.Name)); " is 144.
Complex Conditional,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,renderBorderSafe,The conditional expression  "ActualWidth > x2 && ActualHeight > y2 && y2 > y && x2 > x"  is complex.
Complex Conditional,ConsoleFramework.Controls,WindowsHost,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\WindowsHost.cs,onPreviewMouseEvents,The conditional expression  "windowInfos [modalWindow].OutsideClickClosesWindow && (eventType == 0 || eventType == 2 && args.LeftButton == MouseButtonState.Pressed)"  is complex.
Complex Conditional,ConsoleFramework.Controls,WindowsHost,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\WindowsHost.cs,onPreviewMouseEvents,The conditional expression  "handle && (eventType == 0 || eventType == 2 && args.LeftButton == MouseButtonState.Pressed)"  is complex.
Complex Conditional,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,ParseInputEvent,The conditional expression  "mouseEvent.dwEventFlags != MouseEventFlags.PRESSED_OR_RELEASED && mouseEvent.dwEventFlags != MouseEventFlags.MOUSE_MOVED && mouseEvent.dwEventFlags != MouseEventFlags.DOUBLE_CLICK && mouseEvent.dwEventFlags != MouseEventFlags.MOUSE_WHEELED && mouseEvent.dwEventFlags != MouseEventFlags.MOUSE_HWHEELED"  is complex.
Virtual Method Call from Constructor,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Window,The constructor "Window" calls a virtual method "initialize".
Magic Number,ConsoleFramework.Controls,ButtonBase,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ButtonBase.cs,Button_KeyDown,The following statement contains a magic number: if (args.wVirtualKeyCode == VirtualKeys.Space || args.wVirtualKeyCode == VirtualKeys.Return) {  	RaiseEvent (ClickEvent' new RoutedEventArgs (this' ClickEvent));  	if (command != null && command.CanExecute (CommandParameter)) {  		command.Execute (CommandParameter);  	}  	pressedUsingKeyboard = true;  	Invalidate ();  	ConsoleApplication.Instance.Post (() => {  		pressedUsingKeyboard = false;  		Invalidate ();  	}' TimeSpan.FromMilliseconds (300));  	args.Handled = true;  }  
Magic Number,ConsoleFramework.Controls,ButtonBase,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ButtonBase.cs,Button_KeyDown,The following statement contains a magic number: ConsoleApplication.Instance.Post (() => {  	pressedUsingKeyboard = false;  	Invalidate ();  }' TimeSpan.FromMilliseconds (300));  
Magic Number,ConsoleFramework.Controls,CheckBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\CheckBox.cs,MeasureOverride,The following statement contains a magic number: if (!string.IsNullOrEmpty (caption)) {  	Size minButtonSize = new Size (caption.Length + 4' 1);  	return minButtonSize;  } else  	return new Size (8' 1);  
Magic Number,ConsoleFramework.Controls,CheckBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\CheckBox.cs,MeasureOverride,The following statement contains a magic number: if (!string.IsNullOrEmpty (caption)) {  	Size minButtonSize = new Size (caption.Length + 4' 1);  	return minButtonSize;  } else  	return new Size (8' 1);  
Magic Number,ConsoleFramework.Controls,CheckBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\CheckBox.cs,MeasureOverride,The following statement contains a magic number: return new Size (8' 1);  
Magic Number,ConsoleFramework.Controls,CheckBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\CheckBox.cs,Render,The following statement contains a magic number: buffer.SetOpacityRect (0' 0' ActualWidth' ActualHeight' 3);  
Magic Number,ConsoleFramework.Controls,CheckBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\CheckBox.cs,Render,The following statement contains a magic number: buffer.SetPixel (2' 0' pressed ? '>' : ']'' buttonAttrs);  
Magic Number,ConsoleFramework.Controls,CheckBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\CheckBox.cs,Render,The following statement contains a magic number: buffer.SetPixel (3' 0' ' '' buttonAttrs);  
Magic Number,ConsoleFramework.Controls,CheckBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\CheckBox.cs,Render,The following statement contains a magic number: if (null != caption)  	RenderString (caption' buffer' 4' 0' ActualWidth - 4' captionAttrs);  
Magic Number,ConsoleFramework.Controls,CheckBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\CheckBox.cs,Render,The following statement contains a magic number: if (null != caption)  	RenderString (caption' buffer' 4' 0' ActualWidth - 4' captionAttrs);  
Magic Number,ConsoleFramework.Controls,CheckBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\CheckBox.cs,Render,The following statement contains a magic number: RenderString (caption' buffer' 4' 0' ActualWidth - 4' captionAttrs);  
Magic Number,ConsoleFramework.Controls,CheckBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\CheckBox.cs,Render,The following statement contains a magic number: RenderString (caption' buffer' 4' 0' ActualWidth - 4' captionAttrs);  
Magic Number,ConsoleFramework.Controls,ComboBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ComboBox.cs,openPopup,The following statement contains a magic number: if (Items.Count != 0)  	popup.Height = (ShownItemsCount != null ? ShownItemsCount.Value : Items.Count) + (shadow ? 2 : 1);  // 1 row for transparent "header"  else  	popup.Height = shadow ? 3 : 2;  
Magic Number,ConsoleFramework.Controls,ComboBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ComboBox.cs,openPopup,The following statement contains a magic number: if (Items.Count != 0)  	popup.Height = (ShownItemsCount != null ? ShownItemsCount.Value : Items.Count) + (shadow ? 2 : 1);  // 1 row for transparent "header"  else  	popup.Height = shadow ? 3 : 2;  
Magic Number,ConsoleFramework.Controls,ComboBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ComboBox.cs,openPopup,The following statement contains a magic number: if (Items.Count != 0)  	popup.Height = (ShownItemsCount != null ? ShownItemsCount.Value : Items.Count) + (shadow ? 2 : 1);  // 1 row for transparent "header"  else  	popup.Height = shadow ? 3 : 2;  
Magic Number,ConsoleFramework.Controls,ComboBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ComboBox.cs,openPopup,The following statement contains a magic number: popup.Height = (ShownItemsCount != null ? ShownItemsCount.Value : Items.Count) + (shadow ? 2 : 1);  
Magic Number,ConsoleFramework.Controls,ComboBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ComboBox.cs,openPopup,The following statement contains a magic number: popup.Height = shadow ? 3 : 2;  
Magic Number,ConsoleFramework.Controls,ComboBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ComboBox.cs,openPopup,The following statement contains a magic number: popup.Height = shadow ? 3 : 2;  
Magic Number,ConsoleFramework.Controls,ComboBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ComboBox.cs,Render,The following statement contains a magic number: if (Items.Count != 0 && ActualWidth > 4) {  	usedForCurrentItem = RenderString (Items [SelectedItemIndex ?? 0]' buffer' 1' 0' ActualWidth - 4' attrs);  }  
Magic Number,ConsoleFramework.Controls,ComboBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ComboBox.cs,Render,The following statement contains a magic number: if (Items.Count != 0 && ActualWidth > 4) {  	usedForCurrentItem = RenderString (Items [SelectedItemIndex ?? 0]' buffer' 1' 0' ActualWidth - 4' attrs);  }  
Magic Number,ConsoleFramework.Controls,ComboBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ComboBox.cs,Render,The following statement contains a magic number: usedForCurrentItem = RenderString (Items [SelectedItemIndex ?? 0]' buffer' 1' 0' ActualWidth - 4' attrs);  
Magic Number,ConsoleFramework.Controls,ComboBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ComboBox.cs,Render,The following statement contains a magic number: if (ActualWidth > 2) {  	buffer.SetPixel (ActualWidth - 2' 0' opened ? '^' : 'v'' attrs);  }  
Magic Number,ConsoleFramework.Controls,ComboBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ComboBox.cs,Render,The following statement contains a magic number: if (ActualWidth > 2) {  	buffer.SetPixel (ActualWidth - 2' 0' opened ? '^' : 'v'' attrs);  }  
Magic Number,ConsoleFramework.Controls,ComboBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ComboBox.cs,Render,The following statement contains a magic number: buffer.SetPixel (ActualWidth - 2' 0' opened ? '^' : 'v'' attrs);  
Magic Number,ConsoleFramework.Controls,Grid,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Grid.cs,Render,The following statement contains a magic number: buffer.SetOpacityRect (0' 0' ActualWidth' ActualHeight' 2);  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,MeasureOverride,The following statement contains a magic number: if (needSize != constrainedSize && content != null) {  	// если контрол вместе с содержимым не помещается в availableSize'  	// то мы оставляем содержимому меньше места' чем ему хотелось бы'  	// и поэтому повторным вызовом Measure должны установить его реальные размеры'  	// которые будут использованы при размещении  	content.Measure (new Size (Math.Max (0' constrainedSize.Width - 2)' Math.Max (0' constrainedSize.Height - 2)));  }  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,MeasureOverride,The following statement contains a magic number: if (needSize != constrainedSize && content != null) {  	// если контрол вместе с содержимым не помещается в availableSize'  	// то мы оставляем содержимому меньше места' чем ему хотелось бы'  	// и поэтому повторным вызовом Measure должны установить его реальные размеры'  	// которые будут использованы при размещении  	content.Measure (new Size (Math.Max (0' constrainedSize.Width - 2)' Math.Max (0' constrainedSize.Height - 2)));  }  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,MeasureOverride,The following statement contains a magic number: content.Measure (new Size (Math.Max (0' constrainedSize.Width - 2)' Math.Max (0' constrainedSize.Height - 2)));  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,MeasureOverride,The following statement contains a magic number: content.Measure (new Size (Math.Max (0' constrainedSize.Width - 2)' Math.Max (0' constrainedSize.Height - 2)));  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: buffer.SetOpacityRect (0' 0' ActualWidth' ActualHeight' 3);  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: if (ActualWidth > 2 && ActualHeight > 2)  	buffer.SetOpacityRect (1' 1' ActualWidth - 2' ActualHeight - 2' 2);  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: if (ActualWidth > 2 && ActualHeight > 2)  	buffer.SetOpacityRect (1' 1' ActualWidth - 2' ActualHeight - 2' 2);  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: if (ActualWidth > 2 && ActualHeight > 2)  	buffer.SetOpacityRect (1' 1' ActualWidth - 2' ActualHeight - 2' 2);  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: if (ActualWidth > 2 && ActualHeight > 2)  	buffer.SetOpacityRect (1' 1' ActualWidth - 2' ActualHeight - 2' 2);  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: if (ActualWidth > 2 && ActualHeight > 2)  	buffer.SetOpacityRect (1' 1' ActualWidth - 2' ActualHeight - 2' 2);  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: buffer.SetOpacityRect (1' 1' ActualWidth - 2' ActualHeight - 2' 2);  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: buffer.SetOpacityRect (1' 1' ActualWidth - 2' ActualHeight - 2' 2);  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: buffer.SetOpacityRect (1' 1' ActualWidth - 2' ActualHeight - 2' 2);  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (title))  	titleRenderedWidth = RenderString (title' buffer' 2' 0' ActualWidth - 4' attr);  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (title))  	titleRenderedWidth = RenderString (title' buffer' 2' 0' ActualWidth - 4' attr);  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: titleRenderedWidth = RenderString (title' buffer' 2' 0' ActualWidth - 4' attr);  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: titleRenderedWidth = RenderString (title' buffer' 2' 0' ActualWidth - 4' attr);  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: for (int x = 0; x < ActualWidth; x++) {  	char? c = null;  	if (x == 0)  		c = UnicodeTable.SingleFrameTopLeftCorner;  	else if (x == ActualWidth - 1)  		c = UnicodeTable.SingleFrameTopRightCorner;  	else if (x == 1 || x == 2 + titleRenderedWidth)  		c = ' ';  	else if (x > 2 + titleRenderedWidth && x < ActualWidth - 1)  		c = UnicodeTable.SingleFrameHorizontal;  	if (c != null)  		buffer.SetPixel (x' 0' c.Value' attr);  }  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: for (int x = 0; x < ActualWidth; x++) {  	char? c = null;  	if (x == 0)  		c = UnicodeTable.SingleFrameTopLeftCorner;  	else if (x == ActualWidth - 1)  		c = UnicodeTable.SingleFrameTopRightCorner;  	else if (x == 1 || x == 2 + titleRenderedWidth)  		c = ' ';  	else if (x > 2 + titleRenderedWidth && x < ActualWidth - 1)  		c = UnicodeTable.SingleFrameHorizontal;  	if (c != null)  		buffer.SetPixel (x' 0' c.Value' attr);  }  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: if (x == 0)  	c = UnicodeTable.SingleFrameTopLeftCorner;  else if (x == ActualWidth - 1)  	c = UnicodeTable.SingleFrameTopRightCorner;  else if (x == 1 || x == 2 + titleRenderedWidth)  	c = ' ';  else if (x > 2 + titleRenderedWidth && x < ActualWidth - 1)  	c = UnicodeTable.SingleFrameHorizontal;  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: if (x == 0)  	c = UnicodeTable.SingleFrameTopLeftCorner;  else if (x == ActualWidth - 1)  	c = UnicodeTable.SingleFrameTopRightCorner;  else if (x == 1 || x == 2 + titleRenderedWidth)  	c = ' ';  else if (x > 2 + titleRenderedWidth && x < ActualWidth - 1)  	c = UnicodeTable.SingleFrameHorizontal;  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: if (x == ActualWidth - 1)  	c = UnicodeTable.SingleFrameTopRightCorner;  else if (x == 1 || x == 2 + titleRenderedWidth)  	c = ' ';  else if (x > 2 + titleRenderedWidth && x < ActualWidth - 1)  	c = UnicodeTable.SingleFrameHorizontal;  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: if (x == ActualWidth - 1)  	c = UnicodeTable.SingleFrameTopRightCorner;  else if (x == 1 || x == 2 + titleRenderedWidth)  	c = ' ';  else if (x > 2 + titleRenderedWidth && x < ActualWidth - 1)  	c = UnicodeTable.SingleFrameHorizontal;  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: if (x == 1 || x == 2 + titleRenderedWidth)  	c = ' ';  else if (x > 2 + titleRenderedWidth && x < ActualWidth - 1)  	c = UnicodeTable.SingleFrameHorizontal;  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: if (x == 1 || x == 2 + titleRenderedWidth)  	c = ' ';  else if (x > 2 + titleRenderedWidth && x < ActualWidth - 1)  	c = UnicodeTable.SingleFrameHorizontal;  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: if (x > 2 + titleRenderedWidth && x < ActualWidth - 1)  	c = UnicodeTable.SingleFrameHorizontal;  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: if (ActualHeight > 2)  	buffer.FillRectangle (0' 1' 1' ActualHeight - 2' UnicodeTable.SingleFrameVertical' attr);  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: if (ActualHeight > 2)  	buffer.FillRectangle (0' 1' 1' ActualHeight - 2' UnicodeTable.SingleFrameVertical' attr);  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: buffer.FillRectangle (0' 1' 1' ActualHeight - 2' UnicodeTable.SingleFrameVertical' attr);  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: if (ActualWidth > 1) {  	if (ActualHeight > 2)  		buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.SingleFrameVertical' attr);  	if (ActualHeight > 1)  		buffer.SetPixel (ActualWidth - 1' ActualHeight - 1' UnicodeTable.SingleFrameBottomRightCorner' attr);  }  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: if (ActualWidth > 1) {  	if (ActualHeight > 2)  		buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.SingleFrameVertical' attr);  	if (ActualHeight > 1)  		buffer.SetPixel (ActualWidth - 1' ActualHeight - 1' UnicodeTable.SingleFrameBottomRightCorner' attr);  }  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: if (ActualHeight > 2)  	buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.SingleFrameVertical' attr);  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: if (ActualHeight > 2)  	buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.SingleFrameVertical' attr);  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.SingleFrameVertical' attr);  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: if (ActualHeight > 1 && ActualWidth > 2) {  	buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - 2' 1' UnicodeTable.SingleFrameHorizontal' attr);  }  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: if (ActualHeight > 1 && ActualWidth > 2) {  	buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - 2' 1' UnicodeTable.SingleFrameHorizontal' attr);  }  
Magic Number,ConsoleFramework.Controls,GroupBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\GroupBox.cs,Render,The following statement contains a magic number: buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - 2' 1' UnicodeTable.SingleFrameHorizontal' attr);  
Magic Number,ConsoleFramework.Controls,ListBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ListBox.cs,onMouseWheel,The following statement contains a magic number: if (args.Delta > 0) {  	pageUpCore (2);  } else {  	pageDownCore (2);  }  
Magic Number,ConsoleFramework.Controls,ListBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ListBox.cs,onMouseWheel,The following statement contains a magic number: if (args.Delta > 0) {  	pageUpCore (2);  } else {  	pageDownCore (2);  }  
Magic Number,ConsoleFramework.Controls,ListBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ListBox.cs,onMouseWheel,The following statement contains a magic number: pageUpCore (2);  
Magic Number,ConsoleFramework.Controls,ListBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ListBox.cs,onMouseWheel,The following statement contains a magic number: pageDownCore (2);  
Magic Number,ConsoleFramework.Controls,ListBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ListBox.cs,Render,The following statement contains a magic number: for (int y = 0; y < ActualHeight; y++) {  	string item = y < items.Count ? items [y] : null;  	if (item != null) {  		Attr currentAttr = disabledItemsIndexes.Contains (y) ? disabledAttr : (SelectedItemIndex == y ? selectedAttr : attr);  		buffer.SetPixel (0' y' ' '' currentAttr);  		if (ActualWidth > 1) {  			// минус 2 потому что у нас есть по пустому пикселю слева и справа  			int rendered = RenderString (item' buffer' 1' y' ActualWidth - 2' currentAttr);  			buffer.FillRectangle (1 + rendered' y' ActualWidth - (1 + rendered)' 1' ' '' currentAttr);  		}  	} else {  		buffer.FillRectangle (0' y' ActualWidth' 1' ' '' attr);  	}  }  
Magic Number,ConsoleFramework.Controls,ListBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ListBox.cs,Render,The following statement contains a magic number: if (item != null) {  	Attr currentAttr = disabledItemsIndexes.Contains (y) ? disabledAttr : (SelectedItemIndex == y ? selectedAttr : attr);  	buffer.SetPixel (0' y' ' '' currentAttr);  	if (ActualWidth > 1) {  		// минус 2 потому что у нас есть по пустому пикселю слева и справа  		int rendered = RenderString (item' buffer' 1' y' ActualWidth - 2' currentAttr);  		buffer.FillRectangle (1 + rendered' y' ActualWidth - (1 + rendered)' 1' ' '' currentAttr);  	}  } else {  	buffer.FillRectangle (0' y' ActualWidth' 1' ' '' attr);  }  
Magic Number,ConsoleFramework.Controls,ListBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ListBox.cs,Render,The following statement contains a magic number: if (ActualWidth > 1) {  	// минус 2 потому что у нас есть по пустому пикселю слева и справа  	int rendered = RenderString (item' buffer' 1' y' ActualWidth - 2' currentAttr);  	buffer.FillRectangle (1 + rendered' y' ActualWidth - (1 + rendered)' 1' ' '' currentAttr);  }  
Magic Number,ConsoleFramework.Controls,MenuItem,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Menu.cs,renderString,The following statement contains a magic number: for (int i = 0; i < s.Length && j < maxWidth; i++) {  	char c;  	if (underscore) {  		c = s [i];  	} else {  		if (s [i] == '_') {  			underscore = true;  			continue;  		} else {  			c = s [i];  		}  	}  	Attr a;  	if (j + 2 >= maxWidth && j >= 2 && s.Length > maxWidth) {  		c = '.';  		a = attr;  	} else {  		a = underscore ? specialAttr : attr;  	}  	buffer.SetPixel (x + j' y' c' a);  	j++;  	underscore = false;  }  
Magic Number,ConsoleFramework.Controls,MenuItem,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Menu.cs,renderString,The following statement contains a magic number: for (int i = 0; i < s.Length && j < maxWidth; i++) {  	char c;  	if (underscore) {  		c = s [i];  	} else {  		if (s [i] == '_') {  			underscore = true;  			continue;  		} else {  			c = s [i];  		}  	}  	Attr a;  	if (j + 2 >= maxWidth && j >= 2 && s.Length > maxWidth) {  		c = '.';  		a = attr;  	} else {  		a = underscore ? specialAttr : attr;  	}  	buffer.SetPixel (x + j' y' c' a);  	j++;  	underscore = false;  }  
Magic Number,ConsoleFramework.Controls,MenuItem,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Menu.cs,renderString,The following statement contains a magic number: if (j + 2 >= maxWidth && j >= 2 && s.Length > maxWidth) {  	c = '.';  	a = attr;  } else {  	a = underscore ? specialAttr : attr;  }  
Magic Number,ConsoleFramework.Controls,MenuItem,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Menu.cs,renderString,The following statement contains a magic number: if (j + 2 >= maxWidth && j >= 2 && s.Length > maxWidth) {  	c = '.';  	a = attr;  } else {  	a = underscore ? specialAttr : attr;  }  
Magic Number,ConsoleFramework.Controls,MessageBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\MessageBox.cs,MessageBox,The following statement contains a magic number: button.Margin = new Thickness (4' 0' 4' 0);  
Magic Number,ConsoleFramework.Controls,MessageBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\MessageBox.cs,MessageBox,The following statement contains a magic number: button.Margin = new Thickness (4' 0' 4' 0);  
Magic Number,ConsoleFramework.Controls,RadioButton,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\RadioButton.cs,Render,The following statement contains a magic number: buffer.SetOpacityRect (0' 0' ActualWidth' ActualHeight' 3);  
Magic Number,ConsoleFramework.Controls,RadioButton,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\RadioButton.cs,Render,The following statement contains a magic number: buffer.SetPixel (2' 0' pressed ? '>' : ')'' buttonAttrs);  
Magic Number,ConsoleFramework.Controls,RadioButton,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\RadioButton.cs,Render,The following statement contains a magic number: buffer.SetPixel (3' 0' ' '' buttonAttrs);  
Magic Number,ConsoleFramework.Controls,RadioButton,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\RadioButton.cs,Render,The following statement contains a magic number: if (null != Caption)  	RenderString (Caption' buffer' 4' 0' ActualWidth - 4' captionAttrs);  
Magic Number,ConsoleFramework.Controls,RadioButton,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\RadioButton.cs,Render,The following statement contains a magic number: if (null != Caption)  	RenderString (Caption' buffer' 4' 0' ActualWidth - 4' captionAttrs);  
Magic Number,ConsoleFramework.Controls,RadioButton,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\RadioButton.cs,Render,The following statement contains a magic number: RenderString (Caption' buffer' 4' 0' ActualWidth - 4' captionAttrs);  
Magic Number,ConsoleFramework.Controls,RadioButton,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\RadioButton.cs,Render,The following statement contains a magic number: RenderString (Caption' buffer' 4' 0' ActualWidth - 4' captionAttrs);  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: buffer.SetOpacityRect (0' 0' ActualWidth' ActualHeight' 2);  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (horizontalScrollVisible) {  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 0);  	buffer.SetPixel (0' ActualHeight - 1' UnicodeTable.ArrowLeft' attr);  	// ◄  	// оставляем дополнительный пиксель справа' если одновременно видны оба скроллбара  	int rightOffset = verticalScrollVisible ? 1 : 0;  	if (ActualWidth > 2 + rightOffset) {  		buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - (2 + rightOffset)' 1' UnicodeTable.MediumShade' attr);  		// ▒  	}  	if (ActualWidth > 1 + rightOffset) {  		buffer.SetPixel (ActualWidth - (1 + rightOffset)' ActualHeight - 1' UnicodeTable.ArrowRight' attr);  		// ►  	}  	// определим' в каком месте находится ползунок  	if (ActualWidth > 3 + (verticalScrollVisible ? 1 : 0)) {  		int remainingWidth = ActualWidth - (verticalScrollVisible ? 1 : 0);  		int extraWidth = Content.RenderSize.Width - remainingWidth;  		int pages = extraWidth / (remainingWidth - 2 - 1);  		//Debugger.Log( 1' ""' "pages: " + pages + "\n" );  		int scrollerPos;  		if (pages == 0) {  			double posInDelta = (remainingWidth * 1.0 - 2 - 1) / extraWidth;  			//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  			scrollerPos = (int)Math.Round (posInDelta * deltaX);  		} else {  			double deltaInPos = (extraWidth * 1.0) / (remainingWidth - 2 - 1);  			//Debugger.Log( 1' ""' "deltaX/( deltaInPos ): " + deltaX/( deltaInPos ) + "\n" );  			scrollerPos = (int)Math.Round (deltaX / (deltaInPos));  		}  		buffer.SetPixel (1 + scrollerPos' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  		// ■  	} else if (ActualWidth == 3 + (verticalScrollVisible ? 1 : 0)) {  		buffer.SetPixel (1' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  		// ■  	}  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (horizontalScrollVisible) {  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 0);  	buffer.SetPixel (0' ActualHeight - 1' UnicodeTable.ArrowLeft' attr);  	// ◄  	// оставляем дополнительный пиксель справа' если одновременно видны оба скроллбара  	int rightOffset = verticalScrollVisible ? 1 : 0;  	if (ActualWidth > 2 + rightOffset) {  		buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - (2 + rightOffset)' 1' UnicodeTable.MediumShade' attr);  		// ▒  	}  	if (ActualWidth > 1 + rightOffset) {  		buffer.SetPixel (ActualWidth - (1 + rightOffset)' ActualHeight - 1' UnicodeTable.ArrowRight' attr);  		// ►  	}  	// определим' в каком месте находится ползунок  	if (ActualWidth > 3 + (verticalScrollVisible ? 1 : 0)) {  		int remainingWidth = ActualWidth - (verticalScrollVisible ? 1 : 0);  		int extraWidth = Content.RenderSize.Width - remainingWidth;  		int pages = extraWidth / (remainingWidth - 2 - 1);  		//Debugger.Log( 1' ""' "pages: " + pages + "\n" );  		int scrollerPos;  		if (pages == 0) {  			double posInDelta = (remainingWidth * 1.0 - 2 - 1) / extraWidth;  			//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  			scrollerPos = (int)Math.Round (posInDelta * deltaX);  		} else {  			double deltaInPos = (extraWidth * 1.0) / (remainingWidth - 2 - 1);  			//Debugger.Log( 1' ""' "deltaX/( deltaInPos ): " + deltaX/( deltaInPos ) + "\n" );  			scrollerPos = (int)Math.Round (deltaX / (deltaInPos));  		}  		buffer.SetPixel (1 + scrollerPos' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  		// ■  	} else if (ActualWidth == 3 + (verticalScrollVisible ? 1 : 0)) {  		buffer.SetPixel (1' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  		// ■  	}  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (horizontalScrollVisible) {  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 0);  	buffer.SetPixel (0' ActualHeight - 1' UnicodeTable.ArrowLeft' attr);  	// ◄  	// оставляем дополнительный пиксель справа' если одновременно видны оба скроллбара  	int rightOffset = verticalScrollVisible ? 1 : 0;  	if (ActualWidth > 2 + rightOffset) {  		buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - (2 + rightOffset)' 1' UnicodeTable.MediumShade' attr);  		// ▒  	}  	if (ActualWidth > 1 + rightOffset) {  		buffer.SetPixel (ActualWidth - (1 + rightOffset)' ActualHeight - 1' UnicodeTable.ArrowRight' attr);  		// ►  	}  	// определим' в каком месте находится ползунок  	if (ActualWidth > 3 + (verticalScrollVisible ? 1 : 0)) {  		int remainingWidth = ActualWidth - (verticalScrollVisible ? 1 : 0);  		int extraWidth = Content.RenderSize.Width - remainingWidth;  		int pages = extraWidth / (remainingWidth - 2 - 1);  		//Debugger.Log( 1' ""' "pages: " + pages + "\n" );  		int scrollerPos;  		if (pages == 0) {  			double posInDelta = (remainingWidth * 1.0 - 2 - 1) / extraWidth;  			//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  			scrollerPos = (int)Math.Round (posInDelta * deltaX);  		} else {  			double deltaInPos = (extraWidth * 1.0) / (remainingWidth - 2 - 1);  			//Debugger.Log( 1' ""' "deltaX/( deltaInPos ): " + deltaX/( deltaInPos ) + "\n" );  			scrollerPos = (int)Math.Round (deltaX / (deltaInPos));  		}  		buffer.SetPixel (1 + scrollerPos' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  		// ■  	} else if (ActualWidth == 3 + (verticalScrollVisible ? 1 : 0)) {  		buffer.SetPixel (1' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  		// ■  	}  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (horizontalScrollVisible) {  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 0);  	buffer.SetPixel (0' ActualHeight - 1' UnicodeTable.ArrowLeft' attr);  	// ◄  	// оставляем дополнительный пиксель справа' если одновременно видны оба скроллбара  	int rightOffset = verticalScrollVisible ? 1 : 0;  	if (ActualWidth > 2 + rightOffset) {  		buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - (2 + rightOffset)' 1' UnicodeTable.MediumShade' attr);  		// ▒  	}  	if (ActualWidth > 1 + rightOffset) {  		buffer.SetPixel (ActualWidth - (1 + rightOffset)' ActualHeight - 1' UnicodeTable.ArrowRight' attr);  		// ►  	}  	// определим' в каком месте находится ползунок  	if (ActualWidth > 3 + (verticalScrollVisible ? 1 : 0)) {  		int remainingWidth = ActualWidth - (verticalScrollVisible ? 1 : 0);  		int extraWidth = Content.RenderSize.Width - remainingWidth;  		int pages = extraWidth / (remainingWidth - 2 - 1);  		//Debugger.Log( 1' ""' "pages: " + pages + "\n" );  		int scrollerPos;  		if (pages == 0) {  			double posInDelta = (remainingWidth * 1.0 - 2 - 1) / extraWidth;  			//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  			scrollerPos = (int)Math.Round (posInDelta * deltaX);  		} else {  			double deltaInPos = (extraWidth * 1.0) / (remainingWidth - 2 - 1);  			//Debugger.Log( 1' ""' "deltaX/( deltaInPos ): " + deltaX/( deltaInPos ) + "\n" );  			scrollerPos = (int)Math.Round (deltaX / (deltaInPos));  		}  		buffer.SetPixel (1 + scrollerPos' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  		// ■  	} else if (ActualWidth == 3 + (verticalScrollVisible ? 1 : 0)) {  		buffer.SetPixel (1' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  		// ■  	}  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (horizontalScrollVisible) {  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 0);  	buffer.SetPixel (0' ActualHeight - 1' UnicodeTable.ArrowLeft' attr);  	// ◄  	// оставляем дополнительный пиксель справа' если одновременно видны оба скроллбара  	int rightOffset = verticalScrollVisible ? 1 : 0;  	if (ActualWidth > 2 + rightOffset) {  		buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - (2 + rightOffset)' 1' UnicodeTable.MediumShade' attr);  		// ▒  	}  	if (ActualWidth > 1 + rightOffset) {  		buffer.SetPixel (ActualWidth - (1 + rightOffset)' ActualHeight - 1' UnicodeTable.ArrowRight' attr);  		// ►  	}  	// определим' в каком месте находится ползунок  	if (ActualWidth > 3 + (verticalScrollVisible ? 1 : 0)) {  		int remainingWidth = ActualWidth - (verticalScrollVisible ? 1 : 0);  		int extraWidth = Content.RenderSize.Width - remainingWidth;  		int pages = extraWidth / (remainingWidth - 2 - 1);  		//Debugger.Log( 1' ""' "pages: " + pages + "\n" );  		int scrollerPos;  		if (pages == 0) {  			double posInDelta = (remainingWidth * 1.0 - 2 - 1) / extraWidth;  			//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  			scrollerPos = (int)Math.Round (posInDelta * deltaX);  		} else {  			double deltaInPos = (extraWidth * 1.0) / (remainingWidth - 2 - 1);  			//Debugger.Log( 1' ""' "deltaX/( deltaInPos ): " + deltaX/( deltaInPos ) + "\n" );  			scrollerPos = (int)Math.Round (deltaX / (deltaInPos));  		}  		buffer.SetPixel (1 + scrollerPos' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  		// ■  	} else if (ActualWidth == 3 + (verticalScrollVisible ? 1 : 0)) {  		buffer.SetPixel (1' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  		// ■  	}  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (horizontalScrollVisible) {  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 0);  	buffer.SetPixel (0' ActualHeight - 1' UnicodeTable.ArrowLeft' attr);  	// ◄  	// оставляем дополнительный пиксель справа' если одновременно видны оба скроллбара  	int rightOffset = verticalScrollVisible ? 1 : 0;  	if (ActualWidth > 2 + rightOffset) {  		buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - (2 + rightOffset)' 1' UnicodeTable.MediumShade' attr);  		// ▒  	}  	if (ActualWidth > 1 + rightOffset) {  		buffer.SetPixel (ActualWidth - (1 + rightOffset)' ActualHeight - 1' UnicodeTable.ArrowRight' attr);  		// ►  	}  	// определим' в каком месте находится ползунок  	if (ActualWidth > 3 + (verticalScrollVisible ? 1 : 0)) {  		int remainingWidth = ActualWidth - (verticalScrollVisible ? 1 : 0);  		int extraWidth = Content.RenderSize.Width - remainingWidth;  		int pages = extraWidth / (remainingWidth - 2 - 1);  		//Debugger.Log( 1' ""' "pages: " + pages + "\n" );  		int scrollerPos;  		if (pages == 0) {  			double posInDelta = (remainingWidth * 1.0 - 2 - 1) / extraWidth;  			//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  			scrollerPos = (int)Math.Round (posInDelta * deltaX);  		} else {  			double deltaInPos = (extraWidth * 1.0) / (remainingWidth - 2 - 1);  			//Debugger.Log( 1' ""' "deltaX/( deltaInPos ): " + deltaX/( deltaInPos ) + "\n" );  			scrollerPos = (int)Math.Round (deltaX / (deltaInPos));  		}  		buffer.SetPixel (1 + scrollerPos' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  		// ■  	} else if (ActualWidth == 3 + (verticalScrollVisible ? 1 : 0)) {  		buffer.SetPixel (1' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  		// ■  	}  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (horizontalScrollVisible) {  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 0);  	buffer.SetPixel (0' ActualHeight - 1' UnicodeTable.ArrowLeft' attr);  	// ◄  	// оставляем дополнительный пиксель справа' если одновременно видны оба скроллбара  	int rightOffset = verticalScrollVisible ? 1 : 0;  	if (ActualWidth > 2 + rightOffset) {  		buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - (2 + rightOffset)' 1' UnicodeTable.MediumShade' attr);  		// ▒  	}  	if (ActualWidth > 1 + rightOffset) {  		buffer.SetPixel (ActualWidth - (1 + rightOffset)' ActualHeight - 1' UnicodeTable.ArrowRight' attr);  		// ►  	}  	// определим' в каком месте находится ползунок  	if (ActualWidth > 3 + (verticalScrollVisible ? 1 : 0)) {  		int remainingWidth = ActualWidth - (verticalScrollVisible ? 1 : 0);  		int extraWidth = Content.RenderSize.Width - remainingWidth;  		int pages = extraWidth / (remainingWidth - 2 - 1);  		//Debugger.Log( 1' ""' "pages: " + pages + "\n" );  		int scrollerPos;  		if (pages == 0) {  			double posInDelta = (remainingWidth * 1.0 - 2 - 1) / extraWidth;  			//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  			scrollerPos = (int)Math.Round (posInDelta * deltaX);  		} else {  			double deltaInPos = (extraWidth * 1.0) / (remainingWidth - 2 - 1);  			//Debugger.Log( 1' ""' "deltaX/( deltaInPos ): " + deltaX/( deltaInPos ) + "\n" );  			scrollerPos = (int)Math.Round (deltaX / (deltaInPos));  		}  		buffer.SetPixel (1 + scrollerPos' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  		// ■  	} else if (ActualWidth == 3 + (verticalScrollVisible ? 1 : 0)) {  		buffer.SetPixel (1' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  		// ■  	}  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (ActualWidth > 2 + rightOffset) {  	buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - (2 + rightOffset)' 1' UnicodeTable.MediumShade' attr);  	// ▒  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (ActualWidth > 2 + rightOffset) {  	buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - (2 + rightOffset)' 1' UnicodeTable.MediumShade' attr);  	// ▒  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - (2 + rightOffset)' 1' UnicodeTable.MediumShade' attr);  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (ActualWidth > 3 + (verticalScrollVisible ? 1 : 0)) {  	int remainingWidth = ActualWidth - (verticalScrollVisible ? 1 : 0);  	int extraWidth = Content.RenderSize.Width - remainingWidth;  	int pages = extraWidth / (remainingWidth - 2 - 1);  	//Debugger.Log( 1' ""' "pages: " + pages + "\n" );  	int scrollerPos;  	if (pages == 0) {  		double posInDelta = (remainingWidth * 1.0 - 2 - 1) / extraWidth;  		//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  		scrollerPos = (int)Math.Round (posInDelta * deltaX);  	} else {  		double deltaInPos = (extraWidth * 1.0) / (remainingWidth - 2 - 1);  		//Debugger.Log( 1' ""' "deltaX/( deltaInPos ): " + deltaX/( deltaInPos ) + "\n" );  		scrollerPos = (int)Math.Round (deltaX / (deltaInPos));  	}  	buffer.SetPixel (1 + scrollerPos' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  	// ■  } else if (ActualWidth == 3 + (verticalScrollVisible ? 1 : 0)) {  	buffer.SetPixel (1' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  	// ■  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (ActualWidth > 3 + (verticalScrollVisible ? 1 : 0)) {  	int remainingWidth = ActualWidth - (verticalScrollVisible ? 1 : 0);  	int extraWidth = Content.RenderSize.Width - remainingWidth;  	int pages = extraWidth / (remainingWidth - 2 - 1);  	//Debugger.Log( 1' ""' "pages: " + pages + "\n" );  	int scrollerPos;  	if (pages == 0) {  		double posInDelta = (remainingWidth * 1.0 - 2 - 1) / extraWidth;  		//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  		scrollerPos = (int)Math.Round (posInDelta * deltaX);  	} else {  		double deltaInPos = (extraWidth * 1.0) / (remainingWidth - 2 - 1);  		//Debugger.Log( 1' ""' "deltaX/( deltaInPos ): " + deltaX/( deltaInPos ) + "\n" );  		scrollerPos = (int)Math.Round (deltaX / (deltaInPos));  	}  	buffer.SetPixel (1 + scrollerPos' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  	// ■  } else if (ActualWidth == 3 + (verticalScrollVisible ? 1 : 0)) {  	buffer.SetPixel (1' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  	// ■  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (ActualWidth > 3 + (verticalScrollVisible ? 1 : 0)) {  	int remainingWidth = ActualWidth - (verticalScrollVisible ? 1 : 0);  	int extraWidth = Content.RenderSize.Width - remainingWidth;  	int pages = extraWidth / (remainingWidth - 2 - 1);  	//Debugger.Log( 1' ""' "pages: " + pages + "\n" );  	int scrollerPos;  	if (pages == 0) {  		double posInDelta = (remainingWidth * 1.0 - 2 - 1) / extraWidth;  		//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  		scrollerPos = (int)Math.Round (posInDelta * deltaX);  	} else {  		double deltaInPos = (extraWidth * 1.0) / (remainingWidth - 2 - 1);  		//Debugger.Log( 1' ""' "deltaX/( deltaInPos ): " + deltaX/( deltaInPos ) + "\n" );  		scrollerPos = (int)Math.Round (deltaX / (deltaInPos));  	}  	buffer.SetPixel (1 + scrollerPos' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  	// ■  } else if (ActualWidth == 3 + (verticalScrollVisible ? 1 : 0)) {  	buffer.SetPixel (1' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  	// ■  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (ActualWidth > 3 + (verticalScrollVisible ? 1 : 0)) {  	int remainingWidth = ActualWidth - (verticalScrollVisible ? 1 : 0);  	int extraWidth = Content.RenderSize.Width - remainingWidth;  	int pages = extraWidth / (remainingWidth - 2 - 1);  	//Debugger.Log( 1' ""' "pages: " + pages + "\n" );  	int scrollerPos;  	if (pages == 0) {  		double posInDelta = (remainingWidth * 1.0 - 2 - 1) / extraWidth;  		//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  		scrollerPos = (int)Math.Round (posInDelta * deltaX);  	} else {  		double deltaInPos = (extraWidth * 1.0) / (remainingWidth - 2 - 1);  		//Debugger.Log( 1' ""' "deltaX/( deltaInPos ): " + deltaX/( deltaInPos ) + "\n" );  		scrollerPos = (int)Math.Round (deltaX / (deltaInPos));  	}  	buffer.SetPixel (1 + scrollerPos' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  	// ■  } else if (ActualWidth == 3 + (verticalScrollVisible ? 1 : 0)) {  	buffer.SetPixel (1' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  	// ■  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (ActualWidth > 3 + (verticalScrollVisible ? 1 : 0)) {  	int remainingWidth = ActualWidth - (verticalScrollVisible ? 1 : 0);  	int extraWidth = Content.RenderSize.Width - remainingWidth;  	int pages = extraWidth / (remainingWidth - 2 - 1);  	//Debugger.Log( 1' ""' "pages: " + pages + "\n" );  	int scrollerPos;  	if (pages == 0) {  		double posInDelta = (remainingWidth * 1.0 - 2 - 1) / extraWidth;  		//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  		scrollerPos = (int)Math.Round (posInDelta * deltaX);  	} else {  		double deltaInPos = (extraWidth * 1.0) / (remainingWidth - 2 - 1);  		//Debugger.Log( 1' ""' "deltaX/( deltaInPos ): " + deltaX/( deltaInPos ) + "\n" );  		scrollerPos = (int)Math.Round (deltaX / (deltaInPos));  	}  	buffer.SetPixel (1 + scrollerPos' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  	// ■  } else if (ActualWidth == 3 + (verticalScrollVisible ? 1 : 0)) {  	buffer.SetPixel (1' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  	// ■  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (pages == 0) {  	double posInDelta = (remainingWidth * 1.0 - 2 - 1) / extraWidth;  	//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  	scrollerPos = (int)Math.Round (posInDelta * deltaX);  } else {  	double deltaInPos = (extraWidth * 1.0) / (remainingWidth - 2 - 1);  	//Debugger.Log( 1' ""' "deltaX/( deltaInPos ): " + deltaX/( deltaInPos ) + "\n" );  	scrollerPos = (int)Math.Round (deltaX / (deltaInPos));  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (pages == 0) {  	double posInDelta = (remainingWidth * 1.0 - 2 - 1) / extraWidth;  	//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  	scrollerPos = (int)Math.Round (posInDelta * deltaX);  } else {  	double deltaInPos = (extraWidth * 1.0) / (remainingWidth - 2 - 1);  	//Debugger.Log( 1' ""' "deltaX/( deltaInPos ): " + deltaX/( deltaInPos ) + "\n" );  	scrollerPos = (int)Math.Round (deltaX / (deltaInPos));  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (ActualWidth == 3 + (verticalScrollVisible ? 1 : 0)) {  	buffer.SetPixel (1' ActualHeight - 1' UnicodeTable.BlackSquare' attr);  	// ■  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (verticalScrollVisible) {  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 0);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.ArrowUp' attr);  	// ▲  	// оставляем дополнительный пиксель снизу' если одновременно видны оба скроллбара  	int downOffset = horizontalScrollVisible ? 1 : 0;  	if (ActualHeight > 2 + downOffset) {  		buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - (2 + downOffset)' UnicodeTable.MediumShade' attr);  		// ▒  	}  	if (ActualHeight > 1 + downOffset) {  		buffer.SetPixel (ActualWidth - 1' ActualHeight - (1 + downOffset)' UnicodeTable.ArrowDown' attr);  		// ▼  	}  	// определим' в каком месте находится ползунок  	if (ActualHeight > 3 + (horizontalScrollVisible ? 1 : 0)) {  		int remainingHeight = ActualHeight - (horizontalScrollVisible ? 1 : 0);  		int extraHeight = Content.RenderSize.Height - remainingHeight;  		int pages = extraHeight / (remainingHeight - 2 - 1);  		//Debugger.Log( 1' ""' "pages: " + pages + "\n" );  		int scrollerPos;  		if (pages == 0) {  			double posInDelta = (remainingHeight * 1.0 - 2 - 1) / extraHeight;  			//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  			scrollerPos = (int)Math.Round (posInDelta * deltaY);  		} else {  			double deltaInPos = (extraHeight * 1.0) / (remainingHeight - 2 - 1);  			//Debugger.Log( 1' ""' "deltaY/( deltaInPos ): " + deltaY/( deltaInPos ) + "\n" );  			scrollerPos = (int)Math.Round (deltaY / (deltaInPos));  		}  		buffer.SetPixel (ActualWidth - 1' 1 + scrollerPos' UnicodeTable.BlackSquare' attr);  		// ■  	} else if (ActualHeight == 3 + (horizontalScrollVisible ? 1 : 0)) {  		buffer.SetPixel (ActualWidth - 1' 1' UnicodeTable.BlackSquare' attr);  		// ■  	}  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (verticalScrollVisible) {  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 0);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.ArrowUp' attr);  	// ▲  	// оставляем дополнительный пиксель снизу' если одновременно видны оба скроллбара  	int downOffset = horizontalScrollVisible ? 1 : 0;  	if (ActualHeight > 2 + downOffset) {  		buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - (2 + downOffset)' UnicodeTable.MediumShade' attr);  		// ▒  	}  	if (ActualHeight > 1 + downOffset) {  		buffer.SetPixel (ActualWidth - 1' ActualHeight - (1 + downOffset)' UnicodeTable.ArrowDown' attr);  		// ▼  	}  	// определим' в каком месте находится ползунок  	if (ActualHeight > 3 + (horizontalScrollVisible ? 1 : 0)) {  		int remainingHeight = ActualHeight - (horizontalScrollVisible ? 1 : 0);  		int extraHeight = Content.RenderSize.Height - remainingHeight;  		int pages = extraHeight / (remainingHeight - 2 - 1);  		//Debugger.Log( 1' ""' "pages: " + pages + "\n" );  		int scrollerPos;  		if (pages == 0) {  			double posInDelta = (remainingHeight * 1.0 - 2 - 1) / extraHeight;  			//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  			scrollerPos = (int)Math.Round (posInDelta * deltaY);  		} else {  			double deltaInPos = (extraHeight * 1.0) / (remainingHeight - 2 - 1);  			//Debugger.Log( 1' ""' "deltaY/( deltaInPos ): " + deltaY/( deltaInPos ) + "\n" );  			scrollerPos = (int)Math.Round (deltaY / (deltaInPos));  		}  		buffer.SetPixel (ActualWidth - 1' 1 + scrollerPos' UnicodeTable.BlackSquare' attr);  		// ■  	} else if (ActualHeight == 3 + (horizontalScrollVisible ? 1 : 0)) {  		buffer.SetPixel (ActualWidth - 1' 1' UnicodeTable.BlackSquare' attr);  		// ■  	}  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (verticalScrollVisible) {  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 0);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.ArrowUp' attr);  	// ▲  	// оставляем дополнительный пиксель снизу' если одновременно видны оба скроллбара  	int downOffset = horizontalScrollVisible ? 1 : 0;  	if (ActualHeight > 2 + downOffset) {  		buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - (2 + downOffset)' UnicodeTable.MediumShade' attr);  		// ▒  	}  	if (ActualHeight > 1 + downOffset) {  		buffer.SetPixel (ActualWidth - 1' ActualHeight - (1 + downOffset)' UnicodeTable.ArrowDown' attr);  		// ▼  	}  	// определим' в каком месте находится ползунок  	if (ActualHeight > 3 + (horizontalScrollVisible ? 1 : 0)) {  		int remainingHeight = ActualHeight - (horizontalScrollVisible ? 1 : 0);  		int extraHeight = Content.RenderSize.Height - remainingHeight;  		int pages = extraHeight / (remainingHeight - 2 - 1);  		//Debugger.Log( 1' ""' "pages: " + pages + "\n" );  		int scrollerPos;  		if (pages == 0) {  			double posInDelta = (remainingHeight * 1.0 - 2 - 1) / extraHeight;  			//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  			scrollerPos = (int)Math.Round (posInDelta * deltaY);  		} else {  			double deltaInPos = (extraHeight * 1.0) / (remainingHeight - 2 - 1);  			//Debugger.Log( 1' ""' "deltaY/( deltaInPos ): " + deltaY/( deltaInPos ) + "\n" );  			scrollerPos = (int)Math.Round (deltaY / (deltaInPos));  		}  		buffer.SetPixel (ActualWidth - 1' 1 + scrollerPos' UnicodeTable.BlackSquare' attr);  		// ■  	} else if (ActualHeight == 3 + (horizontalScrollVisible ? 1 : 0)) {  		buffer.SetPixel (ActualWidth - 1' 1' UnicodeTable.BlackSquare' attr);  		// ■  	}  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (verticalScrollVisible) {  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 0);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.ArrowUp' attr);  	// ▲  	// оставляем дополнительный пиксель снизу' если одновременно видны оба скроллбара  	int downOffset = horizontalScrollVisible ? 1 : 0;  	if (ActualHeight > 2 + downOffset) {  		buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - (2 + downOffset)' UnicodeTable.MediumShade' attr);  		// ▒  	}  	if (ActualHeight > 1 + downOffset) {  		buffer.SetPixel (ActualWidth - 1' ActualHeight - (1 + downOffset)' UnicodeTable.ArrowDown' attr);  		// ▼  	}  	// определим' в каком месте находится ползунок  	if (ActualHeight > 3 + (horizontalScrollVisible ? 1 : 0)) {  		int remainingHeight = ActualHeight - (horizontalScrollVisible ? 1 : 0);  		int extraHeight = Content.RenderSize.Height - remainingHeight;  		int pages = extraHeight / (remainingHeight - 2 - 1);  		//Debugger.Log( 1' ""' "pages: " + pages + "\n" );  		int scrollerPos;  		if (pages == 0) {  			double posInDelta = (remainingHeight * 1.0 - 2 - 1) / extraHeight;  			//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  			scrollerPos = (int)Math.Round (posInDelta * deltaY);  		} else {  			double deltaInPos = (extraHeight * 1.0) / (remainingHeight - 2 - 1);  			//Debugger.Log( 1' ""' "deltaY/( deltaInPos ): " + deltaY/( deltaInPos ) + "\n" );  			scrollerPos = (int)Math.Round (deltaY / (deltaInPos));  		}  		buffer.SetPixel (ActualWidth - 1' 1 + scrollerPos' UnicodeTable.BlackSquare' attr);  		// ■  	} else if (ActualHeight == 3 + (horizontalScrollVisible ? 1 : 0)) {  		buffer.SetPixel (ActualWidth - 1' 1' UnicodeTable.BlackSquare' attr);  		// ■  	}  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (verticalScrollVisible) {  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 0);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.ArrowUp' attr);  	// ▲  	// оставляем дополнительный пиксель снизу' если одновременно видны оба скроллбара  	int downOffset = horizontalScrollVisible ? 1 : 0;  	if (ActualHeight > 2 + downOffset) {  		buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - (2 + downOffset)' UnicodeTable.MediumShade' attr);  		// ▒  	}  	if (ActualHeight > 1 + downOffset) {  		buffer.SetPixel (ActualWidth - 1' ActualHeight - (1 + downOffset)' UnicodeTable.ArrowDown' attr);  		// ▼  	}  	// определим' в каком месте находится ползунок  	if (ActualHeight > 3 + (horizontalScrollVisible ? 1 : 0)) {  		int remainingHeight = ActualHeight - (horizontalScrollVisible ? 1 : 0);  		int extraHeight = Content.RenderSize.Height - remainingHeight;  		int pages = extraHeight / (remainingHeight - 2 - 1);  		//Debugger.Log( 1' ""' "pages: " + pages + "\n" );  		int scrollerPos;  		if (pages == 0) {  			double posInDelta = (remainingHeight * 1.0 - 2 - 1) / extraHeight;  			//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  			scrollerPos = (int)Math.Round (posInDelta * deltaY);  		} else {  			double deltaInPos = (extraHeight * 1.0) / (remainingHeight - 2 - 1);  			//Debugger.Log( 1' ""' "deltaY/( deltaInPos ): " + deltaY/( deltaInPos ) + "\n" );  			scrollerPos = (int)Math.Round (deltaY / (deltaInPos));  		}  		buffer.SetPixel (ActualWidth - 1' 1 + scrollerPos' UnicodeTable.BlackSquare' attr);  		// ■  	} else if (ActualHeight == 3 + (horizontalScrollVisible ? 1 : 0)) {  		buffer.SetPixel (ActualWidth - 1' 1' UnicodeTable.BlackSquare' attr);  		// ■  	}  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (verticalScrollVisible) {  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 0);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.ArrowUp' attr);  	// ▲  	// оставляем дополнительный пиксель снизу' если одновременно видны оба скроллбара  	int downOffset = horizontalScrollVisible ? 1 : 0;  	if (ActualHeight > 2 + downOffset) {  		buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - (2 + downOffset)' UnicodeTable.MediumShade' attr);  		// ▒  	}  	if (ActualHeight > 1 + downOffset) {  		buffer.SetPixel (ActualWidth - 1' ActualHeight - (1 + downOffset)' UnicodeTable.ArrowDown' attr);  		// ▼  	}  	// определим' в каком месте находится ползунок  	if (ActualHeight > 3 + (horizontalScrollVisible ? 1 : 0)) {  		int remainingHeight = ActualHeight - (horizontalScrollVisible ? 1 : 0);  		int extraHeight = Content.RenderSize.Height - remainingHeight;  		int pages = extraHeight / (remainingHeight - 2 - 1);  		//Debugger.Log( 1' ""' "pages: " + pages + "\n" );  		int scrollerPos;  		if (pages == 0) {  			double posInDelta = (remainingHeight * 1.0 - 2 - 1) / extraHeight;  			//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  			scrollerPos = (int)Math.Round (posInDelta * deltaY);  		} else {  			double deltaInPos = (extraHeight * 1.0) / (remainingHeight - 2 - 1);  			//Debugger.Log( 1' ""' "deltaY/( deltaInPos ): " + deltaY/( deltaInPos ) + "\n" );  			scrollerPos = (int)Math.Round (deltaY / (deltaInPos));  		}  		buffer.SetPixel (ActualWidth - 1' 1 + scrollerPos' UnicodeTable.BlackSquare' attr);  		// ■  	} else if (ActualHeight == 3 + (horizontalScrollVisible ? 1 : 0)) {  		buffer.SetPixel (ActualWidth - 1' 1' UnicodeTable.BlackSquare' attr);  		// ■  	}  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (verticalScrollVisible) {  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 0);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.ArrowUp' attr);  	// ▲  	// оставляем дополнительный пиксель снизу' если одновременно видны оба скроллбара  	int downOffset = horizontalScrollVisible ? 1 : 0;  	if (ActualHeight > 2 + downOffset) {  		buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - (2 + downOffset)' UnicodeTable.MediumShade' attr);  		// ▒  	}  	if (ActualHeight > 1 + downOffset) {  		buffer.SetPixel (ActualWidth - 1' ActualHeight - (1 + downOffset)' UnicodeTable.ArrowDown' attr);  		// ▼  	}  	// определим' в каком месте находится ползунок  	if (ActualHeight > 3 + (horizontalScrollVisible ? 1 : 0)) {  		int remainingHeight = ActualHeight - (horizontalScrollVisible ? 1 : 0);  		int extraHeight = Content.RenderSize.Height - remainingHeight;  		int pages = extraHeight / (remainingHeight - 2 - 1);  		//Debugger.Log( 1' ""' "pages: " + pages + "\n" );  		int scrollerPos;  		if (pages == 0) {  			double posInDelta = (remainingHeight * 1.0 - 2 - 1) / extraHeight;  			//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  			scrollerPos = (int)Math.Round (posInDelta * deltaY);  		} else {  			double deltaInPos = (extraHeight * 1.0) / (remainingHeight - 2 - 1);  			//Debugger.Log( 1' ""' "deltaY/( deltaInPos ): " + deltaY/( deltaInPos ) + "\n" );  			scrollerPos = (int)Math.Round (deltaY / (deltaInPos));  		}  		buffer.SetPixel (ActualWidth - 1' 1 + scrollerPos' UnicodeTable.BlackSquare' attr);  		// ■  	} else if (ActualHeight == 3 + (horizontalScrollVisible ? 1 : 0)) {  		buffer.SetPixel (ActualWidth - 1' 1' UnicodeTable.BlackSquare' attr);  		// ■  	}  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (ActualHeight > 2 + downOffset) {  	buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - (2 + downOffset)' UnicodeTable.MediumShade' attr);  	// ▒  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (ActualHeight > 2 + downOffset) {  	buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - (2 + downOffset)' UnicodeTable.MediumShade' attr);  	// ▒  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - (2 + downOffset)' UnicodeTable.MediumShade' attr);  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (ActualHeight > 3 + (horizontalScrollVisible ? 1 : 0)) {  	int remainingHeight = ActualHeight - (horizontalScrollVisible ? 1 : 0);  	int extraHeight = Content.RenderSize.Height - remainingHeight;  	int pages = extraHeight / (remainingHeight - 2 - 1);  	//Debugger.Log( 1' ""' "pages: " + pages + "\n" );  	int scrollerPos;  	if (pages == 0) {  		double posInDelta = (remainingHeight * 1.0 - 2 - 1) / extraHeight;  		//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  		scrollerPos = (int)Math.Round (posInDelta * deltaY);  	} else {  		double deltaInPos = (extraHeight * 1.0) / (remainingHeight - 2 - 1);  		//Debugger.Log( 1' ""' "deltaY/( deltaInPos ): " + deltaY/( deltaInPos ) + "\n" );  		scrollerPos = (int)Math.Round (deltaY / (deltaInPos));  	}  	buffer.SetPixel (ActualWidth - 1' 1 + scrollerPos' UnicodeTable.BlackSquare' attr);  	// ■  } else if (ActualHeight == 3 + (horizontalScrollVisible ? 1 : 0)) {  	buffer.SetPixel (ActualWidth - 1' 1' UnicodeTable.BlackSquare' attr);  	// ■  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (ActualHeight > 3 + (horizontalScrollVisible ? 1 : 0)) {  	int remainingHeight = ActualHeight - (horizontalScrollVisible ? 1 : 0);  	int extraHeight = Content.RenderSize.Height - remainingHeight;  	int pages = extraHeight / (remainingHeight - 2 - 1);  	//Debugger.Log( 1' ""' "pages: " + pages + "\n" );  	int scrollerPos;  	if (pages == 0) {  		double posInDelta = (remainingHeight * 1.0 - 2 - 1) / extraHeight;  		//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  		scrollerPos = (int)Math.Round (posInDelta * deltaY);  	} else {  		double deltaInPos = (extraHeight * 1.0) / (remainingHeight - 2 - 1);  		//Debugger.Log( 1' ""' "deltaY/( deltaInPos ): " + deltaY/( deltaInPos ) + "\n" );  		scrollerPos = (int)Math.Round (deltaY / (deltaInPos));  	}  	buffer.SetPixel (ActualWidth - 1' 1 + scrollerPos' UnicodeTable.BlackSquare' attr);  	// ■  } else if (ActualHeight == 3 + (horizontalScrollVisible ? 1 : 0)) {  	buffer.SetPixel (ActualWidth - 1' 1' UnicodeTable.BlackSquare' attr);  	// ■  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (ActualHeight > 3 + (horizontalScrollVisible ? 1 : 0)) {  	int remainingHeight = ActualHeight - (horizontalScrollVisible ? 1 : 0);  	int extraHeight = Content.RenderSize.Height - remainingHeight;  	int pages = extraHeight / (remainingHeight - 2 - 1);  	//Debugger.Log( 1' ""' "pages: " + pages + "\n" );  	int scrollerPos;  	if (pages == 0) {  		double posInDelta = (remainingHeight * 1.0 - 2 - 1) / extraHeight;  		//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  		scrollerPos = (int)Math.Round (posInDelta * deltaY);  	} else {  		double deltaInPos = (extraHeight * 1.0) / (remainingHeight - 2 - 1);  		//Debugger.Log( 1' ""' "deltaY/( deltaInPos ): " + deltaY/( deltaInPos ) + "\n" );  		scrollerPos = (int)Math.Round (deltaY / (deltaInPos));  	}  	buffer.SetPixel (ActualWidth - 1' 1 + scrollerPos' UnicodeTable.BlackSquare' attr);  	// ■  } else if (ActualHeight == 3 + (horizontalScrollVisible ? 1 : 0)) {  	buffer.SetPixel (ActualWidth - 1' 1' UnicodeTable.BlackSquare' attr);  	// ■  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (ActualHeight > 3 + (horizontalScrollVisible ? 1 : 0)) {  	int remainingHeight = ActualHeight - (horizontalScrollVisible ? 1 : 0);  	int extraHeight = Content.RenderSize.Height - remainingHeight;  	int pages = extraHeight / (remainingHeight - 2 - 1);  	//Debugger.Log( 1' ""' "pages: " + pages + "\n" );  	int scrollerPos;  	if (pages == 0) {  		double posInDelta = (remainingHeight * 1.0 - 2 - 1) / extraHeight;  		//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  		scrollerPos = (int)Math.Round (posInDelta * deltaY);  	} else {  		double deltaInPos = (extraHeight * 1.0) / (remainingHeight - 2 - 1);  		//Debugger.Log( 1' ""' "deltaY/( deltaInPos ): " + deltaY/( deltaInPos ) + "\n" );  		scrollerPos = (int)Math.Round (deltaY / (deltaInPos));  	}  	buffer.SetPixel (ActualWidth - 1' 1 + scrollerPos' UnicodeTable.BlackSquare' attr);  	// ■  } else if (ActualHeight == 3 + (horizontalScrollVisible ? 1 : 0)) {  	buffer.SetPixel (ActualWidth - 1' 1' UnicodeTable.BlackSquare' attr);  	// ■  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (ActualHeight > 3 + (horizontalScrollVisible ? 1 : 0)) {  	int remainingHeight = ActualHeight - (horizontalScrollVisible ? 1 : 0);  	int extraHeight = Content.RenderSize.Height - remainingHeight;  	int pages = extraHeight / (remainingHeight - 2 - 1);  	//Debugger.Log( 1' ""' "pages: " + pages + "\n" );  	int scrollerPos;  	if (pages == 0) {  		double posInDelta = (remainingHeight * 1.0 - 2 - 1) / extraHeight;  		//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  		scrollerPos = (int)Math.Round (posInDelta * deltaY);  	} else {  		double deltaInPos = (extraHeight * 1.0) / (remainingHeight - 2 - 1);  		//Debugger.Log( 1' ""' "deltaY/( deltaInPos ): " + deltaY/( deltaInPos ) + "\n" );  		scrollerPos = (int)Math.Round (deltaY / (deltaInPos));  	}  	buffer.SetPixel (ActualWidth - 1' 1 + scrollerPos' UnicodeTable.BlackSquare' attr);  	// ■  } else if (ActualHeight == 3 + (horizontalScrollVisible ? 1 : 0)) {  	buffer.SetPixel (ActualWidth - 1' 1' UnicodeTable.BlackSquare' attr);  	// ■  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (pages == 0) {  	double posInDelta = (remainingHeight * 1.0 - 2 - 1) / extraHeight;  	//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  	scrollerPos = (int)Math.Round (posInDelta * deltaY);  } else {  	double deltaInPos = (extraHeight * 1.0) / (remainingHeight - 2 - 1);  	//Debugger.Log( 1' ""' "deltaY/( deltaInPos ): " + deltaY/( deltaInPos ) + "\n" );  	scrollerPos = (int)Math.Round (deltaY / (deltaInPos));  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (pages == 0) {  	double posInDelta = (remainingHeight * 1.0 - 2 - 1) / extraHeight;  	//Debugger.Log( 1' ""' "posInDelta: " + posInDelta + "\n" );  	scrollerPos = (int)Math.Round (posInDelta * deltaY);  } else {  	double deltaInPos = (extraHeight * 1.0) / (remainingHeight - 2 - 1);  	//Debugger.Log( 1' ""' "deltaY/( deltaInPos ): " + deltaY/( deltaInPos ) + "\n" );  	scrollerPos = (int)Math.Round (deltaY / (deltaInPos));  }  
Magic Number,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,Render,The following statement contains a magic number: if (ActualHeight == 3 + (horizontalScrollVisible ? 1 : 0)) {  	buffer.SetPixel (ActualWidth - 1' 1' UnicodeTable.BlackSquare' attr);  	// ■  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,mouseDown,The following statement contains a magic number: if (pos.y > 2)  	return;  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,mouseDown,The following statement contains a magic number: for (int i = 0; i < tabDefinitions.Count; i++) {  	TabDefinition tabDefinition = tabDefinitions [i];  	if (pos.X > x && pos.X <= x + tabDefinition.Title.Length + 2) {  		activeTabIndex = i;  		Invalidate ();  		break;  	}  	x += tabDefinition.Title.Length + 2 + 1;  	// Two spaces around + one vertical border  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,mouseDown,The following statement contains a magic number: for (int i = 0; i < tabDefinitions.Count; i++) {  	TabDefinition tabDefinition = tabDefinitions [i];  	if (pos.X > x && pos.X <= x + tabDefinition.Title.Length + 2) {  		activeTabIndex = i;  		Invalidate ();  		break;  	}  	x += tabDefinition.Title.Length + 2 + 1;  	// Two spaces around + one vertical border  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,mouseDown,The following statement contains a magic number: if (pos.X > x && pos.X <= x + tabDefinition.Title.Length + 2) {  	activeTabIndex = i;  	Invalidate ();  	break;  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,mouseDown,The following statement contains a magic number: x += tabDefinition.Title.Length + 2 + 1;  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,MeasureOverride,The following statement contains a magic number: for (int i = 0; i < Children.Count; i++) {  	Control child = Children [i];  	if (activeTabIndex == i) {  		child.Measure (new Size (Math.Max (0' finalAvailableSize.Width - 2)' Math.Max (0' finalAvailableSize.Height - 4)));  	} else {  		child.Measure (Size.Empty);  	}  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,MeasureOverride,The following statement contains a magic number: for (int i = 0; i < Children.Count; i++) {  	Control child = Children [i];  	if (activeTabIndex == i) {  		child.Measure (new Size (Math.Max (0' finalAvailableSize.Width - 2)' Math.Max (0' finalAvailableSize.Height - 4)));  	} else {  		child.Measure (Size.Empty);  	}  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,MeasureOverride,The following statement contains a magic number: if (activeTabIndex == i) {  	child.Measure (new Size (Math.Max (0' finalAvailableSize.Width - 2)' Math.Max (0' finalAvailableSize.Height - 4)));  } else {  	child.Measure (Size.Empty);  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,MeasureOverride,The following statement contains a magic number: if (activeTabIndex == i) {  	child.Measure (new Size (Math.Max (0' finalAvailableSize.Width - 2)' Math.Max (0' finalAvailableSize.Height - 4)));  } else {  	child.Measure (Size.Empty);  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,MeasureOverride,The following statement contains a magic number: child.Measure (new Size (Math.Max (0' finalAvailableSize.Width - 2)' Math.Max (0' finalAvailableSize.Height - 4)));  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,MeasureOverride,The following statement contains a magic number: child.Measure (new Size (Math.Max (0' finalAvailableSize.Width - 2)' Math.Max (0' finalAvailableSize.Height - 4)));  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,getTabHeaderWidth,The following statement contains a magic number: return 1 + tabDefinitions.Sum (tabDefinition => tabDefinition.Title.Length + 2 + 1);  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,ArrangeOverride,The following statement contains a magic number: for (int i = 0; i < Children.Count; i++) {  	Control child = Children [i];  	if (activeTabIndex == i) {  		child.Arrange (new Rect (new Point (1' 3)' new Size (Math.Max (0' finalSize.Width - 2)' Math.Max (0' finalSize.Height - 4))));  	} else {  		child.Arrange (Rect.Empty);  	}  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,ArrangeOverride,The following statement contains a magic number: for (int i = 0; i < Children.Count; i++) {  	Control child = Children [i];  	if (activeTabIndex == i) {  		child.Arrange (new Rect (new Point (1' 3)' new Size (Math.Max (0' finalSize.Width - 2)' Math.Max (0' finalSize.Height - 4))));  	} else {  		child.Arrange (Rect.Empty);  	}  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,ArrangeOverride,The following statement contains a magic number: for (int i = 0; i < Children.Count; i++) {  	Control child = Children [i];  	if (activeTabIndex == i) {  		child.Arrange (new Rect (new Point (1' 3)' new Size (Math.Max (0' finalSize.Width - 2)' Math.Max (0' finalSize.Height - 4))));  	} else {  		child.Arrange (Rect.Empty);  	}  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,ArrangeOverride,The following statement contains a magic number: if (activeTabIndex == i) {  	child.Arrange (new Rect (new Point (1' 3)' new Size (Math.Max (0' finalSize.Width - 2)' Math.Max (0' finalSize.Height - 4))));  } else {  	child.Arrange (Rect.Empty);  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,ArrangeOverride,The following statement contains a magic number: if (activeTabIndex == i) {  	child.Arrange (new Rect (new Point (1' 3)' new Size (Math.Max (0' finalSize.Width - 2)' Math.Max (0' finalSize.Height - 4))));  } else {  	child.Arrange (Rect.Empty);  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,ArrangeOverride,The following statement contains a magic number: if (activeTabIndex == i) {  	child.Arrange (new Rect (new Point (1' 3)' new Size (Math.Max (0' finalSize.Width - 2)' Math.Max (0' finalSize.Height - 4))));  } else {  	child.Arrange (Rect.Empty);  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,ArrangeOverride,The following statement contains a magic number: child.Arrange (new Rect (new Point (1' 3)' new Size (Math.Max (0' finalSize.Width - 2)' Math.Max (0' finalSize.Height - 4))));  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,ArrangeOverride,The following statement contains a magic number: child.Arrange (new Rect (new Point (1' 3)' new Size (Math.Max (0' finalSize.Width - 2)' Math.Max (0' finalSize.Height - 4))));  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,ArrangeOverride,The following statement contains a magic number: child.Arrange (new Rect (new Point (1' 3)' new Size (Math.Max (0' finalSize.Width - 2)' Math.Max (0' finalSize.Height - 4))));  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: buffer.SetOpacityRect (0' 0' ActualWidth' ActualHeight' 3);  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: if (ActualWidth > 2 && ActualHeight > 3)  	buffer.SetOpacityRect (1' 3' ActualWidth - 2' ActualHeight - 4' 2);  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: if (ActualWidth > 2 && ActualHeight > 3)  	buffer.SetOpacityRect (1' 3' ActualWidth - 2' ActualHeight - 4' 2);  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: if (ActualWidth > 2 && ActualHeight > 3)  	buffer.SetOpacityRect (1' 3' ActualWidth - 2' ActualHeight - 4' 2);  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: if (ActualWidth > 2 && ActualHeight > 3)  	buffer.SetOpacityRect (1' 3' ActualWidth - 2' ActualHeight - 4' 2);  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: if (ActualWidth > 2 && ActualHeight > 3)  	buffer.SetOpacityRect (1' 3' ActualWidth - 2' ActualHeight - 4' 2);  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: if (ActualWidth > 2 && ActualHeight > 3)  	buffer.SetOpacityRect (1' 3' ActualWidth - 2' ActualHeight - 4' 2);  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: buffer.SetOpacityRect (1' 3' ActualWidth - 2' ActualHeight - 4' 2);  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: buffer.SetOpacityRect (1' 3' ActualWidth - 2' ActualHeight - 4' 2);  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: buffer.SetOpacityRect (1' 3' ActualWidth - 2' ActualHeight - 4' 2);  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: buffer.SetOpacityRect (1' 3' ActualWidth - 2' ActualHeight - 4' 2);  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: renderBorderSafe (buffer' 0' 2' Math.Max (getTabHeaderWidth () - 1' ActualWidth - 1)' ActualHeight - 1);  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: buffer.FillRectangle (0' 0' ActualWidth' Math.Min (2' ActualHeight)' ' '' attr);  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: for (int tab = 0; tab < tabDefinitions.Count; x += TabDefinitions [tab++].Title.Length + 3) {  	var tabDefinition = TabDefinitions [tab];  	if (tab <= activeTabIndex) {  		buffer.SetPixelSafe (x' 0' UnicodeTable.SingleFrameTopLeftCorner);  		buffer.SetPixelSafe (x' 1' UnicodeTable.SingleFrameVertical);  	}  	if (tab == activeTabIndex) {  		buffer.SetPixelSafe (x' 2' activeTabIndex == 0 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomRightCorner);  	}  	for (int i = 0; i < tabDefinition.Title.Length + 2; i++) {  		buffer.SetPixelSafe (x + 1 + i' 0' UnicodeTable.SingleFrameHorizontal);  		if (tab == activeTabIndex)  			buffer.SetPixelSafe (x + 1 + i' 2' ' ');  	}  	buffer.RenderStringSafe (" " + tabDefinition.Title + " "' x + 1' 1' activeTabIndex == tab ? attr : inactiveAttr);  	if (tab >= activeTabIndex) {  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 0' UnicodeTable.SingleFrameTopRightCorner);  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 1' UnicodeTable.SingleFrameVertical);  	}  	if (tab == activeTabIndex) {  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 2' activeTabIndex == tabDefinitions.Count - 1 && ActualWidth - 1 == x + tabDefinition.Title.Length + 3 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomLeftCorner);  	}  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: for (int tab = 0; tab < tabDefinitions.Count; x += TabDefinitions [tab++].Title.Length + 3) {  	var tabDefinition = TabDefinitions [tab];  	if (tab <= activeTabIndex) {  		buffer.SetPixelSafe (x' 0' UnicodeTable.SingleFrameTopLeftCorner);  		buffer.SetPixelSafe (x' 1' UnicodeTable.SingleFrameVertical);  	}  	if (tab == activeTabIndex) {  		buffer.SetPixelSafe (x' 2' activeTabIndex == 0 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomRightCorner);  	}  	for (int i = 0; i < tabDefinition.Title.Length + 2; i++) {  		buffer.SetPixelSafe (x + 1 + i' 0' UnicodeTable.SingleFrameHorizontal);  		if (tab == activeTabIndex)  			buffer.SetPixelSafe (x + 1 + i' 2' ' ');  	}  	buffer.RenderStringSafe (" " + tabDefinition.Title + " "' x + 1' 1' activeTabIndex == tab ? attr : inactiveAttr);  	if (tab >= activeTabIndex) {  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 0' UnicodeTable.SingleFrameTopRightCorner);  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 1' UnicodeTable.SingleFrameVertical);  	}  	if (tab == activeTabIndex) {  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 2' activeTabIndex == tabDefinitions.Count - 1 && ActualWidth - 1 == x + tabDefinition.Title.Length + 3 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomLeftCorner);  	}  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: for (int tab = 0; tab < tabDefinitions.Count; x += TabDefinitions [tab++].Title.Length + 3) {  	var tabDefinition = TabDefinitions [tab];  	if (tab <= activeTabIndex) {  		buffer.SetPixelSafe (x' 0' UnicodeTable.SingleFrameTopLeftCorner);  		buffer.SetPixelSafe (x' 1' UnicodeTable.SingleFrameVertical);  	}  	if (tab == activeTabIndex) {  		buffer.SetPixelSafe (x' 2' activeTabIndex == 0 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomRightCorner);  	}  	for (int i = 0; i < tabDefinition.Title.Length + 2; i++) {  		buffer.SetPixelSafe (x + 1 + i' 0' UnicodeTable.SingleFrameHorizontal);  		if (tab == activeTabIndex)  			buffer.SetPixelSafe (x + 1 + i' 2' ' ');  	}  	buffer.RenderStringSafe (" " + tabDefinition.Title + " "' x + 1' 1' activeTabIndex == tab ? attr : inactiveAttr);  	if (tab >= activeTabIndex) {  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 0' UnicodeTable.SingleFrameTopRightCorner);  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 1' UnicodeTable.SingleFrameVertical);  	}  	if (tab == activeTabIndex) {  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 2' activeTabIndex == tabDefinitions.Count - 1 && ActualWidth - 1 == x + tabDefinition.Title.Length + 3 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomLeftCorner);  	}  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: for (int tab = 0; tab < tabDefinitions.Count; x += TabDefinitions [tab++].Title.Length + 3) {  	var tabDefinition = TabDefinitions [tab];  	if (tab <= activeTabIndex) {  		buffer.SetPixelSafe (x' 0' UnicodeTable.SingleFrameTopLeftCorner);  		buffer.SetPixelSafe (x' 1' UnicodeTable.SingleFrameVertical);  	}  	if (tab == activeTabIndex) {  		buffer.SetPixelSafe (x' 2' activeTabIndex == 0 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomRightCorner);  	}  	for (int i = 0; i < tabDefinition.Title.Length + 2; i++) {  		buffer.SetPixelSafe (x + 1 + i' 0' UnicodeTable.SingleFrameHorizontal);  		if (tab == activeTabIndex)  			buffer.SetPixelSafe (x + 1 + i' 2' ' ');  	}  	buffer.RenderStringSafe (" " + tabDefinition.Title + " "' x + 1' 1' activeTabIndex == tab ? attr : inactiveAttr);  	if (tab >= activeTabIndex) {  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 0' UnicodeTable.SingleFrameTopRightCorner);  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 1' UnicodeTable.SingleFrameVertical);  	}  	if (tab == activeTabIndex) {  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 2' activeTabIndex == tabDefinitions.Count - 1 && ActualWidth - 1 == x + tabDefinition.Title.Length + 3 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomLeftCorner);  	}  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: for (int tab = 0; tab < tabDefinitions.Count; x += TabDefinitions [tab++].Title.Length + 3) {  	var tabDefinition = TabDefinitions [tab];  	if (tab <= activeTabIndex) {  		buffer.SetPixelSafe (x' 0' UnicodeTable.SingleFrameTopLeftCorner);  		buffer.SetPixelSafe (x' 1' UnicodeTable.SingleFrameVertical);  	}  	if (tab == activeTabIndex) {  		buffer.SetPixelSafe (x' 2' activeTabIndex == 0 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomRightCorner);  	}  	for (int i = 0; i < tabDefinition.Title.Length + 2; i++) {  		buffer.SetPixelSafe (x + 1 + i' 0' UnicodeTable.SingleFrameHorizontal);  		if (tab == activeTabIndex)  			buffer.SetPixelSafe (x + 1 + i' 2' ' ');  	}  	buffer.RenderStringSafe (" " + tabDefinition.Title + " "' x + 1' 1' activeTabIndex == tab ? attr : inactiveAttr);  	if (tab >= activeTabIndex) {  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 0' UnicodeTable.SingleFrameTopRightCorner);  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 1' UnicodeTable.SingleFrameVertical);  	}  	if (tab == activeTabIndex) {  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 2' activeTabIndex == tabDefinitions.Count - 1 && ActualWidth - 1 == x + tabDefinition.Title.Length + 3 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomLeftCorner);  	}  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: for (int tab = 0; tab < tabDefinitions.Count; x += TabDefinitions [tab++].Title.Length + 3) {  	var tabDefinition = TabDefinitions [tab];  	if (tab <= activeTabIndex) {  		buffer.SetPixelSafe (x' 0' UnicodeTable.SingleFrameTopLeftCorner);  		buffer.SetPixelSafe (x' 1' UnicodeTable.SingleFrameVertical);  	}  	if (tab == activeTabIndex) {  		buffer.SetPixelSafe (x' 2' activeTabIndex == 0 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomRightCorner);  	}  	for (int i = 0; i < tabDefinition.Title.Length + 2; i++) {  		buffer.SetPixelSafe (x + 1 + i' 0' UnicodeTable.SingleFrameHorizontal);  		if (tab == activeTabIndex)  			buffer.SetPixelSafe (x + 1 + i' 2' ' ');  	}  	buffer.RenderStringSafe (" " + tabDefinition.Title + " "' x + 1' 1' activeTabIndex == tab ? attr : inactiveAttr);  	if (tab >= activeTabIndex) {  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 0' UnicodeTable.SingleFrameTopRightCorner);  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 1' UnicodeTable.SingleFrameVertical);  	}  	if (tab == activeTabIndex) {  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 2' activeTabIndex == tabDefinitions.Count - 1 && ActualWidth - 1 == x + tabDefinition.Title.Length + 3 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomLeftCorner);  	}  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: for (int tab = 0; tab < tabDefinitions.Count; x += TabDefinitions [tab++].Title.Length + 3) {  	var tabDefinition = TabDefinitions [tab];  	if (tab <= activeTabIndex) {  		buffer.SetPixelSafe (x' 0' UnicodeTable.SingleFrameTopLeftCorner);  		buffer.SetPixelSafe (x' 1' UnicodeTable.SingleFrameVertical);  	}  	if (tab == activeTabIndex) {  		buffer.SetPixelSafe (x' 2' activeTabIndex == 0 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomRightCorner);  	}  	for (int i = 0; i < tabDefinition.Title.Length + 2; i++) {  		buffer.SetPixelSafe (x + 1 + i' 0' UnicodeTable.SingleFrameHorizontal);  		if (tab == activeTabIndex)  			buffer.SetPixelSafe (x + 1 + i' 2' ' ');  	}  	buffer.RenderStringSafe (" " + tabDefinition.Title + " "' x + 1' 1' activeTabIndex == tab ? attr : inactiveAttr);  	if (tab >= activeTabIndex) {  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 0' UnicodeTable.SingleFrameTopRightCorner);  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 1' UnicodeTable.SingleFrameVertical);  	}  	if (tab == activeTabIndex) {  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 2' activeTabIndex == tabDefinitions.Count - 1 && ActualWidth - 1 == x + tabDefinition.Title.Length + 3 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomLeftCorner);  	}  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: for (int tab = 0; tab < tabDefinitions.Count; x += TabDefinitions [tab++].Title.Length + 3) {  	var tabDefinition = TabDefinitions [tab];  	if (tab <= activeTabIndex) {  		buffer.SetPixelSafe (x' 0' UnicodeTable.SingleFrameTopLeftCorner);  		buffer.SetPixelSafe (x' 1' UnicodeTable.SingleFrameVertical);  	}  	if (tab == activeTabIndex) {  		buffer.SetPixelSafe (x' 2' activeTabIndex == 0 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomRightCorner);  	}  	for (int i = 0; i < tabDefinition.Title.Length + 2; i++) {  		buffer.SetPixelSafe (x + 1 + i' 0' UnicodeTable.SingleFrameHorizontal);  		if (tab == activeTabIndex)  			buffer.SetPixelSafe (x + 1 + i' 2' ' ');  	}  	buffer.RenderStringSafe (" " + tabDefinition.Title + " "' x + 1' 1' activeTabIndex == tab ? attr : inactiveAttr);  	if (tab >= activeTabIndex) {  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 0' UnicodeTable.SingleFrameTopRightCorner);  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 1' UnicodeTable.SingleFrameVertical);  	}  	if (tab == activeTabIndex) {  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 2' activeTabIndex == tabDefinitions.Count - 1 && ActualWidth - 1 == x + tabDefinition.Title.Length + 3 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomLeftCorner);  	}  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: for (int tab = 0; tab < tabDefinitions.Count; x += TabDefinitions [tab++].Title.Length + 3) {  	var tabDefinition = TabDefinitions [tab];  	if (tab <= activeTabIndex) {  		buffer.SetPixelSafe (x' 0' UnicodeTable.SingleFrameTopLeftCorner);  		buffer.SetPixelSafe (x' 1' UnicodeTable.SingleFrameVertical);  	}  	if (tab == activeTabIndex) {  		buffer.SetPixelSafe (x' 2' activeTabIndex == 0 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomRightCorner);  	}  	for (int i = 0; i < tabDefinition.Title.Length + 2; i++) {  		buffer.SetPixelSafe (x + 1 + i' 0' UnicodeTable.SingleFrameHorizontal);  		if (tab == activeTabIndex)  			buffer.SetPixelSafe (x + 1 + i' 2' ' ');  	}  	buffer.RenderStringSafe (" " + tabDefinition.Title + " "' x + 1' 1' activeTabIndex == tab ? attr : inactiveAttr);  	if (tab >= activeTabIndex) {  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 0' UnicodeTable.SingleFrameTopRightCorner);  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 1' UnicodeTable.SingleFrameVertical);  	}  	if (tab == activeTabIndex) {  		buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 2' activeTabIndex == tabDefinitions.Count - 1 && ActualWidth - 1 == x + tabDefinition.Title.Length + 3 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomLeftCorner);  	}  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: x += TabDefinitions [tab++].Title.Length + 3
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: if (tab == activeTabIndex) {  	buffer.SetPixelSafe (x' 2' activeTabIndex == 0 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomRightCorner);  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: buffer.SetPixelSafe (x' 2' activeTabIndex == 0 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomRightCorner);  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: for (int i = 0; i < tabDefinition.Title.Length + 2; i++) {  	buffer.SetPixelSafe (x + 1 + i' 0' UnicodeTable.SingleFrameHorizontal);  	if (tab == activeTabIndex)  		buffer.SetPixelSafe (x + 1 + i' 2' ' ');  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: for (int i = 0; i < tabDefinition.Title.Length + 2; i++) {  	buffer.SetPixelSafe (x + 1 + i' 0' UnicodeTable.SingleFrameHorizontal);  	if (tab == activeTabIndex)  		buffer.SetPixelSafe (x + 1 + i' 2' ' ');  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: if (tab == activeTabIndex)  	buffer.SetPixelSafe (x + 1 + i' 2' ' ');  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: buffer.SetPixelSafe (x + 1 + i' 2' ' ');  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: if (tab >= activeTabIndex) {  	buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 0' UnicodeTable.SingleFrameTopRightCorner);  	buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 1' UnicodeTable.SingleFrameVertical);  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: if (tab >= activeTabIndex) {  	buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 0' UnicodeTable.SingleFrameTopRightCorner);  	buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 1' UnicodeTable.SingleFrameVertical);  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 0' UnicodeTable.SingleFrameTopRightCorner);  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 1' UnicodeTable.SingleFrameVertical);  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: if (tab == activeTabIndex) {  	buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 2' activeTabIndex == tabDefinitions.Count - 1 && ActualWidth - 1 == x + tabDefinition.Title.Length + 3 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomLeftCorner);  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: if (tab == activeTabIndex) {  	buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 2' activeTabIndex == tabDefinitions.Count - 1 && ActualWidth - 1 == x + tabDefinition.Title.Length + 3 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomLeftCorner);  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: if (tab == activeTabIndex) {  	buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 2' activeTabIndex == tabDefinitions.Count - 1 && ActualWidth - 1 == x + tabDefinition.Title.Length + 3 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomLeftCorner);  }  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 2' activeTabIndex == tabDefinitions.Count - 1 && ActualWidth - 1 == x + tabDefinition.Title.Length + 3 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomLeftCorner);  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 2' activeTabIndex == tabDefinitions.Count - 1 && ActualWidth - 1 == x + tabDefinition.Title.Length + 3 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomLeftCorner);  
Magic Number,ConsoleFramework.Controls,TabControl,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TabControl.cs,Render,The following statement contains a magic number: buffer.SetPixelSafe (x + tabDefinition.Title.Length + 3' 2' activeTabIndex == tabDefinitions.Count - 1 && ActualWidth - 1 == x + tabDefinition.Title.Length + 3 ? UnicodeTable.SingleFrameVertical : UnicodeTable.SingleFrameBottomLeftCorner);  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: if (!char.IsControl (keyInfo.KeyChar)) {  	// insert keychar into a text string according to cursorPosition and offset  	if (text != null) {  		string leftPart = text.Substring (0' cursorPosition + displayOffset);  		string rightPart = text.Substring (cursorPosition + displayOffset);  		Text = leftPart + keyInfo.KeyChar + rightPart;  	} else {  		Text = keyInfo.KeyChar.ToString ();  	}  	if (cursorPosition + 1 < ActualWidth - 2) {  		cursorPosition++;  		CursorPosition = new Point (cursorPosition + 1' 0);  	} else {  		displayOffset++;  	}  } else {  	if (keyInfo.Key == ConsoleKey.Delete) {  		if (!String.IsNullOrEmpty (text) && displayOffset + cursorPosition < text.Length) {  			string leftPart = text.Substring (0' cursorPosition + displayOffset);  			string rightPart = text.Substring (cursorPosition + displayOffset + 1);  			Text = leftPart + rightPart;  			//  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.Backspace) {  		if (!String.IsNullOrEmpty (text) && (displayOffset != 0 || cursorPosition != 0)) {  			string leftPart = text.Substring (0' cursorPosition + displayOffset - 1);  			string rightPart = text.Substring (cursorPosition + displayOffset);  			Text = leftPart + rightPart;  			if (displayOffset > 0)  				displayOffset--;  			else {  				if (cursorPosition > 0) {  					cursorPosition--;  					CursorPosition = new Point (cursorPosition + 1' 0);  				}  			}  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.LeftArrow) {  		if (!String.IsNullOrEmpty (text) && (displayOffset != 0 || cursorPosition != 0)) {  			if (cursorPosition > 0) {  				cursorPosition--;  				CursorPosition = new Point (cursorPosition + 1' 0);  			} else {  				if (displayOffset > 0) {  					displayOffset--;  					Invalidate ();  				}  			}  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.RightArrow) {  		if (!String.IsNullOrEmpty (text) && displayOffset + cursorPosition < text.Length) {  			if (cursorPosition + 1 < ActualWidth - 2) {  				cursorPosition++;  				CursorPosition = new Point (cursorPosition + 1' 0);  			} else {  				if (displayOffset + cursorPosition < text.Length) {  					displayOffset++;  					Invalidate ();  				}  			}  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.Home) {  		if (displayOffset != 0 || cursorPosition != 0) {  			displayOffset = 0;  			cursorPosition = 0;  			CursorPosition = new Point (cursorPosition + 1' 0);  			Invalidate ();  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.End) {  		if (!String.IsNullOrEmpty (text) && cursorPosition + displayOffset < ActualWidth - 2) {  			displayOffset = text.Length >= ActualWidth - 2 ? text.Length - (ActualWidth - 2) + 1 : 0;  			cursorPosition = text.Length >= ActualWidth - 2 ? ActualWidth - 2 - 1 : text.Length;  			CursorPosition = new Point (cursorPosition + 1' 0);  			Invalidate ();  		} else {  			Console.Beep ();  		}  	}  }  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: if (!char.IsControl (keyInfo.KeyChar)) {  	// insert keychar into a text string according to cursorPosition and offset  	if (text != null) {  		string leftPart = text.Substring (0' cursorPosition + displayOffset);  		string rightPart = text.Substring (cursorPosition + displayOffset);  		Text = leftPart + keyInfo.KeyChar + rightPart;  	} else {  		Text = keyInfo.KeyChar.ToString ();  	}  	if (cursorPosition + 1 < ActualWidth - 2) {  		cursorPosition++;  		CursorPosition = new Point (cursorPosition + 1' 0);  	} else {  		displayOffset++;  	}  } else {  	if (keyInfo.Key == ConsoleKey.Delete) {  		if (!String.IsNullOrEmpty (text) && displayOffset + cursorPosition < text.Length) {  			string leftPart = text.Substring (0' cursorPosition + displayOffset);  			string rightPart = text.Substring (cursorPosition + displayOffset + 1);  			Text = leftPart + rightPart;  			//  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.Backspace) {  		if (!String.IsNullOrEmpty (text) && (displayOffset != 0 || cursorPosition != 0)) {  			string leftPart = text.Substring (0' cursorPosition + displayOffset - 1);  			string rightPart = text.Substring (cursorPosition + displayOffset);  			Text = leftPart + rightPart;  			if (displayOffset > 0)  				displayOffset--;  			else {  				if (cursorPosition > 0) {  					cursorPosition--;  					CursorPosition = new Point (cursorPosition + 1' 0);  				}  			}  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.LeftArrow) {  		if (!String.IsNullOrEmpty (text) && (displayOffset != 0 || cursorPosition != 0)) {  			if (cursorPosition > 0) {  				cursorPosition--;  				CursorPosition = new Point (cursorPosition + 1' 0);  			} else {  				if (displayOffset > 0) {  					displayOffset--;  					Invalidate ();  				}  			}  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.RightArrow) {  		if (!String.IsNullOrEmpty (text) && displayOffset + cursorPosition < text.Length) {  			if (cursorPosition + 1 < ActualWidth - 2) {  				cursorPosition++;  				CursorPosition = new Point (cursorPosition + 1' 0);  			} else {  				if (displayOffset + cursorPosition < text.Length) {  					displayOffset++;  					Invalidate ();  				}  			}  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.Home) {  		if (displayOffset != 0 || cursorPosition != 0) {  			displayOffset = 0;  			cursorPosition = 0;  			CursorPosition = new Point (cursorPosition + 1' 0);  			Invalidate ();  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.End) {  		if (!String.IsNullOrEmpty (text) && cursorPosition + displayOffset < ActualWidth - 2) {  			displayOffset = text.Length >= ActualWidth - 2 ? text.Length - (ActualWidth - 2) + 1 : 0;  			cursorPosition = text.Length >= ActualWidth - 2 ? ActualWidth - 2 - 1 : text.Length;  			CursorPosition = new Point (cursorPosition + 1' 0);  			Invalidate ();  		} else {  			Console.Beep ();  		}  	}  }  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: if (!char.IsControl (keyInfo.KeyChar)) {  	// insert keychar into a text string according to cursorPosition and offset  	if (text != null) {  		string leftPart = text.Substring (0' cursorPosition + displayOffset);  		string rightPart = text.Substring (cursorPosition + displayOffset);  		Text = leftPart + keyInfo.KeyChar + rightPart;  	} else {  		Text = keyInfo.KeyChar.ToString ();  	}  	if (cursorPosition + 1 < ActualWidth - 2) {  		cursorPosition++;  		CursorPosition = new Point (cursorPosition + 1' 0);  	} else {  		displayOffset++;  	}  } else {  	if (keyInfo.Key == ConsoleKey.Delete) {  		if (!String.IsNullOrEmpty (text) && displayOffset + cursorPosition < text.Length) {  			string leftPart = text.Substring (0' cursorPosition + displayOffset);  			string rightPart = text.Substring (cursorPosition + displayOffset + 1);  			Text = leftPart + rightPart;  			//  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.Backspace) {  		if (!String.IsNullOrEmpty (text) && (displayOffset != 0 || cursorPosition != 0)) {  			string leftPart = text.Substring (0' cursorPosition + displayOffset - 1);  			string rightPart = text.Substring (cursorPosition + displayOffset);  			Text = leftPart + rightPart;  			if (displayOffset > 0)  				displayOffset--;  			else {  				if (cursorPosition > 0) {  					cursorPosition--;  					CursorPosition = new Point (cursorPosition + 1' 0);  				}  			}  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.LeftArrow) {  		if (!String.IsNullOrEmpty (text) && (displayOffset != 0 || cursorPosition != 0)) {  			if (cursorPosition > 0) {  				cursorPosition--;  				CursorPosition = new Point (cursorPosition + 1' 0);  			} else {  				if (displayOffset > 0) {  					displayOffset--;  					Invalidate ();  				}  			}  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.RightArrow) {  		if (!String.IsNullOrEmpty (text) && displayOffset + cursorPosition < text.Length) {  			if (cursorPosition + 1 < ActualWidth - 2) {  				cursorPosition++;  				CursorPosition = new Point (cursorPosition + 1' 0);  			} else {  				if (displayOffset + cursorPosition < text.Length) {  					displayOffset++;  					Invalidate ();  				}  			}  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.Home) {  		if (displayOffset != 0 || cursorPosition != 0) {  			displayOffset = 0;  			cursorPosition = 0;  			CursorPosition = new Point (cursorPosition + 1' 0);  			Invalidate ();  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.End) {  		if (!String.IsNullOrEmpty (text) && cursorPosition + displayOffset < ActualWidth - 2) {  			displayOffset = text.Length >= ActualWidth - 2 ? text.Length - (ActualWidth - 2) + 1 : 0;  			cursorPosition = text.Length >= ActualWidth - 2 ? ActualWidth - 2 - 1 : text.Length;  			CursorPosition = new Point (cursorPosition + 1' 0);  			Invalidate ();  		} else {  			Console.Beep ();  		}  	}  }  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: if (!char.IsControl (keyInfo.KeyChar)) {  	// insert keychar into a text string according to cursorPosition and offset  	if (text != null) {  		string leftPart = text.Substring (0' cursorPosition + displayOffset);  		string rightPart = text.Substring (cursorPosition + displayOffset);  		Text = leftPart + keyInfo.KeyChar + rightPart;  	} else {  		Text = keyInfo.KeyChar.ToString ();  	}  	if (cursorPosition + 1 < ActualWidth - 2) {  		cursorPosition++;  		CursorPosition = new Point (cursorPosition + 1' 0);  	} else {  		displayOffset++;  	}  } else {  	if (keyInfo.Key == ConsoleKey.Delete) {  		if (!String.IsNullOrEmpty (text) && displayOffset + cursorPosition < text.Length) {  			string leftPart = text.Substring (0' cursorPosition + displayOffset);  			string rightPart = text.Substring (cursorPosition + displayOffset + 1);  			Text = leftPart + rightPart;  			//  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.Backspace) {  		if (!String.IsNullOrEmpty (text) && (displayOffset != 0 || cursorPosition != 0)) {  			string leftPart = text.Substring (0' cursorPosition + displayOffset - 1);  			string rightPart = text.Substring (cursorPosition + displayOffset);  			Text = leftPart + rightPart;  			if (displayOffset > 0)  				displayOffset--;  			else {  				if (cursorPosition > 0) {  					cursorPosition--;  					CursorPosition = new Point (cursorPosition + 1' 0);  				}  			}  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.LeftArrow) {  		if (!String.IsNullOrEmpty (text) && (displayOffset != 0 || cursorPosition != 0)) {  			if (cursorPosition > 0) {  				cursorPosition--;  				CursorPosition = new Point (cursorPosition + 1' 0);  			} else {  				if (displayOffset > 0) {  					displayOffset--;  					Invalidate ();  				}  			}  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.RightArrow) {  		if (!String.IsNullOrEmpty (text) && displayOffset + cursorPosition < text.Length) {  			if (cursorPosition + 1 < ActualWidth - 2) {  				cursorPosition++;  				CursorPosition = new Point (cursorPosition + 1' 0);  			} else {  				if (displayOffset + cursorPosition < text.Length) {  					displayOffset++;  					Invalidate ();  				}  			}  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.Home) {  		if (displayOffset != 0 || cursorPosition != 0) {  			displayOffset = 0;  			cursorPosition = 0;  			CursorPosition = new Point (cursorPosition + 1' 0);  			Invalidate ();  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.End) {  		if (!String.IsNullOrEmpty (text) && cursorPosition + displayOffset < ActualWidth - 2) {  			displayOffset = text.Length >= ActualWidth - 2 ? text.Length - (ActualWidth - 2) + 1 : 0;  			cursorPosition = text.Length >= ActualWidth - 2 ? ActualWidth - 2 - 1 : text.Length;  			CursorPosition = new Point (cursorPosition + 1' 0);  			Invalidate ();  		} else {  			Console.Beep ();  		}  	}  }  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: if (!char.IsControl (keyInfo.KeyChar)) {  	// insert keychar into a text string according to cursorPosition and offset  	if (text != null) {  		string leftPart = text.Substring (0' cursorPosition + displayOffset);  		string rightPart = text.Substring (cursorPosition + displayOffset);  		Text = leftPart + keyInfo.KeyChar + rightPart;  	} else {  		Text = keyInfo.KeyChar.ToString ();  	}  	if (cursorPosition + 1 < ActualWidth - 2) {  		cursorPosition++;  		CursorPosition = new Point (cursorPosition + 1' 0);  	} else {  		displayOffset++;  	}  } else {  	if (keyInfo.Key == ConsoleKey.Delete) {  		if (!String.IsNullOrEmpty (text) && displayOffset + cursorPosition < text.Length) {  			string leftPart = text.Substring (0' cursorPosition + displayOffset);  			string rightPart = text.Substring (cursorPosition + displayOffset + 1);  			Text = leftPart + rightPart;  			//  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.Backspace) {  		if (!String.IsNullOrEmpty (text) && (displayOffset != 0 || cursorPosition != 0)) {  			string leftPart = text.Substring (0' cursorPosition + displayOffset - 1);  			string rightPart = text.Substring (cursorPosition + displayOffset);  			Text = leftPart + rightPart;  			if (displayOffset > 0)  				displayOffset--;  			else {  				if (cursorPosition > 0) {  					cursorPosition--;  					CursorPosition = new Point (cursorPosition + 1' 0);  				}  			}  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.LeftArrow) {  		if (!String.IsNullOrEmpty (text) && (displayOffset != 0 || cursorPosition != 0)) {  			if (cursorPosition > 0) {  				cursorPosition--;  				CursorPosition = new Point (cursorPosition + 1' 0);  			} else {  				if (displayOffset > 0) {  					displayOffset--;  					Invalidate ();  				}  			}  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.RightArrow) {  		if (!String.IsNullOrEmpty (text) && displayOffset + cursorPosition < text.Length) {  			if (cursorPosition + 1 < ActualWidth - 2) {  				cursorPosition++;  				CursorPosition = new Point (cursorPosition + 1' 0);  			} else {  				if (displayOffset + cursorPosition < text.Length) {  					displayOffset++;  					Invalidate ();  				}  			}  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.Home) {  		if (displayOffset != 0 || cursorPosition != 0) {  			displayOffset = 0;  			cursorPosition = 0;  			CursorPosition = new Point (cursorPosition + 1' 0);  			Invalidate ();  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.End) {  		if (!String.IsNullOrEmpty (text) && cursorPosition + displayOffset < ActualWidth - 2) {  			displayOffset = text.Length >= ActualWidth - 2 ? text.Length - (ActualWidth - 2) + 1 : 0;  			cursorPosition = text.Length >= ActualWidth - 2 ? ActualWidth - 2 - 1 : text.Length;  			CursorPosition = new Point (cursorPosition + 1' 0);  			Invalidate ();  		} else {  			Console.Beep ();  		}  	}  }  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: if (!char.IsControl (keyInfo.KeyChar)) {  	// insert keychar into a text string according to cursorPosition and offset  	if (text != null) {  		string leftPart = text.Substring (0' cursorPosition + displayOffset);  		string rightPart = text.Substring (cursorPosition + displayOffset);  		Text = leftPart + keyInfo.KeyChar + rightPart;  	} else {  		Text = keyInfo.KeyChar.ToString ();  	}  	if (cursorPosition + 1 < ActualWidth - 2) {  		cursorPosition++;  		CursorPosition = new Point (cursorPosition + 1' 0);  	} else {  		displayOffset++;  	}  } else {  	if (keyInfo.Key == ConsoleKey.Delete) {  		if (!String.IsNullOrEmpty (text) && displayOffset + cursorPosition < text.Length) {  			string leftPart = text.Substring (0' cursorPosition + displayOffset);  			string rightPart = text.Substring (cursorPosition + displayOffset + 1);  			Text = leftPart + rightPart;  			//  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.Backspace) {  		if (!String.IsNullOrEmpty (text) && (displayOffset != 0 || cursorPosition != 0)) {  			string leftPart = text.Substring (0' cursorPosition + displayOffset - 1);  			string rightPart = text.Substring (cursorPosition + displayOffset);  			Text = leftPart + rightPart;  			if (displayOffset > 0)  				displayOffset--;  			else {  				if (cursorPosition > 0) {  					cursorPosition--;  					CursorPosition = new Point (cursorPosition + 1' 0);  				}  			}  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.LeftArrow) {  		if (!String.IsNullOrEmpty (text) && (displayOffset != 0 || cursorPosition != 0)) {  			if (cursorPosition > 0) {  				cursorPosition--;  				CursorPosition = new Point (cursorPosition + 1' 0);  			} else {  				if (displayOffset > 0) {  					displayOffset--;  					Invalidate ();  				}  			}  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.RightArrow) {  		if (!String.IsNullOrEmpty (text) && displayOffset + cursorPosition < text.Length) {  			if (cursorPosition + 1 < ActualWidth - 2) {  				cursorPosition++;  				CursorPosition = new Point (cursorPosition + 1' 0);  			} else {  				if (displayOffset + cursorPosition < text.Length) {  					displayOffset++;  					Invalidate ();  				}  			}  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.Home) {  		if (displayOffset != 0 || cursorPosition != 0) {  			displayOffset = 0;  			cursorPosition = 0;  			CursorPosition = new Point (cursorPosition + 1' 0);  			Invalidate ();  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.End) {  		if (!String.IsNullOrEmpty (text) && cursorPosition + displayOffset < ActualWidth - 2) {  			displayOffset = text.Length >= ActualWidth - 2 ? text.Length - (ActualWidth - 2) + 1 : 0;  			cursorPosition = text.Length >= ActualWidth - 2 ? ActualWidth - 2 - 1 : text.Length;  			CursorPosition = new Point (cursorPosition + 1' 0);  			Invalidate ();  		} else {  			Console.Beep ();  		}  	}  }  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: if (!char.IsControl (keyInfo.KeyChar)) {  	// insert keychar into a text string according to cursorPosition and offset  	if (text != null) {  		string leftPart = text.Substring (0' cursorPosition + displayOffset);  		string rightPart = text.Substring (cursorPosition + displayOffset);  		Text = leftPart + keyInfo.KeyChar + rightPart;  	} else {  		Text = keyInfo.KeyChar.ToString ();  	}  	if (cursorPosition + 1 < ActualWidth - 2) {  		cursorPosition++;  		CursorPosition = new Point (cursorPosition + 1' 0);  	} else {  		displayOffset++;  	}  } else {  	if (keyInfo.Key == ConsoleKey.Delete) {  		if (!String.IsNullOrEmpty (text) && displayOffset + cursorPosition < text.Length) {  			string leftPart = text.Substring (0' cursorPosition + displayOffset);  			string rightPart = text.Substring (cursorPosition + displayOffset + 1);  			Text = leftPart + rightPart;  			//  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.Backspace) {  		if (!String.IsNullOrEmpty (text) && (displayOffset != 0 || cursorPosition != 0)) {  			string leftPart = text.Substring (0' cursorPosition + displayOffset - 1);  			string rightPart = text.Substring (cursorPosition + displayOffset);  			Text = leftPart + rightPart;  			if (displayOffset > 0)  				displayOffset--;  			else {  				if (cursorPosition > 0) {  					cursorPosition--;  					CursorPosition = new Point (cursorPosition + 1' 0);  				}  			}  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.LeftArrow) {  		if (!String.IsNullOrEmpty (text) && (displayOffset != 0 || cursorPosition != 0)) {  			if (cursorPosition > 0) {  				cursorPosition--;  				CursorPosition = new Point (cursorPosition + 1' 0);  			} else {  				if (displayOffset > 0) {  					displayOffset--;  					Invalidate ();  				}  			}  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.RightArrow) {  		if (!String.IsNullOrEmpty (text) && displayOffset + cursorPosition < text.Length) {  			if (cursorPosition + 1 < ActualWidth - 2) {  				cursorPosition++;  				CursorPosition = new Point (cursorPosition + 1' 0);  			} else {  				if (displayOffset + cursorPosition < text.Length) {  					displayOffset++;  					Invalidate ();  				}  			}  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.Home) {  		if (displayOffset != 0 || cursorPosition != 0) {  			displayOffset = 0;  			cursorPosition = 0;  			CursorPosition = new Point (cursorPosition + 1' 0);  			Invalidate ();  		} else {  			Console.Beep ();  		}  	}  	if (keyInfo.Key == ConsoleKey.End) {  		if (!String.IsNullOrEmpty (text) && cursorPosition + displayOffset < ActualWidth - 2) {  			displayOffset = text.Length >= ActualWidth - 2 ? text.Length - (ActualWidth - 2) + 1 : 0;  			cursorPosition = text.Length >= ActualWidth - 2 ? ActualWidth - 2 - 1 : text.Length;  			CursorPosition = new Point (cursorPosition + 1' 0);  			Invalidate ();  		} else {  			Console.Beep ();  		}  	}  }  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: if (cursorPosition + 1 < ActualWidth - 2) {  	cursorPosition++;  	CursorPosition = new Point (cursorPosition + 1' 0);  } else {  	displayOffset++;  }  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: if (keyInfo.Key == ConsoleKey.RightArrow) {  	if (!String.IsNullOrEmpty (text) && displayOffset + cursorPosition < text.Length) {  		if (cursorPosition + 1 < ActualWidth - 2) {  			cursorPosition++;  			CursorPosition = new Point (cursorPosition + 1' 0);  		} else {  			if (displayOffset + cursorPosition < text.Length) {  				displayOffset++;  				Invalidate ();  			}  		}  	} else {  		Console.Beep ();  	}  }  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: if (!String.IsNullOrEmpty (text) && displayOffset + cursorPosition < text.Length) {  	if (cursorPosition + 1 < ActualWidth - 2) {  		cursorPosition++;  		CursorPosition = new Point (cursorPosition + 1' 0);  	} else {  		if (displayOffset + cursorPosition < text.Length) {  			displayOffset++;  			Invalidate ();  		}  	}  } else {  	Console.Beep ();  }  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: if (cursorPosition + 1 < ActualWidth - 2) {  	cursorPosition++;  	CursorPosition = new Point (cursorPosition + 1' 0);  } else {  	if (displayOffset + cursorPosition < text.Length) {  		displayOffset++;  		Invalidate ();  	}  }  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: if (keyInfo.Key == ConsoleKey.End) {  	if (!String.IsNullOrEmpty (text) && cursorPosition + displayOffset < ActualWidth - 2) {  		displayOffset = text.Length >= ActualWidth - 2 ? text.Length - (ActualWidth - 2) + 1 : 0;  		cursorPosition = text.Length >= ActualWidth - 2 ? ActualWidth - 2 - 1 : text.Length;  		CursorPosition = new Point (cursorPosition + 1' 0);  		Invalidate ();  	} else {  		Console.Beep ();  	}  }  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: if (keyInfo.Key == ConsoleKey.End) {  	if (!String.IsNullOrEmpty (text) && cursorPosition + displayOffset < ActualWidth - 2) {  		displayOffset = text.Length >= ActualWidth - 2 ? text.Length - (ActualWidth - 2) + 1 : 0;  		cursorPosition = text.Length >= ActualWidth - 2 ? ActualWidth - 2 - 1 : text.Length;  		CursorPosition = new Point (cursorPosition + 1' 0);  		Invalidate ();  	} else {  		Console.Beep ();  	}  }  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: if (keyInfo.Key == ConsoleKey.End) {  	if (!String.IsNullOrEmpty (text) && cursorPosition + displayOffset < ActualWidth - 2) {  		displayOffset = text.Length >= ActualWidth - 2 ? text.Length - (ActualWidth - 2) + 1 : 0;  		cursorPosition = text.Length >= ActualWidth - 2 ? ActualWidth - 2 - 1 : text.Length;  		CursorPosition = new Point (cursorPosition + 1' 0);  		Invalidate ();  	} else {  		Console.Beep ();  	}  }  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: if (keyInfo.Key == ConsoleKey.End) {  	if (!String.IsNullOrEmpty (text) && cursorPosition + displayOffset < ActualWidth - 2) {  		displayOffset = text.Length >= ActualWidth - 2 ? text.Length - (ActualWidth - 2) + 1 : 0;  		cursorPosition = text.Length >= ActualWidth - 2 ? ActualWidth - 2 - 1 : text.Length;  		CursorPosition = new Point (cursorPosition + 1' 0);  		Invalidate ();  	} else {  		Console.Beep ();  	}  }  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: if (keyInfo.Key == ConsoleKey.End) {  	if (!String.IsNullOrEmpty (text) && cursorPosition + displayOffset < ActualWidth - 2) {  		displayOffset = text.Length >= ActualWidth - 2 ? text.Length - (ActualWidth - 2) + 1 : 0;  		cursorPosition = text.Length >= ActualWidth - 2 ? ActualWidth - 2 - 1 : text.Length;  		CursorPosition = new Point (cursorPosition + 1' 0);  		Invalidate ();  	} else {  		Console.Beep ();  	}  }  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: if (!String.IsNullOrEmpty (text) && cursorPosition + displayOffset < ActualWidth - 2) {  	displayOffset = text.Length >= ActualWidth - 2 ? text.Length - (ActualWidth - 2) + 1 : 0;  	cursorPosition = text.Length >= ActualWidth - 2 ? ActualWidth - 2 - 1 : text.Length;  	CursorPosition = new Point (cursorPosition + 1' 0);  	Invalidate ();  } else {  	Console.Beep ();  }  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: if (!String.IsNullOrEmpty (text) && cursorPosition + displayOffset < ActualWidth - 2) {  	displayOffset = text.Length >= ActualWidth - 2 ? text.Length - (ActualWidth - 2) + 1 : 0;  	cursorPosition = text.Length >= ActualWidth - 2 ? ActualWidth - 2 - 1 : text.Length;  	CursorPosition = new Point (cursorPosition + 1' 0);  	Invalidate ();  } else {  	Console.Beep ();  }  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: if (!String.IsNullOrEmpty (text) && cursorPosition + displayOffset < ActualWidth - 2) {  	displayOffset = text.Length >= ActualWidth - 2 ? text.Length - (ActualWidth - 2) + 1 : 0;  	cursorPosition = text.Length >= ActualWidth - 2 ? ActualWidth - 2 - 1 : text.Length;  	CursorPosition = new Point (cursorPosition + 1' 0);  	Invalidate ();  } else {  	Console.Beep ();  }  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: if (!String.IsNullOrEmpty (text) && cursorPosition + displayOffset < ActualWidth - 2) {  	displayOffset = text.Length >= ActualWidth - 2 ? text.Length - (ActualWidth - 2) + 1 : 0;  	cursorPosition = text.Length >= ActualWidth - 2 ? ActualWidth - 2 - 1 : text.Length;  	CursorPosition = new Point (cursorPosition + 1' 0);  	Invalidate ();  } else {  	Console.Beep ();  }  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: if (!String.IsNullOrEmpty (text) && cursorPosition + displayOffset < ActualWidth - 2) {  	displayOffset = text.Length >= ActualWidth - 2 ? text.Length - (ActualWidth - 2) + 1 : 0;  	cursorPosition = text.Length >= ActualWidth - 2 ? ActualWidth - 2 - 1 : text.Length;  	CursorPosition = new Point (cursorPosition + 1' 0);  	Invalidate ();  } else {  	Console.Beep ();  }  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: displayOffset = text.Length >= ActualWidth - 2 ? text.Length - (ActualWidth - 2) + 1 : 0;  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: displayOffset = text.Length >= ActualWidth - 2 ? text.Length - (ActualWidth - 2) + 1 : 0;  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: cursorPosition = text.Length >= ActualWidth - 2 ? ActualWidth - 2 - 1 : text.Length;  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,TextBox_KeyDown,The following statement contains a magic number: cursorPosition = text.Length >= ActualWidth - 2 ? ActualWidth - 2 - 1 : text.Length;  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,Render,The following statement contains a magic number: if (null != text) {  	for (int i = displayOffset; i < text.Length; i++) {  		if (i - displayOffset < ActualWidth - 2 && i - displayOffset >= 0) {  			buffer.SetPixel (1 + i - displayOffset' 0' text [i]);  		}  	}  }  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,Render,The following statement contains a magic number: for (int i = displayOffset; i < text.Length; i++) {  	if (i - displayOffset < ActualWidth - 2 && i - displayOffset >= 0) {  		buffer.SetPixel (1 + i - displayOffset' 0' text [i]);  	}  }  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,Render,The following statement contains a magic number: if (i - displayOffset < ActualWidth - 2 && i - displayOffset >= 0) {  	buffer.SetPixel (1 + i - displayOffset' 0' text [i]);  }  
Magic Number,ConsoleFramework.Controls,TextBox,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBox.cs,Render,The following statement contains a magic number: if (!String.IsNullOrEmpty (text) && ActualWidth - 2 + displayOffset < text.Length)  	buffer.SetPixel (ActualWidth - 1' 0' '>'' arrowsAttr);  
Magic Number,ConsoleFramework.Controls,Control,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\UIElementCollection.cs,computeAlignmentOffsetCore,The following statement contains a magic number: if (ha == HorizontalAlignment.Center || ha == HorizontalAlignment.Stretch) {  	offset.X = (clientSize.Width - inkSize.Width) / 2;  } else if (ha == HorizontalAlignment.Right) {  	offset.X = clientSize.Width - inkSize.Width;  } else {  	offset.X = 0;  }  
Magic Number,ConsoleFramework.Controls,Control,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\UIElementCollection.cs,computeAlignmentOffsetCore,The following statement contains a magic number: offset.X = (clientSize.Width - inkSize.Width) / 2;  
Magic Number,ConsoleFramework.Controls,Control,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\UIElementCollection.cs,computeAlignmentOffsetCore,The following statement contains a magic number: if (va == VerticalAlignment.Center || va == VerticalAlignment.Stretch) {  	offset.Y = (clientSize.Height - inkSize.Height) / 2;  } else if (va == VerticalAlignment.Bottom) {  	offset.Y = clientSize.Height - inkSize.Height;  } else {  	offset.Y = 0;  }  
Magic Number,ConsoleFramework.Controls,Control,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\UIElementCollection.cs,computeAlignmentOffsetCore,The following statement contains a magic number: offset.Y = (clientSize.Height - inkSize.Height) / 2;  
Magic Number,ConsoleFramework.Controls,Control,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\UIElementCollection.cs,RenderString,The following statement contains a magic number: for (int i = 0; i < Math.Min (s.Length' maxWidth); i++) {  	char c;  	if (i + 2 < maxWidth || i < 2 || s.Length <= maxWidth) {  		c = s [i];  	} else {  		c = '.';  	}  	buffer.SetPixel (x + i' y' c' attr);  }  
Magic Number,ConsoleFramework.Controls,Control,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\UIElementCollection.cs,RenderString,The following statement contains a magic number: for (int i = 0; i < Math.Min (s.Length' maxWidth); i++) {  	char c;  	if (i + 2 < maxWidth || i < 2 || s.Length <= maxWidth) {  		c = s [i];  	} else {  		c = '.';  	}  	buffer.SetPixel (x + i' y' c' attr);  }  
Magic Number,ConsoleFramework.Controls,Control,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\UIElementCollection.cs,RenderString,The following statement contains a magic number: if (i + 2 < maxWidth || i < 2 || s.Length <= maxWidth) {  	c = s [i];  } else {  	c = '.';  }  
Magic Number,ConsoleFramework.Controls,Control,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\UIElementCollection.cs,RenderString,The following statement contains a magic number: if (i + 2 < maxWidth || i < 2 || s.Length <= maxWidth) {  	c = s [i];  } else {  	c = '.';  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,MeasureOverride,The following statement contains a magic number: if (Content == null)  	return new Size (Math.Min (availableSize.Width' EMPTY_WINDOW_SIZE.Width + 4)' Math.Min (availableSize.Height' EMPTY_WINDOW_SIZE.Height + 3));  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,MeasureOverride,The following statement contains a magic number: if (Content == null)  	return new Size (Math.Min (availableSize.Width' EMPTY_WINDOW_SIZE.Width + 4)' Math.Min (availableSize.Height' EMPTY_WINDOW_SIZE.Height + 3));  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,MeasureOverride,The following statement contains a magic number: return new Size (Math.Min (availableSize.Width' EMPTY_WINDOW_SIZE.Width + 4)' Math.Min (availableSize.Height' EMPTY_WINDOW_SIZE.Height + 3));  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,MeasureOverride,The following statement contains a magic number: return new Size (Math.Min (availableSize.Width' EMPTY_WINDOW_SIZE.Width + 4)' Math.Min (availableSize.Height' EMPTY_WINDOW_SIZE.Height + 3));  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,MeasureOverride,The following statement contains a magic number: if (availableSize.Width != int.MaxValue && availableSize.Height != int.MaxValue) {  	// reserve 2 pixels for frame and 2/1 pixels for shadow  	Content.Measure (new Size (availableSize.width - 4' availableSize.height - 3));  } else {  	int width = availableSize.Width != int.MaxValue ? availableSize.Width - 4 : int.MaxValue;  	int height = availableSize.Height != int.MaxValue ? availableSize.Height - 3 : int.MaxValue;  	Content.Measure (new Size (width' height));  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,MeasureOverride,The following statement contains a magic number: if (availableSize.Width != int.MaxValue && availableSize.Height != int.MaxValue) {  	// reserve 2 pixels for frame and 2/1 pixels for shadow  	Content.Measure (new Size (availableSize.width - 4' availableSize.height - 3));  } else {  	int width = availableSize.Width != int.MaxValue ? availableSize.Width - 4 : int.MaxValue;  	int height = availableSize.Height != int.MaxValue ? availableSize.Height - 3 : int.MaxValue;  	Content.Measure (new Size (width' height));  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,MeasureOverride,The following statement contains a magic number: if (availableSize.Width != int.MaxValue && availableSize.Height != int.MaxValue) {  	// reserve 2 pixels for frame and 2/1 pixels for shadow  	Content.Measure (new Size (availableSize.width - 4' availableSize.height - 3));  } else {  	int width = availableSize.Width != int.MaxValue ? availableSize.Width - 4 : int.MaxValue;  	int height = availableSize.Height != int.MaxValue ? availableSize.Height - 3 : int.MaxValue;  	Content.Measure (new Size (width' height));  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,MeasureOverride,The following statement contains a magic number: if (availableSize.Width != int.MaxValue && availableSize.Height != int.MaxValue) {  	// reserve 2 pixels for frame and 2/1 pixels for shadow  	Content.Measure (new Size (availableSize.width - 4' availableSize.height - 3));  } else {  	int width = availableSize.Width != int.MaxValue ? availableSize.Width - 4 : int.MaxValue;  	int height = availableSize.Height != int.MaxValue ? availableSize.Height - 3 : int.MaxValue;  	Content.Measure (new Size (width' height));  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,MeasureOverride,The following statement contains a magic number: Content.Measure (new Size (availableSize.width - 4' availableSize.height - 3));  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,MeasureOverride,The following statement contains a magic number: Content.Measure (new Size (availableSize.width - 4' availableSize.height - 3));  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,ArrangeOverride,The following statement contains a magic number: if (Content != null) {  	Content.Arrange (new Rect (1' 1' finalSize.width - 4' finalSize.height - 3));  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,ArrangeOverride,The following statement contains a magic number: if (Content != null) {  	Content.Arrange (new Rect (1' 1' finalSize.width - 4' finalSize.height - 3));  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,ArrangeOverride,The following statement contains a magic number: Content.Arrange (new Rect (1' 1' finalSize.width - 4' finalSize.height - 3));  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,ArrangeOverride,The following statement contains a magic number: Content.Arrange (new Rect (1' 1' finalSize.width - 4' finalSize.height - 3));  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: RenderBorders (buffer' new Point (0' 0)' new Point (ActualWidth - 3' ActualHeight - 2)' this.moving || this.resizing' borderAttrs);  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: RenderBorders (buffer' new Point (0' 0)' new Point (ActualWidth - 3' ActualHeight - 2)' this.moving || this.resizing' borderAttrs);  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: if (ActualWidth > 4) {  	buffer.SetPixel (2' 0' '[');  	buffer.SetPixel (3' 0' showClosingGlyph ? UnicodeTable.WindowClosePressedSymbol : UnicodeTable.WindowCloseSymbol' Colors.Blend (Color.Green' Color.Gray));  	buffer.SetPixel (4' 0' ']');  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: if (ActualWidth > 4) {  	buffer.SetPixel (2' 0' '[');  	buffer.SetPixel (3' 0' showClosingGlyph ? UnicodeTable.WindowClosePressedSymbol : UnicodeTable.WindowCloseSymbol' Colors.Blend (Color.Green' Color.Gray));  	buffer.SetPixel (4' 0' ']');  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: if (ActualWidth > 4) {  	buffer.SetPixel (2' 0' '[');  	buffer.SetPixel (3' 0' showClosingGlyph ? UnicodeTable.WindowClosePressedSymbol : UnicodeTable.WindowCloseSymbol' Colors.Blend (Color.Green' Color.Gray));  	buffer.SetPixel (4' 0' ']');  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: if (ActualWidth > 4) {  	buffer.SetPixel (2' 0' '[');  	buffer.SetPixel (3' 0' showClosingGlyph ? UnicodeTable.WindowClosePressedSymbol : UnicodeTable.WindowCloseSymbol' Colors.Blend (Color.Green' Color.Gray));  	buffer.SetPixel (4' 0' ']');  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: buffer.SetPixel (2' 0' '[');  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: buffer.SetPixel (3' 0' showClosingGlyph ? UnicodeTable.WindowClosePressedSymbol : UnicodeTable.WindowCloseSymbol' Colors.Blend (Color.Green' Color.Gray));  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: buffer.SetPixel (4' 0' ']');  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: buffer.SetOpacity (0' ActualHeight - 1' 2 + 4);  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: buffer.SetOpacity (0' ActualHeight - 1' 2 + 4);  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: buffer.SetOpacity (1' ActualHeight - 1' 2 + 4);  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: buffer.SetOpacity (1' ActualHeight - 1' 2 + 4);  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: buffer.SetOpacity (ActualWidth - 1' 0' 2 + 4);  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: buffer.SetOpacity (ActualWidth - 1' 0' 2 + 4);  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: buffer.SetOpacity (ActualWidth - 2' 0' 2 + 4);  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: buffer.SetOpacity (ActualWidth - 2' 0' 2 + 4);  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: buffer.SetOpacity (ActualWidth - 2' 0' 2 + 4);  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: buffer.SetOpacityRect (2' ActualHeight - 1' ActualWidth - 2' 1' 1 + 4);  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: buffer.SetOpacityRect (2' ActualHeight - 1' ActualWidth - 2' 1' 1 + 4);  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: buffer.SetOpacityRect (2' ActualHeight - 1' ActualWidth - 2' 1' 1 + 4);  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: buffer.SetOpacityRect (ActualWidth - 2' 1' 2' ActualHeight - 1' 1 + 4);  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: buffer.SetOpacityRect (ActualWidth - 2' 1' 2' ActualHeight - 1' 1 + 4);  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: buffer.SetOpacityRect (ActualWidth - 2' 1' 2' ActualHeight - 1' 1 + 4);  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (Title)) {  	int titleStartX = 7;  	bool renderTitle = false;  	string renderTitleString = null;  	int availablePixelsCount = ActualWidth - titleStartX * 2;  	if (availablePixelsCount > 0) {  		renderTitle = true;  		if (Title.Length <= availablePixelsCount) {  			// dont truncate title  			titleStartX += (availablePixelsCount - Title.Length) / 2;  			renderTitleString = Title;  		} else {  			renderTitleString = Title.Substring (0' availablePixelsCount);  			if (renderTitleString.Length > 2) {  				renderTitleString = renderTitleString.Substring (0' renderTitleString.Length - 2) + "..";  			} else {  				renderTitle = false;  			}  		}  	}  	if (renderTitle) {  		// assert !string.IsNullOrEmpty(renderingTitleString);  		buffer.SetPixel (titleStartX - 1' 0' ' '' borderAttrs);  		for (int i = 0; i < renderTitleString.Length; i++) {  			buffer.SetPixel (titleStartX + i' 0' renderTitleString [i]' borderAttrs);  		}  		buffer.SetPixel (titleStartX + renderTitleString.Length' 0' ' '' borderAttrs);  	}  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (Title)) {  	int titleStartX = 7;  	bool renderTitle = false;  	string renderTitleString = null;  	int availablePixelsCount = ActualWidth - titleStartX * 2;  	if (availablePixelsCount > 0) {  		renderTitle = true;  		if (Title.Length <= availablePixelsCount) {  			// dont truncate title  			titleStartX += (availablePixelsCount - Title.Length) / 2;  			renderTitleString = Title;  		} else {  			renderTitleString = Title.Substring (0' availablePixelsCount);  			if (renderTitleString.Length > 2) {  				renderTitleString = renderTitleString.Substring (0' renderTitleString.Length - 2) + "..";  			} else {  				renderTitle = false;  			}  		}  	}  	if (renderTitle) {  		// assert !string.IsNullOrEmpty(renderingTitleString);  		buffer.SetPixel (titleStartX - 1' 0' ' '' borderAttrs);  		for (int i = 0; i < renderTitleString.Length; i++) {  			buffer.SetPixel (titleStartX + i' 0' renderTitleString [i]' borderAttrs);  		}  		buffer.SetPixel (titleStartX + renderTitleString.Length' 0' ' '' borderAttrs);  	}  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (Title)) {  	int titleStartX = 7;  	bool renderTitle = false;  	string renderTitleString = null;  	int availablePixelsCount = ActualWidth - titleStartX * 2;  	if (availablePixelsCount > 0) {  		renderTitle = true;  		if (Title.Length <= availablePixelsCount) {  			// dont truncate title  			titleStartX += (availablePixelsCount - Title.Length) / 2;  			renderTitleString = Title;  		} else {  			renderTitleString = Title.Substring (0' availablePixelsCount);  			if (renderTitleString.Length > 2) {  				renderTitleString = renderTitleString.Substring (0' renderTitleString.Length - 2) + "..";  			} else {  				renderTitle = false;  			}  		}  	}  	if (renderTitle) {  		// assert !string.IsNullOrEmpty(renderingTitleString);  		buffer.SetPixel (titleStartX - 1' 0' ' '' borderAttrs);  		for (int i = 0; i < renderTitleString.Length; i++) {  			buffer.SetPixel (titleStartX + i' 0' renderTitleString [i]' borderAttrs);  		}  		buffer.SetPixel (titleStartX + renderTitleString.Length' 0' ' '' borderAttrs);  	}  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (Title)) {  	int titleStartX = 7;  	bool renderTitle = false;  	string renderTitleString = null;  	int availablePixelsCount = ActualWidth - titleStartX * 2;  	if (availablePixelsCount > 0) {  		renderTitle = true;  		if (Title.Length <= availablePixelsCount) {  			// dont truncate title  			titleStartX += (availablePixelsCount - Title.Length) / 2;  			renderTitleString = Title;  		} else {  			renderTitleString = Title.Substring (0' availablePixelsCount);  			if (renderTitleString.Length > 2) {  				renderTitleString = renderTitleString.Substring (0' renderTitleString.Length - 2) + "..";  			} else {  				renderTitle = false;  			}  		}  	}  	if (renderTitle) {  		// assert !string.IsNullOrEmpty(renderingTitleString);  		buffer.SetPixel (titleStartX - 1' 0' ' '' borderAttrs);  		for (int i = 0; i < renderTitleString.Length; i++) {  			buffer.SetPixel (titleStartX + i' 0' renderTitleString [i]' borderAttrs);  		}  		buffer.SetPixel (titleStartX + renderTitleString.Length' 0' ' '' borderAttrs);  	}  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (Title)) {  	int titleStartX = 7;  	bool renderTitle = false;  	string renderTitleString = null;  	int availablePixelsCount = ActualWidth - titleStartX * 2;  	if (availablePixelsCount > 0) {  		renderTitle = true;  		if (Title.Length <= availablePixelsCount) {  			// dont truncate title  			titleStartX += (availablePixelsCount - Title.Length) / 2;  			renderTitleString = Title;  		} else {  			renderTitleString = Title.Substring (0' availablePixelsCount);  			if (renderTitleString.Length > 2) {  				renderTitleString = renderTitleString.Substring (0' renderTitleString.Length - 2) + "..";  			} else {  				renderTitle = false;  			}  		}  	}  	if (renderTitle) {  		// assert !string.IsNullOrEmpty(renderingTitleString);  		buffer.SetPixel (titleStartX - 1' 0' ' '' borderAttrs);  		for (int i = 0; i < renderTitleString.Length; i++) {  			buffer.SetPixel (titleStartX + i' 0' renderTitleString [i]' borderAttrs);  		}  		buffer.SetPixel (titleStartX + renderTitleString.Length' 0' ' '' borderAttrs);  	}  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: if (availablePixelsCount > 0) {  	renderTitle = true;  	if (Title.Length <= availablePixelsCount) {  		// dont truncate title  		titleStartX += (availablePixelsCount - Title.Length) / 2;  		renderTitleString = Title;  	} else {  		renderTitleString = Title.Substring (0' availablePixelsCount);  		if (renderTitleString.Length > 2) {  			renderTitleString = renderTitleString.Substring (0' renderTitleString.Length - 2) + "..";  		} else {  			renderTitle = false;  		}  	}  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: if (availablePixelsCount > 0) {  	renderTitle = true;  	if (Title.Length <= availablePixelsCount) {  		// dont truncate title  		titleStartX += (availablePixelsCount - Title.Length) / 2;  		renderTitleString = Title;  	} else {  		renderTitleString = Title.Substring (0' availablePixelsCount);  		if (renderTitleString.Length > 2) {  			renderTitleString = renderTitleString.Substring (0' renderTitleString.Length - 2) + "..";  		} else {  			renderTitle = false;  		}  	}  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: if (availablePixelsCount > 0) {  	renderTitle = true;  	if (Title.Length <= availablePixelsCount) {  		// dont truncate title  		titleStartX += (availablePixelsCount - Title.Length) / 2;  		renderTitleString = Title;  	} else {  		renderTitleString = Title.Substring (0' availablePixelsCount);  		if (renderTitleString.Length > 2) {  			renderTitleString = renderTitleString.Substring (0' renderTitleString.Length - 2) + "..";  		} else {  			renderTitle = false;  		}  	}  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: if (Title.Length <= availablePixelsCount) {  	// dont truncate title  	titleStartX += (availablePixelsCount - Title.Length) / 2;  	renderTitleString = Title;  } else {  	renderTitleString = Title.Substring (0' availablePixelsCount);  	if (renderTitleString.Length > 2) {  		renderTitleString = renderTitleString.Substring (0' renderTitleString.Length - 2) + "..";  	} else {  		renderTitle = false;  	}  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: if (Title.Length <= availablePixelsCount) {  	// dont truncate title  	titleStartX += (availablePixelsCount - Title.Length) / 2;  	renderTitleString = Title;  } else {  	renderTitleString = Title.Substring (0' availablePixelsCount);  	if (renderTitleString.Length > 2) {  		renderTitleString = renderTitleString.Substring (0' renderTitleString.Length - 2) + "..";  	} else {  		renderTitle = false;  	}  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: if (Title.Length <= availablePixelsCount) {  	// dont truncate title  	titleStartX += (availablePixelsCount - Title.Length) / 2;  	renderTitleString = Title;  } else {  	renderTitleString = Title.Substring (0' availablePixelsCount);  	if (renderTitleString.Length > 2) {  		renderTitleString = renderTitleString.Substring (0' renderTitleString.Length - 2) + "..";  	} else {  		renderTitle = false;  	}  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: titleStartX += (availablePixelsCount - Title.Length) / 2;  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: if (renderTitleString.Length > 2) {  	renderTitleString = renderTitleString.Substring (0' renderTitleString.Length - 2) + "..";  } else {  	renderTitle = false;  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: if (renderTitleString.Length > 2) {  	renderTitleString = renderTitleString.Substring (0' renderTitleString.Length - 2) + "..";  } else {  	renderTitle = false;  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Render,The following statement contains a magic number: renderTitleString = renderTitleString.Substring (0' renderTitleString.Length - 2) + "..";  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Window_OnMouseDown,The following statement contains a magic number: if (!moving && !resizing && !closing) {  	Point point = args.GetPosition (this);  	Point parentPoint = args.GetPosition (getWindowsHost ());  	if (point.y == 0 && point.x == 3) {  		closing = true;  		showClosingGlyph = true;  		ConsoleApplication.Instance.BeginCaptureInput (this);  		// closing is started' we should redraw the border  		Invalidate ();  		args.Handled = true;  	} else if (point.y == 0) {  		moving = true;  		movingStartPoint = parentPoint;  		movingStartX = RenderSlotRect.TopLeft.X;  		movingStartY = RenderSlotRect.TopLeft.Y;  		ConsoleApplication.Instance.BeginCaptureInput (this);  		// moving is started' we should redraw the border  		Invalidate ();  		args.Handled = true;  	} else if (point.x == ActualWidth - 3 && point.y == ActualHeight - 2) {  		resizing = true;  		resizingStartPoint = parentPoint;  		resizingStartWidth = ActualWidth;  		resizingStartHeight = ActualHeight;  		ConsoleApplication.Instance.BeginCaptureInput (this);  		// resizing is started' we should redraw the border  		Invalidate ();  		args.Handled = true;  	}  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Window_OnMouseDown,The following statement contains a magic number: if (!moving && !resizing && !closing) {  	Point point = args.GetPosition (this);  	Point parentPoint = args.GetPosition (getWindowsHost ());  	if (point.y == 0 && point.x == 3) {  		closing = true;  		showClosingGlyph = true;  		ConsoleApplication.Instance.BeginCaptureInput (this);  		// closing is started' we should redraw the border  		Invalidate ();  		args.Handled = true;  	} else if (point.y == 0) {  		moving = true;  		movingStartPoint = parentPoint;  		movingStartX = RenderSlotRect.TopLeft.X;  		movingStartY = RenderSlotRect.TopLeft.Y;  		ConsoleApplication.Instance.BeginCaptureInput (this);  		// moving is started' we should redraw the border  		Invalidate ();  		args.Handled = true;  	} else if (point.x == ActualWidth - 3 && point.y == ActualHeight - 2) {  		resizing = true;  		resizingStartPoint = parentPoint;  		resizingStartWidth = ActualWidth;  		resizingStartHeight = ActualHeight;  		ConsoleApplication.Instance.BeginCaptureInput (this);  		// resizing is started' we should redraw the border  		Invalidate ();  		args.Handled = true;  	}  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Window_OnMouseDown,The following statement contains a magic number: if (!moving && !resizing && !closing) {  	Point point = args.GetPosition (this);  	Point parentPoint = args.GetPosition (getWindowsHost ());  	if (point.y == 0 && point.x == 3) {  		closing = true;  		showClosingGlyph = true;  		ConsoleApplication.Instance.BeginCaptureInput (this);  		// closing is started' we should redraw the border  		Invalidate ();  		args.Handled = true;  	} else if (point.y == 0) {  		moving = true;  		movingStartPoint = parentPoint;  		movingStartX = RenderSlotRect.TopLeft.X;  		movingStartY = RenderSlotRect.TopLeft.Y;  		ConsoleApplication.Instance.BeginCaptureInput (this);  		// moving is started' we should redraw the border  		Invalidate ();  		args.Handled = true;  	} else if (point.x == ActualWidth - 3 && point.y == ActualHeight - 2) {  		resizing = true;  		resizingStartPoint = parentPoint;  		resizingStartWidth = ActualWidth;  		resizingStartHeight = ActualHeight;  		ConsoleApplication.Instance.BeginCaptureInput (this);  		// resizing is started' we should redraw the border  		Invalidate ();  		args.Handled = true;  	}  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Window_OnMouseDown,The following statement contains a magic number: if (point.y == 0 && point.x == 3) {  	closing = true;  	showClosingGlyph = true;  	ConsoleApplication.Instance.BeginCaptureInput (this);  	// closing is started' we should redraw the border  	Invalidate ();  	args.Handled = true;  } else if (point.y == 0) {  	moving = true;  	movingStartPoint = parentPoint;  	movingStartX = RenderSlotRect.TopLeft.X;  	movingStartY = RenderSlotRect.TopLeft.Y;  	ConsoleApplication.Instance.BeginCaptureInput (this);  	// moving is started' we should redraw the border  	Invalidate ();  	args.Handled = true;  } else if (point.x == ActualWidth - 3 && point.y == ActualHeight - 2) {  	resizing = true;  	resizingStartPoint = parentPoint;  	resizingStartWidth = ActualWidth;  	resizingStartHeight = ActualHeight;  	ConsoleApplication.Instance.BeginCaptureInput (this);  	// resizing is started' we should redraw the border  	Invalidate ();  	args.Handled = true;  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Window_OnMouseDown,The following statement contains a magic number: if (point.y == 0 && point.x == 3) {  	closing = true;  	showClosingGlyph = true;  	ConsoleApplication.Instance.BeginCaptureInput (this);  	// closing is started' we should redraw the border  	Invalidate ();  	args.Handled = true;  } else if (point.y == 0) {  	moving = true;  	movingStartPoint = parentPoint;  	movingStartX = RenderSlotRect.TopLeft.X;  	movingStartY = RenderSlotRect.TopLeft.Y;  	ConsoleApplication.Instance.BeginCaptureInput (this);  	// moving is started' we should redraw the border  	Invalidate ();  	args.Handled = true;  } else if (point.x == ActualWidth - 3 && point.y == ActualHeight - 2) {  	resizing = true;  	resizingStartPoint = parentPoint;  	resizingStartWidth = ActualWidth;  	resizingStartHeight = ActualHeight;  	ConsoleApplication.Instance.BeginCaptureInput (this);  	// resizing is started' we should redraw the border  	Invalidate ();  	args.Handled = true;  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Window_OnMouseDown,The following statement contains a magic number: if (point.y == 0 && point.x == 3) {  	closing = true;  	showClosingGlyph = true;  	ConsoleApplication.Instance.BeginCaptureInput (this);  	// closing is started' we should redraw the border  	Invalidate ();  	args.Handled = true;  } else if (point.y == 0) {  	moving = true;  	movingStartPoint = parentPoint;  	movingStartX = RenderSlotRect.TopLeft.X;  	movingStartY = RenderSlotRect.TopLeft.Y;  	ConsoleApplication.Instance.BeginCaptureInput (this);  	// moving is started' we should redraw the border  	Invalidate ();  	args.Handled = true;  } else if (point.x == ActualWidth - 3 && point.y == ActualHeight - 2) {  	resizing = true;  	resizingStartPoint = parentPoint;  	resizingStartWidth = ActualWidth;  	resizingStartHeight = ActualHeight;  	ConsoleApplication.Instance.BeginCaptureInput (this);  	// resizing is started' we should redraw the border  	Invalidate ();  	args.Handled = true;  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Window_OnMouseDown,The following statement contains a magic number: if (point.y == 0) {  	moving = true;  	movingStartPoint = parentPoint;  	movingStartX = RenderSlotRect.TopLeft.X;  	movingStartY = RenderSlotRect.TopLeft.Y;  	ConsoleApplication.Instance.BeginCaptureInput (this);  	// moving is started' we should redraw the border  	Invalidate ();  	args.Handled = true;  } else if (point.x == ActualWidth - 3 && point.y == ActualHeight - 2) {  	resizing = true;  	resizingStartPoint = parentPoint;  	resizingStartWidth = ActualWidth;  	resizingStartHeight = ActualHeight;  	ConsoleApplication.Instance.BeginCaptureInput (this);  	// resizing is started' we should redraw the border  	Invalidate ();  	args.Handled = true;  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Window_OnMouseDown,The following statement contains a magic number: if (point.y == 0) {  	moving = true;  	movingStartPoint = parentPoint;  	movingStartX = RenderSlotRect.TopLeft.X;  	movingStartY = RenderSlotRect.TopLeft.Y;  	ConsoleApplication.Instance.BeginCaptureInput (this);  	// moving is started' we should redraw the border  	Invalidate ();  	args.Handled = true;  } else if (point.x == ActualWidth - 3 && point.y == ActualHeight - 2) {  	resizing = true;  	resizingStartPoint = parentPoint;  	resizingStartWidth = ActualWidth;  	resizingStartHeight = ActualHeight;  	ConsoleApplication.Instance.BeginCaptureInput (this);  	// resizing is started' we should redraw the border  	Invalidate ();  	args.Handled = true;  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Window_OnMouseDown,The following statement contains a magic number: if (point.x == ActualWidth - 3 && point.y == ActualHeight - 2) {  	resizing = true;  	resizingStartPoint = parentPoint;  	resizingStartWidth = ActualWidth;  	resizingStartHeight = ActualHeight;  	ConsoleApplication.Instance.BeginCaptureInput (this);  	// resizing is started' we should redraw the border  	Invalidate ();  	args.Handled = true;  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Window_OnMouseDown,The following statement contains a magic number: if (point.x == ActualWidth - 3 && point.y == ActualHeight - 2) {  	resizing = true;  	resizingStartPoint = parentPoint;  	resizingStartWidth = ActualWidth;  	resizingStartHeight = ActualHeight;  	ConsoleApplication.Instance.BeginCaptureInput (this);  	// resizing is started' we should redraw the border  	Invalidate ();  	args.Handled = true;  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Window_OnMouseUp,The following statement contains a magic number: if (closing) {  	Point point = args.GetPosition (this);  	if (point.x == 3 && point.y == 0) {  		getWindowsHost ().CloseWindow (this);  	}  	closing = false;  	showClosingGlyph = false;  	ConsoleApplication.Instance.EndCaptureInput (this);  	Invalidate ();  	args.Handled = true;  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Window_OnMouseUp,The following statement contains a magic number: if (point.x == 3 && point.y == 0) {  	getWindowsHost ().CloseWindow (this);  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Window_OnMouseMove,The following statement contains a magic number: if (closing) {  	Point point = args.GetPosition (this);  	bool anyChanged = false;  	if (point.x == 3 && point.y == 0) {  		if (!showClosingGlyph) {  			showClosingGlyph = true;  			anyChanged = true;  		}  	} else {  		if (showClosingGlyph) {  			showClosingGlyph = false;  			anyChanged = true;  		}  	}  	if (anyChanged)  		Invalidate ();  	args.Handled = true;  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Window_OnMouseMove,The following statement contains a magic number: if (point.x == 3 && point.y == 0) {  	if (!showClosingGlyph) {  		showClosingGlyph = true;  		anyChanged = true;  	}  } else {  	if (showClosingGlyph) {  		showClosingGlyph = false;  		anyChanged = true;  	}  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Window_OnMouseMove,The following statement contains a magic number: if (resizing) {  	Point parentPoint = args.GetPosition (getWindowsHost ());  	int deltaWidth = parentPoint.X - resizingStartPoint.x;  	int deltaHeight = parentPoint.Y - resizingStartPoint.y;  	int width = resizingStartWidth + deltaWidth;  	int height = resizingStartHeight + deltaHeight;  	bool anyChanged = false;  	if (width >= 4) {  		this.Width = width;  		anyChanged = true;  	}  	if (height >= 3) {  		this.Height = height;  		anyChanged = true;  	}  	if (anyChanged)  		Invalidate ();  	args.Handled = true;  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Window_OnMouseMove,The following statement contains a magic number: if (resizing) {  	Point parentPoint = args.GetPosition (getWindowsHost ());  	int deltaWidth = parentPoint.X - resizingStartPoint.x;  	int deltaHeight = parentPoint.Y - resizingStartPoint.y;  	int width = resizingStartWidth + deltaWidth;  	int height = resizingStartHeight + deltaHeight;  	bool anyChanged = false;  	if (width >= 4) {  		this.Width = width;  		anyChanged = true;  	}  	if (height >= 3) {  		this.Height = height;  		anyChanged = true;  	}  	if (anyChanged)  		Invalidate ();  	args.Handled = true;  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Window_OnMouseMove,The following statement contains a magic number: if (width >= 4) {  	this.Width = width;  	anyChanged = true;  }  
Magic Number,ConsoleFramework.Controls,Window,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Window.cs,Window_OnMouseMove,The following statement contains a magic number: if (height >= 3) {  	this.Height = height;  	anyChanged = true;  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,MeasureOverride,The following statement contains a magic number: if (!string.IsNullOrEmpty (caption)) {  	Size minButtonSize = new Size (caption.Length + 10' 2);  	return minButtonSize;  } else  	return new Size (8' 2);  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,MeasureOverride,The following statement contains a magic number: if (!string.IsNullOrEmpty (caption)) {  	Size minButtonSize = new Size (caption.Length + 10' 2);  	return minButtonSize;  } else  	return new Size (8' 2);  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,MeasureOverride,The following statement contains a magic number: if (!string.IsNullOrEmpty (caption)) {  	Size minButtonSize = new Size (caption.Length + 10' 2);  	return minButtonSize;  } else  	return new Size (8' 2);  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,MeasureOverride,The following statement contains a magic number: if (!string.IsNullOrEmpty (caption)) {  	Size minButtonSize = new Size (caption.Length + 10' 2);  	return minButtonSize;  } else  	return new Size (8' 2);  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,MeasureOverride,The following statement contains a magic number: return new Size (8' 2);  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,MeasureOverride,The following statement contains a magic number: return new Size (8' 2);  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (pressed || pressedUsingKeyboard) {  	buffer.FillRectangle (1' 0' ActualWidth - 1' ActualHeight - 1' ' '' captionAttrs);  	buffer.SetOpacityRect (0' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (0' 0' 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (0' ActualHeight - 1' ActualWidth' 1' ' '' Attr.NO_ATTRIBUTES);  } else {  	buffer.FillRectangle (0' 0' ActualWidth - 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetPixel (0' ActualHeight - 1' ' ');  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - 1' 1' UnicodeTable.UpperHalfBlock' Attr.NO_ATTRIBUTES);  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.FullBlock' Attr.NO_ATTRIBUTES);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.LowerHalfBlock);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (pressed || pressedUsingKeyboard) {  	buffer.FillRectangle (1' 0' ActualWidth - 1' ActualHeight - 1' ' '' captionAttrs);  	buffer.SetOpacityRect (0' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (0' 0' 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (0' ActualHeight - 1' ActualWidth' 1' ' '' Attr.NO_ATTRIBUTES);  } else {  	buffer.FillRectangle (0' 0' ActualWidth - 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetPixel (0' ActualHeight - 1' ' ');  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - 1' 1' UnicodeTable.UpperHalfBlock' Attr.NO_ATTRIBUTES);  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.FullBlock' Attr.NO_ATTRIBUTES);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.LowerHalfBlock);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (pressed || pressedUsingKeyboard) {  	buffer.FillRectangle (1' 0' ActualWidth - 1' ActualHeight - 1' ' '' captionAttrs);  	buffer.SetOpacityRect (0' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (0' 0' 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (0' ActualHeight - 1' ActualWidth' 1' ' '' Attr.NO_ATTRIBUTES);  } else {  	buffer.FillRectangle (0' 0' ActualWidth - 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetPixel (0' ActualHeight - 1' ' ');  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - 1' 1' UnicodeTable.UpperHalfBlock' Attr.NO_ATTRIBUTES);  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.FullBlock' Attr.NO_ATTRIBUTES);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.LowerHalfBlock);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (pressed || pressedUsingKeyboard) {  	buffer.FillRectangle (1' 0' ActualWidth - 1' ActualHeight - 1' ' '' captionAttrs);  	buffer.SetOpacityRect (0' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (0' 0' 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (0' ActualHeight - 1' ActualWidth' 1' ' '' Attr.NO_ATTRIBUTES);  } else {  	buffer.FillRectangle (0' 0' ActualWidth - 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetPixel (0' ActualHeight - 1' ' ');  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - 1' 1' UnicodeTable.UpperHalfBlock' Attr.NO_ATTRIBUTES);  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.FullBlock' Attr.NO_ATTRIBUTES);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.LowerHalfBlock);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (pressed || pressedUsingKeyboard) {  	buffer.FillRectangle (1' 0' ActualWidth - 1' ActualHeight - 1' ' '' captionAttrs);  	buffer.SetOpacityRect (0' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (0' 0' 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (0' ActualHeight - 1' ActualWidth' 1' ' '' Attr.NO_ATTRIBUTES);  } else {  	buffer.FillRectangle (0' 0' ActualWidth - 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetPixel (0' ActualHeight - 1' ' ');  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - 1' 1' UnicodeTable.UpperHalfBlock' Attr.NO_ATTRIBUTES);  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.FullBlock' Attr.NO_ATTRIBUTES);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.LowerHalfBlock);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (pressed || pressedUsingKeyboard) {  	buffer.FillRectangle (1' 0' ActualWidth - 1' ActualHeight - 1' ' '' captionAttrs);  	buffer.SetOpacityRect (0' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (0' 0' 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (0' ActualHeight - 1' ActualWidth' 1' ' '' Attr.NO_ATTRIBUTES);  } else {  	buffer.FillRectangle (0' 0' ActualWidth - 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetPixel (0' ActualHeight - 1' ' ');  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - 1' 1' UnicodeTable.UpperHalfBlock' Attr.NO_ATTRIBUTES);  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.FullBlock' Attr.NO_ATTRIBUTES);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.LowerHalfBlock);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (pressed || pressedUsingKeyboard) {  	buffer.FillRectangle (1' 0' ActualWidth - 1' ActualHeight - 1' ' '' captionAttrs);  	buffer.SetOpacityRect (0' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (0' 0' 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (0' ActualHeight - 1' ActualWidth' 1' ' '' Attr.NO_ATTRIBUTES);  } else {  	buffer.FillRectangle (0' 0' ActualWidth - 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetPixel (0' ActualHeight - 1' ' ');  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - 1' 1' UnicodeTable.UpperHalfBlock' Attr.NO_ATTRIBUTES);  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.FullBlock' Attr.NO_ATTRIBUTES);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.LowerHalfBlock);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (pressed || pressedUsingKeyboard) {  	buffer.FillRectangle (1' 0' ActualWidth - 1' ActualHeight - 1' ' '' captionAttrs);  	buffer.SetOpacityRect (0' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (0' 0' 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (0' ActualHeight - 1' ActualWidth' 1' ' '' Attr.NO_ATTRIBUTES);  } else {  	buffer.FillRectangle (0' 0' ActualWidth - 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetPixel (0' ActualHeight - 1' ' ');  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - 1' 1' UnicodeTable.UpperHalfBlock' Attr.NO_ATTRIBUTES);  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.FullBlock' Attr.NO_ATTRIBUTES);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.LowerHalfBlock);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (pressed || pressedUsingKeyboard) {  	buffer.FillRectangle (1' 0' ActualWidth - 1' ActualHeight - 1' ' '' captionAttrs);  	buffer.SetOpacityRect (0' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (0' 0' 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (0' ActualHeight - 1' ActualWidth' 1' ' '' Attr.NO_ATTRIBUTES);  } else {  	buffer.FillRectangle (0' 0' ActualWidth - 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetPixel (0' ActualHeight - 1' ' ');  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - 1' 1' UnicodeTable.UpperHalfBlock' Attr.NO_ATTRIBUTES);  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.FullBlock' Attr.NO_ATTRIBUTES);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.LowerHalfBlock);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (pressed || pressedUsingKeyboard) {  	buffer.FillRectangle (1' 0' ActualWidth - 1' ActualHeight - 1' ' '' captionAttrs);  	buffer.SetOpacityRect (0' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (0' 0' 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (0' ActualHeight - 1' ActualWidth' 1' ' '' Attr.NO_ATTRIBUTES);  } else {  	buffer.FillRectangle (0' 0' ActualWidth - 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetPixel (0' ActualHeight - 1' ' ');  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - 1' 1' UnicodeTable.UpperHalfBlock' Attr.NO_ATTRIBUTES);  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.FullBlock' Attr.NO_ATTRIBUTES);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.LowerHalfBlock);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (pressed || pressedUsingKeyboard) {  	buffer.FillRectangle (1' 0' ActualWidth - 1' ActualHeight - 1' ' '' captionAttrs);  	buffer.SetOpacityRect (0' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (0' 0' 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (0' ActualHeight - 1' ActualWidth' 1' ' '' Attr.NO_ATTRIBUTES);  } else {  	buffer.FillRectangle (0' 0' ActualWidth - 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetPixel (0' ActualHeight - 1' ' ');  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - 1' 1' UnicodeTable.UpperHalfBlock' Attr.NO_ATTRIBUTES);  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.FullBlock' Attr.NO_ATTRIBUTES);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.LowerHalfBlock);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (pressed || pressedUsingKeyboard) {  	buffer.FillRectangle (1' 0' ActualWidth - 1' ActualHeight - 1' ' '' captionAttrs);  	buffer.SetOpacityRect (0' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (0' 0' 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (0' ActualHeight - 1' ActualWidth' 1' ' '' Attr.NO_ATTRIBUTES);  } else {  	buffer.FillRectangle (0' 0' ActualWidth - 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetPixel (0' ActualHeight - 1' ' ');  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - 1' 1' UnicodeTable.UpperHalfBlock' Attr.NO_ATTRIBUTES);  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.FullBlock' Attr.NO_ATTRIBUTES);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.LowerHalfBlock);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (pressed || pressedUsingKeyboard) {  	buffer.FillRectangle (1' 0' ActualWidth - 1' ActualHeight - 1' ' '' captionAttrs);  	buffer.SetOpacityRect (0' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (0' 0' 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (0' ActualHeight - 1' ActualWidth' 1' ' '' Attr.NO_ATTRIBUTES);  } else {  	buffer.FillRectangle (0' 0' ActualWidth - 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetPixel (0' ActualHeight - 1' ' ');  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - 1' 1' UnicodeTable.UpperHalfBlock' Attr.NO_ATTRIBUTES);  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.FullBlock' Attr.NO_ATTRIBUTES);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.LowerHalfBlock);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (pressed || pressedUsingKeyboard) {  	buffer.FillRectangle (1' 0' ActualWidth - 1' ActualHeight - 1' ' '' captionAttrs);  	buffer.SetOpacityRect (0' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (0' 0' 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (0' ActualHeight - 1' ActualWidth' 1' ' '' Attr.NO_ATTRIBUTES);  } else {  	buffer.FillRectangle (0' 0' ActualWidth - 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetPixel (0' ActualHeight - 1' ' ');  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - 1' 1' UnicodeTable.UpperHalfBlock' Attr.NO_ATTRIBUTES);  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.FullBlock' Attr.NO_ATTRIBUTES);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.LowerHalfBlock);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (pressed || pressedUsingKeyboard) {  	buffer.FillRectangle (1' 0' ActualWidth - 1' ActualHeight - 1' ' '' captionAttrs);  	buffer.SetOpacityRect (0' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (0' 0' 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (0' ActualHeight - 1' ActualWidth' 1' ' '' Attr.NO_ATTRIBUTES);  } else {  	buffer.FillRectangle (0' 0' ActualWidth - 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetPixel (0' ActualHeight - 1' ' ');  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - 1' 1' UnicodeTable.UpperHalfBlock' Attr.NO_ATTRIBUTES);  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.FullBlock' Attr.NO_ATTRIBUTES);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.LowerHalfBlock);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (pressed || pressedUsingKeyboard) {  	buffer.FillRectangle (1' 0' ActualWidth - 1' ActualHeight - 1' ' '' captionAttrs);  	buffer.SetOpacityRect (0' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (0' 0' 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (0' ActualHeight - 1' ActualWidth' 1' ' '' Attr.NO_ATTRIBUTES);  } else {  	buffer.FillRectangle (0' 0' ActualWidth - 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetPixel (0' ActualHeight - 1' ' ');  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - 1' 1' UnicodeTable.UpperHalfBlock' Attr.NO_ATTRIBUTES);  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.FullBlock' Attr.NO_ATTRIBUTES);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.LowerHalfBlock);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (pressed || pressedUsingKeyboard) {  	buffer.FillRectangle (1' 0' ActualWidth - 1' ActualHeight - 1' ' '' captionAttrs);  	buffer.SetOpacityRect (0' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (0' 0' 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (0' ActualHeight - 1' ActualWidth' 1' ' '' Attr.NO_ATTRIBUTES);  } else {  	buffer.FillRectangle (0' 0' ActualWidth - 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetPixel (0' ActualHeight - 1' ' ');  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - 1' 1' UnicodeTable.UpperHalfBlock' Attr.NO_ATTRIBUTES);  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.FullBlock' Attr.NO_ATTRIBUTES);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.LowerHalfBlock);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (pressed || pressedUsingKeyboard) {  	buffer.FillRectangle (1' 0' ActualWidth - 1' ActualHeight - 1' ' '' captionAttrs);  	buffer.SetOpacityRect (0' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (0' 0' 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (0' ActualHeight - 1' ActualWidth' 1' ' '' Attr.NO_ATTRIBUTES);  } else {  	buffer.FillRectangle (0' 0' ActualWidth - 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetPixel (0' ActualHeight - 1' ' ');  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - 1' 1' UnicodeTable.UpperHalfBlock' Attr.NO_ATTRIBUTES);  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.FullBlock' Attr.NO_ATTRIBUTES);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.LowerHalfBlock);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (pressed || pressedUsingKeyboard) {  	buffer.FillRectangle (1' 0' ActualWidth - 1' ActualHeight - 1' ' '' captionAttrs);  	buffer.SetOpacityRect (0' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (0' 0' 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (0' ActualHeight - 1' ActualWidth' 1' ' '' Attr.NO_ATTRIBUTES);  } else {  	buffer.FillRectangle (0' 0' ActualWidth - 1' ActualHeight' ' '' captionAttrs);  	if (!string.IsNullOrEmpty (Caption)) {  		RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  	}  	buffer.SetPixel (0' ActualHeight - 1' ' ');  	buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  	buffer.FillRectangle (1' ActualHeight - 1' ActualWidth - 1' 1' UnicodeTable.UpperHalfBlock' Attr.NO_ATTRIBUTES);  	buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 3);  	buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.FullBlock' Attr.NO_ATTRIBUTES);  	buffer.SetPixel (ActualWidth - 1' 0' UnicodeTable.LowerHalfBlock);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: buffer.SetOpacityRect (0' 0' 1' ActualHeight' 3);  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (Caption)) {  	RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (Caption)) {  	RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (Caption)) {  	RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (Caption)) {  	RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (Caption)) {  	RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (Caption)) {  	RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (Caption)) {  	RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: RenderString (Caption' buffer' 2 + 1 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (Caption)) {  	RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (Caption)) {  	RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (Caption)) {  	RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (Caption)) {  	RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (Caption)) {  	RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (Caption)) {  	RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: if (!string.IsNullOrEmpty (Caption)) {  	RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  }  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: RenderString (Caption' buffer' 2 + (ActualWidth - 2 * 2 - Caption.Length) / 2' (ActualHeight - 1) / 2' ActualWidth - 2 * 2' captionAttrs);  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: buffer.SetOpacityRect (0' ActualHeight - 1' ActualWidth' 1' 3);  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: buffer.SetOpacityRect (ActualWidth - 1' 0' 1' ActualHeight' 3);  
Magic Number,ConsoleFramework.Controls,Button,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Button.cs,Render,The following statement contains a magic number: buffer.FillRectangle (ActualWidth - 1' 1' 1' ActualHeight - 2' UnicodeTable.FullBlock' Attr.NO_ATTRIBUTES);  
Magic Number,ConsoleFramework.Controls,Panel,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Panel.cs,Render,The following statement contains a magic number: for (int x = 0; x < ActualWidth; ++x) {  	for (int y = 0; y < ActualHeight; ++y) {  		buffer.SetPixel (x' y' ' '' Attr.BACKGROUND_BLUE | Attr.BACKGROUND_GREEN | Attr.BACKGROUND_RED | Attr.FOREGROUND_BLUE | Attr.FOREGROUND_GREEN | Attr.FOREGROUND_RED | Attr.FOREGROUND_INTENSITY);  		buffer.SetOpacity (x' y' 4);  	}  }  
Magic Number,ConsoleFramework.Controls,Panel,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Panel.cs,Render,The following statement contains a magic number: for (int y = 0; y < ActualHeight; ++y) {  	buffer.SetPixel (x' y' ' '' Attr.BACKGROUND_BLUE | Attr.BACKGROUND_GREEN | Attr.BACKGROUND_RED | Attr.FOREGROUND_BLUE | Attr.FOREGROUND_GREEN | Attr.FOREGROUND_RED | Attr.FOREGROUND_INTENSITY);  	buffer.SetOpacity (x' y' 4);  }  
Magic Number,ConsoleFramework.Controls,Panel,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Panel.cs,Render,The following statement contains a magic number: buffer.SetOpacity (x' y' 4);  
Magic Number,ConsoleFramework.Controls,TextBlock,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TextBlock.cs,Render,The following statement contains a magic number: buffer.SetOpacityRect (0' 0' ActualWidth' ActualHeight' 3);  
Magic Number,ConsoleFramework.Controls,WindowsHost,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\WindowsHost.cs,ArrangeOverride,The following statement contains a magic number: for (int index = windowsStartIndex; index < Children.Count; index++) {  	Control control = Children [index];  	Window window = (Window)control;  	int x;  	if (window.X.HasValue) {  		x = window.X.Value;  	} else {  		x = (finalSize.Width - window.DesiredSize.Width) / 2;  	}  	int y;  	if (window.Y.HasValue) {  		y = window.Y.Value;  	} else {  		y = (finalSize.Height - window.DesiredSize.Height) / 2;  	}  	window.Arrange (new Rect (x' y' window.DesiredSize.Width' window.DesiredSize.Height));  }  
Magic Number,ConsoleFramework.Controls,WindowsHost,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\WindowsHost.cs,ArrangeOverride,The following statement contains a magic number: for (int index = windowsStartIndex; index < Children.Count; index++) {  	Control control = Children [index];  	Window window = (Window)control;  	int x;  	if (window.X.HasValue) {  		x = window.X.Value;  	} else {  		x = (finalSize.Width - window.DesiredSize.Width) / 2;  	}  	int y;  	if (window.Y.HasValue) {  		y = window.Y.Value;  	} else {  		y = (finalSize.Height - window.DesiredSize.Height) / 2;  	}  	window.Arrange (new Rect (x' y' window.DesiredSize.Width' window.DesiredSize.Height));  }  
Magic Number,ConsoleFramework.Controls,WindowsHost,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\WindowsHost.cs,ArrangeOverride,The following statement contains a magic number: if (window.X.HasValue) {  	x = window.X.Value;  } else {  	x = (finalSize.Width - window.DesiredSize.Width) / 2;  }  
Magic Number,ConsoleFramework.Controls,WindowsHost,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\WindowsHost.cs,ArrangeOverride,The following statement contains a magic number: x = (finalSize.Width - window.DesiredSize.Width) / 2;  
Magic Number,ConsoleFramework.Controls,WindowsHost,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\WindowsHost.cs,ArrangeOverride,The following statement contains a magic number: if (window.Y.HasValue) {  	y = window.Y.Value;  } else {  	y = (finalSize.Height - window.DesiredSize.Height) / 2;  }  
Magic Number,ConsoleFramework.Controls,WindowsHost,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\WindowsHost.cs,ArrangeOverride,The following statement contains a magic number: y = (finalSize.Height - window.DesiredSize.Height) / 2;  
Magic Number,ConsoleFramework.Controls,WindowsHost,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\WindowsHost.cs,onPreviewMouseMove,The following statement contains a magic number: onPreviewMouseEvents (args' 2);  
Magic Number,ConsoleFramework.Controls,WindowsHost,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\WindowsHost.cs,onPreviewMouseEvents,The following statement contains a magic number: if (isTopWindowModal ()) {  	Window modalWindow = (Window)Children [Children.Count - 1];  	Window windowClicked = VisualTreeHelper.FindClosestParent<Window> ((Control)args.Source);  	if (windowClicked != modalWindow) {  		if (windowInfos [modalWindow].OutsideClickClosesWindow && (eventType == 0 || eventType == 2 && args.LeftButton == MouseButtonState.Pressed)) {  			// закрываем текущее модальное окно  			CloseWindow (modalWindow);  			// далее обрабатываем событие как обычно  			handle = true;  			// Если дальше снова модальное окно' проверку нужно повторить' и закрыть  			// его тоже' и так далее. Можно отрефакторить как вызов подпрограммы  			// вида while (closeTopModalWindowIfNeed()) ;  			goto check;  		} else {  			// прекращаем распространение события (правда' контролы' подписавшиеся с флагом  			// handledEventsToo' получат его в любом случае) и генерацию соответствующего  			// парного не-preview события  			args.Handled = true;  		}  	}  } else {  	handle = true;  }  
Magic Number,ConsoleFramework.Controls,WindowsHost,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\WindowsHost.cs,onPreviewMouseEvents,The following statement contains a magic number: if (windowClicked != modalWindow) {  	if (windowInfos [modalWindow].OutsideClickClosesWindow && (eventType == 0 || eventType == 2 && args.LeftButton == MouseButtonState.Pressed)) {  		// закрываем текущее модальное окно  		CloseWindow (modalWindow);  		// далее обрабатываем событие как обычно  		handle = true;  		// Если дальше снова модальное окно' проверку нужно повторить' и закрыть  		// его тоже' и так далее. Можно отрефакторить как вызов подпрограммы  		// вида while (closeTopModalWindowIfNeed()) ;  		goto check;  	} else {  		// прекращаем распространение события (правда' контролы' подписавшиеся с флагом  		// handledEventsToo' получат его в любом случае) и генерацию соответствующего  		// парного не-preview события  		args.Handled = true;  	}  }  
Magic Number,ConsoleFramework.Controls,WindowsHost,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\WindowsHost.cs,onPreviewMouseEvents,The following statement contains a magic number: if (windowInfos [modalWindow].OutsideClickClosesWindow && (eventType == 0 || eventType == 2 && args.LeftButton == MouseButtonState.Pressed)) {  	// закрываем текущее модальное окно  	CloseWindow (modalWindow);  	// далее обрабатываем событие как обычно  	handle = true;  	// Если дальше снова модальное окно' проверку нужно повторить' и закрыть  	// его тоже' и так далее. Можно отрефакторить как вызов подпрограммы  	// вида while (closeTopModalWindowIfNeed()) ;  	goto check;  } else {  	// прекращаем распространение события (правда' контролы' подписавшиеся с флагом  	// handledEventsToo' получат его в любом случае) и генерацию соответствующего  	// парного не-preview события  	args.Handled = true;  }  
Magic Number,ConsoleFramework.Controls,WindowsHost,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\WindowsHost.cs,onPreviewMouseEvents,The following statement contains a magic number: if (handle && (eventType == 0 || eventType == 2 && args.LeftButton == MouseButtonState.Pressed)) {  	Window windowClicked = VisualTreeHelper.FindClosestParent<Window> ((Control)args.Source);  	if (null != windowClicked) {  		activateWindow (windowClicked);  	} else {  		Menu menu = VisualTreeHelper.FindClosestParent<Menu> ((Control)args.Source);  		if (null != menu) {  			activateMenu ();  		}  	}  }  
Magic Number,ConsoleFramework.Core,ThicknessConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: if (value is String) {  	string[] parts = ((string)value).Split (''');  	if (parts.Length == 1) {  		return new Thickness (int.Parse ((string)value));  	} else if (parts.Length == 2) {  		return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [0])' int.Parse (parts [1]));  	} else if (parts.Length == 4) {  		return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [2])' int.Parse (parts [3]));  	}  }  
Magic Number,ConsoleFramework.Core,ThicknessConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: if (value is String) {  	string[] parts = ((string)value).Split (''');  	if (parts.Length == 1) {  		return new Thickness (int.Parse ((string)value));  	} else if (parts.Length == 2) {  		return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [0])' int.Parse (parts [1]));  	} else if (parts.Length == 4) {  		return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [2])' int.Parse (parts [3]));  	}  }  
Magic Number,ConsoleFramework.Core,ThicknessConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: if (value is String) {  	string[] parts = ((string)value).Split (''');  	if (parts.Length == 1) {  		return new Thickness (int.Parse ((string)value));  	} else if (parts.Length == 2) {  		return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [0])' int.Parse (parts [1]));  	} else if (parts.Length == 4) {  		return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [2])' int.Parse (parts [3]));  	}  }  
Magic Number,ConsoleFramework.Core,ThicknessConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: if (value is String) {  	string[] parts = ((string)value).Split (''');  	if (parts.Length == 1) {  		return new Thickness (int.Parse ((string)value));  	} else if (parts.Length == 2) {  		return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [0])' int.Parse (parts [1]));  	} else if (parts.Length == 4) {  		return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [2])' int.Parse (parts [3]));  	}  }  
Magic Number,ConsoleFramework.Core,ThicknessConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: if (parts.Length == 1) {  	return new Thickness (int.Parse ((string)value));  } else if (parts.Length == 2) {  	return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [0])' int.Parse (parts [1]));  } else if (parts.Length == 4) {  	return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [2])' int.Parse (parts [3]));  }  
Magic Number,ConsoleFramework.Core,ThicknessConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: if (parts.Length == 1) {  	return new Thickness (int.Parse ((string)value));  } else if (parts.Length == 2) {  	return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [0])' int.Parse (parts [1]));  } else if (parts.Length == 4) {  	return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [2])' int.Parse (parts [3]));  }  
Magic Number,ConsoleFramework.Core,ThicknessConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: if (parts.Length == 1) {  	return new Thickness (int.Parse ((string)value));  } else if (parts.Length == 2) {  	return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [0])' int.Parse (parts [1]));  } else if (parts.Length == 4) {  	return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [2])' int.Parse (parts [3]));  }  
Magic Number,ConsoleFramework.Core,ThicknessConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: if (parts.Length == 1) {  	return new Thickness (int.Parse ((string)value));  } else if (parts.Length == 2) {  	return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [0])' int.Parse (parts [1]));  } else if (parts.Length == 4) {  	return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [2])' int.Parse (parts [3]));  }  
Magic Number,ConsoleFramework.Core,ThicknessConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: if (parts.Length == 2) {  	return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [0])' int.Parse (parts [1]));  } else if (parts.Length == 4) {  	return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [2])' int.Parse (parts [3]));  }  
Magic Number,ConsoleFramework.Core,ThicknessConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: if (parts.Length == 2) {  	return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [0])' int.Parse (parts [1]));  } else if (parts.Length == 4) {  	return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [2])' int.Parse (parts [3]));  }  
Magic Number,ConsoleFramework.Core,ThicknessConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: if (parts.Length == 2) {  	return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [0])' int.Parse (parts [1]));  } else if (parts.Length == 4) {  	return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [2])' int.Parse (parts [3]));  }  
Magic Number,ConsoleFramework.Core,ThicknessConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: if (parts.Length == 2) {  	return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [0])' int.Parse (parts [1]));  } else if (parts.Length == 4) {  	return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [2])' int.Parse (parts [3]));  }  
Magic Number,ConsoleFramework.Core,ThicknessConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: if (parts.Length == 4) {  	return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [2])' int.Parse (parts [3]));  }  
Magic Number,ConsoleFramework.Core,ThicknessConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: if (parts.Length == 4) {  	return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [2])' int.Parse (parts [3]));  }  
Magic Number,ConsoleFramework.Core,ThicknessConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: if (parts.Length == 4) {  	return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [2])' int.Parse (parts [3]));  }  
Magic Number,ConsoleFramework.Core,ThicknessConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [2])' int.Parse (parts [3]));  
Magic Number,ConsoleFramework.Core,ThicknessConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\ThicknessConverter.cs,ConvertFrom,The following statement contains a magic number: return new Thickness (int.Parse (parts [0])' int.Parse (parts [1])' int.Parse (parts [2])' int.Parse (parts [3]));  
Magic Number,ConsoleFramework.Core,VisualTreeHelper,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\VisualTreeHelper.cs,FindTopControlUnderMouse,The following statement contains a magic number: if (!controlRect.Contains (localPoint)) {  	return null;  } else {  	if (control.Visibility != Visibility.Visible)  		return null;  	int _opacity = ConsoleApplication.Instance.Renderer.getControlOpacityAt (control' localPoint.X' localPoint.Y);  	if (_opacity >= 4 && _opacity <= 7) {  		return null;  	}  }  
Magic Number,ConsoleFramework.Core,VisualTreeHelper,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\VisualTreeHelper.cs,FindTopControlUnderMouse,The following statement contains a magic number: if (!controlRect.Contains (localPoint)) {  	return null;  } else {  	if (control.Visibility != Visibility.Visible)  		return null;  	int _opacity = ConsoleApplication.Instance.Renderer.getControlOpacityAt (control' localPoint.X' localPoint.Y);  	if (_opacity >= 4 && _opacity <= 7) {  		return null;  	}  }  
Magic Number,ConsoleFramework.Core,VisualTreeHelper,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\VisualTreeHelper.cs,FindTopControlUnderMouse,The following statement contains a magic number: if (_opacity >= 4 && _opacity <= 7) {  	return null;  }  
Magic Number,ConsoleFramework.Core,VisualTreeHelper,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\VisualTreeHelper.cs,FindTopControlUnderMouse,The following statement contains a magic number: if (_opacity >= 4 && _opacity <= 7) {  	return null;  }  
Magic Number,ConsoleFramework.Core,Colors,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\Colors.cs,Blend,The following statement contains a magic number: return (Attr)((ushort)foreground + (((ushort)background) << 4));  
Magic Number,ConsoleFramework.Core,Thickness,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\Thickness.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = left;  	result = (result * 397) ^ top;  	result = (result * 397) ^ right;  	result = (result * 397) ^ bottom;  	return result;  }  
Magic Number,ConsoleFramework.Core,Thickness,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\Thickness.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = left;  	result = (result * 397) ^ top;  	result = (result * 397) ^ right;  	result = (result * 397) ^ bottom;  	return result;  }  
Magic Number,ConsoleFramework.Core,Thickness,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\Thickness.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = left;  	result = (result * 397) ^ top;  	result = (result * 397) ^ right;  	result = (result * 397) ^ bottom;  	return result;  }  
Magic Number,ConsoleFramework.Core,Thickness,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\Thickness.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ top;  
Magic Number,ConsoleFramework.Core,Thickness,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\Thickness.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ right;  
Magic Number,ConsoleFramework.Core,Thickness,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\Thickness.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ bottom;  
Magic Number,ConsoleFramework.Core,Vector,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Core\Vector.cs,AngleBetween,The following statement contains a magic number: return (Math.Atan2 (y' x) * 57.295779513082323);  
Magic Number,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,startAutoRepeatTimer,The following statement contains a magic number: timer = new Timer (state => {  	ConsoleApplication.Instance.RunOnUiThread (() => {  		if (autoRepeatTimerRunning) {  			eventsQueue.Enqueue (new MouseButtonEventArgs (lastMousePressEventArgs.Source' Control.MouseDownEvent' lastMousePosition' lastMousePressEventArgs.LeftButton' lastMousePressEventArgs.MiddleButton' lastMousePressEventArgs.RightButton' MouseButton.Left' 1' true));  		}  	});  	// todo : make this constants configurable  }' null' TimeSpan.FromMilliseconds (300)' TimeSpan.FromMilliseconds (100));  
Magic Number,ConsoleFramework.Events,EventManager,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\EventManager.cs,startAutoRepeatTimer,The following statement contains a magic number: timer = new Timer (state => {  	ConsoleApplication.Instance.RunOnUiThread (() => {  		if (autoRepeatTimerRunning) {  			eventsQueue.Enqueue (new MouseButtonEventArgs (lastMousePressEventArgs.Source' Control.MouseDownEvent' lastMousePosition' lastMousePressEventArgs.LeftButton' lastMousePressEventArgs.MiddleButton' lastMousePressEventArgs.RightButton' MouseButton.Left' 1' true));  		}  	});  	// todo : make this constants configurable  }' null' TimeSpan.FromMilliseconds (300)' TimeSpan.FromMilliseconds (100));  
Magic Number,ConsoleFramework.Events,RoutedEventKey,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\RoutedEvent.cs,GetHashCode,The following statement contains a magic number: unchecked {  	return ((name != null ? name.GetHashCode () : 0) * 397) ^ (ownerType != null ? ownerType.GetHashCode () : 0);  }  
Magic Number,ConsoleFramework.Events,RoutedEventKey,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\RoutedEvent.cs,GetHashCode,The following statement contains a magic number: return ((name != null ? name.GetHashCode () : 0) * 397) ^ (ownerType != null ? ownerType.GetHashCode () : 0);  
Magic Number,ConsoleFramework.Native,LibTermKey,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Native\LibTermKey.cs,termkey_getkey,The following statement contains a magic number: if (IntPtr.Size == 4) {  	TermKeyKey32 temp = new TermKeyKey32 ();  	TermKeyResult result = termkey_getkey32 (termKey' ref temp);  	key.type = temp.type;  	key.code = temp.code;  	key.modifiers = temp.modifiers;  	key.utf8_0 = temp.utf8_0;  	key.utf8_1 = temp.utf8_1;  	key.utf8_2 = temp.utf8_2;  	key.utf8_3 = temp.utf8_3;  	key.utf8_4 = temp.utf8_4;  	key.utf8_5 = temp.utf8_5;  	key.utf8_6 = temp.utf8_6;  	return result;  } else {  	TermKeyKey64 temp = new TermKeyKey64 ();  	TermKeyResult result = termkey_getkey64 (termKey' ref temp);  	key.type = temp.type;  	key.code = temp.code;  	key.modifiers = temp.modifiers;  	key.utf8_0 = temp.utf8_0;  	key.utf8_1 = temp.utf8_1;  	key.utf8_2 = temp.utf8_2;  	key.utf8_3 = temp.utf8_3;  	key.utf8_4 = temp.utf8_4;  	key.utf8_5 = temp.utf8_5;  	key.utf8_6 = temp.utf8_6;  	return result;  }  
Magic Number,ConsoleFramework.Native,LibTermKey,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Native\LibTermKey.cs,termkey_getkey_force,The following statement contains a magic number: if (IntPtr.Size == 4) {  	TermKeyKey32 temp = new TermKeyKey32 ();  	TermKeyResult result = termkey_getkey_force32 (termKey' ref temp);  	key.type = temp.type;  	key.code = temp.code;  	key.modifiers = temp.modifiers;  	key.utf8_0 = temp.utf8_0;  	key.utf8_1 = temp.utf8_1;  	key.utf8_2 = temp.utf8_2;  	key.utf8_3 = temp.utf8_3;  	key.utf8_4 = temp.utf8_4;  	key.utf8_5 = temp.utf8_5;  	key.utf8_6 = temp.utf8_6;  	return result;  } else {  	TermKeyKey64 temp = new TermKeyKey64 ();  	TermKeyResult result = termkey_getkey_force64 (termKey' ref temp);  	key.type = temp.type;  	key.code = temp.code;  	key.modifiers = temp.modifiers;  	key.utf8_0 = temp.utf8_0;  	key.utf8_1 = temp.utf8_1;  	key.utf8_2 = temp.utf8_2;  	key.utf8_3 = temp.utf8_3;  	key.utf8_4 = temp.utf8_4;  	key.utf8_5 = temp.utf8_5;  	key.utf8_6 = temp.utf8_6;  	return result;  }  
Magic Number,ConsoleFramework.Native,LibTermKey,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Native\LibTermKey.cs,termkey_interpret_mouse,The following statement contains a magic number: if (IntPtr.Size == 4) {  	TermKeyKey32 temp = new TermKeyKey32 ();  	temp.type = key.type;  	temp.code = key.code;  	temp.modifiers = key.modifiers;  	temp.utf8_0 = key.utf8_0;  	temp.utf8_1 = key.utf8_1;  	temp.utf8_2 = key.utf8_2;  	temp.utf8_3 = key.utf8_3;  	temp.utf8_4 = key.utf8_4;  	temp.utf8_5 = key.utf8_5;  	temp.utf8_6 = key.utf8_6;  	TermKeyResult result = termkey_interpret_mouse32 (termKey' ref temp' out ev' out button' out line' out col);  	key.type = temp.type;  	key.code = temp.code;  	key.modifiers = temp.modifiers;  	key.utf8_0 = temp.utf8_0;  	key.utf8_1 = temp.utf8_1;  	key.utf8_2 = temp.utf8_2;  	key.utf8_3 = temp.utf8_3;  	key.utf8_4 = temp.utf8_4;  	key.utf8_5 = temp.utf8_5;  	key.utf8_6 = temp.utf8_6;  	return result;  } else {  	TermKeyKey64 temp = new TermKeyKey64 ();  	temp.type = key.type;  	temp.code = key.code;  	temp.modifiers = key.modifiers;  	temp.utf8_0 = key.utf8_0;  	temp.utf8_1 = key.utf8_1;  	temp.utf8_2 = key.utf8_2;  	temp.utf8_3 = key.utf8_3;  	temp.utf8_4 = key.utf8_4;  	temp.utf8_5 = key.utf8_5;  	temp.utf8_6 = key.utf8_6;  	TermKeyResult result = termkey_interpret_mouse64 (termKey' ref temp' out ev' out button' out line' out col);  	key.type = temp.type;  	key.code = temp.code;  	key.modifiers = temp.modifiers;  	key.utf8_0 = temp.utf8_0;  	key.utf8_1 = temp.utf8_1;  	key.utf8_2 = temp.utf8_2;  	key.utf8_3 = temp.utf8_3;  	key.utf8_4 = temp.utf8_4;  	key.utf8_5 = temp.utf8_5;  	key.utf8_6 = temp.utf8_6;  	return result;  }  
Magic Number,ConsoleFramework.Native,NCurses,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Native\NCurses.cs,NCURSES_MOUSE_MASK,The following statement contains a magic number: return ((m) << (((b) - 1) * 6));  
Magic Number,ConsoleFramework.Native,NCurses,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Native\NCurses.cs,BUTTON_PRESS,The following statement contains a magic number: return ((e) & NCURSES_MOUSE_MASK (x' 002)) != 0;  
Magic Number,ConsoleFramework.Native,NCurses,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Native\NCurses.cs,BUTTON_CLICK,The following statement contains a magic number: return ((e) & NCURSES_MOUSE_MASK (x' 004)) != 0;  
Magic Number,ConsoleFramework.Native,NCurses,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Native\NCurses.cs,BUTTON_DOUBLE_CLICK,The following statement contains a magic number: return ((e) & NCURSES_MOUSE_MASK (x' 010)) != 0;  
Magic Number,ConsoleFramework.Native,NCurses,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Native\NCurses.cs,BUTTON_TRIPLE_CLICK,The following statement contains a magic number: return ((e) & NCURSES_MOUSE_MASK (x' 020)) != 0;  
Magic Number,ConsoleFramework.Native,NCurses,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Native\NCurses.cs,BUTTON_RESERVED_EVENT,The following statement contains a magic number: return ((e) & NCURSES_MOUSE_MASK (x' 040)) != 0;  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: for (int x = finalRect.Left; x < finalRect.Right; x++) {  	int parentX = x;  	int childX = parentX - actualOffset.x;  	for (int y = finalRect.Top; y < finalRect.Bottom; y++) {  		int parentY = y;  		int childY = parentY - actualOffset.y;  		CHAR_INFO charInfo = childBuffer.buffer [childX' childY];  		int opacity = childBuffer.opacityMatrix [childX' childY];  		// Для полностью прозрачных пикселей родительского буфера - присваиваем и значение  		// пикселя' и значение opacity' дальше дело за следующим родителем  		if (this.opacityMatrix [parentX' parentY] == 2 || this.opacityMatrix [parentX' parentY] == 6) {  			this.buffer [parentX' parentY] = charInfo;  			this.opacityMatrix [parentX' parentY] = opacity;  		} else {  			// В остальных случаях opacity родительского буфера остаётся' а  			// сам пиксель зависит от opacity дочернего элемента  			if (opacity == 0 || opacity == 4) {  				this.buffer [parentX' parentY] = charInfo;  			} else if (opacity == 1 || opacity == 5) {  				charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  				charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  				buffer [parentX' parentY] = charInfo;  			} else if (opacity == 3 || opacity == 7) {  				// берем фоновые атрибуты символа из родительского буфера  				Attr parentAttr = buffer [parentX' parentY].Attributes;  				if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  					charInfo.Attributes |= Attr.BACKGROUND_BLUE;  				} else {  					charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  				}  				if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  					charInfo.Attributes |= Attr.BACKGROUND_GREEN;  				} else {  					charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  				}  				if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  					charInfo.Attributes |= Attr.BACKGROUND_RED;  				} else {  					charInfo.Attributes &= ~Attr.BACKGROUND_RED;  				}  				if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  					charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  				} else {  					charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  				}  				buffer [parentX' parentY] = charInfo;  			}  		}  	}  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: for (int x = finalRect.Left; x < finalRect.Right; x++) {  	int parentX = x;  	int childX = parentX - actualOffset.x;  	for (int y = finalRect.Top; y < finalRect.Bottom; y++) {  		int parentY = y;  		int childY = parentY - actualOffset.y;  		CHAR_INFO charInfo = childBuffer.buffer [childX' childY];  		int opacity = childBuffer.opacityMatrix [childX' childY];  		// Для полностью прозрачных пикселей родительского буфера - присваиваем и значение  		// пикселя' и значение opacity' дальше дело за следующим родителем  		if (this.opacityMatrix [parentX' parentY] == 2 || this.opacityMatrix [parentX' parentY] == 6) {  			this.buffer [parentX' parentY] = charInfo;  			this.opacityMatrix [parentX' parentY] = opacity;  		} else {  			// В остальных случаях opacity родительского буфера остаётся' а  			// сам пиксель зависит от opacity дочернего элемента  			if (opacity == 0 || opacity == 4) {  				this.buffer [parentX' parentY] = charInfo;  			} else if (opacity == 1 || opacity == 5) {  				charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  				charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  				buffer [parentX' parentY] = charInfo;  			} else if (opacity == 3 || opacity == 7) {  				// берем фоновые атрибуты символа из родительского буфера  				Attr parentAttr = buffer [parentX' parentY].Attributes;  				if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  					charInfo.Attributes |= Attr.BACKGROUND_BLUE;  				} else {  					charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  				}  				if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  					charInfo.Attributes |= Attr.BACKGROUND_GREEN;  				} else {  					charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  				}  				if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  					charInfo.Attributes |= Attr.BACKGROUND_RED;  				} else {  					charInfo.Attributes &= ~Attr.BACKGROUND_RED;  				}  				if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  					charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  				} else {  					charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  				}  				buffer [parentX' parentY] = charInfo;  			}  		}  	}  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: for (int x = finalRect.Left; x < finalRect.Right; x++) {  	int parentX = x;  	int childX = parentX - actualOffset.x;  	for (int y = finalRect.Top; y < finalRect.Bottom; y++) {  		int parentY = y;  		int childY = parentY - actualOffset.y;  		CHAR_INFO charInfo = childBuffer.buffer [childX' childY];  		int opacity = childBuffer.opacityMatrix [childX' childY];  		// Для полностью прозрачных пикселей родительского буфера - присваиваем и значение  		// пикселя' и значение opacity' дальше дело за следующим родителем  		if (this.opacityMatrix [parentX' parentY] == 2 || this.opacityMatrix [parentX' parentY] == 6) {  			this.buffer [parentX' parentY] = charInfo;  			this.opacityMatrix [parentX' parentY] = opacity;  		} else {  			// В остальных случаях opacity родительского буфера остаётся' а  			// сам пиксель зависит от opacity дочернего элемента  			if (opacity == 0 || opacity == 4) {  				this.buffer [parentX' parentY] = charInfo;  			} else if (opacity == 1 || opacity == 5) {  				charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  				charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  				buffer [parentX' parentY] = charInfo;  			} else if (opacity == 3 || opacity == 7) {  				// берем фоновые атрибуты символа из родительского буфера  				Attr parentAttr = buffer [parentX' parentY].Attributes;  				if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  					charInfo.Attributes |= Attr.BACKGROUND_BLUE;  				} else {  					charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  				}  				if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  					charInfo.Attributes |= Attr.BACKGROUND_GREEN;  				} else {  					charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  				}  				if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  					charInfo.Attributes |= Attr.BACKGROUND_RED;  				} else {  					charInfo.Attributes &= ~Attr.BACKGROUND_RED;  				}  				if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  					charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  				} else {  					charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  				}  				buffer [parentX' parentY] = charInfo;  			}  		}  	}  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: for (int x = finalRect.Left; x < finalRect.Right; x++) {  	int parentX = x;  	int childX = parentX - actualOffset.x;  	for (int y = finalRect.Top; y < finalRect.Bottom; y++) {  		int parentY = y;  		int childY = parentY - actualOffset.y;  		CHAR_INFO charInfo = childBuffer.buffer [childX' childY];  		int opacity = childBuffer.opacityMatrix [childX' childY];  		// Для полностью прозрачных пикселей родительского буфера - присваиваем и значение  		// пикселя' и значение opacity' дальше дело за следующим родителем  		if (this.opacityMatrix [parentX' parentY] == 2 || this.opacityMatrix [parentX' parentY] == 6) {  			this.buffer [parentX' parentY] = charInfo;  			this.opacityMatrix [parentX' parentY] = opacity;  		} else {  			// В остальных случаях opacity родительского буфера остаётся' а  			// сам пиксель зависит от opacity дочернего элемента  			if (opacity == 0 || opacity == 4) {  				this.buffer [parentX' parentY] = charInfo;  			} else if (opacity == 1 || opacity == 5) {  				charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  				charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  				buffer [parentX' parentY] = charInfo;  			} else if (opacity == 3 || opacity == 7) {  				// берем фоновые атрибуты символа из родительского буфера  				Attr parentAttr = buffer [parentX' parentY].Attributes;  				if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  					charInfo.Attributes |= Attr.BACKGROUND_BLUE;  				} else {  					charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  				}  				if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  					charInfo.Attributes |= Attr.BACKGROUND_GREEN;  				} else {  					charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  				}  				if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  					charInfo.Attributes |= Attr.BACKGROUND_RED;  				} else {  					charInfo.Attributes &= ~Attr.BACKGROUND_RED;  				}  				if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  					charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  				} else {  					charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  				}  				buffer [parentX' parentY] = charInfo;  			}  		}  	}  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: for (int x = finalRect.Left; x < finalRect.Right; x++) {  	int parentX = x;  	int childX = parentX - actualOffset.x;  	for (int y = finalRect.Top; y < finalRect.Bottom; y++) {  		int parentY = y;  		int childY = parentY - actualOffset.y;  		CHAR_INFO charInfo = childBuffer.buffer [childX' childY];  		int opacity = childBuffer.opacityMatrix [childX' childY];  		// Для полностью прозрачных пикселей родительского буфера - присваиваем и значение  		// пикселя' и значение opacity' дальше дело за следующим родителем  		if (this.opacityMatrix [parentX' parentY] == 2 || this.opacityMatrix [parentX' parentY] == 6) {  			this.buffer [parentX' parentY] = charInfo;  			this.opacityMatrix [parentX' parentY] = opacity;  		} else {  			// В остальных случаях opacity родительского буфера остаётся' а  			// сам пиксель зависит от opacity дочернего элемента  			if (opacity == 0 || opacity == 4) {  				this.buffer [parentX' parentY] = charInfo;  			} else if (opacity == 1 || opacity == 5) {  				charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  				charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  				buffer [parentX' parentY] = charInfo;  			} else if (opacity == 3 || opacity == 7) {  				// берем фоновые атрибуты символа из родительского буфера  				Attr parentAttr = buffer [parentX' parentY].Attributes;  				if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  					charInfo.Attributes |= Attr.BACKGROUND_BLUE;  				} else {  					charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  				}  				if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  					charInfo.Attributes |= Attr.BACKGROUND_GREEN;  				} else {  					charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  				}  				if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  					charInfo.Attributes |= Attr.BACKGROUND_RED;  				} else {  					charInfo.Attributes &= ~Attr.BACKGROUND_RED;  				}  				if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  					charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  				} else {  					charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  				}  				buffer [parentX' parentY] = charInfo;  			}  		}  	}  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: for (int x = finalRect.Left; x < finalRect.Right; x++) {  	int parentX = x;  	int childX = parentX - actualOffset.x;  	for (int y = finalRect.Top; y < finalRect.Bottom; y++) {  		int parentY = y;  		int childY = parentY - actualOffset.y;  		CHAR_INFO charInfo = childBuffer.buffer [childX' childY];  		int opacity = childBuffer.opacityMatrix [childX' childY];  		// Для полностью прозрачных пикселей родительского буфера - присваиваем и значение  		// пикселя' и значение opacity' дальше дело за следующим родителем  		if (this.opacityMatrix [parentX' parentY] == 2 || this.opacityMatrix [parentX' parentY] == 6) {  			this.buffer [parentX' parentY] = charInfo;  			this.opacityMatrix [parentX' parentY] = opacity;  		} else {  			// В остальных случаях opacity родительского буфера остаётся' а  			// сам пиксель зависит от opacity дочернего элемента  			if (opacity == 0 || opacity == 4) {  				this.buffer [parentX' parentY] = charInfo;  			} else if (opacity == 1 || opacity == 5) {  				charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  				charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  				buffer [parentX' parentY] = charInfo;  			} else if (opacity == 3 || opacity == 7) {  				// берем фоновые атрибуты символа из родительского буфера  				Attr parentAttr = buffer [parentX' parentY].Attributes;  				if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  					charInfo.Attributes |= Attr.BACKGROUND_BLUE;  				} else {  					charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  				}  				if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  					charInfo.Attributes |= Attr.BACKGROUND_GREEN;  				} else {  					charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  				}  				if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  					charInfo.Attributes |= Attr.BACKGROUND_RED;  				} else {  					charInfo.Attributes &= ~Attr.BACKGROUND_RED;  				}  				if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  					charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  				} else {  					charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  				}  				buffer [parentX' parentY] = charInfo;  			}  		}  	}  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: for (int y = finalRect.Top; y < finalRect.Bottom; y++) {  	int parentY = y;  	int childY = parentY - actualOffset.y;  	CHAR_INFO charInfo = childBuffer.buffer [childX' childY];  	int opacity = childBuffer.opacityMatrix [childX' childY];  	// Для полностью прозрачных пикселей родительского буфера - присваиваем и значение  	// пикселя' и значение opacity' дальше дело за следующим родителем  	if (this.opacityMatrix [parentX' parentY] == 2 || this.opacityMatrix [parentX' parentY] == 6) {  		this.buffer [parentX' parentY] = charInfo;  		this.opacityMatrix [parentX' parentY] = opacity;  	} else {  		// В остальных случаях opacity родительского буфера остаётся' а  		// сам пиксель зависит от opacity дочернего элемента  		if (opacity == 0 || opacity == 4) {  			this.buffer [parentX' parentY] = charInfo;  		} else if (opacity == 1 || opacity == 5) {  			charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  			charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  			buffer [parentX' parentY] = charInfo;  		} else if (opacity == 3 || opacity == 7) {  			// берем фоновые атрибуты символа из родительского буфера  			Attr parentAttr = buffer [parentX' parentY].Attributes;  			if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  				charInfo.Attributes |= Attr.BACKGROUND_BLUE;  			} else {  				charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  			}  			if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  				charInfo.Attributes |= Attr.BACKGROUND_GREEN;  			} else {  				charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  			}  			if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  				charInfo.Attributes |= Attr.BACKGROUND_RED;  			} else {  				charInfo.Attributes &= ~Attr.BACKGROUND_RED;  			}  			if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  				charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  			} else {  				charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  			}  			buffer [parentX' parentY] = charInfo;  		}  	}  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: for (int y = finalRect.Top; y < finalRect.Bottom; y++) {  	int parentY = y;  	int childY = parentY - actualOffset.y;  	CHAR_INFO charInfo = childBuffer.buffer [childX' childY];  	int opacity = childBuffer.opacityMatrix [childX' childY];  	// Для полностью прозрачных пикселей родительского буфера - присваиваем и значение  	// пикселя' и значение opacity' дальше дело за следующим родителем  	if (this.opacityMatrix [parentX' parentY] == 2 || this.opacityMatrix [parentX' parentY] == 6) {  		this.buffer [parentX' parentY] = charInfo;  		this.opacityMatrix [parentX' parentY] = opacity;  	} else {  		// В остальных случаях opacity родительского буфера остаётся' а  		// сам пиксель зависит от opacity дочернего элемента  		if (opacity == 0 || opacity == 4) {  			this.buffer [parentX' parentY] = charInfo;  		} else if (opacity == 1 || opacity == 5) {  			charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  			charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  			buffer [parentX' parentY] = charInfo;  		} else if (opacity == 3 || opacity == 7) {  			// берем фоновые атрибуты символа из родительского буфера  			Attr parentAttr = buffer [parentX' parentY].Attributes;  			if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  				charInfo.Attributes |= Attr.BACKGROUND_BLUE;  			} else {  				charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  			}  			if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  				charInfo.Attributes |= Attr.BACKGROUND_GREEN;  			} else {  				charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  			}  			if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  				charInfo.Attributes |= Attr.BACKGROUND_RED;  			} else {  				charInfo.Attributes &= ~Attr.BACKGROUND_RED;  			}  			if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  				charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  			} else {  				charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  			}  			buffer [parentX' parentY] = charInfo;  		}  	}  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: for (int y = finalRect.Top; y < finalRect.Bottom; y++) {  	int parentY = y;  	int childY = parentY - actualOffset.y;  	CHAR_INFO charInfo = childBuffer.buffer [childX' childY];  	int opacity = childBuffer.opacityMatrix [childX' childY];  	// Для полностью прозрачных пикселей родительского буфера - присваиваем и значение  	// пикселя' и значение opacity' дальше дело за следующим родителем  	if (this.opacityMatrix [parentX' parentY] == 2 || this.opacityMatrix [parentX' parentY] == 6) {  		this.buffer [parentX' parentY] = charInfo;  		this.opacityMatrix [parentX' parentY] = opacity;  	} else {  		// В остальных случаях opacity родительского буфера остаётся' а  		// сам пиксель зависит от opacity дочернего элемента  		if (opacity == 0 || opacity == 4) {  			this.buffer [parentX' parentY] = charInfo;  		} else if (opacity == 1 || opacity == 5) {  			charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  			charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  			buffer [parentX' parentY] = charInfo;  		} else if (opacity == 3 || opacity == 7) {  			// берем фоновые атрибуты символа из родительского буфера  			Attr parentAttr = buffer [parentX' parentY].Attributes;  			if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  				charInfo.Attributes |= Attr.BACKGROUND_BLUE;  			} else {  				charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  			}  			if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  				charInfo.Attributes |= Attr.BACKGROUND_GREEN;  			} else {  				charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  			}  			if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  				charInfo.Attributes |= Attr.BACKGROUND_RED;  			} else {  				charInfo.Attributes &= ~Attr.BACKGROUND_RED;  			}  			if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  				charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  			} else {  				charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  			}  			buffer [parentX' parentY] = charInfo;  		}  	}  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: for (int y = finalRect.Top; y < finalRect.Bottom; y++) {  	int parentY = y;  	int childY = parentY - actualOffset.y;  	CHAR_INFO charInfo = childBuffer.buffer [childX' childY];  	int opacity = childBuffer.opacityMatrix [childX' childY];  	// Для полностью прозрачных пикселей родительского буфера - присваиваем и значение  	// пикселя' и значение opacity' дальше дело за следующим родителем  	if (this.opacityMatrix [parentX' parentY] == 2 || this.opacityMatrix [parentX' parentY] == 6) {  		this.buffer [parentX' parentY] = charInfo;  		this.opacityMatrix [parentX' parentY] = opacity;  	} else {  		// В остальных случаях opacity родительского буфера остаётся' а  		// сам пиксель зависит от opacity дочернего элемента  		if (opacity == 0 || opacity == 4) {  			this.buffer [parentX' parentY] = charInfo;  		} else if (opacity == 1 || opacity == 5) {  			charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  			charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  			buffer [parentX' parentY] = charInfo;  		} else if (opacity == 3 || opacity == 7) {  			// берем фоновые атрибуты символа из родительского буфера  			Attr parentAttr = buffer [parentX' parentY].Attributes;  			if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  				charInfo.Attributes |= Attr.BACKGROUND_BLUE;  			} else {  				charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  			}  			if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  				charInfo.Attributes |= Attr.BACKGROUND_GREEN;  			} else {  				charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  			}  			if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  				charInfo.Attributes |= Attr.BACKGROUND_RED;  			} else {  				charInfo.Attributes &= ~Attr.BACKGROUND_RED;  			}  			if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  				charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  			} else {  				charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  			}  			buffer [parentX' parentY] = charInfo;  		}  	}  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: for (int y = finalRect.Top; y < finalRect.Bottom; y++) {  	int parentY = y;  	int childY = parentY - actualOffset.y;  	CHAR_INFO charInfo = childBuffer.buffer [childX' childY];  	int opacity = childBuffer.opacityMatrix [childX' childY];  	// Для полностью прозрачных пикселей родительского буфера - присваиваем и значение  	// пикселя' и значение opacity' дальше дело за следующим родителем  	if (this.opacityMatrix [parentX' parentY] == 2 || this.opacityMatrix [parentX' parentY] == 6) {  		this.buffer [parentX' parentY] = charInfo;  		this.opacityMatrix [parentX' parentY] = opacity;  	} else {  		// В остальных случаях opacity родительского буфера остаётся' а  		// сам пиксель зависит от opacity дочернего элемента  		if (opacity == 0 || opacity == 4) {  			this.buffer [parentX' parentY] = charInfo;  		} else if (opacity == 1 || opacity == 5) {  			charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  			charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  			buffer [parentX' parentY] = charInfo;  		} else if (opacity == 3 || opacity == 7) {  			// берем фоновые атрибуты символа из родительского буфера  			Attr parentAttr = buffer [parentX' parentY].Attributes;  			if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  				charInfo.Attributes |= Attr.BACKGROUND_BLUE;  			} else {  				charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  			}  			if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  				charInfo.Attributes |= Attr.BACKGROUND_GREEN;  			} else {  				charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  			}  			if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  				charInfo.Attributes |= Attr.BACKGROUND_RED;  			} else {  				charInfo.Attributes &= ~Attr.BACKGROUND_RED;  			}  			if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  				charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  			} else {  				charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  			}  			buffer [parentX' parentY] = charInfo;  		}  	}  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: for (int y = finalRect.Top; y < finalRect.Bottom; y++) {  	int parentY = y;  	int childY = parentY - actualOffset.y;  	CHAR_INFO charInfo = childBuffer.buffer [childX' childY];  	int opacity = childBuffer.opacityMatrix [childX' childY];  	// Для полностью прозрачных пикселей родительского буфера - присваиваем и значение  	// пикселя' и значение opacity' дальше дело за следующим родителем  	if (this.opacityMatrix [parentX' parentY] == 2 || this.opacityMatrix [parentX' parentY] == 6) {  		this.buffer [parentX' parentY] = charInfo;  		this.opacityMatrix [parentX' parentY] = opacity;  	} else {  		// В остальных случаях opacity родительского буфера остаётся' а  		// сам пиксель зависит от opacity дочернего элемента  		if (opacity == 0 || opacity == 4) {  			this.buffer [parentX' parentY] = charInfo;  		} else if (opacity == 1 || opacity == 5) {  			charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  			charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  			buffer [parentX' parentY] = charInfo;  		} else if (opacity == 3 || opacity == 7) {  			// берем фоновые атрибуты символа из родительского буфера  			Attr parentAttr = buffer [parentX' parentY].Attributes;  			if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  				charInfo.Attributes |= Attr.BACKGROUND_BLUE;  			} else {  				charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  			}  			if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  				charInfo.Attributes |= Attr.BACKGROUND_GREEN;  			} else {  				charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  			}  			if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  				charInfo.Attributes |= Attr.BACKGROUND_RED;  			} else {  				charInfo.Attributes &= ~Attr.BACKGROUND_RED;  			}  			if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  				charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  			} else {  				charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  			}  			buffer [parentX' parentY] = charInfo;  		}  	}  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: if (this.opacityMatrix [parentX' parentY] == 2 || this.opacityMatrix [parentX' parentY] == 6) {  	this.buffer [parentX' parentY] = charInfo;  	this.opacityMatrix [parentX' parentY] = opacity;  } else {  	// В остальных случаях opacity родительского буфера остаётся' а  	// сам пиксель зависит от opacity дочернего элемента  	if (opacity == 0 || opacity == 4) {  		this.buffer [parentX' parentY] = charInfo;  	} else if (opacity == 1 || opacity == 5) {  		charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  		charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  		buffer [parentX' parentY] = charInfo;  	} else if (opacity == 3 || opacity == 7) {  		// берем фоновые атрибуты символа из родительского буфера  		Attr parentAttr = buffer [parentX' parentY].Attributes;  		if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  			charInfo.Attributes |= Attr.BACKGROUND_BLUE;  		} else {  			charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  		}  		if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  			charInfo.Attributes |= Attr.BACKGROUND_GREEN;  		} else {  			charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  		}  		if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  			charInfo.Attributes |= Attr.BACKGROUND_RED;  		} else {  			charInfo.Attributes &= ~Attr.BACKGROUND_RED;  		}  		if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  			charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  		} else {  			charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  		}  		buffer [parentX' parentY] = charInfo;  	}  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: if (this.opacityMatrix [parentX' parentY] == 2 || this.opacityMatrix [parentX' parentY] == 6) {  	this.buffer [parentX' parentY] = charInfo;  	this.opacityMatrix [parentX' parentY] = opacity;  } else {  	// В остальных случаях opacity родительского буфера остаётся' а  	// сам пиксель зависит от opacity дочернего элемента  	if (opacity == 0 || opacity == 4) {  		this.buffer [parentX' parentY] = charInfo;  	} else if (opacity == 1 || opacity == 5) {  		charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  		charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  		buffer [parentX' parentY] = charInfo;  	} else if (opacity == 3 || opacity == 7) {  		// берем фоновые атрибуты символа из родительского буфера  		Attr parentAttr = buffer [parentX' parentY].Attributes;  		if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  			charInfo.Attributes |= Attr.BACKGROUND_BLUE;  		} else {  			charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  		}  		if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  			charInfo.Attributes |= Attr.BACKGROUND_GREEN;  		} else {  			charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  		}  		if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  			charInfo.Attributes |= Attr.BACKGROUND_RED;  		} else {  			charInfo.Attributes &= ~Attr.BACKGROUND_RED;  		}  		if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  			charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  		} else {  			charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  		}  		buffer [parentX' parentY] = charInfo;  	}  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: if (this.opacityMatrix [parentX' parentY] == 2 || this.opacityMatrix [parentX' parentY] == 6) {  	this.buffer [parentX' parentY] = charInfo;  	this.opacityMatrix [parentX' parentY] = opacity;  } else {  	// В остальных случаях opacity родительского буфера остаётся' а  	// сам пиксель зависит от opacity дочернего элемента  	if (opacity == 0 || opacity == 4) {  		this.buffer [parentX' parentY] = charInfo;  	} else if (opacity == 1 || opacity == 5) {  		charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  		charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  		buffer [parentX' parentY] = charInfo;  	} else if (opacity == 3 || opacity == 7) {  		// берем фоновые атрибуты символа из родительского буфера  		Attr parentAttr = buffer [parentX' parentY].Attributes;  		if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  			charInfo.Attributes |= Attr.BACKGROUND_BLUE;  		} else {  			charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  		}  		if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  			charInfo.Attributes |= Attr.BACKGROUND_GREEN;  		} else {  			charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  		}  		if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  			charInfo.Attributes |= Attr.BACKGROUND_RED;  		} else {  			charInfo.Attributes &= ~Attr.BACKGROUND_RED;  		}  		if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  			charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  		} else {  			charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  		}  		buffer [parentX' parentY] = charInfo;  	}  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: if (this.opacityMatrix [parentX' parentY] == 2 || this.opacityMatrix [parentX' parentY] == 6) {  	this.buffer [parentX' parentY] = charInfo;  	this.opacityMatrix [parentX' parentY] = opacity;  } else {  	// В остальных случаях opacity родительского буфера остаётся' а  	// сам пиксель зависит от opacity дочернего элемента  	if (opacity == 0 || opacity == 4) {  		this.buffer [parentX' parentY] = charInfo;  	} else if (opacity == 1 || opacity == 5) {  		charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  		charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  		buffer [parentX' parentY] = charInfo;  	} else if (opacity == 3 || opacity == 7) {  		// берем фоновые атрибуты символа из родительского буфера  		Attr parentAttr = buffer [parentX' parentY].Attributes;  		if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  			charInfo.Attributes |= Attr.BACKGROUND_BLUE;  		} else {  			charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  		}  		if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  			charInfo.Attributes |= Attr.BACKGROUND_GREEN;  		} else {  			charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  		}  		if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  			charInfo.Attributes |= Attr.BACKGROUND_RED;  		} else {  			charInfo.Attributes &= ~Attr.BACKGROUND_RED;  		}  		if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  			charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  		} else {  			charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  		}  		buffer [parentX' parentY] = charInfo;  	}  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: if (this.opacityMatrix [parentX' parentY] == 2 || this.opacityMatrix [parentX' parentY] == 6) {  	this.buffer [parentX' parentY] = charInfo;  	this.opacityMatrix [parentX' parentY] = opacity;  } else {  	// В остальных случаях opacity родительского буфера остаётся' а  	// сам пиксель зависит от opacity дочернего элемента  	if (opacity == 0 || opacity == 4) {  		this.buffer [parentX' parentY] = charInfo;  	} else if (opacity == 1 || opacity == 5) {  		charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  		charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  		buffer [parentX' parentY] = charInfo;  	} else if (opacity == 3 || opacity == 7) {  		// берем фоновые атрибуты символа из родительского буфера  		Attr parentAttr = buffer [parentX' parentY].Attributes;  		if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  			charInfo.Attributes |= Attr.BACKGROUND_BLUE;  		} else {  			charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  		}  		if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  			charInfo.Attributes |= Attr.BACKGROUND_GREEN;  		} else {  			charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  		}  		if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  			charInfo.Attributes |= Attr.BACKGROUND_RED;  		} else {  			charInfo.Attributes &= ~Attr.BACKGROUND_RED;  		}  		if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  			charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  		} else {  			charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  		}  		buffer [parentX' parentY] = charInfo;  	}  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: if (this.opacityMatrix [parentX' parentY] == 2 || this.opacityMatrix [parentX' parentY] == 6) {  	this.buffer [parentX' parentY] = charInfo;  	this.opacityMatrix [parentX' parentY] = opacity;  } else {  	// В остальных случаях opacity родительского буфера остаётся' а  	// сам пиксель зависит от opacity дочернего элемента  	if (opacity == 0 || opacity == 4) {  		this.buffer [parentX' parentY] = charInfo;  	} else if (opacity == 1 || opacity == 5) {  		charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  		charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  		buffer [parentX' parentY] = charInfo;  	} else if (opacity == 3 || opacity == 7) {  		// берем фоновые атрибуты символа из родительского буфера  		Attr parentAttr = buffer [parentX' parentY].Attributes;  		if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  			charInfo.Attributes |= Attr.BACKGROUND_BLUE;  		} else {  			charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  		}  		if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  			charInfo.Attributes |= Attr.BACKGROUND_GREEN;  		} else {  			charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  		}  		if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  			charInfo.Attributes |= Attr.BACKGROUND_RED;  		} else {  			charInfo.Attributes &= ~Attr.BACKGROUND_RED;  		}  		if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  			charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  		} else {  			charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  		}  		buffer [parentX' parentY] = charInfo;  	}  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: if (opacity == 0 || opacity == 4) {  	this.buffer [parentX' parentY] = charInfo;  } else if (opacity == 1 || opacity == 5) {  	charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  	charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  	buffer [parentX' parentY] = charInfo;  } else if (opacity == 3 || opacity == 7) {  	// берем фоновые атрибуты символа из родительского буфера  	Attr parentAttr = buffer [parentX' parentY].Attributes;  	if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  		charInfo.Attributes |= Attr.BACKGROUND_BLUE;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  	}  	if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  		charInfo.Attributes |= Attr.BACKGROUND_GREEN;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  	}  	if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  		charInfo.Attributes |= Attr.BACKGROUND_RED;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_RED;  	}  	if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  		charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  	}  	buffer [parentX' parentY] = charInfo;  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: if (opacity == 0 || opacity == 4) {  	this.buffer [parentX' parentY] = charInfo;  } else if (opacity == 1 || opacity == 5) {  	charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  	charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  	buffer [parentX' parentY] = charInfo;  } else if (opacity == 3 || opacity == 7) {  	// берем фоновые атрибуты символа из родительского буфера  	Attr parentAttr = buffer [parentX' parentY].Attributes;  	if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  		charInfo.Attributes |= Attr.BACKGROUND_BLUE;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  	}  	if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  		charInfo.Attributes |= Attr.BACKGROUND_GREEN;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  	}  	if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  		charInfo.Attributes |= Attr.BACKGROUND_RED;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_RED;  	}  	if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  		charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  	}  	buffer [parentX' parentY] = charInfo;  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: if (opacity == 0 || opacity == 4) {  	this.buffer [parentX' parentY] = charInfo;  } else if (opacity == 1 || opacity == 5) {  	charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  	charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  	buffer [parentX' parentY] = charInfo;  } else if (opacity == 3 || opacity == 7) {  	// берем фоновые атрибуты символа из родительского буфера  	Attr parentAttr = buffer [parentX' parentY].Attributes;  	if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  		charInfo.Attributes |= Attr.BACKGROUND_BLUE;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  	}  	if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  		charInfo.Attributes |= Attr.BACKGROUND_GREEN;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  	}  	if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  		charInfo.Attributes |= Attr.BACKGROUND_RED;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_RED;  	}  	if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  		charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  	}  	buffer [parentX' parentY] = charInfo;  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: if (opacity == 0 || opacity == 4) {  	this.buffer [parentX' parentY] = charInfo;  } else if (opacity == 1 || opacity == 5) {  	charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  	charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  	buffer [parentX' parentY] = charInfo;  } else if (opacity == 3 || opacity == 7) {  	// берем фоновые атрибуты символа из родительского буфера  	Attr parentAttr = buffer [parentX' parentY].Attributes;  	if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  		charInfo.Attributes |= Attr.BACKGROUND_BLUE;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  	}  	if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  		charInfo.Attributes |= Attr.BACKGROUND_GREEN;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  	}  	if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  		charInfo.Attributes |= Attr.BACKGROUND_RED;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_RED;  	}  	if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  		charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  	}  	buffer [parentX' parentY] = charInfo;  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: if (opacity == 1 || opacity == 5) {  	charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  	charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  	buffer [parentX' parentY] = charInfo;  } else if (opacity == 3 || opacity == 7) {  	// берем фоновые атрибуты символа из родительского буфера  	Attr parentAttr = buffer [parentX' parentY].Attributes;  	if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  		charInfo.Attributes |= Attr.BACKGROUND_BLUE;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  	}  	if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  		charInfo.Attributes |= Attr.BACKGROUND_GREEN;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  	}  	if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  		charInfo.Attributes |= Attr.BACKGROUND_RED;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_RED;  	}  	if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  		charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  	}  	buffer [parentX' parentY] = charInfo;  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: if (opacity == 1 || opacity == 5) {  	charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  	charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  	buffer [parentX' parentY] = charInfo;  } else if (opacity == 3 || opacity == 7) {  	// берем фоновые атрибуты символа из родительского буфера  	Attr parentAttr = buffer [parentX' parentY].Attributes;  	if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  		charInfo.Attributes |= Attr.BACKGROUND_BLUE;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  	}  	if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  		charInfo.Attributes |= Attr.BACKGROUND_GREEN;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  	}  	if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  		charInfo.Attributes |= Attr.BACKGROUND_RED;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_RED;  	}  	if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  		charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  	}  	buffer [parentX' parentY] = charInfo;  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: if (opacity == 1 || opacity == 5) {  	charInfo.Attributes = Colors.Blend (Color.DarkGray' Color.Black);  	charInfo.UnicodeChar = buffer [parentX' parentY].UnicodeChar;  	buffer [parentX' parentY] = charInfo;  } else if (opacity == 3 || opacity == 7) {  	// берем фоновые атрибуты символа из родительского буфера  	Attr parentAttr = buffer [parentX' parentY].Attributes;  	if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  		charInfo.Attributes |= Attr.BACKGROUND_BLUE;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  	}  	if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  		charInfo.Attributes |= Attr.BACKGROUND_GREEN;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  	}  	if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  		charInfo.Attributes |= Attr.BACKGROUND_RED;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_RED;  	}  	if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  		charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  	}  	buffer [parentX' parentY] = charInfo;  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: if (opacity == 3 || opacity == 7) {  	// берем фоновые атрибуты символа из родительского буфера  	Attr parentAttr = buffer [parentX' parentY].Attributes;  	if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  		charInfo.Attributes |= Attr.BACKGROUND_BLUE;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  	}  	if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  		charInfo.Attributes |= Attr.BACKGROUND_GREEN;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  	}  	if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  		charInfo.Attributes |= Attr.BACKGROUND_RED;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_RED;  	}  	if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  		charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  	}  	buffer [parentX' parentY] = charInfo;  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,ApplyChild,The following statement contains a magic number: if (opacity == 3 || opacity == 7) {  	// берем фоновые атрибуты символа из родительского буфера  	Attr parentAttr = buffer [parentX' parentY].Attributes;  	if ((parentAttr & Attr.BACKGROUND_BLUE) == Attr.BACKGROUND_BLUE) {  		charInfo.Attributes |= Attr.BACKGROUND_BLUE;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_BLUE;  	}  	if ((parentAttr & Attr.BACKGROUND_GREEN) == Attr.BACKGROUND_GREEN) {  		charInfo.Attributes |= Attr.BACKGROUND_GREEN;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_GREEN;  	}  	if ((parentAttr & Attr.BACKGROUND_RED) == Attr.BACKGROUND_RED) {  		charInfo.Attributes |= Attr.BACKGROUND_RED;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_RED;  	}  	if ((parentAttr & Attr.BACKGROUND_INTENSITY) == Attr.BACKGROUND_INTENSITY) {  		charInfo.Attributes |= Attr.BACKGROUND_INTENSITY;  	} else {  		charInfo.Attributes &= ~Attr.BACKGROUND_INTENSITY;  	}  	buffer [parentX' parentY] = charInfo;  }  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,SetOpacity,The following statement contains a magic number: if (opacity < 0 || opacity > 7)  	throw new ArgumentException ("opacity");  
Magic Number,ConsoleFramework.Rendering,RenderingBuffer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\RenderingBuffer.cs,SetOpacityRect,The following statement contains a magic number: if (opacity < 0 || opacity > 7)  	throw new ArgumentException ("opacity");  
Magic Number,ConsoleFramework.Rendering,Renderer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\Renderer.cs,getControlOpacityAt,The following statement contains a magic number: if (!buffers.ContainsKey (control)) {  	return 6;  }  
Magic Number,ConsoleFramework.Rendering,Renderer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Rendering\Renderer.cs,getControlOpacityAt,The following statement contains a magic number: return 6;  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,ShowCursor,The following statement contains a magic number: if (!usingLinux) {  	CONSOLE_CURSOR_INFO consoleCursorInfo = new CONSOLE_CURSOR_INFO {  		Size = 5'  		Visible = true  	};  	Win32.SetConsoleCursorInfo (stdOutputHandle' ref consoleCursorInfo);  } else {  	NCurses.curs_set (CursorVisibility.Visible);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,HideCursor,The following statement contains a magic number: if (!usingLinux) {  	CONSOLE_CURSOR_INFO consoleCursorInfo = new CONSOLE_CURSOR_INFO {  		Size = 5'  		Visible = false  	};  	Win32.SetConsoleCursorInfo (stdOutputHandle' ref consoleCursorInfo);  } else {  	NCurses.curs_set (CursorVisibility.Invisible);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runLinux,The following statement contains a magic number: try {  	renderer.UpdateLayout ();  	renderer.FinallyApplyChangesToCanvas ();  	termkeyHandle = LibTermKey.termkey_new (0' TermKeyFlag.TERMKEY_FLAG_SPACESYMBOL);  	// Setup the input mode  	Console.Write ("\x1B[?1002h");  	pollfd fd = new pollfd ();  	fd.fd = 0;  	fd.events = POLL_EVENTS.POLLIN;  	pollfd[] fds = new pollfd[2];  	fds [0] = fd;  	fds [1] = new pollfd ();  	int pipeResult = Libc.pipe (pipeFds);  	if (pipeResult == -1) {  		throw new InvalidOperationException ("Cannot create self-pipe.");  	}  	fds [1].fd = pipeFds [0];  	fds [1].events = POLL_EVENTS.POLLIN;  	try {  		#if !WIN32  		                    // Catch SIGWINCH to handle terminal resizing 			        UnixSignal[] signals = new UnixSignal [] { 			            new UnixSignal (Signum.SIGWINCH) 			        }; 			        Thread signal_thread = new Thread (delegate () { 				        while (true) { 					        // Wait for a signal to be delivered 					        int index = UnixSignal.WaitAny (signals' -1); 					        Signum signal = signals [index].Signum; 					        Libc.writeInt64 (pipeFds[1]' 2); 				        } 			        } 			        ); 			        signal_thread.IsBackground = false; 			        signal_thread.Start (); #endif  		TermKeyKey key = new TermKeyKey ();  		//  		this.running = true;  		this.mainThreadId = Thread.CurrentThread.ManagedThreadId;  		//  		int nextwait = -1;  		while (true) {  			int pollRes = Libc.poll (fds' 2' nextwait);  			if (pollRes == 0) {  				if (nextwait == -1)  					throw new InvalidOperationException ("Assertion failed.");  				if (TermKeyResult.TERMKEY_RES_KEY == LibTermKey.termkey_getkey_force (termkeyHandle' ref key)) {  					processLinuxInput (key);  				}  			}  			if (pollRes == -1) {  				int errorCode = Marshal.GetLastWin32Error ();  				if (errorCode != Libc.EINTR) {  					throw new InvalidOperationException (string.Format ("poll() returned with error code {0}"' errorCode));  				}  			}  			if (fds [1].revents != POLL_EVENTS.NONE) {  				UInt64 u;  				Libc.readInt64 (fds [1].fd' out u);  				if (u == 1) {  					// Exit from application  					#if !WIN32  											        signal_thread.Abort (); #endif  					break;  				}  				if (u == 2) {  					// Get new term size and process appropriate INPUT_RECORD event  					INPUT_RECORD inputRecord = new INPUT_RECORD ();  					inputRecord.EventType = EventType.WINDOW_BUFFER_SIZE_EVENT;  					winsize ws = Libc.GetTerminalSize (isDarwin);  					inputRecord.WindowBufferSizeEvent.dwSize.X = (short)ws.ws_col;  					inputRecord.WindowBufferSizeEvent.dwSize.Y = (short)ws.ws_row;  					processInputEvent (inputRecord);  				}  				if (u == 3) {  					// It is signal from async actions invocation stuff  				}  			}  			if ((fds [0].revents & POLL_EVENTS.POLLIN) == POLL_EVENTS.POLLIN || (fds [0].revents & POLL_EVENTS.POLLHUP) == POLL_EVENTS.POLLHUP || (fds [0].revents & POLL_EVENTS.POLLERR) == POLL_EVENTS.POLLERR) {  				LibTermKey.termkey_advisereadable (termkeyHandle);  			}  			TermKeyResult result = (LibTermKey.termkey_getkey (termkeyHandle' ref key));  			while (result == TermKeyResult.TERMKEY_RES_KEY) {  				processLinuxInput (key);  				result = (LibTermKey.termkey_getkey (termkeyHandle' ref key));  			}  			if (result == TermKeyResult.TERMKEY_RES_AGAIN) {  				nextwait = LibTermKey.termkey_get_waittime (termkeyHandle);  			} else {  				nextwait = -1;  			}  			while (true) {  				bool anyInvokeActions = isAnyInvokeActions ();  				bool anyRoutedEvent = !EventManager.IsQueueEmpty ();  				bool anyLayoutToRevalidate = renderer.AnyControlInvalidated;  				if (!anyInvokeActions && !anyRoutedEvent && !anyLayoutToRevalidate)  					break;  				EventManager.ProcessEvents ();  				processInvokeActions ();  				renderer.UpdateLayout ();  			}  			renderer.FinallyApplyChangesToCanvas ();  		}  	} finally {  		LibTermKey.termkey_destroy (termkeyHandle);  		Libc.close (pipeFds [0]);  		Libc.close (pipeFds [1]);  		Console.Write ("\x1B[?1002l");  	}  } finally {  	// Restore cursor visibility before exit  	ShowCursor ();  	NCurses.endwin ();  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runLinux,The following statement contains a magic number: try {  	renderer.UpdateLayout ();  	renderer.FinallyApplyChangesToCanvas ();  	termkeyHandle = LibTermKey.termkey_new (0' TermKeyFlag.TERMKEY_FLAG_SPACESYMBOL);  	// Setup the input mode  	Console.Write ("\x1B[?1002h");  	pollfd fd = new pollfd ();  	fd.fd = 0;  	fd.events = POLL_EVENTS.POLLIN;  	pollfd[] fds = new pollfd[2];  	fds [0] = fd;  	fds [1] = new pollfd ();  	int pipeResult = Libc.pipe (pipeFds);  	if (pipeResult == -1) {  		throw new InvalidOperationException ("Cannot create self-pipe.");  	}  	fds [1].fd = pipeFds [0];  	fds [1].events = POLL_EVENTS.POLLIN;  	try {  		#if !WIN32  		                    // Catch SIGWINCH to handle terminal resizing 			        UnixSignal[] signals = new UnixSignal [] { 			            new UnixSignal (Signum.SIGWINCH) 			        }; 			        Thread signal_thread = new Thread (delegate () { 				        while (true) { 					        // Wait for a signal to be delivered 					        int index = UnixSignal.WaitAny (signals' -1); 					        Signum signal = signals [index].Signum; 					        Libc.writeInt64 (pipeFds[1]' 2); 				        } 			        } 			        ); 			        signal_thread.IsBackground = false; 			        signal_thread.Start (); #endif  		TermKeyKey key = new TermKeyKey ();  		//  		this.running = true;  		this.mainThreadId = Thread.CurrentThread.ManagedThreadId;  		//  		int nextwait = -1;  		while (true) {  			int pollRes = Libc.poll (fds' 2' nextwait);  			if (pollRes == 0) {  				if (nextwait == -1)  					throw new InvalidOperationException ("Assertion failed.");  				if (TermKeyResult.TERMKEY_RES_KEY == LibTermKey.termkey_getkey_force (termkeyHandle' ref key)) {  					processLinuxInput (key);  				}  			}  			if (pollRes == -1) {  				int errorCode = Marshal.GetLastWin32Error ();  				if (errorCode != Libc.EINTR) {  					throw new InvalidOperationException (string.Format ("poll() returned with error code {0}"' errorCode));  				}  			}  			if (fds [1].revents != POLL_EVENTS.NONE) {  				UInt64 u;  				Libc.readInt64 (fds [1].fd' out u);  				if (u == 1) {  					// Exit from application  					#if !WIN32  											        signal_thread.Abort (); #endif  					break;  				}  				if (u == 2) {  					// Get new term size and process appropriate INPUT_RECORD event  					INPUT_RECORD inputRecord = new INPUT_RECORD ();  					inputRecord.EventType = EventType.WINDOW_BUFFER_SIZE_EVENT;  					winsize ws = Libc.GetTerminalSize (isDarwin);  					inputRecord.WindowBufferSizeEvent.dwSize.X = (short)ws.ws_col;  					inputRecord.WindowBufferSizeEvent.dwSize.Y = (short)ws.ws_row;  					processInputEvent (inputRecord);  				}  				if (u == 3) {  					// It is signal from async actions invocation stuff  				}  			}  			if ((fds [0].revents & POLL_EVENTS.POLLIN) == POLL_EVENTS.POLLIN || (fds [0].revents & POLL_EVENTS.POLLHUP) == POLL_EVENTS.POLLHUP || (fds [0].revents & POLL_EVENTS.POLLERR) == POLL_EVENTS.POLLERR) {  				LibTermKey.termkey_advisereadable (termkeyHandle);  			}  			TermKeyResult result = (LibTermKey.termkey_getkey (termkeyHandle' ref key));  			while (result == TermKeyResult.TERMKEY_RES_KEY) {  				processLinuxInput (key);  				result = (LibTermKey.termkey_getkey (termkeyHandle' ref key));  			}  			if (result == TermKeyResult.TERMKEY_RES_AGAIN) {  				nextwait = LibTermKey.termkey_get_waittime (termkeyHandle);  			} else {  				nextwait = -1;  			}  			while (true) {  				bool anyInvokeActions = isAnyInvokeActions ();  				bool anyRoutedEvent = !EventManager.IsQueueEmpty ();  				bool anyLayoutToRevalidate = renderer.AnyControlInvalidated;  				if (!anyInvokeActions && !anyRoutedEvent && !anyLayoutToRevalidate)  					break;  				EventManager.ProcessEvents ();  				processInvokeActions ();  				renderer.UpdateLayout ();  			}  			renderer.FinallyApplyChangesToCanvas ();  		}  	} finally {  		LibTermKey.termkey_destroy (termkeyHandle);  		Libc.close (pipeFds [0]);  		Libc.close (pipeFds [1]);  		Console.Write ("\x1B[?1002l");  	}  } finally {  	// Restore cursor visibility before exit  	ShowCursor ();  	NCurses.endwin ();  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runLinux,The following statement contains a magic number: try {  	renderer.UpdateLayout ();  	renderer.FinallyApplyChangesToCanvas ();  	termkeyHandle = LibTermKey.termkey_new (0' TermKeyFlag.TERMKEY_FLAG_SPACESYMBOL);  	// Setup the input mode  	Console.Write ("\x1B[?1002h");  	pollfd fd = new pollfd ();  	fd.fd = 0;  	fd.events = POLL_EVENTS.POLLIN;  	pollfd[] fds = new pollfd[2];  	fds [0] = fd;  	fds [1] = new pollfd ();  	int pipeResult = Libc.pipe (pipeFds);  	if (pipeResult == -1) {  		throw new InvalidOperationException ("Cannot create self-pipe.");  	}  	fds [1].fd = pipeFds [0];  	fds [1].events = POLL_EVENTS.POLLIN;  	try {  		#if !WIN32  		                    // Catch SIGWINCH to handle terminal resizing 			        UnixSignal[] signals = new UnixSignal [] { 			            new UnixSignal (Signum.SIGWINCH) 			        }; 			        Thread signal_thread = new Thread (delegate () { 				        while (true) { 					        // Wait for a signal to be delivered 					        int index = UnixSignal.WaitAny (signals' -1); 					        Signum signal = signals [index].Signum; 					        Libc.writeInt64 (pipeFds[1]' 2); 				        } 			        } 			        ); 			        signal_thread.IsBackground = false; 			        signal_thread.Start (); #endif  		TermKeyKey key = new TermKeyKey ();  		//  		this.running = true;  		this.mainThreadId = Thread.CurrentThread.ManagedThreadId;  		//  		int nextwait = -1;  		while (true) {  			int pollRes = Libc.poll (fds' 2' nextwait);  			if (pollRes == 0) {  				if (nextwait == -1)  					throw new InvalidOperationException ("Assertion failed.");  				if (TermKeyResult.TERMKEY_RES_KEY == LibTermKey.termkey_getkey_force (termkeyHandle' ref key)) {  					processLinuxInput (key);  				}  			}  			if (pollRes == -1) {  				int errorCode = Marshal.GetLastWin32Error ();  				if (errorCode != Libc.EINTR) {  					throw new InvalidOperationException (string.Format ("poll() returned with error code {0}"' errorCode));  				}  			}  			if (fds [1].revents != POLL_EVENTS.NONE) {  				UInt64 u;  				Libc.readInt64 (fds [1].fd' out u);  				if (u == 1) {  					// Exit from application  					#if !WIN32  											        signal_thread.Abort (); #endif  					break;  				}  				if (u == 2) {  					// Get new term size and process appropriate INPUT_RECORD event  					INPUT_RECORD inputRecord = new INPUT_RECORD ();  					inputRecord.EventType = EventType.WINDOW_BUFFER_SIZE_EVENT;  					winsize ws = Libc.GetTerminalSize (isDarwin);  					inputRecord.WindowBufferSizeEvent.dwSize.X = (short)ws.ws_col;  					inputRecord.WindowBufferSizeEvent.dwSize.Y = (short)ws.ws_row;  					processInputEvent (inputRecord);  				}  				if (u == 3) {  					// It is signal from async actions invocation stuff  				}  			}  			if ((fds [0].revents & POLL_EVENTS.POLLIN) == POLL_EVENTS.POLLIN || (fds [0].revents & POLL_EVENTS.POLLHUP) == POLL_EVENTS.POLLHUP || (fds [0].revents & POLL_EVENTS.POLLERR) == POLL_EVENTS.POLLERR) {  				LibTermKey.termkey_advisereadable (termkeyHandle);  			}  			TermKeyResult result = (LibTermKey.termkey_getkey (termkeyHandle' ref key));  			while (result == TermKeyResult.TERMKEY_RES_KEY) {  				processLinuxInput (key);  				result = (LibTermKey.termkey_getkey (termkeyHandle' ref key));  			}  			if (result == TermKeyResult.TERMKEY_RES_AGAIN) {  				nextwait = LibTermKey.termkey_get_waittime (termkeyHandle);  			} else {  				nextwait = -1;  			}  			while (true) {  				bool anyInvokeActions = isAnyInvokeActions ();  				bool anyRoutedEvent = !EventManager.IsQueueEmpty ();  				bool anyLayoutToRevalidate = renderer.AnyControlInvalidated;  				if (!anyInvokeActions && !anyRoutedEvent && !anyLayoutToRevalidate)  					break;  				EventManager.ProcessEvents ();  				processInvokeActions ();  				renderer.UpdateLayout ();  			}  			renderer.FinallyApplyChangesToCanvas ();  		}  	} finally {  		LibTermKey.termkey_destroy (termkeyHandle);  		Libc.close (pipeFds [0]);  		Libc.close (pipeFds [1]);  		Console.Write ("\x1B[?1002l");  	}  } finally {  	// Restore cursor visibility before exit  	ShowCursor ();  	NCurses.endwin ();  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runLinux,The following statement contains a magic number: try {  	renderer.UpdateLayout ();  	renderer.FinallyApplyChangesToCanvas ();  	termkeyHandle = LibTermKey.termkey_new (0' TermKeyFlag.TERMKEY_FLAG_SPACESYMBOL);  	// Setup the input mode  	Console.Write ("\x1B[?1002h");  	pollfd fd = new pollfd ();  	fd.fd = 0;  	fd.events = POLL_EVENTS.POLLIN;  	pollfd[] fds = new pollfd[2];  	fds [0] = fd;  	fds [1] = new pollfd ();  	int pipeResult = Libc.pipe (pipeFds);  	if (pipeResult == -1) {  		throw new InvalidOperationException ("Cannot create self-pipe.");  	}  	fds [1].fd = pipeFds [0];  	fds [1].events = POLL_EVENTS.POLLIN;  	try {  		#if !WIN32  		                    // Catch SIGWINCH to handle terminal resizing 			        UnixSignal[] signals = new UnixSignal [] { 			            new UnixSignal (Signum.SIGWINCH) 			        }; 			        Thread signal_thread = new Thread (delegate () { 				        while (true) { 					        // Wait for a signal to be delivered 					        int index = UnixSignal.WaitAny (signals' -1); 					        Signum signal = signals [index].Signum; 					        Libc.writeInt64 (pipeFds[1]' 2); 				        } 			        } 			        ); 			        signal_thread.IsBackground = false; 			        signal_thread.Start (); #endif  		TermKeyKey key = new TermKeyKey ();  		//  		this.running = true;  		this.mainThreadId = Thread.CurrentThread.ManagedThreadId;  		//  		int nextwait = -1;  		while (true) {  			int pollRes = Libc.poll (fds' 2' nextwait);  			if (pollRes == 0) {  				if (nextwait == -1)  					throw new InvalidOperationException ("Assertion failed.");  				if (TermKeyResult.TERMKEY_RES_KEY == LibTermKey.termkey_getkey_force (termkeyHandle' ref key)) {  					processLinuxInput (key);  				}  			}  			if (pollRes == -1) {  				int errorCode = Marshal.GetLastWin32Error ();  				if (errorCode != Libc.EINTR) {  					throw new InvalidOperationException (string.Format ("poll() returned with error code {0}"' errorCode));  				}  			}  			if (fds [1].revents != POLL_EVENTS.NONE) {  				UInt64 u;  				Libc.readInt64 (fds [1].fd' out u);  				if (u == 1) {  					// Exit from application  					#if !WIN32  											        signal_thread.Abort (); #endif  					break;  				}  				if (u == 2) {  					// Get new term size and process appropriate INPUT_RECORD event  					INPUT_RECORD inputRecord = new INPUT_RECORD ();  					inputRecord.EventType = EventType.WINDOW_BUFFER_SIZE_EVENT;  					winsize ws = Libc.GetTerminalSize (isDarwin);  					inputRecord.WindowBufferSizeEvent.dwSize.X = (short)ws.ws_col;  					inputRecord.WindowBufferSizeEvent.dwSize.Y = (short)ws.ws_row;  					processInputEvent (inputRecord);  				}  				if (u == 3) {  					// It is signal from async actions invocation stuff  				}  			}  			if ((fds [0].revents & POLL_EVENTS.POLLIN) == POLL_EVENTS.POLLIN || (fds [0].revents & POLL_EVENTS.POLLHUP) == POLL_EVENTS.POLLHUP || (fds [0].revents & POLL_EVENTS.POLLERR) == POLL_EVENTS.POLLERR) {  				LibTermKey.termkey_advisereadable (termkeyHandle);  			}  			TermKeyResult result = (LibTermKey.termkey_getkey (termkeyHandle' ref key));  			while (result == TermKeyResult.TERMKEY_RES_KEY) {  				processLinuxInput (key);  				result = (LibTermKey.termkey_getkey (termkeyHandle' ref key));  			}  			if (result == TermKeyResult.TERMKEY_RES_AGAIN) {  				nextwait = LibTermKey.termkey_get_waittime (termkeyHandle);  			} else {  				nextwait = -1;  			}  			while (true) {  				bool anyInvokeActions = isAnyInvokeActions ();  				bool anyRoutedEvent = !EventManager.IsQueueEmpty ();  				bool anyLayoutToRevalidate = renderer.AnyControlInvalidated;  				if (!anyInvokeActions && !anyRoutedEvent && !anyLayoutToRevalidate)  					break;  				EventManager.ProcessEvents ();  				processInvokeActions ();  				renderer.UpdateLayout ();  			}  			renderer.FinallyApplyChangesToCanvas ();  		}  	} finally {  		LibTermKey.termkey_destroy (termkeyHandle);  		Libc.close (pipeFds [0]);  		Libc.close (pipeFds [1]);  		Console.Write ("\x1B[?1002l");  	}  } finally {  	// Restore cursor visibility before exit  	ShowCursor ();  	NCurses.endwin ();  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runLinux,The following statement contains a magic number: try {  	#if !WIN32  	                    // Catch SIGWINCH to handle terminal resizing 			        UnixSignal[] signals = new UnixSignal [] { 			            new UnixSignal (Signum.SIGWINCH) 			        }; 			        Thread signal_thread = new Thread (delegate () { 				        while (true) { 					        // Wait for a signal to be delivered 					        int index = UnixSignal.WaitAny (signals' -1); 					        Signum signal = signals [index].Signum; 					        Libc.writeInt64 (pipeFds[1]' 2); 				        } 			        } 			        ); 			        signal_thread.IsBackground = false; 			        signal_thread.Start (); #endif  	TermKeyKey key = new TermKeyKey ();  	//  	this.running = true;  	this.mainThreadId = Thread.CurrentThread.ManagedThreadId;  	//  	int nextwait = -1;  	while (true) {  		int pollRes = Libc.poll (fds' 2' nextwait);  		if (pollRes == 0) {  			if (nextwait == -1)  				throw new InvalidOperationException ("Assertion failed.");  			if (TermKeyResult.TERMKEY_RES_KEY == LibTermKey.termkey_getkey_force (termkeyHandle' ref key)) {  				processLinuxInput (key);  			}  		}  		if (pollRes == -1) {  			int errorCode = Marshal.GetLastWin32Error ();  			if (errorCode != Libc.EINTR) {  				throw new InvalidOperationException (string.Format ("poll() returned with error code {0}"' errorCode));  			}  		}  		if (fds [1].revents != POLL_EVENTS.NONE) {  			UInt64 u;  			Libc.readInt64 (fds [1].fd' out u);  			if (u == 1) {  				// Exit from application  				#if !WIN32  										        signal_thread.Abort (); #endif  				break;  			}  			if (u == 2) {  				// Get new term size and process appropriate INPUT_RECORD event  				INPUT_RECORD inputRecord = new INPUT_RECORD ();  				inputRecord.EventType = EventType.WINDOW_BUFFER_SIZE_EVENT;  				winsize ws = Libc.GetTerminalSize (isDarwin);  				inputRecord.WindowBufferSizeEvent.dwSize.X = (short)ws.ws_col;  				inputRecord.WindowBufferSizeEvent.dwSize.Y = (short)ws.ws_row;  				processInputEvent (inputRecord);  			}  			if (u == 3) {  				// It is signal from async actions invocation stuff  			}  		}  		if ((fds [0].revents & POLL_EVENTS.POLLIN) == POLL_EVENTS.POLLIN || (fds [0].revents & POLL_EVENTS.POLLHUP) == POLL_EVENTS.POLLHUP || (fds [0].revents & POLL_EVENTS.POLLERR) == POLL_EVENTS.POLLERR) {  			LibTermKey.termkey_advisereadable (termkeyHandle);  		}  		TermKeyResult result = (LibTermKey.termkey_getkey (termkeyHandle' ref key));  		while (result == TermKeyResult.TERMKEY_RES_KEY) {  			processLinuxInput (key);  			result = (LibTermKey.termkey_getkey (termkeyHandle' ref key));  		}  		if (result == TermKeyResult.TERMKEY_RES_AGAIN) {  			nextwait = LibTermKey.termkey_get_waittime (termkeyHandle);  		} else {  			nextwait = -1;  		}  		while (true) {  			bool anyInvokeActions = isAnyInvokeActions ();  			bool anyRoutedEvent = !EventManager.IsQueueEmpty ();  			bool anyLayoutToRevalidate = renderer.AnyControlInvalidated;  			if (!anyInvokeActions && !anyRoutedEvent && !anyLayoutToRevalidate)  				break;  			EventManager.ProcessEvents ();  			processInvokeActions ();  			renderer.UpdateLayout ();  		}  		renderer.FinallyApplyChangesToCanvas ();  	}  } finally {  	LibTermKey.termkey_destroy (termkeyHandle);  	Libc.close (pipeFds [0]);  	Libc.close (pipeFds [1]);  	Console.Write ("\x1B[?1002l");  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runLinux,The following statement contains a magic number: try {  	#if !WIN32  	                    // Catch SIGWINCH to handle terminal resizing 			        UnixSignal[] signals = new UnixSignal [] { 			            new UnixSignal (Signum.SIGWINCH) 			        }; 			        Thread signal_thread = new Thread (delegate () { 				        while (true) { 					        // Wait for a signal to be delivered 					        int index = UnixSignal.WaitAny (signals' -1); 					        Signum signal = signals [index].Signum; 					        Libc.writeInt64 (pipeFds[1]' 2); 				        } 			        } 			        ); 			        signal_thread.IsBackground = false; 			        signal_thread.Start (); #endif  	TermKeyKey key = new TermKeyKey ();  	//  	this.running = true;  	this.mainThreadId = Thread.CurrentThread.ManagedThreadId;  	//  	int nextwait = -1;  	while (true) {  		int pollRes = Libc.poll (fds' 2' nextwait);  		if (pollRes == 0) {  			if (nextwait == -1)  				throw new InvalidOperationException ("Assertion failed.");  			if (TermKeyResult.TERMKEY_RES_KEY == LibTermKey.termkey_getkey_force (termkeyHandle' ref key)) {  				processLinuxInput (key);  			}  		}  		if (pollRes == -1) {  			int errorCode = Marshal.GetLastWin32Error ();  			if (errorCode != Libc.EINTR) {  				throw new InvalidOperationException (string.Format ("poll() returned with error code {0}"' errorCode));  			}  		}  		if (fds [1].revents != POLL_EVENTS.NONE) {  			UInt64 u;  			Libc.readInt64 (fds [1].fd' out u);  			if (u == 1) {  				// Exit from application  				#if !WIN32  										        signal_thread.Abort (); #endif  				break;  			}  			if (u == 2) {  				// Get new term size and process appropriate INPUT_RECORD event  				INPUT_RECORD inputRecord = new INPUT_RECORD ();  				inputRecord.EventType = EventType.WINDOW_BUFFER_SIZE_EVENT;  				winsize ws = Libc.GetTerminalSize (isDarwin);  				inputRecord.WindowBufferSizeEvent.dwSize.X = (short)ws.ws_col;  				inputRecord.WindowBufferSizeEvent.dwSize.Y = (short)ws.ws_row;  				processInputEvent (inputRecord);  			}  			if (u == 3) {  				// It is signal from async actions invocation stuff  			}  		}  		if ((fds [0].revents & POLL_EVENTS.POLLIN) == POLL_EVENTS.POLLIN || (fds [0].revents & POLL_EVENTS.POLLHUP) == POLL_EVENTS.POLLHUP || (fds [0].revents & POLL_EVENTS.POLLERR) == POLL_EVENTS.POLLERR) {  			LibTermKey.termkey_advisereadable (termkeyHandle);  		}  		TermKeyResult result = (LibTermKey.termkey_getkey (termkeyHandle' ref key));  		while (result == TermKeyResult.TERMKEY_RES_KEY) {  			processLinuxInput (key);  			result = (LibTermKey.termkey_getkey (termkeyHandle' ref key));  		}  		if (result == TermKeyResult.TERMKEY_RES_AGAIN) {  			nextwait = LibTermKey.termkey_get_waittime (termkeyHandle);  		} else {  			nextwait = -1;  		}  		while (true) {  			bool anyInvokeActions = isAnyInvokeActions ();  			bool anyRoutedEvent = !EventManager.IsQueueEmpty ();  			bool anyLayoutToRevalidate = renderer.AnyControlInvalidated;  			if (!anyInvokeActions && !anyRoutedEvent && !anyLayoutToRevalidate)  				break;  			EventManager.ProcessEvents ();  			processInvokeActions ();  			renderer.UpdateLayout ();  		}  		renderer.FinallyApplyChangesToCanvas ();  	}  } finally {  	LibTermKey.termkey_destroy (termkeyHandle);  	Libc.close (pipeFds [0]);  	Libc.close (pipeFds [1]);  	Console.Write ("\x1B[?1002l");  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runLinux,The following statement contains a magic number: try {  	#if !WIN32  	                    // Catch SIGWINCH to handle terminal resizing 			        UnixSignal[] signals = new UnixSignal [] { 			            new UnixSignal (Signum.SIGWINCH) 			        }; 			        Thread signal_thread = new Thread (delegate () { 				        while (true) { 					        // Wait for a signal to be delivered 					        int index = UnixSignal.WaitAny (signals' -1); 					        Signum signal = signals [index].Signum; 					        Libc.writeInt64 (pipeFds[1]' 2); 				        } 			        } 			        ); 			        signal_thread.IsBackground = false; 			        signal_thread.Start (); #endif  	TermKeyKey key = new TermKeyKey ();  	//  	this.running = true;  	this.mainThreadId = Thread.CurrentThread.ManagedThreadId;  	//  	int nextwait = -1;  	while (true) {  		int pollRes = Libc.poll (fds' 2' nextwait);  		if (pollRes == 0) {  			if (nextwait == -1)  				throw new InvalidOperationException ("Assertion failed.");  			if (TermKeyResult.TERMKEY_RES_KEY == LibTermKey.termkey_getkey_force (termkeyHandle' ref key)) {  				processLinuxInput (key);  			}  		}  		if (pollRes == -1) {  			int errorCode = Marshal.GetLastWin32Error ();  			if (errorCode != Libc.EINTR) {  				throw new InvalidOperationException (string.Format ("poll() returned with error code {0}"' errorCode));  			}  		}  		if (fds [1].revents != POLL_EVENTS.NONE) {  			UInt64 u;  			Libc.readInt64 (fds [1].fd' out u);  			if (u == 1) {  				// Exit from application  				#if !WIN32  										        signal_thread.Abort (); #endif  				break;  			}  			if (u == 2) {  				// Get new term size and process appropriate INPUT_RECORD event  				INPUT_RECORD inputRecord = new INPUT_RECORD ();  				inputRecord.EventType = EventType.WINDOW_BUFFER_SIZE_EVENT;  				winsize ws = Libc.GetTerminalSize (isDarwin);  				inputRecord.WindowBufferSizeEvent.dwSize.X = (short)ws.ws_col;  				inputRecord.WindowBufferSizeEvent.dwSize.Y = (short)ws.ws_row;  				processInputEvent (inputRecord);  			}  			if (u == 3) {  				// It is signal from async actions invocation stuff  			}  		}  		if ((fds [0].revents & POLL_EVENTS.POLLIN) == POLL_EVENTS.POLLIN || (fds [0].revents & POLL_EVENTS.POLLHUP) == POLL_EVENTS.POLLHUP || (fds [0].revents & POLL_EVENTS.POLLERR) == POLL_EVENTS.POLLERR) {  			LibTermKey.termkey_advisereadable (termkeyHandle);  		}  		TermKeyResult result = (LibTermKey.termkey_getkey (termkeyHandle' ref key));  		while (result == TermKeyResult.TERMKEY_RES_KEY) {  			processLinuxInput (key);  			result = (LibTermKey.termkey_getkey (termkeyHandle' ref key));  		}  		if (result == TermKeyResult.TERMKEY_RES_AGAIN) {  			nextwait = LibTermKey.termkey_get_waittime (termkeyHandle);  		} else {  			nextwait = -1;  		}  		while (true) {  			bool anyInvokeActions = isAnyInvokeActions ();  			bool anyRoutedEvent = !EventManager.IsQueueEmpty ();  			bool anyLayoutToRevalidate = renderer.AnyControlInvalidated;  			if (!anyInvokeActions && !anyRoutedEvent && !anyLayoutToRevalidate)  				break;  			EventManager.ProcessEvents ();  			processInvokeActions ();  			renderer.UpdateLayout ();  		}  		renderer.FinallyApplyChangesToCanvas ();  	}  } finally {  	LibTermKey.termkey_destroy (termkeyHandle);  	Libc.close (pipeFds [0]);  	Libc.close (pipeFds [1]);  	Console.Write ("\x1B[?1002l");  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runLinux,The following statement contains a magic number: while (true) {  	int pollRes = Libc.poll (fds' 2' nextwait);  	if (pollRes == 0) {  		if (nextwait == -1)  			throw new InvalidOperationException ("Assertion failed.");  		if (TermKeyResult.TERMKEY_RES_KEY == LibTermKey.termkey_getkey_force (termkeyHandle' ref key)) {  			processLinuxInput (key);  		}  	}  	if (pollRes == -1) {  		int errorCode = Marshal.GetLastWin32Error ();  		if (errorCode != Libc.EINTR) {  			throw new InvalidOperationException (string.Format ("poll() returned with error code {0}"' errorCode));  		}  	}  	if (fds [1].revents != POLL_EVENTS.NONE) {  		UInt64 u;  		Libc.readInt64 (fds [1].fd' out u);  		if (u == 1) {  			// Exit from application  			#if !WIN32  									        signal_thread.Abort (); #endif  			break;  		}  		if (u == 2) {  			// Get new term size and process appropriate INPUT_RECORD event  			INPUT_RECORD inputRecord = new INPUT_RECORD ();  			inputRecord.EventType = EventType.WINDOW_BUFFER_SIZE_EVENT;  			winsize ws = Libc.GetTerminalSize (isDarwin);  			inputRecord.WindowBufferSizeEvent.dwSize.X = (short)ws.ws_col;  			inputRecord.WindowBufferSizeEvent.dwSize.Y = (short)ws.ws_row;  			processInputEvent (inputRecord);  		}  		if (u == 3) {  			// It is signal from async actions invocation stuff  		}  	}  	if ((fds [0].revents & POLL_EVENTS.POLLIN) == POLL_EVENTS.POLLIN || (fds [0].revents & POLL_EVENTS.POLLHUP) == POLL_EVENTS.POLLHUP || (fds [0].revents & POLL_EVENTS.POLLERR) == POLL_EVENTS.POLLERR) {  		LibTermKey.termkey_advisereadable (termkeyHandle);  	}  	TermKeyResult result = (LibTermKey.termkey_getkey (termkeyHandle' ref key));  	while (result == TermKeyResult.TERMKEY_RES_KEY) {  		processLinuxInput (key);  		result = (LibTermKey.termkey_getkey (termkeyHandle' ref key));  	}  	if (result == TermKeyResult.TERMKEY_RES_AGAIN) {  		nextwait = LibTermKey.termkey_get_waittime (termkeyHandle);  	} else {  		nextwait = -1;  	}  	while (true) {  		bool anyInvokeActions = isAnyInvokeActions ();  		bool anyRoutedEvent = !EventManager.IsQueueEmpty ();  		bool anyLayoutToRevalidate = renderer.AnyControlInvalidated;  		if (!anyInvokeActions && !anyRoutedEvent && !anyLayoutToRevalidate)  			break;  		EventManager.ProcessEvents ();  		processInvokeActions ();  		renderer.UpdateLayout ();  	}  	renderer.FinallyApplyChangesToCanvas ();  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runLinux,The following statement contains a magic number: while (true) {  	int pollRes = Libc.poll (fds' 2' nextwait);  	if (pollRes == 0) {  		if (nextwait == -1)  			throw new InvalidOperationException ("Assertion failed.");  		if (TermKeyResult.TERMKEY_RES_KEY == LibTermKey.termkey_getkey_force (termkeyHandle' ref key)) {  			processLinuxInput (key);  		}  	}  	if (pollRes == -1) {  		int errorCode = Marshal.GetLastWin32Error ();  		if (errorCode != Libc.EINTR) {  			throw new InvalidOperationException (string.Format ("poll() returned with error code {0}"' errorCode));  		}  	}  	if (fds [1].revents != POLL_EVENTS.NONE) {  		UInt64 u;  		Libc.readInt64 (fds [1].fd' out u);  		if (u == 1) {  			// Exit from application  			#if !WIN32  									        signal_thread.Abort (); #endif  			break;  		}  		if (u == 2) {  			// Get new term size and process appropriate INPUT_RECORD event  			INPUT_RECORD inputRecord = new INPUT_RECORD ();  			inputRecord.EventType = EventType.WINDOW_BUFFER_SIZE_EVENT;  			winsize ws = Libc.GetTerminalSize (isDarwin);  			inputRecord.WindowBufferSizeEvent.dwSize.X = (short)ws.ws_col;  			inputRecord.WindowBufferSizeEvent.dwSize.Y = (short)ws.ws_row;  			processInputEvent (inputRecord);  		}  		if (u == 3) {  			// It is signal from async actions invocation stuff  		}  	}  	if ((fds [0].revents & POLL_EVENTS.POLLIN) == POLL_EVENTS.POLLIN || (fds [0].revents & POLL_EVENTS.POLLHUP) == POLL_EVENTS.POLLHUP || (fds [0].revents & POLL_EVENTS.POLLERR) == POLL_EVENTS.POLLERR) {  		LibTermKey.termkey_advisereadable (termkeyHandle);  	}  	TermKeyResult result = (LibTermKey.termkey_getkey (termkeyHandle' ref key));  	while (result == TermKeyResult.TERMKEY_RES_KEY) {  		processLinuxInput (key);  		result = (LibTermKey.termkey_getkey (termkeyHandle' ref key));  	}  	if (result == TermKeyResult.TERMKEY_RES_AGAIN) {  		nextwait = LibTermKey.termkey_get_waittime (termkeyHandle);  	} else {  		nextwait = -1;  	}  	while (true) {  		bool anyInvokeActions = isAnyInvokeActions ();  		bool anyRoutedEvent = !EventManager.IsQueueEmpty ();  		bool anyLayoutToRevalidate = renderer.AnyControlInvalidated;  		if (!anyInvokeActions && !anyRoutedEvent && !anyLayoutToRevalidate)  			break;  		EventManager.ProcessEvents ();  		processInvokeActions ();  		renderer.UpdateLayout ();  	}  	renderer.FinallyApplyChangesToCanvas ();  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runLinux,The following statement contains a magic number: while (true) {  	int pollRes = Libc.poll (fds' 2' nextwait);  	if (pollRes == 0) {  		if (nextwait == -1)  			throw new InvalidOperationException ("Assertion failed.");  		if (TermKeyResult.TERMKEY_RES_KEY == LibTermKey.termkey_getkey_force (termkeyHandle' ref key)) {  			processLinuxInput (key);  		}  	}  	if (pollRes == -1) {  		int errorCode = Marshal.GetLastWin32Error ();  		if (errorCode != Libc.EINTR) {  			throw new InvalidOperationException (string.Format ("poll() returned with error code {0}"' errorCode));  		}  	}  	if (fds [1].revents != POLL_EVENTS.NONE) {  		UInt64 u;  		Libc.readInt64 (fds [1].fd' out u);  		if (u == 1) {  			// Exit from application  			#if !WIN32  									        signal_thread.Abort (); #endif  			break;  		}  		if (u == 2) {  			// Get new term size and process appropriate INPUT_RECORD event  			INPUT_RECORD inputRecord = new INPUT_RECORD ();  			inputRecord.EventType = EventType.WINDOW_BUFFER_SIZE_EVENT;  			winsize ws = Libc.GetTerminalSize (isDarwin);  			inputRecord.WindowBufferSizeEvent.dwSize.X = (short)ws.ws_col;  			inputRecord.WindowBufferSizeEvent.dwSize.Y = (short)ws.ws_row;  			processInputEvent (inputRecord);  		}  		if (u == 3) {  			// It is signal from async actions invocation stuff  		}  	}  	if ((fds [0].revents & POLL_EVENTS.POLLIN) == POLL_EVENTS.POLLIN || (fds [0].revents & POLL_EVENTS.POLLHUP) == POLL_EVENTS.POLLHUP || (fds [0].revents & POLL_EVENTS.POLLERR) == POLL_EVENTS.POLLERR) {  		LibTermKey.termkey_advisereadable (termkeyHandle);  	}  	TermKeyResult result = (LibTermKey.termkey_getkey (termkeyHandle' ref key));  	while (result == TermKeyResult.TERMKEY_RES_KEY) {  		processLinuxInput (key);  		result = (LibTermKey.termkey_getkey (termkeyHandle' ref key));  	}  	if (result == TermKeyResult.TERMKEY_RES_AGAIN) {  		nextwait = LibTermKey.termkey_get_waittime (termkeyHandle);  	} else {  		nextwait = -1;  	}  	while (true) {  		bool anyInvokeActions = isAnyInvokeActions ();  		bool anyRoutedEvent = !EventManager.IsQueueEmpty ();  		bool anyLayoutToRevalidate = renderer.AnyControlInvalidated;  		if (!anyInvokeActions && !anyRoutedEvent && !anyLayoutToRevalidate)  			break;  		EventManager.ProcessEvents ();  		processInvokeActions ();  		renderer.UpdateLayout ();  	}  	renderer.FinallyApplyChangesToCanvas ();  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runLinux,The following statement contains a magic number: if (fds [1].revents != POLL_EVENTS.NONE) {  	UInt64 u;  	Libc.readInt64 (fds [1].fd' out u);  	if (u == 1) {  		// Exit from application  		#if !WIN32  								        signal_thread.Abort (); #endif  		break;  	}  	if (u == 2) {  		// Get new term size and process appropriate INPUT_RECORD event  		INPUT_RECORD inputRecord = new INPUT_RECORD ();  		inputRecord.EventType = EventType.WINDOW_BUFFER_SIZE_EVENT;  		winsize ws = Libc.GetTerminalSize (isDarwin);  		inputRecord.WindowBufferSizeEvent.dwSize.X = (short)ws.ws_col;  		inputRecord.WindowBufferSizeEvent.dwSize.Y = (short)ws.ws_row;  		processInputEvent (inputRecord);  	}  	if (u == 3) {  		// It is signal from async actions invocation stuff  	}  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runLinux,The following statement contains a magic number: if (fds [1].revents != POLL_EVENTS.NONE) {  	UInt64 u;  	Libc.readInt64 (fds [1].fd' out u);  	if (u == 1) {  		// Exit from application  		#if !WIN32  								        signal_thread.Abort (); #endif  		break;  	}  	if (u == 2) {  		// Get new term size and process appropriate INPUT_RECORD event  		INPUT_RECORD inputRecord = new INPUT_RECORD ();  		inputRecord.EventType = EventType.WINDOW_BUFFER_SIZE_EVENT;  		winsize ws = Libc.GetTerminalSize (isDarwin);  		inputRecord.WindowBufferSizeEvent.dwSize.X = (short)ws.ws_col;  		inputRecord.WindowBufferSizeEvent.dwSize.Y = (short)ws.ws_row;  		processInputEvent (inputRecord);  	}  	if (u == 3) {  		// It is signal from async actions invocation stuff  	}  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runLinux,The following statement contains a magic number: if (u == 2) {  	// Get new term size and process appropriate INPUT_RECORD event  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.WINDOW_BUFFER_SIZE_EVENT;  	winsize ws = Libc.GetTerminalSize (isDarwin);  	inputRecord.WindowBufferSizeEvent.dwSize.X = (short)ws.ws_col;  	inputRecord.WindowBufferSizeEvent.dwSize.Y = (short)ws.ws_row;  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runLinux,The following statement contains a magic number: if (u == 3) {  	// It is signal from async actions invocation stuff  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_KEYSYM) {  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	switch (key.code.sym) {  	case TermKeySym.TERMKEY_SYM_TAB:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Tab;  		break;  	case TermKeySym.TERMKEY_SYM_ENTER:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Return;  		break;  	// in gnome-terminal it is backspace by default  	// (see default compatibility settings in Profile's settings)  	case TermKeySym.TERMKEY_SYM_DEL:  	case TermKeySym.TERMKEY_SYM_BACKSPACE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Back;  		break;  	case TermKeySym.TERMKEY_SYM_DELETE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Delete;  		break;  	case TermKeySym.TERMKEY_SYM_HOME:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Home;  		break;  	case TermKeySym.TERMKEY_SYM_END:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.End;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEUP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Prior;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEDOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Next;  		break;  	case TermKeySym.TERMKEY_SYM_SPACE:  		inputRecord.KeyEvent.UnicodeChar = ' ';  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Space;  		break;  	case TermKeySym.TERMKEY_SYM_ESCAPE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Escape;  		break;  	case TermKeySym.TERMKEY_SYM_INSERT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Insert;  		break;  	case TermKeySym.TERMKEY_SYM_UP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Up;  		break;  	case TermKeySym.TERMKEY_SYM_DOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Down;  		break;  	case TermKeySym.TERMKEY_SYM_LEFT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Left;  		break;  	case TermKeySym.TERMKEY_SYM_RIGHT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Right;  		break;  	default:  		throw new NotSupportedException ("Not supported keyboard code detected: " + key.code.sym);  	}  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	processInputEvent (inputRecord);  } else if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_KEYSYM) {  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	switch (key.code.sym) {  	case TermKeySym.TERMKEY_SYM_TAB:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Tab;  		break;  	case TermKeySym.TERMKEY_SYM_ENTER:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Return;  		break;  	// in gnome-terminal it is backspace by default  	// (see default compatibility settings in Profile's settings)  	case TermKeySym.TERMKEY_SYM_DEL:  	case TermKeySym.TERMKEY_SYM_BACKSPACE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Back;  		break;  	case TermKeySym.TERMKEY_SYM_DELETE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Delete;  		break;  	case TermKeySym.TERMKEY_SYM_HOME:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Home;  		break;  	case TermKeySym.TERMKEY_SYM_END:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.End;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEUP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Prior;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEDOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Next;  		break;  	case TermKeySym.TERMKEY_SYM_SPACE:  		inputRecord.KeyEvent.UnicodeChar = ' ';  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Space;  		break;  	case TermKeySym.TERMKEY_SYM_ESCAPE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Escape;  		break;  	case TermKeySym.TERMKEY_SYM_INSERT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Insert;  		break;  	case TermKeySym.TERMKEY_SYM_UP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Up;  		break;  	case TermKeySym.TERMKEY_SYM_DOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Down;  		break;  	case TermKeySym.TERMKEY_SYM_LEFT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Left;  		break;  	case TermKeySym.TERMKEY_SYM_RIGHT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Right;  		break;  	default:  		throw new NotSupportedException ("Not supported keyboard code detected: " + key.code.sym);  	}  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	processInputEvent (inputRecord);  } else if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_KEYSYM) {  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	switch (key.code.sym) {  	case TermKeySym.TERMKEY_SYM_TAB:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Tab;  		break;  	case TermKeySym.TERMKEY_SYM_ENTER:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Return;  		break;  	// in gnome-terminal it is backspace by default  	// (see default compatibility settings in Profile's settings)  	case TermKeySym.TERMKEY_SYM_DEL:  	case TermKeySym.TERMKEY_SYM_BACKSPACE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Back;  		break;  	case TermKeySym.TERMKEY_SYM_DELETE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Delete;  		break;  	case TermKeySym.TERMKEY_SYM_HOME:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Home;  		break;  	case TermKeySym.TERMKEY_SYM_END:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.End;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEUP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Prior;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEDOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Next;  		break;  	case TermKeySym.TERMKEY_SYM_SPACE:  		inputRecord.KeyEvent.UnicodeChar = ' ';  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Space;  		break;  	case TermKeySym.TERMKEY_SYM_ESCAPE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Escape;  		break;  	case TermKeySym.TERMKEY_SYM_INSERT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Insert;  		break;  	case TermKeySym.TERMKEY_SYM_UP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Up;  		break;  	case TermKeySym.TERMKEY_SYM_DOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Down;  		break;  	case TermKeySym.TERMKEY_SYM_LEFT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Left;  		break;  	case TermKeySym.TERMKEY_SYM_RIGHT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Right;  		break;  	default:  		throw new NotSupportedException ("Not supported keyboard code detected: " + key.code.sym);  	}  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	processInputEvent (inputRecord);  } else if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_KEYSYM) {  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	switch (key.code.sym) {  	case TermKeySym.TERMKEY_SYM_TAB:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Tab;  		break;  	case TermKeySym.TERMKEY_SYM_ENTER:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Return;  		break;  	// in gnome-terminal it is backspace by default  	// (see default compatibility settings in Profile's settings)  	case TermKeySym.TERMKEY_SYM_DEL:  	case TermKeySym.TERMKEY_SYM_BACKSPACE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Back;  		break;  	case TermKeySym.TERMKEY_SYM_DELETE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Delete;  		break;  	case TermKeySym.TERMKEY_SYM_HOME:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Home;  		break;  	case TermKeySym.TERMKEY_SYM_END:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.End;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEUP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Prior;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEDOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Next;  		break;  	case TermKeySym.TERMKEY_SYM_SPACE:  		inputRecord.KeyEvent.UnicodeChar = ' ';  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Space;  		break;  	case TermKeySym.TERMKEY_SYM_ESCAPE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Escape;  		break;  	case TermKeySym.TERMKEY_SYM_INSERT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Insert;  		break;  	case TermKeySym.TERMKEY_SYM_UP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Up;  		break;  	case TermKeySym.TERMKEY_SYM_DOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Down;  		break;  	case TermKeySym.TERMKEY_SYM_LEFT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Left;  		break;  	case TermKeySym.TERMKEY_SYM_RIGHT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Right;  		break;  	default:  		throw new NotSupportedException ("Not supported keyboard code detected: " + key.code.sym);  	}  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	processInputEvent (inputRecord);  } else if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_KEYSYM) {  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	switch (key.code.sym) {  	case TermKeySym.TERMKEY_SYM_TAB:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Tab;  		break;  	case TermKeySym.TERMKEY_SYM_ENTER:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Return;  		break;  	// in gnome-terminal it is backspace by default  	// (see default compatibility settings in Profile's settings)  	case TermKeySym.TERMKEY_SYM_DEL:  	case TermKeySym.TERMKEY_SYM_BACKSPACE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Back;  		break;  	case TermKeySym.TERMKEY_SYM_DELETE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Delete;  		break;  	case TermKeySym.TERMKEY_SYM_HOME:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Home;  		break;  	case TermKeySym.TERMKEY_SYM_END:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.End;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEUP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Prior;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEDOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Next;  		break;  	case TermKeySym.TERMKEY_SYM_SPACE:  		inputRecord.KeyEvent.UnicodeChar = ' ';  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Space;  		break;  	case TermKeySym.TERMKEY_SYM_ESCAPE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Escape;  		break;  	case TermKeySym.TERMKEY_SYM_INSERT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Insert;  		break;  	case TermKeySym.TERMKEY_SYM_UP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Up;  		break;  	case TermKeySym.TERMKEY_SYM_DOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Down;  		break;  	case TermKeySym.TERMKEY_SYM_LEFT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Left;  		break;  	case TermKeySym.TERMKEY_SYM_RIGHT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Right;  		break;  	default:  		throw new NotSupportedException ("Not supported keyboard code detected: " + key.code.sym);  	}  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	processInputEvent (inputRecord);  } else if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_KEYSYM) {  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	switch (key.code.sym) {  	case TermKeySym.TERMKEY_SYM_TAB:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Tab;  		break;  	case TermKeySym.TERMKEY_SYM_ENTER:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Return;  		break;  	// in gnome-terminal it is backspace by default  	// (see default compatibility settings in Profile's settings)  	case TermKeySym.TERMKEY_SYM_DEL:  	case TermKeySym.TERMKEY_SYM_BACKSPACE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Back;  		break;  	case TermKeySym.TERMKEY_SYM_DELETE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Delete;  		break;  	case TermKeySym.TERMKEY_SYM_HOME:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Home;  		break;  	case TermKeySym.TERMKEY_SYM_END:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.End;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEUP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Prior;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEDOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Next;  		break;  	case TermKeySym.TERMKEY_SYM_SPACE:  		inputRecord.KeyEvent.UnicodeChar = ' ';  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Space;  		break;  	case TermKeySym.TERMKEY_SYM_ESCAPE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Escape;  		break;  	case TermKeySym.TERMKEY_SYM_INSERT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Insert;  		break;  	case TermKeySym.TERMKEY_SYM_UP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Up;  		break;  	case TermKeySym.TERMKEY_SYM_DOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Down;  		break;  	case TermKeySym.TERMKEY_SYM_LEFT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Left;  		break;  	case TermKeySym.TERMKEY_SYM_RIGHT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Right;  		break;  	default:  		throw new NotSupportedException ("Not supported keyboard code detected: " + key.code.sym);  	}  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	processInputEvent (inputRecord);  } else if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_KEYSYM) {  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	switch (key.code.sym) {  	case TermKeySym.TERMKEY_SYM_TAB:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Tab;  		break;  	case TermKeySym.TERMKEY_SYM_ENTER:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Return;  		break;  	// in gnome-terminal it is backspace by default  	// (see default compatibility settings in Profile's settings)  	case TermKeySym.TERMKEY_SYM_DEL:  	case TermKeySym.TERMKEY_SYM_BACKSPACE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Back;  		break;  	case TermKeySym.TERMKEY_SYM_DELETE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Delete;  		break;  	case TermKeySym.TERMKEY_SYM_HOME:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Home;  		break;  	case TermKeySym.TERMKEY_SYM_END:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.End;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEUP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Prior;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEDOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Next;  		break;  	case TermKeySym.TERMKEY_SYM_SPACE:  		inputRecord.KeyEvent.UnicodeChar = ' ';  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Space;  		break;  	case TermKeySym.TERMKEY_SYM_ESCAPE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Escape;  		break;  	case TermKeySym.TERMKEY_SYM_INSERT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Insert;  		break;  	case TermKeySym.TERMKEY_SYM_UP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Up;  		break;  	case TermKeySym.TERMKEY_SYM_DOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Down;  		break;  	case TermKeySym.TERMKEY_SYM_LEFT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Left;  		break;  	case TermKeySym.TERMKEY_SYM_RIGHT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Right;  		break;  	default:  		throw new NotSupportedException ("Not supported keyboard code detected: " + key.code.sym);  	}  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	processInputEvent (inputRecord);  } else if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_KEYSYM) {  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	switch (key.code.sym) {  	case TermKeySym.TERMKEY_SYM_TAB:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Tab;  		break;  	case TermKeySym.TERMKEY_SYM_ENTER:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Return;  		break;  	// in gnome-terminal it is backspace by default  	// (see default compatibility settings in Profile's settings)  	case TermKeySym.TERMKEY_SYM_DEL:  	case TermKeySym.TERMKEY_SYM_BACKSPACE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Back;  		break;  	case TermKeySym.TERMKEY_SYM_DELETE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Delete;  		break;  	case TermKeySym.TERMKEY_SYM_HOME:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Home;  		break;  	case TermKeySym.TERMKEY_SYM_END:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.End;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEUP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Prior;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEDOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Next;  		break;  	case TermKeySym.TERMKEY_SYM_SPACE:  		inputRecord.KeyEvent.UnicodeChar = ' ';  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Space;  		break;  	case TermKeySym.TERMKEY_SYM_ESCAPE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Escape;  		break;  	case TermKeySym.TERMKEY_SYM_INSERT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Insert;  		break;  	case TermKeySym.TERMKEY_SYM_UP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Up;  		break;  	case TermKeySym.TERMKEY_SYM_DOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Down;  		break;  	case TermKeySym.TERMKEY_SYM_LEFT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Left;  		break;  	case TermKeySym.TERMKEY_SYM_RIGHT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Right;  		break;  	default:  		throw new NotSupportedException ("Not supported keyboard code detected: " + key.code.sym);  	}  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	processInputEvent (inputRecord);  } else if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_KEYSYM) {  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	switch (key.code.sym) {  	case TermKeySym.TERMKEY_SYM_TAB:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Tab;  		break;  	case TermKeySym.TERMKEY_SYM_ENTER:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Return;  		break;  	// in gnome-terminal it is backspace by default  	// (see default compatibility settings in Profile's settings)  	case TermKeySym.TERMKEY_SYM_DEL:  	case TermKeySym.TERMKEY_SYM_BACKSPACE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Back;  		break;  	case TermKeySym.TERMKEY_SYM_DELETE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Delete;  		break;  	case TermKeySym.TERMKEY_SYM_HOME:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Home;  		break;  	case TermKeySym.TERMKEY_SYM_END:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.End;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEUP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Prior;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEDOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Next;  		break;  	case TermKeySym.TERMKEY_SYM_SPACE:  		inputRecord.KeyEvent.UnicodeChar = ' ';  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Space;  		break;  	case TermKeySym.TERMKEY_SYM_ESCAPE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Escape;  		break;  	case TermKeySym.TERMKEY_SYM_INSERT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Insert;  		break;  	case TermKeySym.TERMKEY_SYM_UP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Up;  		break;  	case TermKeySym.TERMKEY_SYM_DOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Down;  		break;  	case TermKeySym.TERMKEY_SYM_LEFT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Left;  		break;  	case TermKeySym.TERMKEY_SYM_RIGHT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Right;  		break;  	default:  		throw new NotSupportedException ("Not supported keyboard code detected: " + key.code.sym);  	}  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	processInputEvent (inputRecord);  } else if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_KEYSYM) {  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	switch (key.code.sym) {  	case TermKeySym.TERMKEY_SYM_TAB:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Tab;  		break;  	case TermKeySym.TERMKEY_SYM_ENTER:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Return;  		break;  	// in gnome-terminal it is backspace by default  	// (see default compatibility settings in Profile's settings)  	case TermKeySym.TERMKEY_SYM_DEL:  	case TermKeySym.TERMKEY_SYM_BACKSPACE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Back;  		break;  	case TermKeySym.TERMKEY_SYM_DELETE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Delete;  		break;  	case TermKeySym.TERMKEY_SYM_HOME:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Home;  		break;  	case TermKeySym.TERMKEY_SYM_END:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.End;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEUP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Prior;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEDOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Next;  		break;  	case TermKeySym.TERMKEY_SYM_SPACE:  		inputRecord.KeyEvent.UnicodeChar = ' ';  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Space;  		break;  	case TermKeySym.TERMKEY_SYM_ESCAPE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Escape;  		break;  	case TermKeySym.TERMKEY_SYM_INSERT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Insert;  		break;  	case TermKeySym.TERMKEY_SYM_UP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Up;  		break;  	case TermKeySym.TERMKEY_SYM_DOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Down;  		break;  	case TermKeySym.TERMKEY_SYM_LEFT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Left;  		break;  	case TermKeySym.TERMKEY_SYM_RIGHT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Right;  		break;  	default:  		throw new NotSupportedException ("Not supported keyboard code detected: " + key.code.sym);  	}  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	processInputEvent (inputRecord);  } else if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_KEYSYM) {  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	switch (key.code.sym) {  	case TermKeySym.TERMKEY_SYM_TAB:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Tab;  		break;  	case TermKeySym.TERMKEY_SYM_ENTER:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Return;  		break;  	// in gnome-terminal it is backspace by default  	// (see default compatibility settings in Profile's settings)  	case TermKeySym.TERMKEY_SYM_DEL:  	case TermKeySym.TERMKEY_SYM_BACKSPACE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Back;  		break;  	case TermKeySym.TERMKEY_SYM_DELETE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Delete;  		break;  	case TermKeySym.TERMKEY_SYM_HOME:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Home;  		break;  	case TermKeySym.TERMKEY_SYM_END:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.End;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEUP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Prior;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEDOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Next;  		break;  	case TermKeySym.TERMKEY_SYM_SPACE:  		inputRecord.KeyEvent.UnicodeChar = ' ';  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Space;  		break;  	case TermKeySym.TERMKEY_SYM_ESCAPE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Escape;  		break;  	case TermKeySym.TERMKEY_SYM_INSERT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Insert;  		break;  	case TermKeySym.TERMKEY_SYM_UP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Up;  		break;  	case TermKeySym.TERMKEY_SYM_DOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Down;  		break;  	case TermKeySym.TERMKEY_SYM_LEFT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Left;  		break;  	case TermKeySym.TERMKEY_SYM_RIGHT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Right;  		break;  	default:  		throw new NotSupportedException ("Not supported keyboard code detected: " + key.code.sym);  	}  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	processInputEvent (inputRecord);  } else if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_KEYSYM) {  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	switch (key.code.sym) {  	case TermKeySym.TERMKEY_SYM_TAB:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Tab;  		break;  	case TermKeySym.TERMKEY_SYM_ENTER:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Return;  		break;  	// in gnome-terminal it is backspace by default  	// (see default compatibility settings in Profile's settings)  	case TermKeySym.TERMKEY_SYM_DEL:  	case TermKeySym.TERMKEY_SYM_BACKSPACE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Back;  		break;  	case TermKeySym.TERMKEY_SYM_DELETE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Delete;  		break;  	case TermKeySym.TERMKEY_SYM_HOME:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Home;  		break;  	case TermKeySym.TERMKEY_SYM_END:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.End;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEUP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Prior;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEDOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Next;  		break;  	case TermKeySym.TERMKEY_SYM_SPACE:  		inputRecord.KeyEvent.UnicodeChar = ' ';  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Space;  		break;  	case TermKeySym.TERMKEY_SYM_ESCAPE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Escape;  		break;  	case TermKeySym.TERMKEY_SYM_INSERT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Insert;  		break;  	case TermKeySym.TERMKEY_SYM_UP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Up;  		break;  	case TermKeySym.TERMKEY_SYM_DOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Down;  		break;  	case TermKeySym.TERMKEY_SYM_LEFT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Left;  		break;  	case TermKeySym.TERMKEY_SYM_RIGHT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Right;  		break;  	default:  		throw new NotSupportedException ("Not supported keyboard code detected: " + key.code.sym);  	}  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	processInputEvent (inputRecord);  } else if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_KEYSYM) {  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	switch (key.code.sym) {  	case TermKeySym.TERMKEY_SYM_TAB:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Tab;  		break;  	case TermKeySym.TERMKEY_SYM_ENTER:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Return;  		break;  	// in gnome-terminal it is backspace by default  	// (see default compatibility settings in Profile's settings)  	case TermKeySym.TERMKEY_SYM_DEL:  	case TermKeySym.TERMKEY_SYM_BACKSPACE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Back;  		break;  	case TermKeySym.TERMKEY_SYM_DELETE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Delete;  		break;  	case TermKeySym.TERMKEY_SYM_HOME:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Home;  		break;  	case TermKeySym.TERMKEY_SYM_END:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.End;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEUP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Prior;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEDOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Next;  		break;  	case TermKeySym.TERMKEY_SYM_SPACE:  		inputRecord.KeyEvent.UnicodeChar = ' ';  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Space;  		break;  	case TermKeySym.TERMKEY_SYM_ESCAPE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Escape;  		break;  	case TermKeySym.TERMKEY_SYM_INSERT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Insert;  		break;  	case TermKeySym.TERMKEY_SYM_UP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Up;  		break;  	case TermKeySym.TERMKEY_SYM_DOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Down;  		break;  	case TermKeySym.TERMKEY_SYM_LEFT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Left;  		break;  	case TermKeySym.TERMKEY_SYM_RIGHT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Right;  		break;  	default:  		throw new NotSupportedException ("Not supported keyboard code detected: " + key.code.sym);  	}  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	processInputEvent (inputRecord);  } else if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_KEYSYM) {  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	switch (key.code.sym) {  	case TermKeySym.TERMKEY_SYM_TAB:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Tab;  		break;  	case TermKeySym.TERMKEY_SYM_ENTER:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Return;  		break;  	// in gnome-terminal it is backspace by default  	// (see default compatibility settings in Profile's settings)  	case TermKeySym.TERMKEY_SYM_DEL:  	case TermKeySym.TERMKEY_SYM_BACKSPACE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Back;  		break;  	case TermKeySym.TERMKEY_SYM_DELETE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Delete;  		break;  	case TermKeySym.TERMKEY_SYM_HOME:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Home;  		break;  	case TermKeySym.TERMKEY_SYM_END:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.End;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEUP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Prior;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEDOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Next;  		break;  	case TermKeySym.TERMKEY_SYM_SPACE:  		inputRecord.KeyEvent.UnicodeChar = ' ';  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Space;  		break;  	case TermKeySym.TERMKEY_SYM_ESCAPE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Escape;  		break;  	case TermKeySym.TERMKEY_SYM_INSERT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Insert;  		break;  	case TermKeySym.TERMKEY_SYM_UP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Up;  		break;  	case TermKeySym.TERMKEY_SYM_DOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Down;  		break;  	case TermKeySym.TERMKEY_SYM_LEFT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Left;  		break;  	case TermKeySym.TERMKEY_SYM_RIGHT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Right;  		break;  	default:  		throw new NotSupportedException ("Not supported keyboard code detected: " + key.code.sym);  	}  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	processInputEvent (inputRecord);  } else if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_KEYSYM) {  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	switch (key.code.sym) {  	case TermKeySym.TERMKEY_SYM_TAB:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Tab;  		break;  	case TermKeySym.TERMKEY_SYM_ENTER:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Return;  		break;  	// in gnome-terminal it is backspace by default  	// (see default compatibility settings in Profile's settings)  	case TermKeySym.TERMKEY_SYM_DEL:  	case TermKeySym.TERMKEY_SYM_BACKSPACE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Back;  		break;  	case TermKeySym.TERMKEY_SYM_DELETE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Delete;  		break;  	case TermKeySym.TERMKEY_SYM_HOME:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Home;  		break;  	case TermKeySym.TERMKEY_SYM_END:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.End;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEUP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Prior;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEDOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Next;  		break;  	case TermKeySym.TERMKEY_SYM_SPACE:  		inputRecord.KeyEvent.UnicodeChar = ' ';  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Space;  		break;  	case TermKeySym.TERMKEY_SYM_ESCAPE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Escape;  		break;  	case TermKeySym.TERMKEY_SYM_INSERT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Insert;  		break;  	case TermKeySym.TERMKEY_SYM_UP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Up;  		break;  	case TermKeySym.TERMKEY_SYM_DOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Down;  		break;  	case TermKeySym.TERMKEY_SYM_LEFT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Left;  		break;  	case TermKeySym.TERMKEY_SYM_RIGHT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Right;  		break;  	default:  		throw new NotSupportedException ("Not supported keyboard code detected: " + key.code.sym);  	}  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	processInputEvent (inputRecord);  } else if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_KEYSYM) {  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	switch (key.code.sym) {  	case TermKeySym.TERMKEY_SYM_TAB:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Tab;  		break;  	case TermKeySym.TERMKEY_SYM_ENTER:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Return;  		break;  	// in gnome-terminal it is backspace by default  	// (see default compatibility settings in Profile's settings)  	case TermKeySym.TERMKEY_SYM_DEL:  	case TermKeySym.TERMKEY_SYM_BACKSPACE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Back;  		break;  	case TermKeySym.TERMKEY_SYM_DELETE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Delete;  		break;  	case TermKeySym.TERMKEY_SYM_HOME:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Home;  		break;  	case TermKeySym.TERMKEY_SYM_END:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.End;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEUP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Prior;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEDOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Next;  		break;  	case TermKeySym.TERMKEY_SYM_SPACE:  		inputRecord.KeyEvent.UnicodeChar = ' ';  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Space;  		break;  	case TermKeySym.TERMKEY_SYM_ESCAPE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Escape;  		break;  	case TermKeySym.TERMKEY_SYM_INSERT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Insert;  		break;  	case TermKeySym.TERMKEY_SYM_UP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Up;  		break;  	case TermKeySym.TERMKEY_SYM_DOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Down;  		break;  	case TermKeySym.TERMKEY_SYM_LEFT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Left;  		break;  	case TermKeySym.TERMKEY_SYM_RIGHT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Right;  		break;  	default:  		throw new NotSupportedException ("Not supported keyboard code detected: " + key.code.sym);  	}  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	processInputEvent (inputRecord);  } else if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_KEYSYM) {  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	switch (key.code.sym) {  	case TermKeySym.TERMKEY_SYM_TAB:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Tab;  		break;  	case TermKeySym.TERMKEY_SYM_ENTER:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Return;  		break;  	// in gnome-terminal it is backspace by default  	// (see default compatibility settings in Profile's settings)  	case TermKeySym.TERMKEY_SYM_DEL:  	case TermKeySym.TERMKEY_SYM_BACKSPACE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Back;  		break;  	case TermKeySym.TERMKEY_SYM_DELETE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Delete;  		break;  	case TermKeySym.TERMKEY_SYM_HOME:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Home;  		break;  	case TermKeySym.TERMKEY_SYM_END:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.End;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEUP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Prior;  		break;  	case TermKeySym.TERMKEY_SYM_PAGEDOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Next;  		break;  	case TermKeySym.TERMKEY_SYM_SPACE:  		inputRecord.KeyEvent.UnicodeChar = ' ';  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Space;  		break;  	case TermKeySym.TERMKEY_SYM_ESCAPE:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Escape;  		break;  	case TermKeySym.TERMKEY_SYM_INSERT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Insert;  		break;  	case TermKeySym.TERMKEY_SYM_UP:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Up;  		break;  	case TermKeySym.TERMKEY_SYM_DOWN:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Down;  		break;  	case TermKeySym.TERMKEY_SYM_LEFT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Left;  		break;  	case TermKeySym.TERMKEY_SYM_RIGHT:  		inputRecord.KeyEvent.wVirtualKeyCode = VirtualKeys.Right;  		break;  	default:  		throw new NotSupportedException ("Not supported keyboard code detected: " + key.code.sym);  	}  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	processInputEvent (inputRecord);  } else if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if ((key.modifiers & 4) == 4) {  	inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if ((key.modifiers & 4) == 4) {  	inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if ((key.modifiers & 2) == 2) {  	inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if ((key.modifiers & 2) == 2) {  	inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_UNICODE) {  	byte[] data = new byte[7];  	data [0] = key.utf8_0;  	data [1] = key.utf8_1;  	data [2] = key.utf8_2;  	data [3] = key.utf8_3;  	data [4] = key.utf8_4;  	data [5] = key.utf8_5;  	data [6] = key.utf8_6;  	string d = System.Text.Encoding.UTF8.GetString (data);  	char unicodeCharacter = d [0];  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.KEY_EVENT;  	inputRecord.KeyEvent.bKeyDown = true;  	inputRecord.KeyEvent.wRepeatCount = 1;  	inputRecord.KeyEvent.UnicodeChar = unicodeCharacter;  	inputRecord.KeyEvent.dwControlKeyState = 0;  	if (char.IsLetterOrDigit (unicodeCharacter)) {  		if (char.IsDigit (unicodeCharacter)) {  			inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(unicodeCharacter - '0' + (int)VirtualKeys.N0);  		} else {  			char lowercased = char.ToLowerInvariant (unicodeCharacter);  			// Only english characters can be converted to VirtualKeys  			if (lowercased >= 'a' && lowercased <= 'z') {  				inputRecord.KeyEvent.wVirtualKeyCode = (VirtualKeys)(lowercased - 'a' + (int)VirtualKeys.A);  			}  		}  	}  	if ((key.modifiers & 4) == 4) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  	}  	if ((key.modifiers & 2) == 2) {  		inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  	}  	// todo : remove hardcoded exit combo after testing  	if (unicodeCharacter == 'd' && key.modifiers == 4) {  		Exit ();  	}  	processInputEvent (inputRecord);  	//  } else if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: data [2] = key.utf8_2;  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: data [3] = key.utf8_3;  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: data [4] = key.utf8_4;  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: data [5] = key.utf8_5;  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: data [6] = key.utf8_6;  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if ((key.modifiers & 4) == 4) {  	inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if ((key.modifiers & 4) == 4) {  	inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_CTRL_PRESSED;  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if ((key.modifiers & 2) == 2) {  	inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if ((key.modifiers & 2) == 2) {  	inputRecord.KeyEvent.dwControlKeyState |= ControlKeyState.LEFT_ALT_PRESSED;  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (unicodeCharacter == 'd' && key.modifiers == 4) {  	Exit ();  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (key.type == TermKeyType.TERMKEY_TYPE_MOUSE) {  	TermKeyMouseEvent ev;  	int button;  	int line' col;  	LibTermKey.termkey_interpret_mouse (termkeyHandle' ref key' out ev' out button' out line' out col);  	//  	INPUT_RECORD inputRecord = new INPUT_RECORD ();  	inputRecord.EventType = EventType.MOUSE_EVENT;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS || ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.PRESSED_OR_RELEASED;  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG)  		inputRecord.MouseEvent.dwEventFlags = MouseEventFlags.MOUSE_MOVED;  	inputRecord.MouseEvent.dwMousePosition = new COORD ((short)(col - 1)' (short)(line - 1));  	if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  		inputRecord.MouseEvent.dwButtonState = 0;  	} else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  		if (1 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  		} else if (2 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  		} else if (3 == button) {  			inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  		}  	}  	//  	processInputEvent (inputRecord);  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  	inputRecord.MouseEvent.dwButtonState = 0;  } else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  	if (1 == button) {  		inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  	} else if (2 == button) {  		inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  	} else if (3 == button) {  		inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  	}  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_RELEASE) {  	inputRecord.MouseEvent.dwButtonState = 0;  } else if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  	if (1 == button) {  		inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  	} else if (2 == button) {  		inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  	} else if (3 == button) {  		inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  	}  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  	if (1 == button) {  		inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  	} else if (2 == button) {  		inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  	} else if (3 == button) {  		inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  	}  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (ev == TermKeyMouseEvent.TERMKEY_MOUSE_DRAG || ev == TermKeyMouseEvent.TERMKEY_MOUSE_PRESS) {  	if (1 == button) {  		inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  	} else if (2 == button) {  		inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  	} else if (3 == button) {  		inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  	}  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (1 == button) {  	inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  } else if (2 == button) {  	inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  } else if (3 == button) {  	inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (1 == button) {  	inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_1ST_BUTTON_PRESSED;  } else if (2 == button) {  	inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  } else if (3 == button) {  	inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (2 == button) {  	inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  } else if (3 == button) {  	inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (2 == button) {  	inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.FROM_LEFT_2ND_BUTTON_PRESSED;  } else if (3 == button) {  	inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,processLinuxInput,The following statement contains a magic number: if (3 == button) {  	inputRecord.MouseEvent.dwButtonState = MOUSE_BUTTON_STATE.RIGHTMOST_BUTTON_PRESSED;  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runWindows,The following statement contains a magic number: while (true) {  	// 100 ms instead of Win32.INFINITE to check console window Zoomed and Iconic  	// state periodically (because if user presses Maximize/Restore button  	// there are no input event generated).  	uint waitResult = Win32.WaitForMultipleObjects (3' handles' false' 100);  	if (waitResult == 0) {  		break;  	}  	if (waitResult == 1) {  		processInput ();  	}  	if (waitResult == 2) {  		// Do nothing special - because invokeActions will be invoked in loop anyway  	}  	// If we received WAIT_TIMEOUT - check window Zoomed and Iconic state  	// and correct buffer size and console window size  	if (waitResult == 0x00000102) {  		IntPtr consoleWindow = getConsoleWindowHwnd ();  		bool isZoomed = Win32.IsZoomed (consoleWindow);  		bool isIconic = Win32.IsIconic (consoleWindow);  		if (maximized != isZoomed && !isIconic) {  			if (isZoomed)  				Maximize ();  			else  				Restore ();  		}  		if (!maximized) {  			savedWindowRect = new Rect (new Point (Console.WindowLeft' Console.WindowTop)' new Size (Console.WindowWidth' Console.WindowHeight));  		}  	}  	// WAIT_FAILED  	if (waitResult == 0xFFFFFFFF) {  		throw new InvalidOperationException ("Invalid wait result of WaitForMultipleObjects.");  	}  	while (true) {  		bool anyInvokeActions = isAnyInvokeActions ();  		bool anyRoutedEvent = !EventManager.IsQueueEmpty ();  		bool anyLayoutToRevalidate = renderer.AnyControlInvalidated;  		if (!anyInvokeActions && !anyRoutedEvent && !anyLayoutToRevalidate)  			break;  		EventManager.ProcessEvents ();  		processInvokeActions ();  		renderer.UpdateLayout ();  	}  	renderer.FinallyApplyChangesToCanvas ();  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runWindows,The following statement contains a magic number: while (true) {  	// 100 ms instead of Win32.INFINITE to check console window Zoomed and Iconic  	// state periodically (because if user presses Maximize/Restore button  	// there are no input event generated).  	uint waitResult = Win32.WaitForMultipleObjects (3' handles' false' 100);  	if (waitResult == 0) {  		break;  	}  	if (waitResult == 1) {  		processInput ();  	}  	if (waitResult == 2) {  		// Do nothing special - because invokeActions will be invoked in loop anyway  	}  	// If we received WAIT_TIMEOUT - check window Zoomed and Iconic state  	// and correct buffer size and console window size  	if (waitResult == 0x00000102) {  		IntPtr consoleWindow = getConsoleWindowHwnd ();  		bool isZoomed = Win32.IsZoomed (consoleWindow);  		bool isIconic = Win32.IsIconic (consoleWindow);  		if (maximized != isZoomed && !isIconic) {  			if (isZoomed)  				Maximize ();  			else  				Restore ();  		}  		if (!maximized) {  			savedWindowRect = new Rect (new Point (Console.WindowLeft' Console.WindowTop)' new Size (Console.WindowWidth' Console.WindowHeight));  		}  	}  	// WAIT_FAILED  	if (waitResult == 0xFFFFFFFF) {  		throw new InvalidOperationException ("Invalid wait result of WaitForMultipleObjects.");  	}  	while (true) {  		bool anyInvokeActions = isAnyInvokeActions ();  		bool anyRoutedEvent = !EventManager.IsQueueEmpty ();  		bool anyLayoutToRevalidate = renderer.AnyControlInvalidated;  		if (!anyInvokeActions && !anyRoutedEvent && !anyLayoutToRevalidate)  			break;  		EventManager.ProcessEvents ();  		processInvokeActions ();  		renderer.UpdateLayout ();  	}  	renderer.FinallyApplyChangesToCanvas ();  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runWindows,The following statement contains a magic number: while (true) {  	// 100 ms instead of Win32.INFINITE to check console window Zoomed and Iconic  	// state periodically (because if user presses Maximize/Restore button  	// there are no input event generated).  	uint waitResult = Win32.WaitForMultipleObjects (3' handles' false' 100);  	if (waitResult == 0) {  		break;  	}  	if (waitResult == 1) {  		processInput ();  	}  	if (waitResult == 2) {  		// Do nothing special - because invokeActions will be invoked in loop anyway  	}  	// If we received WAIT_TIMEOUT - check window Zoomed and Iconic state  	// and correct buffer size and console window size  	if (waitResult == 0x00000102) {  		IntPtr consoleWindow = getConsoleWindowHwnd ();  		bool isZoomed = Win32.IsZoomed (consoleWindow);  		bool isIconic = Win32.IsIconic (consoleWindow);  		if (maximized != isZoomed && !isIconic) {  			if (isZoomed)  				Maximize ();  			else  				Restore ();  		}  		if (!maximized) {  			savedWindowRect = new Rect (new Point (Console.WindowLeft' Console.WindowTop)' new Size (Console.WindowWidth' Console.WindowHeight));  		}  	}  	// WAIT_FAILED  	if (waitResult == 0xFFFFFFFF) {  		throw new InvalidOperationException ("Invalid wait result of WaitForMultipleObjects.");  	}  	while (true) {  		bool anyInvokeActions = isAnyInvokeActions ();  		bool anyRoutedEvent = !EventManager.IsQueueEmpty ();  		bool anyLayoutToRevalidate = renderer.AnyControlInvalidated;  		if (!anyInvokeActions && !anyRoutedEvent && !anyLayoutToRevalidate)  			break;  		EventManager.ProcessEvents ();  		processInvokeActions ();  		renderer.UpdateLayout ();  	}  	renderer.FinallyApplyChangesToCanvas ();  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,runWindows,The following statement contains a magic number: if (waitResult == 2) {  	// Do nothing special - because invokeActions will be invoked in loop anyway  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,RunOnUiThread,The following statement contains a magic number: using (EventWaitHandle waitHandle = new EventWaitHandle (false' EventResetMode.ManualReset)) {  	lock (actionsLocker) {  		actionsToBeInvoked.Add (new ActionInfo (action' waitHandle));  	}  	if (usingLinux) {  		Libc.writeInt64 (pipeFds [1]' 3);  	} else {  		invokeWaitHandle.Set ();  	}  	waitHandle.WaitOne ();  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,RunOnUiThread,The following statement contains a magic number: if (usingLinux) {  	Libc.writeInt64 (pipeFds [1]' 3);  } else {  	invokeWaitHandle.Set ();  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,RunOnUiThread,The following statement contains a magic number: Libc.writeInt64 (pipeFds [1]' 3);  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,Post,The following statement contains a magic number: if (!IsUiThread ()) {  	if (usingLinux) {  		Libc.writeInt64 (pipeFds [1]' 3);  	} else {  		invokeWaitHandle.Set ();  	}  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,Post,The following statement contains a magic number: if (usingLinux) {  	Libc.writeInt64 (pipeFds [1]' 3);  } else {  	invokeWaitHandle.Set ();  }  
Magic Number,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,Post,The following statement contains a magic number: Libc.writeInt64 (pipeFds [1]' 3);  
Missing Default,ConsoleFramework.Controls,GridLengthTypeConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Grid.cs,CanConvertFrom,The following switch statement is missing a default case: switch (Type.GetTypeCode (sourceType)) {  case TypeCode.Int16:  case TypeCode.UInt16:  case TypeCode.Int32:  case TypeCode.UInt32:  case TypeCode.Int64:  case TypeCode.UInt64:  case TypeCode.Single:  case TypeCode.Double:  case TypeCode.Decimal:  case TypeCode.String:  	return true;  }  
Missing Default,ConsoleFramework.Controls,GridLengthTypeConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Grid.cs,ConvertTo,The following switch statement is missing a default case: switch (gl.GridUnitType) {  case GridUnitType.Auto:  	return "Auto";  case GridUnitType.Star:  	if (gl.Value == 1) {  		return "*";  	}  	return (Convert.ToString (gl.Value) + "*");  }  
Missing Default,ConsoleFramework.Controls,MenuItem,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Menu.cs,MenuItem,The following switch statement is missing a default case: switch (args.Type) {  case ListChangedEventType.ItemsInserted: {  	for (int i = 0; i < args.Count; i++) {  		MenuItemBase itemBase = items [args.Index + i];  		if (itemBase is MenuItem) {  			(itemBase as MenuItem).ParentItem = this;  		}  	}  	break;  }  case ListChangedEventType.ItemsRemoved:  	foreach (object removedItem in args.RemovedItems) {  		if (removedItem is MenuItem)  			(removedItem as MenuItem).ParentItem = null;  	}  	break;  case ListChangedEventType.ItemReplaced: {  	object removedItem = args.RemovedItems [0];  	if (removedItem is MenuItem)  		(removedItem as MenuItem).ParentItem = null;  	MenuItemBase itemBase = items [args.Index];  	if (itemBase is MenuItem) {  		(itemBase as MenuItem).ParentItem = this;  	}  	break;  }  }  
Missing Default,ConsoleFramework.Controls,Menu,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\Menu.cs,Menu,The following switch statement is missing a default case: switch (args.Type) {  case ListChangedEventType.ItemsInserted: {  	for (int i = 0; i < args.Count; i++) {  		MenuItemBase item = items [args.Index + i];  		if (item is Separator)  			throw new InvalidOperationException ("Separator cannot be added to root menu.");  		if (((MenuItem)item).Type == MenuItemType.Submenu)  			((MenuItem)item).Type = MenuItemType.RootSubmenu;  		stackPanel.XChildren.Insert (args.Index + i' item);  	}  	break;  }  case ListChangedEventType.ItemsRemoved:  	for (int i = 0; i < args.Count; i++)  		stackPanel.XChildren.RemoveAt (args.Index);  	break;  case ListChangedEventType.ItemReplaced: {  	MenuItemBase item = items [args.Index];  	if (item is Separator)  		throw new InvalidOperationException ("Separator cannot be added to root menu.");  	if (((MenuItem)item).Type == MenuItemType.Submenu)  		((MenuItem)item).Type = MenuItemType.RootSubmenu;  	stackPanel.XChildren [args.Index] = item;  	break;  }  }  
Missing Default,ConsoleFramework.Controls,ScrollViewer,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\ScrollViewer.cs,ScrollContent,The following switch statement is missing a default case: switch (direction) {  case Direction.Left: {  	// сколько места сейчас оставлено дочернему контролу  	int remainingWidth = ActualWidth - (verticalScrollVisible ? 1 : 0);  	if (deltaX < Content.RenderSize.Width - remainingWidth) {  		deltaX++;  	}  	Invalidate ();  	break;  }  case Direction.Right: {  	if (deltaX > 0) {  		deltaX--;  	}  	Invalidate ();  	break;  }  case Direction.Up: {  	// сколько места сейчас оставлено дочернему контролу  	int remainingHeight = ActualHeight - (horizontalScrollVisible ? 1 : 0);  	if (deltaY < Content.RenderSize.Height - remainingHeight) {  		deltaY++;  	}  	Invalidate ();  	break;  }  case Direction.Down: {  	if (deltaY > 0) {  		deltaY--;  	}  	Invalidate ();  	break;  }  }  
Missing Default,ConsoleFramework.Controls,TreeView,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Controls\TreeView.cs,ItemsOnListChanged,The following switch statement is missing a default case: switch (args.Type) {  case ListChangedEventType.ItemsInserted: {  	for (int i = 0; i < args.Count; i++)  		onItemInserted (i + args.Index);  	break;  }  case ListChangedEventType.ItemsRemoved: {  	foreach (TreeItem treeItem in args.RemovedItems.Cast<TreeItem> ())  		onItemRemoved (treeItem);  	break;  }  case ListChangedEventType.ItemReplaced: {  	onItemRemoved ((TreeItem)args.RemovedItems [0]);  	onItemInserted (args.Index);  	break;  }  }  
Missing Default,ConsoleFramework.Events,ModifierKeysConverter,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\Events\ModifierKeysConverter.cs,MatchModifiers,The following switch statement is missing a default case: switch (modifierKeys) {  case ModifierKeys.Alt:  	return "Alt";  case ModifierKeys.Control:  	return "Ctrl";  case (ModifierKeys.Control | ModifierKeys.Alt):  	return str;  case ModifierKeys.Shift:  	return "Shift";  }  
Missing Default,ConsoleFramework,ConsoleApplication,F:\newReposMay17\elw00d_consoleframework\ConsoleFramework\ConsoleApplication.cs,ConsoleApplication,The following switch statement is missing a default case: switch (Environment.OSVersion.Platform) {  case PlatformID.Win32NT:  case PlatformID.Win32S:  case PlatformID.Win32Windows:  case PlatformID.WinCE:  	usingLinux = false;  	break;  case PlatformID.Unix:  	usingLinux = true;  	#if !WIN32  						Utsname uname; 					Syscall.uname(out uname); 					if (uname.sysname == "Darwin") { 						isDarwin = true; 					} #endif  	break;  case PlatformID.MacOSX:  case PlatformID.Xbox:  	throw new NotSupportedException ();  }  
