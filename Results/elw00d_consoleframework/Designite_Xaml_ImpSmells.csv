Implementation smell,Namespace,Class,File,Method,Description
Long Method,Xaml,XamlParser,C:\repos\elw00d_consoleframework\Xaml\XamlParser.cs,processEndElement,The method has 114 lines of code.
Complex Method,Xaml,ObjectFactory,C:\repos\elw00d_consoleframework\Xaml\Factories.cs,GetObject,Cyclomatic complexity of the method is 8
Complex Method,Xaml,MarkupExtensionsParser,C:\repos\elw00d_consoleframework\Xaml\MarkupExtensionsParser.cs,processMarkupExtensionCore,Cyclomatic complexity of the method is 8
Complex Method,Xaml,XamlParser,C:\repos\elw00d_consoleframework\Xaml\XamlParser.cs,ConvertValueIfNeed,Cyclomatic complexity of the method is 16
Long Parameter List,Xaml,MarkupExtensionContext,C:\repos\elw00d_consoleframework\Xaml\XamlParser.cs,MarkupExtensionContext,The method has 5 parameters. Parameters: self' expression' propertyName' obj' dataContext
Long Statement,Xaml,MarkupExtensionsParser,C:\repos\elw00d_consoleframework\Xaml\MarkupExtensionsParser.cs,construct,The length of the statement  "            List< ConstructorInfo > constructorInfos = constructors.Where( info => info.GetParameters( ).Length == ctorArgs.Count ).ToList( ); " is 130.
Complex Conditional,Xaml,MarkupExtensionsParser,C:\repos\elw00d_consoleframework\Xaml\MarkupExtensionsParser.cs,processString,The conditional expression  "c == '{' || c == '}' || c == ''' || c == '='"  is complex.
Complex Conditional,Xaml,XamlParser,C:\repos\elw00d_consoleframework\Xaml\XamlParser.cs,processEndElement,The conditional expression  "null != typeArg1 && typeArg1 == typeof ( string )                                      && null != typeArg2 &&                                      typeof ( IDictionary< ' > ).MakeGenericType( typeArg1' typeArg2 )                                                              .IsAssignableFrom( property.PropertyType )"  is complex.
Magic Number,Xaml,XamlParser,C:\repos\elw00d_consoleframework\Xaml\XamlParser.cs,processText,The following statement contains a magic number: if ( text[ 0 ] != '{' ) {                  // interpret whole text as string                  return text;              } else if (text.Length > 1 && text[1] == '}') {                  // interpret the rest as string                  return text.Length > 2 ? text.Substring(2) : String.Empty;              } else {                  MarkupExtensionsParser markupExtensionsParser = new MarkupExtensionsParser(                      new MarkupExtensionsResolver( this )' text );                  MarkupExtensionContext context = new MarkupExtensionContext(                      this' text' currentProperty' currentObject' dataContext);                  object providedValue = markupExtensionsParser.ProcessMarkupExtension( context );                  if ( providedValue is IFixupToken ) {                      fixupTokens.Add( ( FixupToken ) providedValue );                      // Null means no value will be assigned to target property                      return null;                  }                  return providedValue;              }
Magic Number,Xaml,XamlParser,C:\repos\elw00d_consoleframework\Xaml\XamlParser.cs,processText,The following statement contains a magic number: if ( text[ 0 ] != '{' ) {                  // interpret whole text as string                  return text;              } else if (text.Length > 1 && text[1] == '}') {                  // interpret the rest as string                  return text.Length > 2 ? text.Substring(2) : String.Empty;              } else {                  MarkupExtensionsParser markupExtensionsParser = new MarkupExtensionsParser(                      new MarkupExtensionsResolver( this )' text );                  MarkupExtensionContext context = new MarkupExtensionContext(                      this' text' currentProperty' currentObject' dataContext);                  object providedValue = markupExtensionsParser.ProcessMarkupExtension( context );                  if ( providedValue is IFixupToken ) {                      fixupTokens.Add( ( FixupToken ) providedValue );                      // Null means no value will be assigned to target property                      return null;                  }                  return providedValue;              }
Magic Number,Xaml,XamlParser,C:\repos\elw00d_consoleframework\Xaml\XamlParser.cs,resolveMarkupExtensionType,The following statement contains a magic number: foreach ( string ns in namespacesToScan ) {                  Regex regex = new Regex( "clr-namespace:(.+);assembly=(.+)" );                  MatchCollection matchCollection = regex.Matches( ns );                  if (matchCollection.Count == 0)                      throw new InvalidOperationException(string.Format("Invalid clr-namespace syntax: {0}"' ns));                  string namespaceName = matchCollection[ 0 ].Groups[ 1 ].Value;                  string assemblyName = matchCollection[ 0 ].Groups[ 2 ].Value;    				Assembly assembly = Assembly.Load( new AssemblyName( assemblyName ) );                  List< Type > types = assembly.GetTypes( ).Where( type => {                      if (type.Namespace != namespaceName) return false;  					object[ ] attributes = type.GetTypeInfo().GetCustomAttributes( typeof ( MarkupExtensionAttribute )' true ).ToArray();                      return ( attributes.Any( o => ( ( MarkupExtensionAttribute ) o ).Name == bindingName ) );                  } ).ToList( );                    if (types.Count > 1)                      throw new InvalidOperationException(string.Format( "More than one markup extension" +                                                          " for name {0} in namespace {1}."'                                                          name' ns));                  else if ( types.Count == 1 ) {                      resultType = types[ 0 ];                      break;                  }              }
Magic Number,Xaml,XamlParser,C:\repos\elw00d_consoleframework\Xaml\XamlParser.cs,resolveType,The following statement contains a magic number: foreach ( string ns in namespacesToScan ) {                  Regex regex = new Regex( "clr-namespace:(.+);assembly=(.+)" );                  MatchCollection matchCollection = regex.Matches( ns );                  if (matchCollection.Count == 0)                      throw new InvalidOperationException(string.Format("Invalid clr-namespace syntax: {0}"' ns));                  string namespaceName = matchCollection[ 0 ].Groups[ 1 ].Value;                  string assemblyName = matchCollection[ 0 ].Groups[ 2 ].Value;    				Assembly assembly = Assembly.Load( new AssemblyName(assemblyName) );                  List< Type > types = assembly.GetTypes( ).Where( type => type.Namespace == namespaceName                      && type.Name == typeName ).ToList( );                  if (types.Count > 1)                      throw new InvalidOperationException("Assertion error.");                  else if ( types.Count == 1 ) {                      resultType = types[ 0 ];                      break;                  }              }
