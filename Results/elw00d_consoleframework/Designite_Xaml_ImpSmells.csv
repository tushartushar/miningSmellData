Implementation smell,Namespace,Class,File,Method,Description
Long Method,Xaml,XamlParser,F:\newReposMay17\elw00d_consoleframework\Xaml\XamlParser.cs,processEndElement,The method has 108 lines of code.
Complex Method,Xaml,ObjectFactory,F:\newReposMay17\elw00d_consoleframework\Xaml\Factories.cs,GetObject,Cyclomatic complexity of the method is 8
Complex Method,Xaml,MarkupExtensionsParser,F:\newReposMay17\elw00d_consoleframework\Xaml\MarkupExtensionsParser.cs,processMarkupExtensionCore,Cyclomatic complexity of the method is 14
Complex Method,Xaml,XamlParser,F:\newReposMay17\elw00d_consoleframework\Xaml\XamlParser.cs,createFromXaml,Cyclomatic complexity of the method is 17
Complex Method,Xaml,XamlParser,F:\newReposMay17\elw00d_consoleframework\Xaml\XamlParser.cs,processAttribute,Cyclomatic complexity of the method is 8
Complex Method,Xaml,XamlParser,F:\newReposMay17\elw00d_consoleframework\Xaml\XamlParser.cs,processEndElement,Cyclomatic complexity of the method is 13
Complex Method,Xaml,XamlParser,F:\newReposMay17\elw00d_consoleframework\Xaml\XamlParser.cs,ConvertValueIfNeed,Cyclomatic complexity of the method is 18
Long Statement,Xaml,MarkupExtensionsParser,F:\newReposMay17\elw00d_consoleframework\Xaml\MarkupExtensionsParser.cs,construct,The length of the statement  "	List<ConstructorInfo> constructorInfos = constructors.Where (info => info.GetParameters ().Length == ctorArgs.Count).ToList (); " is 127.
Long Statement,Xaml,XamlParser,F:\newReposMay17\elw00d_consoleframework\Xaml\XamlParser.cs,getContentPropertyName,The length of the statement  "		throw new InvalidOperationException ("Ambigious content property definition " + "- more than one ContentPropertyAttribute found."); " is 131.
Long Statement,Xaml,XamlParser,F:\newReposMay17\elw00d_consoleframework\Xaml\XamlParser.cs,processEndElement,The length of the statement  "		PropertyInfo property = Top.currentProperty != null ? Top.type.GetProperty (Top.currentProperty) : Top.type.GetProperty (getContentPropertyName (Top.type)); " is 156.
Long Statement,Xaml,XamlParser,F:\newReposMay17\elw00d_consoleframework\Xaml\XamlParser.cs,processEndElement,The length of the statement  "			Type typeArg1 = property.PropertyType.GetTypeInfo ().IsGenericType ? property.PropertyType.GetGenericArguments () [0] : null; " is 125.
Long Statement,Xaml,XamlParser,F:\newReposMay17\elw00d_consoleframework\Xaml\XamlParser.cs,processEndElement,The length of the statement  "					Type typeArg2 = property.PropertyType.GetTypeInfo ().IsGenericType && property.PropertyType.GetGenericArguments ().Length > 1 ? property.PropertyType.GetGenericArguments () [1] : null; " is 184.
Long Statement,Xaml,XamlParser,F:\newReposMay17\elw00d_consoleframework\Xaml\XamlParser.cs,processEndElement,The length of the statement  "					if (null != typeArg1 && typeArg1 == typeof(string) && null != typeArg2 && typeof(IDictionary<' >).MakeGenericType (typeArg1' typeArg2).IsAssignableFrom (property.PropertyType)) { " is 178.
Long Statement,Xaml,XamlParser,F:\newReposMay17\elw00d_consoleframework\Xaml\XamlParser.cs,processFixupTokens,The length of the statement  "			MarkupExtensionsParser markupExtensionsParser = new MarkupExtensionsParser (new MarkupExtensionsResolver (this)' token.Expression); " is 131.
Long Statement,Xaml,XamlParser,F:\newReposMay17\elw00d_consoleframework\Xaml\XamlParser.cs,processFixupTokens,The length of the statement  "			MarkupExtensionContext context = new MarkupExtensionContext (this' token.Expression' token.PropertyName' token.Object' token.DataContext); " is 138.
Long Statement,Xaml,XamlParser,F:\newReposMay17\elw00d_consoleframework\Xaml\XamlParser.cs,resolveMarkupExtensionType,The length of the statement  "			throw new InvalidOperationException (string.Format ("More than one markup extension" + " for name {0} in namespace {1}."' name' ns)); " is 133.
Long Statement,Xaml,XamlParser,F:\newReposMay17\elw00d_consoleframework\Xaml\XamlParser.cs,resolveType,The length of the statement  "		List<Type> types = assembly.GetTypes ().Where (type => type.Namespace == namespaceName && type.Name == typeName).ToList (); " is 123.
Complex Conditional,Xaml,MarkupExtensionsParser,F:\newReposMay17\elw00d_consoleframework\Xaml\MarkupExtensionsParser.cs,processString,The conditional expression  "c == '{' || c == '}' || c == ''' || c == '='"  is complex.
Complex Conditional,Xaml,XamlParser,F:\newReposMay17\elw00d_consoleframework\Xaml\XamlParser.cs,processEndElement,The conditional expression  "null != typeArg1 && typeArg1 == typeof(string) && null != typeArg2 && typeof(IDictionary<' >).MakeGenericType (typeArg1' typeArg2).IsAssignableFrom (property.PropertyType)"  is complex.
Magic Number,Xaml,XamlParser,F:\newReposMay17\elw00d_consoleframework\Xaml\XamlParser.cs,processText,The following statement contains a magic number: if (text [0] != '{') {  	// interpret whole text as string  	return text;  } else if (text.Length > 1 && text [1] == '}') {  	// interpret the rest as string  	return text.Length > 2 ? text.Substring (2) : String.Empty;  } else {  	MarkupExtensionsParser markupExtensionsParser = new MarkupExtensionsParser (new MarkupExtensionsResolver (this)' text);  	MarkupExtensionContext context = new MarkupExtensionContext (this' text' currentProperty' currentObject' dataContext);  	object providedValue = markupExtensionsParser.ProcessMarkupExtension (context);  	if (providedValue is IFixupToken) {  		fixupTokens.Add ((FixupToken)providedValue);  		// Null means no value will be assigned to target property  		return null;  	}  	return providedValue;  }  
Magic Number,Xaml,XamlParser,F:\newReposMay17\elw00d_consoleframework\Xaml\XamlParser.cs,processText,The following statement contains a magic number: if (text [0] != '{') {  	// interpret whole text as string  	return text;  } else if (text.Length > 1 && text [1] == '}') {  	// interpret the rest as string  	return text.Length > 2 ? text.Substring (2) : String.Empty;  } else {  	MarkupExtensionsParser markupExtensionsParser = new MarkupExtensionsParser (new MarkupExtensionsResolver (this)' text);  	MarkupExtensionContext context = new MarkupExtensionContext (this' text' currentProperty' currentObject' dataContext);  	object providedValue = markupExtensionsParser.ProcessMarkupExtension (context);  	if (providedValue is IFixupToken) {  		fixupTokens.Add ((FixupToken)providedValue);  		// Null means no value will be assigned to target property  		return null;  	}  	return providedValue;  }  
Magic Number,Xaml,XamlParser,F:\newReposMay17\elw00d_consoleframework\Xaml\XamlParser.cs,processText,The following statement contains a magic number: if (text.Length > 1 && text [1] == '}') {  	// interpret the rest as string  	return text.Length > 2 ? text.Substring (2) : String.Empty;  } else {  	MarkupExtensionsParser markupExtensionsParser = new MarkupExtensionsParser (new MarkupExtensionsResolver (this)' text);  	MarkupExtensionContext context = new MarkupExtensionContext (this' text' currentProperty' currentObject' dataContext);  	object providedValue = markupExtensionsParser.ProcessMarkupExtension (context);  	if (providedValue is IFixupToken) {  		fixupTokens.Add ((FixupToken)providedValue);  		// Null means no value will be assigned to target property  		return null;  	}  	return providedValue;  }  
Magic Number,Xaml,XamlParser,F:\newReposMay17\elw00d_consoleframework\Xaml\XamlParser.cs,processText,The following statement contains a magic number: if (text.Length > 1 && text [1] == '}') {  	// interpret the rest as string  	return text.Length > 2 ? text.Substring (2) : String.Empty;  } else {  	MarkupExtensionsParser markupExtensionsParser = new MarkupExtensionsParser (new MarkupExtensionsResolver (this)' text);  	MarkupExtensionContext context = new MarkupExtensionContext (this' text' currentProperty' currentObject' dataContext);  	object providedValue = markupExtensionsParser.ProcessMarkupExtension (context);  	if (providedValue is IFixupToken) {  		fixupTokens.Add ((FixupToken)providedValue);  		// Null means no value will be assigned to target property  		return null;  	}  	return providedValue;  }  
Magic Number,Xaml,XamlParser,F:\newReposMay17\elw00d_consoleframework\Xaml\XamlParser.cs,processText,The following statement contains a magic number: return text.Length > 2 ? text.Substring (2) : String.Empty;  
Magic Number,Xaml,XamlParser,F:\newReposMay17\elw00d_consoleframework\Xaml\XamlParser.cs,processText,The following statement contains a magic number: return text.Length > 2 ? text.Substring (2) : String.Empty;  
Magic Number,Xaml,XamlParser,F:\newReposMay17\elw00d_consoleframework\Xaml\XamlParser.cs,resolveMarkupExtensionType,The following statement contains a magic number: foreach (string ns in namespacesToScan) {  	Regex regex = new Regex ("clr-namespace:(.+);assembly=(.+)");  	MatchCollection matchCollection = regex.Matches (ns);  	if (matchCollection.Count == 0)  		throw new InvalidOperationException (string.Format ("Invalid clr-namespace syntax: {0}"' ns));  	string namespaceName = matchCollection [0].Groups [1].Value;  	string assemblyName = matchCollection [0].Groups [2].Value;  	Assembly assembly = Assembly.Load (new AssemblyName (assemblyName));  	List<Type> types = assembly.GetTypes ().Where (type => {  		if (type.Namespace != namespaceName)  			return false;  		object[] attributes = type.GetTypeInfo ().GetCustomAttributes (typeof(MarkupExtensionAttribute)' true).ToArray ();  		return (attributes.Any (o => ((MarkupExtensionAttribute)o).Name == bindingName));  	}).ToList ();  	if (types.Count > 1)  		throw new InvalidOperationException (string.Format ("More than one markup extension" + " for name {0} in namespace {1}."' name' ns));  	else if (types.Count == 1) {  		resultType = types [0];  		break;  	}  }  
Magic Number,Xaml,XamlParser,F:\newReposMay17\elw00d_consoleframework\Xaml\XamlParser.cs,resolveType,The following statement contains a magic number: foreach (string ns in namespacesToScan) {  	Regex regex = new Regex ("clr-namespace:(.+);assembly=(.+)");  	MatchCollection matchCollection = regex.Matches (ns);  	if (matchCollection.Count == 0)  		throw new InvalidOperationException (string.Format ("Invalid clr-namespace syntax: {0}"' ns));  	string namespaceName = matchCollection [0].Groups [1].Value;  	string assemblyName = matchCollection [0].Groups [2].Value;  	Assembly assembly = Assembly.Load (new AssemblyName (assemblyName));  	List<Type> types = assembly.GetTypes ().Where (type => type.Namespace == namespaceName && type.Name == typeName).ToList ();  	if (types.Count > 1)  		throw new InvalidOperationException ("Assertion error.");  	else if (types.Count == 1) {  		resultType = types [0];  		break;  	}  }  
