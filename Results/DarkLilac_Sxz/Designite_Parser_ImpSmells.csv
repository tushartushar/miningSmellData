Implementation smell,Namespace,Class,File,Method,Description
Long Method,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The method has 198 lines of code.
Complex Method,Parser,BoundingBox,F:\newReposMay17\DarkLilac_Sxz\Parser\BoundingBox.cs,Add,Cyclomatic complexity of the method is 9
Complex Method,Parser,Location,F:\newReposMay17\DarkLilac_Sxz\Parser\Location.cs,GetLocalMaxima,Cyclomatic complexity of the method is 9
Complex Method,Parser,LocationPool,F:\newReposMay17\DarkLilac_Sxz\Parser\LocationPool.cs,SetNeighbors,Cyclomatic complexity of the method is 12
Complex Method,Parser,MultiColorRegion,F:\newReposMay17\DarkLilac_Sxz\Parser\MultiColorRegion.cs,GetChunks,Cyclomatic complexity of the method is 8
Complex Method,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,Cyclomatic complexity of the method is 27
Complex Method,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Process,Cyclomatic complexity of the method is 8
Complex Method,Parser,Region,F:\newReposMay17\DarkLilac_Sxz\Parser\Region.cs,GetAllRectangles,Cyclomatic complexity of the method is 10
Long Parameter List,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The method has 7 parameters.
Long Statement,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The length of the statement  "	//Parse all the pixels into the locationpool' histogram and remove the fully transparent pixels into the transparentregion " is 122.
Long Statement,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The length of the statement  "					location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0); " is 130.
Long Statement,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The length of the statement  "					location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0); " is 136.
Long Statement,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The length of the statement  "					location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0); " is 133.
Long Statement,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The length of the statement  "		return first.Value == second.Value ? (int)(SxzColor.GetColorDistance (second.Key' new SxzColor (0' 0' 0)) - SxzColor.GetColorDistance (first.Key' new SxzColor (0' 0' 0))) : second.Value.CompareTo (first.Value); " is 210.
Long Statement,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,PrintTossedChunk,The length of the statement  "	Console.WriteLine ("Tossing " + chunkContainer.Chunk.GetType ().Name.ToString () + " with size " + count + " for pixel count " + chunkContainer.Locations.Count + " ratio " + ((float)count / (float)chunkContainer.Locations.Count)); " is 230.
Long Statement,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,PrintKeptChunk,The length of the statement  "	Console.WriteLine ("Keeping " + chunkContainer.Chunk.GetType ().Name.ToString () + " with size " + count + " for pixel count " + chunkContainer.Locations.Count + " ratio " + ratio); " is 181.
Long Statement,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Process,The length of the statement  "		todoList.Sort ((x' y) => (int)(SxzColor.GetColorDistance (seed.Color' x.Color) - SxzColor.GetColorDistance (seed.Color' y.Color))); " is 131.
Long Statement,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Process,The length of the statement  "				//we can process non-adjacent pixels by adding neighbors here and sorting before returning but limit the distance from an already " is 129.
Long Statement,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Process,The length of the statement  "				todoList.Sort ((x1' y1) => (int)(SxzColor.GetColorDistance (seed.Color' x1.Color) - SxzColor.GetColorDistance (seed.Color' y1.Color))); " is 135.
Magic Number,Parser,ChunkContainer,F:\newReposMay17\DarkLilac_Sxz\Parser\ChunkContainer.cs,IsValid,The following statement contains a magic number: return (Size () * 8) < (Locations.Count * multiplier);  
Magic Number,Parser,Palette,F:\newReposMay17\DarkLilac_Sxz\Parser\Palette.cs,Palette,The following statement contains a magic number: Distance = 32;  
Magic Number,Parser,Palette,F:\newReposMay17\DarkLilac_Sxz\Parser\Palette.cs,Add,The following statement contains a magic number: if (Colors.Count >= 256) {  	throw new Exception ("Palette too large");  }  
Magic Number,Parser,Palette,F:\newReposMay17\DarkLilac_Sxz\Parser\Palette.cs,Add,The following statement contains a magic number: foreach (SxzColor color in colors) {  	if (Contains (color)) {  		continue;  	}  	if (Colors.Count == 256) {  		return false;  	}  	Colors.Add (color);  }  
Magic Number,Parser,Palette,F:\newReposMay17\DarkLilac_Sxz\Parser\Palette.cs,Add,The following statement contains a magic number: if (Colors.Count == 256) {  	return false;  }  
Magic Number,Parser,Palette,F:\newReposMay17\DarkLilac_Sxz\Parser\Palette.cs,HasRoom,The following statement contains a magic number: return Colors.Count < 256;  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: using (System.Drawing.Bitmap bitMap = new System.Drawing.Bitmap (filename)) {  	width = bitMap.Width;  	height = bitMap.Height;  	locationPool = new LocationPool (width' height);  	for (int x = 0; x < width; x++) {  		for (int y = 0; y < height; y++) {  			System.Drawing.Color pixel = bitMap.GetPixel (x' y);  			Location location = new Location ();  			location.Color = new SxzColor (pixel.R' pixel.G' pixel.B);  			location.Point.X = x;  			location.Point.Y = y;  			//Don't put transparent colors into the histogram  			if (pixel.A == 0) {  				transparentRegion.Add (location);  				locationPool.SetLocation (location' x' y);  				locationPool.SetMarked (location);  				continue;  			}  			if (pixel.A > 0 && pixel.A < 255) {  				location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  				location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  				location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  			}  			if (histogram.ContainsKey (location.Color)) {  				int count = histogram [location.Color];  				histogram [location.Color] = count + 1;  			} else {  				histogram.Add (location.Color' 1);  			}  			locationPool.SetLocation (location' x' y);  		}  	}  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: using (System.Drawing.Bitmap bitMap = new System.Drawing.Bitmap (filename)) {  	width = bitMap.Width;  	height = bitMap.Height;  	locationPool = new LocationPool (width' height);  	for (int x = 0; x < width; x++) {  		for (int y = 0; y < height; y++) {  			System.Drawing.Color pixel = bitMap.GetPixel (x' y);  			Location location = new Location ();  			location.Color = new SxzColor (pixel.R' pixel.G' pixel.B);  			location.Point.X = x;  			location.Point.Y = y;  			//Don't put transparent colors into the histogram  			if (pixel.A == 0) {  				transparentRegion.Add (location);  				locationPool.SetLocation (location' x' y);  				locationPool.SetMarked (location);  				continue;  			}  			if (pixel.A > 0 && pixel.A < 255) {  				location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  				location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  				location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  			}  			if (histogram.ContainsKey (location.Color)) {  				int count = histogram [location.Color];  				histogram [location.Color] = count + 1;  			} else {  				histogram.Add (location.Color' 1);  			}  			locationPool.SetLocation (location' x' y);  		}  	}  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: using (System.Drawing.Bitmap bitMap = new System.Drawing.Bitmap (filename)) {  	width = bitMap.Width;  	height = bitMap.Height;  	locationPool = new LocationPool (width' height);  	for (int x = 0; x < width; x++) {  		for (int y = 0; y < height; y++) {  			System.Drawing.Color pixel = bitMap.GetPixel (x' y);  			Location location = new Location ();  			location.Color = new SxzColor (pixel.R' pixel.G' pixel.B);  			location.Point.X = x;  			location.Point.Y = y;  			//Don't put transparent colors into the histogram  			if (pixel.A == 0) {  				transparentRegion.Add (location);  				locationPool.SetLocation (location' x' y);  				locationPool.SetMarked (location);  				continue;  			}  			if (pixel.A > 0 && pixel.A < 255) {  				location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  				location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  				location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  			}  			if (histogram.ContainsKey (location.Color)) {  				int count = histogram [location.Color];  				histogram [location.Color] = count + 1;  			} else {  				histogram.Add (location.Color' 1);  			}  			locationPool.SetLocation (location' x' y);  		}  	}  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: using (System.Drawing.Bitmap bitMap = new System.Drawing.Bitmap (filename)) {  	width = bitMap.Width;  	height = bitMap.Height;  	locationPool = new LocationPool (width' height);  	for (int x = 0; x < width; x++) {  		for (int y = 0; y < height; y++) {  			System.Drawing.Color pixel = bitMap.GetPixel (x' y);  			Location location = new Location ();  			location.Color = new SxzColor (pixel.R' pixel.G' pixel.B);  			location.Point.X = x;  			location.Point.Y = y;  			//Don't put transparent colors into the histogram  			if (pixel.A == 0) {  				transparentRegion.Add (location);  				locationPool.SetLocation (location' x' y);  				locationPool.SetMarked (location);  				continue;  			}  			if (pixel.A > 0 && pixel.A < 255) {  				location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  				location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  				location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  			}  			if (histogram.ContainsKey (location.Color)) {  				int count = histogram [location.Color];  				histogram [location.Color] = count + 1;  			} else {  				histogram.Add (location.Color' 1);  			}  			locationPool.SetLocation (location' x' y);  		}  	}  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: using (System.Drawing.Bitmap bitMap = new System.Drawing.Bitmap (filename)) {  	width = bitMap.Width;  	height = bitMap.Height;  	locationPool = new LocationPool (width' height);  	for (int x = 0; x < width; x++) {  		for (int y = 0; y < height; y++) {  			System.Drawing.Color pixel = bitMap.GetPixel (x' y);  			Location location = new Location ();  			location.Color = new SxzColor (pixel.R' pixel.G' pixel.B);  			location.Point.X = x;  			location.Point.Y = y;  			//Don't put transparent colors into the histogram  			if (pixel.A == 0) {  				transparentRegion.Add (location);  				locationPool.SetLocation (location' x' y);  				locationPool.SetMarked (location);  				continue;  			}  			if (pixel.A > 0 && pixel.A < 255) {  				location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  				location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  				location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  			}  			if (histogram.ContainsKey (location.Color)) {  				int count = histogram [location.Color];  				histogram [location.Color] = count + 1;  			} else {  				histogram.Add (location.Color' 1);  			}  			locationPool.SetLocation (location' x' y);  		}  	}  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: using (System.Drawing.Bitmap bitMap = new System.Drawing.Bitmap (filename)) {  	width = bitMap.Width;  	height = bitMap.Height;  	locationPool = new LocationPool (width' height);  	for (int x = 0; x < width; x++) {  		for (int y = 0; y < height; y++) {  			System.Drawing.Color pixel = bitMap.GetPixel (x' y);  			Location location = new Location ();  			location.Color = new SxzColor (pixel.R' pixel.G' pixel.B);  			location.Point.X = x;  			location.Point.Y = y;  			//Don't put transparent colors into the histogram  			if (pixel.A == 0) {  				transparentRegion.Add (location);  				locationPool.SetLocation (location' x' y);  				locationPool.SetMarked (location);  				continue;  			}  			if (pixel.A > 0 && pixel.A < 255) {  				location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  				location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  				location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  			}  			if (histogram.ContainsKey (location.Color)) {  				int count = histogram [location.Color];  				histogram [location.Color] = count + 1;  			} else {  				histogram.Add (location.Color' 1);  			}  			locationPool.SetLocation (location' x' y);  		}  	}  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: using (System.Drawing.Bitmap bitMap = new System.Drawing.Bitmap (filename)) {  	width = bitMap.Width;  	height = bitMap.Height;  	locationPool = new LocationPool (width' height);  	for (int x = 0; x < width; x++) {  		for (int y = 0; y < height; y++) {  			System.Drawing.Color pixel = bitMap.GetPixel (x' y);  			Location location = new Location ();  			location.Color = new SxzColor (pixel.R' pixel.G' pixel.B);  			location.Point.X = x;  			location.Point.Y = y;  			//Don't put transparent colors into the histogram  			if (pixel.A == 0) {  				transparentRegion.Add (location);  				locationPool.SetLocation (location' x' y);  				locationPool.SetMarked (location);  				continue;  			}  			if (pixel.A > 0 && pixel.A < 255) {  				location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  				location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  				location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  			}  			if (histogram.ContainsKey (location.Color)) {  				int count = histogram [location.Color];  				histogram [location.Color] = count + 1;  			} else {  				histogram.Add (location.Color' 1);  			}  			locationPool.SetLocation (location' x' y);  		}  	}  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	for (int y = 0; y < height; y++) {  		System.Drawing.Color pixel = bitMap.GetPixel (x' y);  		Location location = new Location ();  		location.Color = new SxzColor (pixel.R' pixel.G' pixel.B);  		location.Point.X = x;  		location.Point.Y = y;  		//Don't put transparent colors into the histogram  		if (pixel.A == 0) {  			transparentRegion.Add (location);  			locationPool.SetLocation (location' x' y);  			locationPool.SetMarked (location);  			continue;  		}  		if (pixel.A > 0 && pixel.A < 255) {  			location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  			location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  			location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  		}  		if (histogram.ContainsKey (location.Color)) {  			int count = histogram [location.Color];  			histogram [location.Color] = count + 1;  		} else {  			histogram.Add (location.Color' 1);  		}  		locationPool.SetLocation (location' x' y);  	}  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	for (int y = 0; y < height; y++) {  		System.Drawing.Color pixel = bitMap.GetPixel (x' y);  		Location location = new Location ();  		location.Color = new SxzColor (pixel.R' pixel.G' pixel.B);  		location.Point.X = x;  		location.Point.Y = y;  		//Don't put transparent colors into the histogram  		if (pixel.A == 0) {  			transparentRegion.Add (location);  			locationPool.SetLocation (location' x' y);  			locationPool.SetMarked (location);  			continue;  		}  		if (pixel.A > 0 && pixel.A < 255) {  			location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  			location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  			location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  		}  		if (histogram.ContainsKey (location.Color)) {  			int count = histogram [location.Color];  			histogram [location.Color] = count + 1;  		} else {  			histogram.Add (location.Color' 1);  		}  		locationPool.SetLocation (location' x' y);  	}  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	for (int y = 0; y < height; y++) {  		System.Drawing.Color pixel = bitMap.GetPixel (x' y);  		Location location = new Location ();  		location.Color = new SxzColor (pixel.R' pixel.G' pixel.B);  		location.Point.X = x;  		location.Point.Y = y;  		//Don't put transparent colors into the histogram  		if (pixel.A == 0) {  			transparentRegion.Add (location);  			locationPool.SetLocation (location' x' y);  			locationPool.SetMarked (location);  			continue;  		}  		if (pixel.A > 0 && pixel.A < 255) {  			location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  			location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  			location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  		}  		if (histogram.ContainsKey (location.Color)) {  			int count = histogram [location.Color];  			histogram [location.Color] = count + 1;  		} else {  			histogram.Add (location.Color' 1);  		}  		locationPool.SetLocation (location' x' y);  	}  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	for (int y = 0; y < height; y++) {  		System.Drawing.Color pixel = bitMap.GetPixel (x' y);  		Location location = new Location ();  		location.Color = new SxzColor (pixel.R' pixel.G' pixel.B);  		location.Point.X = x;  		location.Point.Y = y;  		//Don't put transparent colors into the histogram  		if (pixel.A == 0) {  			transparentRegion.Add (location);  			locationPool.SetLocation (location' x' y);  			locationPool.SetMarked (location);  			continue;  		}  		if (pixel.A > 0 && pixel.A < 255) {  			location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  			location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  			location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  		}  		if (histogram.ContainsKey (location.Color)) {  			int count = histogram [location.Color];  			histogram [location.Color] = count + 1;  		} else {  			histogram.Add (location.Color' 1);  		}  		locationPool.SetLocation (location' x' y);  	}  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	for (int y = 0; y < height; y++) {  		System.Drawing.Color pixel = bitMap.GetPixel (x' y);  		Location location = new Location ();  		location.Color = new SxzColor (pixel.R' pixel.G' pixel.B);  		location.Point.X = x;  		location.Point.Y = y;  		//Don't put transparent colors into the histogram  		if (pixel.A == 0) {  			transparentRegion.Add (location);  			locationPool.SetLocation (location' x' y);  			locationPool.SetMarked (location);  			continue;  		}  		if (pixel.A > 0 && pixel.A < 255) {  			location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  			location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  			location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  		}  		if (histogram.ContainsKey (location.Color)) {  			int count = histogram [location.Color];  			histogram [location.Color] = count + 1;  		} else {  			histogram.Add (location.Color' 1);  		}  		locationPool.SetLocation (location' x' y);  	}  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	for (int y = 0; y < height; y++) {  		System.Drawing.Color pixel = bitMap.GetPixel (x' y);  		Location location = new Location ();  		location.Color = new SxzColor (pixel.R' pixel.G' pixel.B);  		location.Point.X = x;  		location.Point.Y = y;  		//Don't put transparent colors into the histogram  		if (pixel.A == 0) {  			transparentRegion.Add (location);  			locationPool.SetLocation (location' x' y);  			locationPool.SetMarked (location);  			continue;  		}  		if (pixel.A > 0 && pixel.A < 255) {  			location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  			location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  			location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  		}  		if (histogram.ContainsKey (location.Color)) {  			int count = histogram [location.Color];  			histogram [location.Color] = count + 1;  		} else {  			histogram.Add (location.Color' 1);  		}  		locationPool.SetLocation (location' x' y);  	}  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	for (int y = 0; y < height; y++) {  		System.Drawing.Color pixel = bitMap.GetPixel (x' y);  		Location location = new Location ();  		location.Color = new SxzColor (pixel.R' pixel.G' pixel.B);  		location.Point.X = x;  		location.Point.Y = y;  		//Don't put transparent colors into the histogram  		if (pixel.A == 0) {  			transparentRegion.Add (location);  			locationPool.SetLocation (location' x' y);  			locationPool.SetMarked (location);  			continue;  		}  		if (pixel.A > 0 && pixel.A < 255) {  			location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  			location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  			location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  		}  		if (histogram.ContainsKey (location.Color)) {  			int count = histogram [location.Color];  			histogram [location.Color] = count + 1;  		} else {  			histogram.Add (location.Color' 1);  		}  		locationPool.SetLocation (location' x' y);  	}  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	System.Drawing.Color pixel = bitMap.GetPixel (x' y);  	Location location = new Location ();  	location.Color = new SxzColor (pixel.R' pixel.G' pixel.B);  	location.Point.X = x;  	location.Point.Y = y;  	//Don't put transparent colors into the histogram  	if (pixel.A == 0) {  		transparentRegion.Add (location);  		locationPool.SetLocation (location' x' y);  		locationPool.SetMarked (location);  		continue;  	}  	if (pixel.A > 0 && pixel.A < 255) {  		location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  		location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  		location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  	}  	if (histogram.ContainsKey (location.Color)) {  		int count = histogram [location.Color];  		histogram [location.Color] = count + 1;  	} else {  		histogram.Add (location.Color' 1);  	}  	locationPool.SetLocation (location' x' y);  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	System.Drawing.Color pixel = bitMap.GetPixel (x' y);  	Location location = new Location ();  	location.Color = new SxzColor (pixel.R' pixel.G' pixel.B);  	location.Point.X = x;  	location.Point.Y = y;  	//Don't put transparent colors into the histogram  	if (pixel.A == 0) {  		transparentRegion.Add (location);  		locationPool.SetLocation (location' x' y);  		locationPool.SetMarked (location);  		continue;  	}  	if (pixel.A > 0 && pixel.A < 255) {  		location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  		location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  		location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  	}  	if (histogram.ContainsKey (location.Color)) {  		int count = histogram [location.Color];  		histogram [location.Color] = count + 1;  	} else {  		histogram.Add (location.Color' 1);  	}  	locationPool.SetLocation (location' x' y);  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	System.Drawing.Color pixel = bitMap.GetPixel (x' y);  	Location location = new Location ();  	location.Color = new SxzColor (pixel.R' pixel.G' pixel.B);  	location.Point.X = x;  	location.Point.Y = y;  	//Don't put transparent colors into the histogram  	if (pixel.A == 0) {  		transparentRegion.Add (location);  		locationPool.SetLocation (location' x' y);  		locationPool.SetMarked (location);  		continue;  	}  	if (pixel.A > 0 && pixel.A < 255) {  		location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  		location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  		location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  	}  	if (histogram.ContainsKey (location.Color)) {  		int count = histogram [location.Color];  		histogram [location.Color] = count + 1;  	} else {  		histogram.Add (location.Color' 1);  	}  	locationPool.SetLocation (location' x' y);  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	System.Drawing.Color pixel = bitMap.GetPixel (x' y);  	Location location = new Location ();  	location.Color = new SxzColor (pixel.R' pixel.G' pixel.B);  	location.Point.X = x;  	location.Point.Y = y;  	//Don't put transparent colors into the histogram  	if (pixel.A == 0) {  		transparentRegion.Add (location);  		locationPool.SetLocation (location' x' y);  		locationPool.SetMarked (location);  		continue;  	}  	if (pixel.A > 0 && pixel.A < 255) {  		location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  		location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  		location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  	}  	if (histogram.ContainsKey (location.Color)) {  		int count = histogram [location.Color];  		histogram [location.Color] = count + 1;  	} else {  		histogram.Add (location.Color' 1);  	}  	locationPool.SetLocation (location' x' y);  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	System.Drawing.Color pixel = bitMap.GetPixel (x' y);  	Location location = new Location ();  	location.Color = new SxzColor (pixel.R' pixel.G' pixel.B);  	location.Point.X = x;  	location.Point.Y = y;  	//Don't put transparent colors into the histogram  	if (pixel.A == 0) {  		transparentRegion.Add (location);  		locationPool.SetLocation (location' x' y);  		locationPool.SetMarked (location);  		continue;  	}  	if (pixel.A > 0 && pixel.A < 255) {  		location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  		location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  		location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  	}  	if (histogram.ContainsKey (location.Color)) {  		int count = histogram [location.Color];  		histogram [location.Color] = count + 1;  	} else {  		histogram.Add (location.Color' 1);  	}  	locationPool.SetLocation (location' x' y);  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	System.Drawing.Color pixel = bitMap.GetPixel (x' y);  	Location location = new Location ();  	location.Color = new SxzColor (pixel.R' pixel.G' pixel.B);  	location.Point.X = x;  	location.Point.Y = y;  	//Don't put transparent colors into the histogram  	if (pixel.A == 0) {  		transparentRegion.Add (location);  		locationPool.SetLocation (location' x' y);  		locationPool.SetMarked (location);  		continue;  	}  	if (pixel.A > 0 && pixel.A < 255) {  		location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  		location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  		location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  	}  	if (histogram.ContainsKey (location.Color)) {  		int count = histogram [location.Color];  		histogram [location.Color] = count + 1;  	} else {  		histogram.Add (location.Color' 1);  	}  	locationPool.SetLocation (location' x' y);  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	System.Drawing.Color pixel = bitMap.GetPixel (x' y);  	Location location = new Location ();  	location.Color = new SxzColor (pixel.R' pixel.G' pixel.B);  	location.Point.X = x;  	location.Point.Y = y;  	//Don't put transparent colors into the histogram  	if (pixel.A == 0) {  		transparentRegion.Add (location);  		locationPool.SetLocation (location' x' y);  		locationPool.SetMarked (location);  		continue;  	}  	if (pixel.A > 0 && pixel.A < 255) {  		location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  		location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  		location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  	}  	if (histogram.ContainsKey (location.Color)) {  		int count = histogram [location.Color];  		histogram [location.Color] = count + 1;  	} else {  		histogram.Add (location.Color' 1);  	}  	locationPool.SetLocation (location' x' y);  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: if (pixel.A > 0 && pixel.A < 255) {  	location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  	location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  	location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: if (pixel.A > 0 && pixel.A < 255) {  	location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  	location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  	location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: if (pixel.A > 0 && pixel.A < 255) {  	location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  	location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  	location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: if (pixel.A > 0 && pixel.A < 255) {  	location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  	location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  	location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: if (pixel.A > 0 && pixel.A < 255) {  	location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  	location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  	location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: if (pixel.A > 0 && pixel.A < 255) {  	location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  	location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  	location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: if (pixel.A > 0 && pixel.A < 255) {  	location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  	location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  	location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: location.Color.Red = (byte)Math.Round ((location.Color.Red * (pixel.A / 255.0)) + backgroundColor.Red * (1 - pixel.A / 255.0)' 0);  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: location.Color.Green = (byte)Math.Round ((location.Color.Green * (pixel.A / 255.0)) + backgroundColor.Green * (1 - pixel.A / 255.0)' 0);  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Parse,The following statement contains a magic number: location.Color.Blue = (byte)Math.Round ((location.Color.Blue * (pixel.A / 255.0)) + backgroundColor.Blue * (1 - pixel.A / 255.0)' 0);  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Process,The following statement contains a magic number: while (!locationPool.Empty ()) {  	alreadyChecked.Clear ();  	Location seed = locationPool.RandomLocation ();  	//Console.WriteLine("Have seed " + seed);  	if (type == RegionType.MonoRegion) {  		region = new MonoRegion ();  	} else if (type == RegionType.MultiColorRegion) {  		MultiColorRegion multiColorRegion = new MultiColorRegion (maximumDistance);  		region = multiColorRegion;  	}  	region.Add (seed);  	region.Origin = seed.Point;  	seed.Region = region;  	locationPool.SetMarked (seed);  	alreadyChecked.Add (seed);  	AddNeighbors (seed' todoList' alreadyChecked);  	todoList.Sort ((x' y) => (int)(SxzColor.GetColorDistance (seed.Color' x.Color) - SxzColor.GetColorDistance (seed.Color' y.Color)));  	int sortCounter = 0;  	//inner loop  	while (todoList.Count != 0) {  		//Console.WriteLine("Unmarked total " + locationPool.Unmarked.Count + " and todolist total " + todoList.Count);  		seed = todoList [0];  		todoList.RemoveAt (0);  		sortCounter++;  		if (seed.Marked) {  			throw new Exception ("Location already marked!");  		}  		if (!region.IsValid (seed)) {  			//we can process non-adjacent pixels by adding neighbors here and sorting before returning but limit the distance from an already  			//validated location  			continue;  		}  		//Console.WriteLine("Parsed pixel " + seed);  		//we have a winner!  		region.Add (seed);  		locationPool.SetMarked (seed);  		AddNeighbors (seed' todoList' alreadyChecked);  		//if (todoList.Count < 1000)  		if (todoList.Count < 1000 || sortCounter > 1000) {  			//let's limit the number to be sorted for performance sake  			todoList.Sort ((x1' y1) => (int)(SxzColor.GetColorDistance (seed.Color' x1.Color) - SxzColor.GetColorDistance (seed.Color' y1.Color)));  			sortCounter = 0;  		}  	}  	result.Add (region);  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Process,The following statement contains a magic number: while (!locationPool.Empty ()) {  	alreadyChecked.Clear ();  	Location seed = locationPool.RandomLocation ();  	//Console.WriteLine("Have seed " + seed);  	if (type == RegionType.MonoRegion) {  		region = new MonoRegion ();  	} else if (type == RegionType.MultiColorRegion) {  		MultiColorRegion multiColorRegion = new MultiColorRegion (maximumDistance);  		region = multiColorRegion;  	}  	region.Add (seed);  	region.Origin = seed.Point;  	seed.Region = region;  	locationPool.SetMarked (seed);  	alreadyChecked.Add (seed);  	AddNeighbors (seed' todoList' alreadyChecked);  	todoList.Sort ((x' y) => (int)(SxzColor.GetColorDistance (seed.Color' x.Color) - SxzColor.GetColorDistance (seed.Color' y.Color)));  	int sortCounter = 0;  	//inner loop  	while (todoList.Count != 0) {  		//Console.WriteLine("Unmarked total " + locationPool.Unmarked.Count + " and todolist total " + todoList.Count);  		seed = todoList [0];  		todoList.RemoveAt (0);  		sortCounter++;  		if (seed.Marked) {  			throw new Exception ("Location already marked!");  		}  		if (!region.IsValid (seed)) {  			//we can process non-adjacent pixels by adding neighbors here and sorting before returning but limit the distance from an already  			//validated location  			continue;  		}  		//Console.WriteLine("Parsed pixel " + seed);  		//we have a winner!  		region.Add (seed);  		locationPool.SetMarked (seed);  		AddNeighbors (seed' todoList' alreadyChecked);  		//if (todoList.Count < 1000)  		if (todoList.Count < 1000 || sortCounter > 1000) {  			//let's limit the number to be sorted for performance sake  			todoList.Sort ((x1' y1) => (int)(SxzColor.GetColorDistance (seed.Color' x1.Color) - SxzColor.GetColorDistance (seed.Color' y1.Color)));  			sortCounter = 0;  		}  	}  	result.Add (region);  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Process,The following statement contains a magic number: while (todoList.Count != 0) {  	//Console.WriteLine("Unmarked total " + locationPool.Unmarked.Count + " and todolist total " + todoList.Count);  	seed = todoList [0];  	todoList.RemoveAt (0);  	sortCounter++;  	if (seed.Marked) {  		throw new Exception ("Location already marked!");  	}  	if (!region.IsValid (seed)) {  		//we can process non-adjacent pixels by adding neighbors here and sorting before returning but limit the distance from an already  		//validated location  		continue;  	}  	//Console.WriteLine("Parsed pixel " + seed);  	//we have a winner!  	region.Add (seed);  	locationPool.SetMarked (seed);  	AddNeighbors (seed' todoList' alreadyChecked);  	//if (todoList.Count < 1000)  	if (todoList.Count < 1000 || sortCounter > 1000) {  		//let's limit the number to be sorted for performance sake  		todoList.Sort ((x1' y1) => (int)(SxzColor.GetColorDistance (seed.Color' x1.Color) - SxzColor.GetColorDistance (seed.Color' y1.Color)));  		sortCounter = 0;  	}  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Process,The following statement contains a magic number: while (todoList.Count != 0) {  	//Console.WriteLine("Unmarked total " + locationPool.Unmarked.Count + " and todolist total " + todoList.Count);  	seed = todoList [0];  	todoList.RemoveAt (0);  	sortCounter++;  	if (seed.Marked) {  		throw new Exception ("Location already marked!");  	}  	if (!region.IsValid (seed)) {  		//we can process non-adjacent pixels by adding neighbors here and sorting before returning but limit the distance from an already  		//validated location  		continue;  	}  	//Console.WriteLine("Parsed pixel " + seed);  	//we have a winner!  	region.Add (seed);  	locationPool.SetMarked (seed);  	AddNeighbors (seed' todoList' alreadyChecked);  	//if (todoList.Count < 1000)  	if (todoList.Count < 1000 || sortCounter > 1000) {  		//let's limit the number to be sorted for performance sake  		todoList.Sort ((x1' y1) => (int)(SxzColor.GetColorDistance (seed.Color' x1.Color) - SxzColor.GetColorDistance (seed.Color' y1.Color)));  		sortCounter = 0;  	}  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Process,The following statement contains a magic number: if (todoList.Count < 1000 || sortCounter > 1000) {  	//let's limit the number to be sorted for performance sake  	todoList.Sort ((x1' y1) => (int)(SxzColor.GetColorDistance (seed.Color' x1.Color) - SxzColor.GetColorDistance (seed.Color' y1.Color)));  	sortCounter = 0;  }  
Magic Number,Parser,ParseImage,F:\newReposMay17\DarkLilac_Sxz\Parser\ParseImage.cs,Process,The following statement contains a magic number: if (todoList.Count < 1000 || sortCounter > 1000) {  	//let's limit the number to be sorted for performance sake  	todoList.Sort ((x1' y1) => (int)(SxzColor.GetColorDistance (seed.Color' x1.Color) - SxzColor.GetColorDistance (seed.Color' y1.Color)));  	sortCounter = 0;  }  
Magic Number,Parser,Region,F:\newReposMay17\DarkLilac_Sxz\Parser\Region.cs,Inside,The following statement contains a magic number: return clone.Area () < (Math.Pow (2' 15) - 1);  
Magic Number,Parser,Region,F:\newReposMay17\DarkLilac_Sxz\Parser\Region.cs,Inside,The following statement contains a magic number: return clone.Area () < (Math.Pow (2' 15) - 1);  
