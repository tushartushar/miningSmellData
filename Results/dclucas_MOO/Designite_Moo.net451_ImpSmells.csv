Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,Moo,MappingException,D:\research\architectureSmells\repos\dclucas_MOO\Moo\MappingException.net4.cs,MappingException,The method has 5 parameters. Parameters: sourceType' targetType' sourceMember' targetMember' innerException
Long Parameter List,Moo,MappingException,D:\research\architectureSmells\repos\dclucas_MOO\Moo\MappingException.net4.cs,MappingException,The method has 6 parameters. Parameters: message' sourceType' targetType' sourceMember' targetMember' innerException
Long Parameter List,Moo.Core,IPropertyConverter,D:\research\architectureSmells\repos\dclucas_MOO\Moo\Core\IPropertyConverter.cs,Convert,The method has 5 parameters. Parameters: source' sourceProperty' target' targetProperty' strict
Long Parameter List,Moo.Core,PropertyConverter,D:\research\architectureSmells\repos\dclucas_MOO\Moo\Core\PropertyConverter.cs,Convert,The method has 5 parameters. Parameters: source' sourceProperty' target' targetProperty' strict
Long Statement,Moo.Core,ExpressionHandler,D:\research\architectureSmells\repos\dclucas_MOO\Moo\Core\ExpressionHandler.cs,ValidatePropertyExpression,The length of the statement  "                        "'To' should be called with a property getter delegate' but instead got a {0} expression type' with a {1} expression body"' " is 123.
Complex Conditional,Moo.Mappers,BaseMapper<TSource;TTarget>,D:\research\architectureSmells\repos\dclucas_MOO\Moo\Mappers\BaseMapper.net4.cs,GetInnerMapper,The conditional expression  "(tt != null)                      && (ts != null)                      && genericEnumerableType.IsAssignableFrom(tt)                      && genericEnumerableType.IsAssignableFrom(ts)"  is complex.
Missing Default,Moo.Core,TypeMappingInfo<TSource;TTarget>,D:\research\architectureSmells\repos\dclucas_MOO\Moo\Core\TypeMappingInfo.cs,Add,The following switch statement is missing a default case: switch (OverwriteBehavior)              {                  case MappingOverwriteBehavior.AllowOverwrite:                      _memberMappings[mappingInfo.TargetMemberName] = mappingInfo;                      break;                    case MappingOverwriteBehavior.SkipOverwrite:                      if (!_memberMappings.ContainsKey(mappingInfo.TargetMemberName))                      {                          _memberMappings[mappingInfo.TargetMemberName] = mappingInfo;                      }                        break;                    case MappingOverwriteBehavior.ThrowOnOverwrite:                      if (!_memberMappings.ContainsKey(mappingInfo.TargetMemberName))                      {                          throw new MappingException(                              string.Format(                                  CultureInfo.InvariantCulture'                                  "Target {0}.{1} was defined multiple times."'                                  typeof (TTarget).FullName'                                  mappingInfo.TargetMemberName)'                              typeof (TSource)'                              typeof (TTarget)'                              mappingInfo.SourceMemberName'                              mappingInfo.TargetMemberName'                              null);                      }                        break;              }
