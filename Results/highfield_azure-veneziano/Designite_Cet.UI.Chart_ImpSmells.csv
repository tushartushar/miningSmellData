Implementation smell,Namespace,Class,File,Method,Description
Long Method,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The method has 137 lines of code.
Complex Method,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,Cyclomatic complexity of the method is 23
Complex Method,Cet.UI.Chart,ChartAxisDouble,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Axis\ChartAxisDouble.cs,OnRender,Cyclomatic complexity of the method is 8
Complex Method,Cet.UI.Chart,ChartPlotCartesianLinear,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Plot\ChartPlotCartesianLinear.cs,RenderCore,Cyclomatic complexity of the method is 8
Complex Method,Cet.UI.Chart,TimelineHelper,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Timeline\Models\TimelineHelper.cs,AccumulateTickInfo,Cyclomatic complexity of the method is 8
Long Parameter List,Cet.UI.Chart,CanvasDrawingContext,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\CanvasDrawingContext.cs,DrawText,The method has 5 parameters.
Long Parameter List,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawDashedLine,The method has 6 parameters.
Long Parameter List,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The method has 12 parameters.
Long Parameter List,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawDivisions,The method has 8 parameters.
Long Statement,Cet.UI.Chart,ChartCanvas,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Controls\ChartCanvas.cs,RenderBorder,The length of the statement  "		dc.DrawLine (pen' new Point (dc.ClientArea.Width - th2' th2)' new Point (dc.ClientArea.Width - th2' dc.ClientArea.Height - th2)); " is 129.
Long Statement,Cet.UI.Chart,ChartCanvas,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Controls\ChartCanvas.cs,RenderBorder,The length of the statement  "		dc.DrawLine (pen' new Point (th2' dc.ClientArea.Height - th2)' new Point (dc.ClientArea.Width - th2' dc.ClientArea.Height - th2)); " is 130.
Long Statement,Cet.UI.Chart,CanvasDrawingContext,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\CanvasDrawingContext.cs,DrawLine,The length of the statement  "	this._originalContext.DrawLine (pen' this.Snapper (pt1 + (Vector)this.ClientArea.Location)' this.Snapper (pt2 + (Vector)this.ClientArea.Location)); " is 147.
Long Statement,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The length of the statement  "		var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key); " is 125.
Long Statement,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The length of the statement  "						dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2)); " is 120.
Long Statement,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The length of the statement  "		var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key); " is 125.
Long Statement,Cet.UI.Chart,ChartPlotCartesianBoolean,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Plot\ChartPlotCartesianBoolean.cs,OnRender,The length of the statement  "	DrawingHelpers.DrawDashedLine (dc' dc.GetTickPen (0)' new Point (0.0' yd)' new Point (dc.ClientArea.Width' yd)' dashPeriod' dashDuty); " is 134.
Long Statement,Cet.UI.Chart,ChartPlotCartesianBoolean,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Plot\ChartPlotCartesianBoolean.cs,OnRender,The length of the statement  "	DrawingHelpers.DrawDashedLine (dc' dc.GetTickPen (0)' new Point (0.0' yd)' new Point (dc.ClientArea.Width' yd)' dashPeriod' dashDuty); " is 134.
Magic Number,Cet.UI.Chart,CanvasDrawingContext,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\CanvasDrawingContext.cs,CanvasDrawingContext,The following statement contains a magic number: _tickBrushes = new Brush[3] {  	Brushes.Gray'  	Brushes.Black'  	Brushes.Black'  };  
Magic Number,Cet.UI.Chart,CanvasDrawingContext,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\CanvasDrawingContext.cs,CanvasDrawingContext,The following statement contains a magic number: _tickPens = new Pen[3] {  	new Pen (Brushes.Gray' 0.5)'  	new Pen (Brushes.Gray' 1.0)'  	new Pen (Brushes.Gray' 2.0)'  };  
Magic Number,Cet.UI.Chart,CanvasDrawingContext,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\CanvasDrawingContext.cs,CanvasDrawingContext,The following statement contains a magic number: _tickPens = new Pen[3] {  	new Pen (Brushes.Gray' 0.5)'  	new Pen (Brushes.Gray' 1.0)'  	new Pen (Brushes.Gray' 2.0)'  };  
Magic Number,Cet.UI.Chart,CanvasDrawingContext,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\CanvasDrawingContext.cs,CanvasDrawingContext,The following statement contains a magic number: _tickPens = new Pen[3] {  	new Pen (Brushes.Gray' 0.5)'  	new Pen (Brushes.Gray' 1.0)'  	new Pen (Brushes.Gray' 2.0)'  };  
Magic Number,Cet.UI.Chart,CanvasDrawingContext,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\CanvasDrawingContext.cs,CanvasDrawingContext,The following statement contains a magic number: _tickFaces = new Typeface[3] {  	new Typeface (family' FontStyles.Normal' FontWeights.Normal' FontStretches.Normal)'  	new Typeface (family' FontStyles.Normal' FontWeights.Normal' FontStretches.Normal)'  	new Typeface (family' FontStyles.Normal' FontWeights.Bold' FontStretches.Normal)'  };  
Magic Number,Cet.UI.Chart,CanvasDrawingContext,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\CanvasDrawingContext.cs,Snapper,The following statement contains a magic number: if (displacement < 0.5) {  	return Math.Round (value) + (0.5 + displacement);  }  else {  	return Math.Round (value) - (displacement - 0.5);  }  
Magic Number,Cet.UI.Chart,CanvasDrawingContext,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\CanvasDrawingContext.cs,Snapper,The following statement contains a magic number: if (displacement < 0.5) {  	return Math.Round (value) + (0.5 + displacement);  }  else {  	return Math.Round (value) - (displacement - 0.5);  }  
Magic Number,Cet.UI.Chart,CanvasDrawingContext,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\CanvasDrawingContext.cs,Snapper,The following statement contains a magic number: if (displacement < 0.5) {  	return Math.Round (value) + (0.5 + displacement);  }  else {  	return Math.Round (value) - (displacement - 0.5);  }  
Magic Number,Cet.UI.Chart,CanvasDrawingContext,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\CanvasDrawingContext.cs,Snapper,The following statement contains a magic number: return Math.Round (value) + (0.5 + displacement);  
Magic Number,Cet.UI.Chart,CanvasDrawingContext,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\CanvasDrawingContext.cs,Snapper,The following statement contains a magic number: return Math.Round (value) - (displacement - 0.5);  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawDashedLine,The following statement contains a magic number: if (dashDuty < 0.01) {  	//non ha senso tracciare perchè il duty è quasi zero  	return;  }  else if (dashPeriod < 2.0 || dashDuty > 0.99) {  	//tratteggio che degenera in una linea continua  	dc.DrawLine (pen' point0' point1);  }  else {  	//linea trasparente in modo da mantenere l'hit-testing  	var pen_trans = new Pen (Brushes.Transparent' pen.Thickness);  	dc.DrawLine (pen_trans' point0' point1);  	//tracciamento dei singoli tratti  	var clipper = new LiangBarskyClipping (dc.ClientArea);  	if (clipper.ClipLine (ref point0' ref point1)) {  		var dx = point1.X - point0.X;  		var dy = point1.Y - point0.Y;  		var d = Math.Sqrt (dx * dx + dy * dy);  		var dashLen = dashPeriod * dashDuty;  		if (d >= dashLen) {  			for (double l = 0; l < d; l += dashPeriod) {  				var a0 = l / d;  				var a1 = Math.Min (a0 + dashLen / d' 1.0);  				var q0 = new Point (point0.X + dx * a0' point0.Y + dy * a0);  				var q1 = new Point (point0.X + dx * a1' point0.Y + dy * a1);  				dc.DrawLine (pen' q0' q1);  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawDashedLine,The following statement contains a magic number: if (dashDuty < 0.01) {  	//non ha senso tracciare perchè il duty è quasi zero  	return;  }  else if (dashPeriod < 2.0 || dashDuty > 0.99) {  	//tratteggio che degenera in una linea continua  	dc.DrawLine (pen' point0' point1);  }  else {  	//linea trasparente in modo da mantenere l'hit-testing  	var pen_trans = new Pen (Brushes.Transparent' pen.Thickness);  	dc.DrawLine (pen_trans' point0' point1);  	//tracciamento dei singoli tratti  	var clipper = new LiangBarskyClipping (dc.ClientArea);  	if (clipper.ClipLine (ref point0' ref point1)) {  		var dx = point1.X - point0.X;  		var dy = point1.Y - point0.Y;  		var d = Math.Sqrt (dx * dx + dy * dy);  		var dashLen = dashPeriod * dashDuty;  		if (d >= dashLen) {  			for (double l = 0; l < d; l += dashPeriod) {  				var a0 = l / d;  				var a1 = Math.Min (a0 + dashLen / d' 1.0);  				var q0 = new Point (point0.X + dx * a0' point0.Y + dy * a0);  				var q1 = new Point (point0.X + dx * a1' point0.Y + dy * a1);  				dc.DrawLine (pen' q0' q1);  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawDashedLine,The following statement contains a magic number: if (dashDuty < 0.01) {  	//non ha senso tracciare perchè il duty è quasi zero  	return;  }  else if (dashPeriod < 2.0 || dashDuty > 0.99) {  	//tratteggio che degenera in una linea continua  	dc.DrawLine (pen' point0' point1);  }  else {  	//linea trasparente in modo da mantenere l'hit-testing  	var pen_trans = new Pen (Brushes.Transparent' pen.Thickness);  	dc.DrawLine (pen_trans' point0' point1);  	//tracciamento dei singoli tratti  	var clipper = new LiangBarskyClipping (dc.ClientArea);  	if (clipper.ClipLine (ref point0' ref point1)) {  		var dx = point1.X - point0.X;  		var dy = point1.Y - point0.Y;  		var d = Math.Sqrt (dx * dx + dy * dy);  		var dashLen = dashPeriod * dashDuty;  		if (d >= dashLen) {  			for (double l = 0; l < d; l += dashPeriod) {  				var a0 = l / d;  				var a1 = Math.Min (a0 + dashLen / d' 1.0);  				var q0 = new Point (point0.X + dx * a0' point0.Y + dy * a0);  				var q1 = new Point (point0.X + dx * a1' point0.Y + dy * a1);  				dc.DrawLine (pen' q0' q1);  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawDashedLine,The following statement contains a magic number: if (dashPeriod < 2.0 || dashDuty > 0.99) {  	//tratteggio che degenera in una linea continua  	dc.DrawLine (pen' point0' point1);  }  else {  	//linea trasparente in modo da mantenere l'hit-testing  	var pen_trans = new Pen (Brushes.Transparent' pen.Thickness);  	dc.DrawLine (pen_trans' point0' point1);  	//tracciamento dei singoli tratti  	var clipper = new LiangBarskyClipping (dc.ClientArea);  	if (clipper.ClipLine (ref point0' ref point1)) {  		var dx = point1.X - point0.X;  		var dy = point1.Y - point0.Y;  		var d = Math.Sqrt (dx * dx + dy * dy);  		var dashLen = dashPeriod * dashDuty;  		if (d >= dashLen) {  			for (double l = 0; l < d; l += dashPeriod) {  				var a0 = l / d;  				var a1 = Math.Min (a0 + dashLen / d' 1.0);  				var q0 = new Point (point0.X + dx * a0' point0.Y + dy * a0);  				var q1 = new Point (point0.X + dx * a1' point0.Y + dy * a1);  				dc.DrawLine (pen' q0' q1);  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawDashedLine,The following statement contains a magic number: if (dashPeriod < 2.0 || dashDuty > 0.99) {  	//tratteggio che degenera in una linea continua  	dc.DrawLine (pen' point0' point1);  }  else {  	//linea trasparente in modo da mantenere l'hit-testing  	var pen_trans = new Pen (Brushes.Transparent' pen.Thickness);  	dc.DrawLine (pen_trans' point0' point1);  	//tracciamento dei singoli tratti  	var clipper = new LiangBarskyClipping (dc.ClientArea);  	if (clipper.ClipLine (ref point0' ref point1)) {  		var dx = point1.X - point0.X;  		var dy = point1.Y - point0.Y;  		var d = Math.Sqrt (dx * dx + dy * dy);  		var dashLen = dashPeriod * dashDuty;  		if (d >= dashLen) {  			for (double l = 0; l < d; l += dashPeriod) {  				var a0 = l / d;  				var a1 = Math.Min (a0 + dashLen / d' 1.0);  				var q0 = new Point (point0.X + dx * a0' point0.Y + dy * a0);  				var q1 = new Point (point0.X + dx * a1' point0.Y + dy * a1);  				dc.DrawLine (pen' q0' q1);  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left || dock == Dock.Right) {  	var slots = new bool[(int)area.Height];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Left) {  				//draw tick line  				dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  			}  			else {  				pos = area.Height - pos;  				//draw tick line  				dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Left) {  					//draw major label text  					var xd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd' pos - ftMinor.Height / 2)  					//    );  				}  				else {  					//draw major label text  					var xd = area.Width - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  					//    );  				}  			}  		}  	}  }  else if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left || dock == Dock.Right) {  	var slots = new bool[(int)area.Height];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Left) {  				//draw tick line  				dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  			}  			else {  				pos = area.Height - pos;  				//draw tick line  				dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Left) {  					//draw major label text  					var xd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd' pos - ftMinor.Height / 2)  					//    );  				}  				else {  					//draw major label text  					var xd = area.Width - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  					//    );  				}  			}  		}  	}  }  else if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left || dock == Dock.Right) {  	var slots = new bool[(int)area.Height];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Left) {  				//draw tick line  				dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  			}  			else {  				pos = area.Height - pos;  				//draw tick line  				dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Left) {  					//draw major label text  					var xd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd' pos - ftMinor.Height / 2)  					//    );  				}  				else {  					//draw major label text  					var xd = area.Width - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  					//    );  				}  			}  		}  	}  }  else if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left || dock == Dock.Right) {  	var slots = new bool[(int)area.Height];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Left) {  				//draw tick line  				dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  			}  			else {  				pos = area.Height - pos;  				//draw tick line  				dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Left) {  					//draw major label text  					var xd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd' pos - ftMinor.Height / 2)  					//    );  				}  				else {  					//draw major label text  					var xd = area.Width - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  					//    );  				}  			}  		}  	}  }  else if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left || dock == Dock.Right) {  	var slots = new bool[(int)area.Height];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Left) {  				//draw tick line  				dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  			}  			else {  				pos = area.Height - pos;  				//draw tick line  				dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Left) {  					//draw major label text  					var xd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd' pos - ftMinor.Height / 2)  					//    );  				}  				else {  					//draw major label text  					var xd = area.Width - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  					//    );  				}  			}  		}  	}  }  else if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left || dock == Dock.Right) {  	var slots = new bool[(int)area.Height];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Left) {  				//draw tick line  				dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  			}  			else {  				pos = area.Height - pos;  				//draw tick line  				dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Left) {  					//draw major label text  					var xd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd' pos - ftMinor.Height / 2)  					//    );  				}  				else {  					//draw major label text  					var xd = area.Width - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  					//    );  				}  			}  		}  	}  }  else if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left || dock == Dock.Right) {  	var slots = new bool[(int)area.Height];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Left) {  				//draw tick line  				dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  			}  			else {  				pos = area.Height - pos;  				//draw tick line  				dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Left) {  					//draw major label text  					var xd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd' pos - ftMinor.Height / 2)  					//    );  				}  				else {  					//draw major label text  					var xd = area.Width - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  					//    );  				}  			}  		}  	}  }  else if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left || dock == Dock.Right) {  	var slots = new bool[(int)area.Height];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Left) {  				//draw tick line  				dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  			}  			else {  				pos = area.Height - pos;  				//draw tick line  				dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Left) {  					//draw major label text  					var xd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd' pos - ftMinor.Height / 2)  					//    );  				}  				else {  					//draw major label text  					var xd = area.Width - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  					//    );  				}  			}  		}  	}  }  else if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left || dock == Dock.Right) {  	var slots = new bool[(int)area.Height];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Left) {  				//draw tick line  				dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  			}  			else {  				pos = area.Height - pos;  				//draw tick line  				dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Left) {  					//draw major label text  					var xd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd' pos - ftMinor.Height / 2)  					//    );  				}  				else {  					//draw major label text  					var xd = area.Width - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  					//    );  				}  			}  		}  	}  }  else if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left || dock == Dock.Right) {  	var slots = new bool[(int)area.Height];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Left) {  				//draw tick line  				dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  			}  			else {  				pos = area.Height - pos;  				//draw tick line  				dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Left) {  					//draw major label text  					var xd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd' pos - ftMinor.Height / 2)  					//    );  				}  				else {  					//draw major label text  					var xd = area.Width - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  					//    );  				}  			}  		}  	}  }  else if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left || dock == Dock.Right) {  	var slots = new bool[(int)area.Height];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Left) {  				//draw tick line  				dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  			}  			else {  				pos = area.Height - pos;  				//draw tick line  				dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Left) {  					//draw major label text  					var xd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd' pos - ftMinor.Height / 2)  					//    );  				}  				else {  					//draw major label text  					var xd = area.Width - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  					//    );  				}  			}  		}  	}  }  else if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left || dock == Dock.Right) {  	var slots = new bool[(int)area.Height];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Left) {  				//draw tick line  				dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  			}  			else {  				pos = area.Height - pos;  				//draw tick line  				dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Left) {  					//draw major label text  					var xd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd' pos - ftMinor.Height / 2)  					//    );  				}  				else {  					//draw major label text  					var xd = area.Width - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  					//    );  				}  			}  		}  	}  }  else if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left || dock == Dock.Right) {  	var slots = new bool[(int)area.Height];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Left) {  				//draw tick line  				dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  			}  			else {  				pos = area.Height - pos;  				//draw tick line  				dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Left) {  					//draw major label text  					var xd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd' pos - ftMinor.Height / 2)  					//    );  				}  				else {  					//draw major label text  					var xd = area.Width - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  					//    );  				}  			}  		}  	}  }  else if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left || dock == Dock.Right) {  	var slots = new bool[(int)area.Height];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Left) {  				//draw tick line  				dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  			}  			else {  				pos = area.Height - pos;  				//draw tick line  				dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Left) {  					//draw major label text  					var xd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd' pos - ftMinor.Height / 2)  					//    );  				}  				else {  					//draw major label text  					var xd = area.Width - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  					//    );  				}  			}  		}  	}  }  else if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left || dock == Dock.Right) {  	var slots = new bool[(int)area.Height];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Left) {  				//draw tick line  				dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  			}  			else {  				pos = area.Height - pos;  				//draw tick line  				dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Left) {  					//draw major label text  					var xd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd' pos - ftMinor.Height / 2)  					//    );  				}  				else {  					//draw major label text  					var xd = area.Width - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  					//    );  				}  			}  		}  	}  }  else if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left || dock == Dock.Right) {  	var slots = new bool[(int)area.Height];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Left) {  				//draw tick line  				dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  			}  			else {  				pos = area.Height - pos;  				//draw tick line  				dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Left) {  					//draw major label text  					var xd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd' pos - ftMinor.Height / 2)  					//    );  				}  				else {  					//draw major label text  					var xd = area.Width - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  					//    );  				}  			}  		}  	}  }  else if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left || dock == Dock.Right) {  	var slots = new bool[(int)area.Height];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Left) {  				//draw tick line  				dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  			}  			else {  				pos = area.Height - pos;  				//draw tick line  				dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Left) {  					//draw major label text  					var xd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd' pos - ftMinor.Height / 2)  					//    );  				}  				else {  					//draw major label text  					var xd = area.Width - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  					//    );  				}  			}  		}  	}  }  else if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left || dock == Dock.Right) {  	var slots = new bool[(int)area.Height];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Left) {  				//draw tick line  				dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  			}  			else {  				pos = area.Height - pos;  				//draw tick line  				dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Left) {  					//draw major label text  					var xd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd' pos - ftMinor.Height / 2)  					//    );  				}  				else {  					//draw major label text  					var xd = area.Width - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  					//    );  				}  			}  		}  	}  }  else if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left || dock == Dock.Right) {  	var slots = new bool[(int)area.Height];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Left) {  				//draw tick line  				dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  			}  			else {  				pos = area.Height - pos;  				//draw tick line  				dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Left) {  					//draw major label text  					var xd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd' pos - ftMinor.Height / 2)  					//    );  				}  				else {  					//draw major label text  					var xd = area.Width - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  					//    );  				}  			}  		}  	}  }  else if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left || dock == Dock.Right) {  	var slots = new bool[(int)area.Height];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Left) {  				//draw tick line  				dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  			}  			else {  				pos = area.Height - pos;  				//draw tick line  				dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Left) {  					//draw major label text  					var xd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd' pos - ftMinor.Height / 2)  					//    );  				}  				else {  					//draw major label text  					var xd = area.Width - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  					//    );  				}  			}  		}  	}  }  else if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left || dock == Dock.Right) {  	var slots = new bool[(int)area.Height];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Left) {  				//draw tick line  				dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  			}  			else {  				pos = area.Height - pos;  				//draw tick line  				dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Left) {  					//draw major label text  					var xd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd' pos - ftMinor.Height / 2)  					//    );  				}  				else {  					//draw major label text  					var xd = area.Width - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  					//    );  				}  			}  		}  	}  }  else if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left || dock == Dock.Right) {  	var slots = new bool[(int)area.Height];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Left) {  				//draw tick line  				dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  			}  			else {  				pos = area.Height - pos;  				//draw tick line  				dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Left) {  					//draw major label text  					var xd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd' pos - ftMinor.Height / 2)  					//    );  				}  				else {  					//draw major label text  					var xd = area.Width - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  					//draw minor label text  					//xd += size;  					//dc.DrawText(  					//    ftMinor'  					//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  					//    );  				}  			}  		}  	}  }  else if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (var segment in segmentGroup) {  	int prio = segment.Key;  	var len = 5 + prio * 10.0;  	var size = 11.0 + prio * 2.5;  	var pen = dc.GetTickPen (prio);  	var brush = dc.GetTickBrush (prio);  	var face = dc.GetTickFace (prio);  	foreach (ChartTickInfo ti in segment) {  		//calculate major and minor label texts  		var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  		var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  		int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  		var ipos = (int)Math.Round (ti.PixelPosition);  		var pos = ti.PixelPosition;  		if (dock == Dock.Left) {  			//draw tick line  			dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  		}  		else {  			pos = area.Height - pos;  			//draw tick line  			dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  		}  		var a = ipos - bigger / 2;  		var b = a + bigger;  		if (a < 0)  			a = 0;  		if (b >= slots.Length)  			b = slots.Length - 1;  		bool canDraw = true;  		for (int x = a; x <= b; x++) {  			if (slots [x]) {  				canDraw = false;  				break;  			}  		}  		if (canDraw) {  			//fill slots  			for (int x = a; x <= b; x++) {  				slots [x] = true;  			}  			if (dock == Dock.Left) {  				//draw major label text  				var xd = len + 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  				//draw minor label text  				//xd += size;  				//dc.DrawText(  				//    ftMinor'  				//    new Point(xd' pos - ftMinor.Height / 2)  				//    );  			}  			else {  				//draw major label text  				var xd = area.Width - len - 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  				//draw minor label text  				//xd += size;  				//dc.DrawText(  				//    ftMinor'  				//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  				//    );  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (var segment in segmentGroup) {  	int prio = segment.Key;  	var len = 5 + prio * 10.0;  	var size = 11.0 + prio * 2.5;  	var pen = dc.GetTickPen (prio);  	var brush = dc.GetTickBrush (prio);  	var face = dc.GetTickFace (prio);  	foreach (ChartTickInfo ti in segment) {  		//calculate major and minor label texts  		var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  		var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  		int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  		var ipos = (int)Math.Round (ti.PixelPosition);  		var pos = ti.PixelPosition;  		if (dock == Dock.Left) {  			//draw tick line  			dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  		}  		else {  			pos = area.Height - pos;  			//draw tick line  			dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  		}  		var a = ipos - bigger / 2;  		var b = a + bigger;  		if (a < 0)  			a = 0;  		if (b >= slots.Length)  			b = slots.Length - 1;  		bool canDraw = true;  		for (int x = a; x <= b; x++) {  			if (slots [x]) {  				canDraw = false;  				break;  			}  		}  		if (canDraw) {  			//fill slots  			for (int x = a; x <= b; x++) {  				slots [x] = true;  			}  			if (dock == Dock.Left) {  				//draw major label text  				var xd = len + 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  				//draw minor label text  				//xd += size;  				//dc.DrawText(  				//    ftMinor'  				//    new Point(xd' pos - ftMinor.Height / 2)  				//    );  			}  			else {  				//draw major label text  				var xd = area.Width - len - 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  				//draw minor label text  				//xd += size;  				//dc.DrawText(  				//    ftMinor'  				//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  				//    );  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (var segment in segmentGroup) {  	int prio = segment.Key;  	var len = 5 + prio * 10.0;  	var size = 11.0 + prio * 2.5;  	var pen = dc.GetTickPen (prio);  	var brush = dc.GetTickBrush (prio);  	var face = dc.GetTickFace (prio);  	foreach (ChartTickInfo ti in segment) {  		//calculate major and minor label texts  		var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  		var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  		int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  		var ipos = (int)Math.Round (ti.PixelPosition);  		var pos = ti.PixelPosition;  		if (dock == Dock.Left) {  			//draw tick line  			dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  		}  		else {  			pos = area.Height - pos;  			//draw tick line  			dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  		}  		var a = ipos - bigger / 2;  		var b = a + bigger;  		if (a < 0)  			a = 0;  		if (b >= slots.Length)  			b = slots.Length - 1;  		bool canDraw = true;  		for (int x = a; x <= b; x++) {  			if (slots [x]) {  				canDraw = false;  				break;  			}  		}  		if (canDraw) {  			//fill slots  			for (int x = a; x <= b; x++) {  				slots [x] = true;  			}  			if (dock == Dock.Left) {  				//draw major label text  				var xd = len + 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  				//draw minor label text  				//xd += size;  				//dc.DrawText(  				//    ftMinor'  				//    new Point(xd' pos - ftMinor.Height / 2)  				//    );  			}  			else {  				//draw major label text  				var xd = area.Width - len - 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  				//draw minor label text  				//xd += size;  				//dc.DrawText(  				//    ftMinor'  				//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  				//    );  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (var segment in segmentGroup) {  	int prio = segment.Key;  	var len = 5 + prio * 10.0;  	var size = 11.0 + prio * 2.5;  	var pen = dc.GetTickPen (prio);  	var brush = dc.GetTickBrush (prio);  	var face = dc.GetTickFace (prio);  	foreach (ChartTickInfo ti in segment) {  		//calculate major and minor label texts  		var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  		var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  		int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  		var ipos = (int)Math.Round (ti.PixelPosition);  		var pos = ti.PixelPosition;  		if (dock == Dock.Left) {  			//draw tick line  			dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  		}  		else {  			pos = area.Height - pos;  			//draw tick line  			dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  		}  		var a = ipos - bigger / 2;  		var b = a + bigger;  		if (a < 0)  			a = 0;  		if (b >= slots.Length)  			b = slots.Length - 1;  		bool canDraw = true;  		for (int x = a; x <= b; x++) {  			if (slots [x]) {  				canDraw = false;  				break;  			}  		}  		if (canDraw) {  			//fill slots  			for (int x = a; x <= b; x++) {  				slots [x] = true;  			}  			if (dock == Dock.Left) {  				//draw major label text  				var xd = len + 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  				//draw minor label text  				//xd += size;  				//dc.DrawText(  				//    ftMinor'  				//    new Point(xd' pos - ftMinor.Height / 2)  				//    );  			}  			else {  				//draw major label text  				var xd = area.Width - len - 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  				//draw minor label text  				//xd += size;  				//dc.DrawText(  				//    ftMinor'  				//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  				//    );  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (var segment in segmentGroup) {  	int prio = segment.Key;  	var len = 5 + prio * 10.0;  	var size = 11.0 + prio * 2.5;  	var pen = dc.GetTickPen (prio);  	var brush = dc.GetTickBrush (prio);  	var face = dc.GetTickFace (prio);  	foreach (ChartTickInfo ti in segment) {  		//calculate major and minor label texts  		var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  		var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  		int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  		var ipos = (int)Math.Round (ti.PixelPosition);  		var pos = ti.PixelPosition;  		if (dock == Dock.Left) {  			//draw tick line  			dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  		}  		else {  			pos = area.Height - pos;  			//draw tick line  			dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  		}  		var a = ipos - bigger / 2;  		var b = a + bigger;  		if (a < 0)  			a = 0;  		if (b >= slots.Length)  			b = slots.Length - 1;  		bool canDraw = true;  		for (int x = a; x <= b; x++) {  			if (slots [x]) {  				canDraw = false;  				break;  			}  		}  		if (canDraw) {  			//fill slots  			for (int x = a; x <= b; x++) {  				slots [x] = true;  			}  			if (dock == Dock.Left) {  				//draw major label text  				var xd = len + 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  				//draw minor label text  				//xd += size;  				//dc.DrawText(  				//    ftMinor'  				//    new Point(xd' pos - ftMinor.Height / 2)  				//    );  			}  			else {  				//draw major label text  				var xd = area.Width - len - 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  				//draw minor label text  				//xd += size;  				//dc.DrawText(  				//    ftMinor'  				//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  				//    );  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (var segment in segmentGroup) {  	int prio = segment.Key;  	var len = 5 + prio * 10.0;  	var size = 11.0 + prio * 2.5;  	var pen = dc.GetTickPen (prio);  	var brush = dc.GetTickBrush (prio);  	var face = dc.GetTickFace (prio);  	foreach (ChartTickInfo ti in segment) {  		//calculate major and minor label texts  		var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  		var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  		int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  		var ipos = (int)Math.Round (ti.PixelPosition);  		var pos = ti.PixelPosition;  		if (dock == Dock.Left) {  			//draw tick line  			dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  		}  		else {  			pos = area.Height - pos;  			//draw tick line  			dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  		}  		var a = ipos - bigger / 2;  		var b = a + bigger;  		if (a < 0)  			a = 0;  		if (b >= slots.Length)  			b = slots.Length - 1;  		bool canDraw = true;  		for (int x = a; x <= b; x++) {  			if (slots [x]) {  				canDraw = false;  				break;  			}  		}  		if (canDraw) {  			//fill slots  			for (int x = a; x <= b; x++) {  				slots [x] = true;  			}  			if (dock == Dock.Left) {  				//draw major label text  				var xd = len + 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  				//draw minor label text  				//xd += size;  				//dc.DrawText(  				//    ftMinor'  				//    new Point(xd' pos - ftMinor.Height / 2)  				//    );  			}  			else {  				//draw major label text  				var xd = area.Width - len - 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  				//draw minor label text  				//xd += size;  				//dc.DrawText(  				//    ftMinor'  				//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  				//    );  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (var segment in segmentGroup) {  	int prio = segment.Key;  	var len = 5 + prio * 10.0;  	var size = 11.0 + prio * 2.5;  	var pen = dc.GetTickPen (prio);  	var brush = dc.GetTickBrush (prio);  	var face = dc.GetTickFace (prio);  	foreach (ChartTickInfo ti in segment) {  		//calculate major and minor label texts  		var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  		var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  		int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  		var ipos = (int)Math.Round (ti.PixelPosition);  		var pos = ti.PixelPosition;  		if (dock == Dock.Left) {  			//draw tick line  			dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  		}  		else {  			pos = area.Height - pos;  			//draw tick line  			dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  		}  		var a = ipos - bigger / 2;  		var b = a + bigger;  		if (a < 0)  			a = 0;  		if (b >= slots.Length)  			b = slots.Length - 1;  		bool canDraw = true;  		for (int x = a; x <= b; x++) {  			if (slots [x]) {  				canDraw = false;  				break;  			}  		}  		if (canDraw) {  			//fill slots  			for (int x = a; x <= b; x++) {  				slots [x] = true;  			}  			if (dock == Dock.Left) {  				//draw major label text  				var xd = len + 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  				//draw minor label text  				//xd += size;  				//dc.DrawText(  				//    ftMinor'  				//    new Point(xd' pos - ftMinor.Height / 2)  				//    );  			}  			else {  				//draw major label text  				var xd = area.Width - len - 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  				//draw minor label text  				//xd += size;  				//dc.DrawText(  				//    ftMinor'  				//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  				//    );  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (var segment in segmentGroup) {  	int prio = segment.Key;  	var len = 5 + prio * 10.0;  	var size = 11.0 + prio * 2.5;  	var pen = dc.GetTickPen (prio);  	var brush = dc.GetTickBrush (prio);  	var face = dc.GetTickFace (prio);  	foreach (ChartTickInfo ti in segment) {  		//calculate major and minor label texts  		var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  		var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  		int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  		var ipos = (int)Math.Round (ti.PixelPosition);  		var pos = ti.PixelPosition;  		if (dock == Dock.Left) {  			//draw tick line  			dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  		}  		else {  			pos = area.Height - pos;  			//draw tick line  			dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  		}  		var a = ipos - bigger / 2;  		var b = a + bigger;  		if (a < 0)  			a = 0;  		if (b >= slots.Length)  			b = slots.Length - 1;  		bool canDraw = true;  		for (int x = a; x <= b; x++) {  			if (slots [x]) {  				canDraw = false;  				break;  			}  		}  		if (canDraw) {  			//fill slots  			for (int x = a; x <= b; x++) {  				slots [x] = true;  			}  			if (dock == Dock.Left) {  				//draw major label text  				var xd = len + 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  				//draw minor label text  				//xd += size;  				//dc.DrawText(  				//    ftMinor'  				//    new Point(xd' pos - ftMinor.Height / 2)  				//    );  			}  			else {  				//draw major label text  				var xd = area.Width - len - 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  				//draw minor label text  				//xd += size;  				//dc.DrawText(  				//    ftMinor'  				//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  				//    );  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (var segment in segmentGroup) {  	int prio = segment.Key;  	var len = 5 + prio * 10.0;  	var size = 11.0 + prio * 2.5;  	var pen = dc.GetTickPen (prio);  	var brush = dc.GetTickBrush (prio);  	var face = dc.GetTickFace (prio);  	foreach (ChartTickInfo ti in segment) {  		//calculate major and minor label texts  		var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  		var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  		int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  		var ipos = (int)Math.Round (ti.PixelPosition);  		var pos = ti.PixelPosition;  		if (dock == Dock.Left) {  			//draw tick line  			dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  		}  		else {  			pos = area.Height - pos;  			//draw tick line  			dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  		}  		var a = ipos - bigger / 2;  		var b = a + bigger;  		if (a < 0)  			a = 0;  		if (b >= slots.Length)  			b = slots.Length - 1;  		bool canDraw = true;  		for (int x = a; x <= b; x++) {  			if (slots [x]) {  				canDraw = false;  				break;  			}  		}  		if (canDraw) {  			//fill slots  			for (int x = a; x <= b; x++) {  				slots [x] = true;  			}  			if (dock == Dock.Left) {  				//draw major label text  				var xd = len + 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  				//draw minor label text  				//xd += size;  				//dc.DrawText(  				//    ftMinor'  				//    new Point(xd' pos - ftMinor.Height / 2)  				//    );  			}  			else {  				//draw major label text  				var xd = area.Width - len - 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  				//draw minor label text  				//xd += size;  				//dc.DrawText(  				//    ftMinor'  				//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  				//    );  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (var segment in segmentGroup) {  	int prio = segment.Key;  	var len = 5 + prio * 10.0;  	var size = 11.0 + prio * 2.5;  	var pen = dc.GetTickPen (prio);  	var brush = dc.GetTickBrush (prio);  	var face = dc.GetTickFace (prio);  	foreach (ChartTickInfo ti in segment) {  		//calculate major and minor label texts  		var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  		var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  		int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  		var ipos = (int)Math.Round (ti.PixelPosition);  		var pos = ti.PixelPosition;  		if (dock == Dock.Left) {  			//draw tick line  			dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  		}  		else {  			pos = area.Height - pos;  			//draw tick line  			dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  		}  		var a = ipos - bigger / 2;  		var b = a + bigger;  		if (a < 0)  			a = 0;  		if (b >= slots.Length)  			b = slots.Length - 1;  		bool canDraw = true;  		for (int x = a; x <= b; x++) {  			if (slots [x]) {  				canDraw = false;  				break;  			}  		}  		if (canDraw) {  			//fill slots  			for (int x = a; x <= b; x++) {  				slots [x] = true;  			}  			if (dock == Dock.Left) {  				//draw major label text  				var xd = len + 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  				//draw minor label text  				//xd += size;  				//dc.DrawText(  				//    ftMinor'  				//    new Point(xd' pos - ftMinor.Height / 2)  				//    );  			}  			else {  				//draw major label text  				var xd = area.Width - len - 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  				//draw minor label text  				//xd += size;  				//dc.DrawText(  				//    ftMinor'  				//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  				//    );  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (ChartTickInfo ti in segment) {  	//calculate major and minor label texts  	var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  	var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  	int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  	var ipos = (int)Math.Round (ti.PixelPosition);  	var pos = ti.PixelPosition;  	if (dock == Dock.Left) {  		//draw tick line  		dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  	}  	else {  		pos = area.Height - pos;  		//draw tick line  		dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  	}  	var a = ipos - bigger / 2;  	var b = a + bigger;  	if (a < 0)  		a = 0;  	if (b >= slots.Length)  		b = slots.Length - 1;  	bool canDraw = true;  	for (int x = a; x <= b; x++) {  		if (slots [x]) {  			canDraw = false;  			break;  		}  	}  	if (canDraw) {  		//fill slots  		for (int x = a; x <= b; x++) {  			slots [x] = true;  		}  		if (dock == Dock.Left) {  			//draw major label text  			var xd = len + 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  			//draw minor label text  			//xd += size;  			//dc.DrawText(  			//    ftMinor'  			//    new Point(xd' pos - ftMinor.Height / 2)  			//    );  		}  		else {  			//draw major label text  			var xd = area.Width - len - 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  			//draw minor label text  			//xd += size;  			//dc.DrawText(  			//    ftMinor'  			//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  			//    );  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (ChartTickInfo ti in segment) {  	//calculate major and minor label texts  	var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  	var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  	int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  	var ipos = (int)Math.Round (ti.PixelPosition);  	var pos = ti.PixelPosition;  	if (dock == Dock.Left) {  		//draw tick line  		dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  	}  	else {  		pos = area.Height - pos;  		//draw tick line  		dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  	}  	var a = ipos - bigger / 2;  	var b = a + bigger;  	if (a < 0)  		a = 0;  	if (b >= slots.Length)  		b = slots.Length - 1;  	bool canDraw = true;  	for (int x = a; x <= b; x++) {  		if (slots [x]) {  			canDraw = false;  			break;  		}  	}  	if (canDraw) {  		//fill slots  		for (int x = a; x <= b; x++) {  			slots [x] = true;  		}  		if (dock == Dock.Left) {  			//draw major label text  			var xd = len + 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  			//draw minor label text  			//xd += size;  			//dc.DrawText(  			//    ftMinor'  			//    new Point(xd' pos - ftMinor.Height / 2)  			//    );  		}  		else {  			//draw major label text  			var xd = area.Width - len - 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  			//draw minor label text  			//xd += size;  			//dc.DrawText(  			//    ftMinor'  			//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  			//    );  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (ChartTickInfo ti in segment) {  	//calculate major and minor label texts  	var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  	var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  	int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  	var ipos = (int)Math.Round (ti.PixelPosition);  	var pos = ti.PixelPosition;  	if (dock == Dock.Left) {  		//draw tick line  		dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  	}  	else {  		pos = area.Height - pos;  		//draw tick line  		dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  	}  	var a = ipos - bigger / 2;  	var b = a + bigger;  	if (a < 0)  		a = 0;  	if (b >= slots.Length)  		b = slots.Length - 1;  	bool canDraw = true;  	for (int x = a; x <= b; x++) {  		if (slots [x]) {  			canDraw = false;  			break;  		}  	}  	if (canDraw) {  		//fill slots  		for (int x = a; x <= b; x++) {  			slots [x] = true;  		}  		if (dock == Dock.Left) {  			//draw major label text  			var xd = len + 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  			//draw minor label text  			//xd += size;  			//dc.DrawText(  			//    ftMinor'  			//    new Point(xd' pos - ftMinor.Height / 2)  			//    );  		}  		else {  			//draw major label text  			var xd = area.Width - len - 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  			//draw minor label text  			//xd += size;  			//dc.DrawText(  			//    ftMinor'  			//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  			//    );  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (ChartTickInfo ti in segment) {  	//calculate major and minor label texts  	var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  	var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  	int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  	var ipos = (int)Math.Round (ti.PixelPosition);  	var pos = ti.PixelPosition;  	if (dock == Dock.Left) {  		//draw tick line  		dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  	}  	else {  		pos = area.Height - pos;  		//draw tick line  		dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  	}  	var a = ipos - bigger / 2;  	var b = a + bigger;  	if (a < 0)  		a = 0;  	if (b >= slots.Length)  		b = slots.Length - 1;  	bool canDraw = true;  	for (int x = a; x <= b; x++) {  		if (slots [x]) {  			canDraw = false;  			break;  		}  	}  	if (canDraw) {  		//fill slots  		for (int x = a; x <= b; x++) {  			slots [x] = true;  		}  		if (dock == Dock.Left) {  			//draw major label text  			var xd = len + 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  			//draw minor label text  			//xd += size;  			//dc.DrawText(  			//    ftMinor'  			//    new Point(xd' pos - ftMinor.Height / 2)  			//    );  		}  		else {  			//draw major label text  			var xd = area.Width - len - 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  			//draw minor label text  			//xd += size;  			//dc.DrawText(  			//    ftMinor'  			//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  			//    );  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (ChartTickInfo ti in segment) {  	//calculate major and minor label texts  	var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  	var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  	int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  	var ipos = (int)Math.Round (ti.PixelPosition);  	var pos = ti.PixelPosition;  	if (dock == Dock.Left) {  		//draw tick line  		dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  	}  	else {  		pos = area.Height - pos;  		//draw tick line  		dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  	}  	var a = ipos - bigger / 2;  	var b = a + bigger;  	if (a < 0)  		a = 0;  	if (b >= slots.Length)  		b = slots.Length - 1;  	bool canDraw = true;  	for (int x = a; x <= b; x++) {  		if (slots [x]) {  			canDraw = false;  			break;  		}  	}  	if (canDraw) {  		//fill slots  		for (int x = a; x <= b; x++) {  			slots [x] = true;  		}  		if (dock == Dock.Left) {  			//draw major label text  			var xd = len + 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  			//draw minor label text  			//xd += size;  			//dc.DrawText(  			//    ftMinor'  			//    new Point(xd' pos - ftMinor.Height / 2)  			//    );  		}  		else {  			//draw major label text  			var xd = area.Width - len - 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  			//draw minor label text  			//xd += size;  			//dc.DrawText(  			//    ftMinor'  			//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  			//    );  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (ChartTickInfo ti in segment) {  	//calculate major and minor label texts  	var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  	var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  	int bigger = 2 + (int)Math.Max (szMajor.Height' szMinor.Height);  	var ipos = (int)Math.Round (ti.PixelPosition);  	var pos = ti.PixelPosition;  	if (dock == Dock.Left) {  		//draw tick line  		dc.DrawLine (pen' new Point (0' pos)' new Point (len' pos));  	}  	else {  		pos = area.Height - pos;  		//draw tick line  		dc.DrawLine (pen' new Point (area.Width' pos)' new Point (area.Width - len' pos));  	}  	var a = ipos - bigger / 2;  	var b = a + bigger;  	if (a < 0)  		a = 0;  	if (b >= slots.Length)  		b = slots.Length - 1;  	bool canDraw = true;  	for (int x = a; x <= b; x++) {  		if (slots [x]) {  			canDraw = false;  			break;  		}  	}  	if (canDraw) {  		//fill slots  		for (int x = a; x <= b; x++) {  			slots [x] = true;  		}  		if (dock == Dock.Left) {  			//draw major label text  			var xd = len + 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  			//draw minor label text  			//xd += size;  			//dc.DrawText(  			//    ftMinor'  			//    new Point(xd' pos - ftMinor.Height / 2)  			//    );  		}  		else {  			//draw major label text  			var xd = area.Width - len - 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  			//draw minor label text  			//xd += size;  			//dc.DrawText(  			//    ftMinor'  			//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  			//    );  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (canDraw) {  	//fill slots  	for (int x = a; x <= b; x++) {  		slots [x] = true;  	}  	if (dock == Dock.Left) {  		//draw major label text  		var xd = len + 4;  		dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  		//draw minor label text  		//xd += size;  		//dc.DrawText(  		//    ftMinor'  		//    new Point(xd' pos - ftMinor.Height / 2)  		//    );  	}  	else {  		//draw major label text  		var xd = area.Width - len - 4;  		dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  		//draw minor label text  		//xd += size;  		//dc.DrawText(  		//    ftMinor'  		//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  		//    );  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (canDraw) {  	//fill slots  	for (int x = a; x <= b; x++) {  		slots [x] = true;  	}  	if (dock == Dock.Left) {  		//draw major label text  		var xd = len + 4;  		dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  		//draw minor label text  		//xd += size;  		//dc.DrawText(  		//    ftMinor'  		//    new Point(xd' pos - ftMinor.Height / 2)  		//    );  	}  	else {  		//draw major label text  		var xd = area.Width - len - 4;  		dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  		//draw minor label text  		//xd += size;  		//dc.DrawText(  		//    ftMinor'  		//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  		//    );  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (canDraw) {  	//fill slots  	for (int x = a; x <= b; x++) {  		slots [x] = true;  	}  	if (dock == Dock.Left) {  		//draw major label text  		var xd = len + 4;  		dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  		//draw minor label text  		//xd += size;  		//dc.DrawText(  		//    ftMinor'  		//    new Point(xd' pos - ftMinor.Height / 2)  		//    );  	}  	else {  		//draw major label text  		var xd = area.Width - len - 4;  		dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  		//draw minor label text  		//xd += size;  		//dc.DrawText(  		//    ftMinor'  		//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  		//    );  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (canDraw) {  	//fill slots  	for (int x = a; x <= b; x++) {  		slots [x] = true;  	}  	if (dock == Dock.Left) {  		//draw major label text  		var xd = len + 4;  		dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  		//draw minor label text  		//xd += size;  		//dc.DrawText(  		//    ftMinor'  		//    new Point(xd' pos - ftMinor.Height / 2)  		//    );  	}  	else {  		//draw major label text  		var xd = area.Width - len - 4;  		dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  		//draw minor label text  		//xd += size;  		//dc.DrawText(  		//    ftMinor'  		//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  		//    );  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left) {  	//draw major label text  	var xd = len + 4;  	dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  	//draw minor label text  	//xd += size;  	//dc.DrawText(  	//    ftMinor'  	//    new Point(xd' pos - ftMinor.Height / 2)  	//    );  }  else {  	//draw major label text  	var xd = area.Width - len - 4;  	dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  	//draw minor label text  	//xd += size;  	//dc.DrawText(  	//    ftMinor'  	//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  	//    );  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left) {  	//draw major label text  	var xd = len + 4;  	dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  	//draw minor label text  	//xd += size;  	//dc.DrawText(  	//    ftMinor'  	//    new Point(xd' pos - ftMinor.Height / 2)  	//    );  }  else {  	//draw major label text  	var xd = area.Width - len - 4;  	dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  	//draw minor label text  	//xd += size;  	//dc.DrawText(  	//    ftMinor'  	//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  	//    );  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left) {  	//draw major label text  	var xd = len + 4;  	dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  	//draw minor label text  	//xd += size;  	//dc.DrawText(  	//    ftMinor'  	//    new Point(xd' pos - ftMinor.Height / 2)  	//    );  }  else {  	//draw major label text  	var xd = area.Width - len - 4;  	dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  	//draw minor label text  	//xd += size;  	//dc.DrawText(  	//    ftMinor'  	//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  	//    );  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Left) {  	//draw major label text  	var xd = len + 4;  	dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  	//draw minor label text  	//xd += size;  	//dc.DrawText(  	//    ftMinor'  	//    new Point(xd' pos - ftMinor.Height / 2)  	//    );  }  else {  	//draw major label text  	var xd = area.Width - len - 4;  	dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  	//draw minor label text  	//xd += size;  	//dc.DrawText(  	//    ftMinor'  	//    new Point(xd - ftMinor.Width' pos - ftMinor.Height / 2)  	//    );  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd' pos - szMajor.Height / 2));  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (xd - szMajor.Width' pos - szMajor.Height / 2));  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Top || dock == Dock.Bottom) {  	var slots = new bool[(int)area.Width];  	var segmentGroup = ticks.Where (_ => _.IsValid).SelectMany (_ => _).GroupBy (_ => _.Priority).OrderByDescending (_ => _.Key);  	foreach (var segment in segmentGroup) {  		int prio = segment.Key;  		var len = 5 + prio * 10.0;  		var size = 11.0 + prio * 2.5;  		var pen = dc.GetTickPen (prio);  		var brush = dc.GetTickBrush (prio);  		var face = dc.GetTickFace (prio);  		foreach (ChartTickInfo ti in segment) {  			//calculate major and minor label texts  			var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  			var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  			int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  			var ipos = (int)Math.Round (ti.PixelPosition);  			var pos = ti.PixelPosition;  			if (dock == Dock.Top) {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  			}  			else {  				//draw tick line  				dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  			}  			var a = ipos - bigger / 2;  			var b = a + bigger;  			if (a < 0)  				a = 0;  			if (b >= slots.Length)  				b = slots.Length - 1;  			bool canDraw = true;  			for (int x = a; x <= b; x++) {  				if (slots [x]) {  					canDraw = false;  					break;  				}  			}  			if (canDraw) {  				//fill slots  				for (int x = a; x <= b; x++) {  					slots [x] = true;  				}  				if (dock == Dock.Top) {  					//draw major label text  					var yd = len + 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd += size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  				else {  					//draw major label text  					var yd = area.Height - len - 4;  					dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  					//draw minor label text  					yd -= size;  					dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  				}  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (var segment in segmentGroup) {  	int prio = segment.Key;  	var len = 5 + prio * 10.0;  	var size = 11.0 + prio * 2.5;  	var pen = dc.GetTickPen (prio);  	var brush = dc.GetTickBrush (prio);  	var face = dc.GetTickFace (prio);  	foreach (ChartTickInfo ti in segment) {  		//calculate major and minor label texts  		var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  		var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  		int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  		var ipos = (int)Math.Round (ti.PixelPosition);  		var pos = ti.PixelPosition;  		if (dock == Dock.Top) {  			//draw tick line  			dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  		}  		else {  			//draw tick line  			dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  		}  		var a = ipos - bigger / 2;  		var b = a + bigger;  		if (a < 0)  			a = 0;  		if (b >= slots.Length)  			b = slots.Length - 1;  		bool canDraw = true;  		for (int x = a; x <= b; x++) {  			if (slots [x]) {  				canDraw = false;  				break;  			}  		}  		if (canDraw) {  			//fill slots  			for (int x = a; x <= b; x++) {  				slots [x] = true;  			}  			if (dock == Dock.Top) {  				//draw major label text  				var yd = len + 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  				//draw minor label text  				yd += size;  				dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  			}  			else {  				//draw major label text  				var yd = area.Height - len - 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  				//draw minor label text  				yd -= size;  				dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (var segment in segmentGroup) {  	int prio = segment.Key;  	var len = 5 + prio * 10.0;  	var size = 11.0 + prio * 2.5;  	var pen = dc.GetTickPen (prio);  	var brush = dc.GetTickBrush (prio);  	var face = dc.GetTickFace (prio);  	foreach (ChartTickInfo ti in segment) {  		//calculate major and minor label texts  		var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  		var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  		int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  		var ipos = (int)Math.Round (ti.PixelPosition);  		var pos = ti.PixelPosition;  		if (dock == Dock.Top) {  			//draw tick line  			dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  		}  		else {  			//draw tick line  			dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  		}  		var a = ipos - bigger / 2;  		var b = a + bigger;  		if (a < 0)  			a = 0;  		if (b >= slots.Length)  			b = slots.Length - 1;  		bool canDraw = true;  		for (int x = a; x <= b; x++) {  			if (slots [x]) {  				canDraw = false;  				break;  			}  		}  		if (canDraw) {  			//fill slots  			for (int x = a; x <= b; x++) {  				slots [x] = true;  			}  			if (dock == Dock.Top) {  				//draw major label text  				var yd = len + 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  				//draw minor label text  				yd += size;  				dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  			}  			else {  				//draw major label text  				var yd = area.Height - len - 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  				//draw minor label text  				yd -= size;  				dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (var segment in segmentGroup) {  	int prio = segment.Key;  	var len = 5 + prio * 10.0;  	var size = 11.0 + prio * 2.5;  	var pen = dc.GetTickPen (prio);  	var brush = dc.GetTickBrush (prio);  	var face = dc.GetTickFace (prio);  	foreach (ChartTickInfo ti in segment) {  		//calculate major and minor label texts  		var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  		var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  		int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  		var ipos = (int)Math.Round (ti.PixelPosition);  		var pos = ti.PixelPosition;  		if (dock == Dock.Top) {  			//draw tick line  			dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  		}  		else {  			//draw tick line  			dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  		}  		var a = ipos - bigger / 2;  		var b = a + bigger;  		if (a < 0)  			a = 0;  		if (b >= slots.Length)  			b = slots.Length - 1;  		bool canDraw = true;  		for (int x = a; x <= b; x++) {  			if (slots [x]) {  				canDraw = false;  				break;  			}  		}  		if (canDraw) {  			//fill slots  			for (int x = a; x <= b; x++) {  				slots [x] = true;  			}  			if (dock == Dock.Top) {  				//draw major label text  				var yd = len + 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  				//draw minor label text  				yd += size;  				dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  			}  			else {  				//draw major label text  				var yd = area.Height - len - 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  				//draw minor label text  				yd -= size;  				dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (var segment in segmentGroup) {  	int prio = segment.Key;  	var len = 5 + prio * 10.0;  	var size = 11.0 + prio * 2.5;  	var pen = dc.GetTickPen (prio);  	var brush = dc.GetTickBrush (prio);  	var face = dc.GetTickFace (prio);  	foreach (ChartTickInfo ti in segment) {  		//calculate major and minor label texts  		var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  		var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  		int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  		var ipos = (int)Math.Round (ti.PixelPosition);  		var pos = ti.PixelPosition;  		if (dock == Dock.Top) {  			//draw tick line  			dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  		}  		else {  			//draw tick line  			dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  		}  		var a = ipos - bigger / 2;  		var b = a + bigger;  		if (a < 0)  			a = 0;  		if (b >= slots.Length)  			b = slots.Length - 1;  		bool canDraw = true;  		for (int x = a; x <= b; x++) {  			if (slots [x]) {  				canDraw = false;  				break;  			}  		}  		if (canDraw) {  			//fill slots  			for (int x = a; x <= b; x++) {  				slots [x] = true;  			}  			if (dock == Dock.Top) {  				//draw major label text  				var yd = len + 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  				//draw minor label text  				yd += size;  				dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  			}  			else {  				//draw major label text  				var yd = area.Height - len - 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  				//draw minor label text  				yd -= size;  				dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (var segment in segmentGroup) {  	int prio = segment.Key;  	var len = 5 + prio * 10.0;  	var size = 11.0 + prio * 2.5;  	var pen = dc.GetTickPen (prio);  	var brush = dc.GetTickBrush (prio);  	var face = dc.GetTickFace (prio);  	foreach (ChartTickInfo ti in segment) {  		//calculate major and minor label texts  		var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  		var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  		int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  		var ipos = (int)Math.Round (ti.PixelPosition);  		var pos = ti.PixelPosition;  		if (dock == Dock.Top) {  			//draw tick line  			dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  		}  		else {  			//draw tick line  			dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  		}  		var a = ipos - bigger / 2;  		var b = a + bigger;  		if (a < 0)  			a = 0;  		if (b >= slots.Length)  			b = slots.Length - 1;  		bool canDraw = true;  		for (int x = a; x <= b; x++) {  			if (slots [x]) {  				canDraw = false;  				break;  			}  		}  		if (canDraw) {  			//fill slots  			for (int x = a; x <= b; x++) {  				slots [x] = true;  			}  			if (dock == Dock.Top) {  				//draw major label text  				var yd = len + 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  				//draw minor label text  				yd += size;  				dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  			}  			else {  				//draw major label text  				var yd = area.Height - len - 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  				//draw minor label text  				yd -= size;  				dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (var segment in segmentGroup) {  	int prio = segment.Key;  	var len = 5 + prio * 10.0;  	var size = 11.0 + prio * 2.5;  	var pen = dc.GetTickPen (prio);  	var brush = dc.GetTickBrush (prio);  	var face = dc.GetTickFace (prio);  	foreach (ChartTickInfo ti in segment) {  		//calculate major and minor label texts  		var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  		var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  		int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  		var ipos = (int)Math.Round (ti.PixelPosition);  		var pos = ti.PixelPosition;  		if (dock == Dock.Top) {  			//draw tick line  			dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  		}  		else {  			//draw tick line  			dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  		}  		var a = ipos - bigger / 2;  		var b = a + bigger;  		if (a < 0)  			a = 0;  		if (b >= slots.Length)  			b = slots.Length - 1;  		bool canDraw = true;  		for (int x = a; x <= b; x++) {  			if (slots [x]) {  				canDraw = false;  				break;  			}  		}  		if (canDraw) {  			//fill slots  			for (int x = a; x <= b; x++) {  				slots [x] = true;  			}  			if (dock == Dock.Top) {  				//draw major label text  				var yd = len + 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  				//draw minor label text  				yd += size;  				dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  			}  			else {  				//draw major label text  				var yd = area.Height - len - 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  				//draw minor label text  				yd -= size;  				dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (var segment in segmentGroup) {  	int prio = segment.Key;  	var len = 5 + prio * 10.0;  	var size = 11.0 + prio * 2.5;  	var pen = dc.GetTickPen (prio);  	var brush = dc.GetTickBrush (prio);  	var face = dc.GetTickFace (prio);  	foreach (ChartTickInfo ti in segment) {  		//calculate major and minor label texts  		var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  		var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  		int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  		var ipos = (int)Math.Round (ti.PixelPosition);  		var pos = ti.PixelPosition;  		if (dock == Dock.Top) {  			//draw tick line  			dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  		}  		else {  			//draw tick line  			dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  		}  		var a = ipos - bigger / 2;  		var b = a + bigger;  		if (a < 0)  			a = 0;  		if (b >= slots.Length)  			b = slots.Length - 1;  		bool canDraw = true;  		for (int x = a; x <= b; x++) {  			if (slots [x]) {  				canDraw = false;  				break;  			}  		}  		if (canDraw) {  			//fill slots  			for (int x = a; x <= b; x++) {  				slots [x] = true;  			}  			if (dock == Dock.Top) {  				//draw major label text  				var yd = len + 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  				//draw minor label text  				yd += size;  				dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  			}  			else {  				//draw major label text  				var yd = area.Height - len - 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  				//draw minor label text  				yd -= size;  				dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (var segment in segmentGroup) {  	int prio = segment.Key;  	var len = 5 + prio * 10.0;  	var size = 11.0 + prio * 2.5;  	var pen = dc.GetTickPen (prio);  	var brush = dc.GetTickBrush (prio);  	var face = dc.GetTickFace (prio);  	foreach (ChartTickInfo ti in segment) {  		//calculate major and minor label texts  		var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  		var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  		int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  		var ipos = (int)Math.Round (ti.PixelPosition);  		var pos = ti.PixelPosition;  		if (dock == Dock.Top) {  			//draw tick line  			dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  		}  		else {  			//draw tick line  			dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  		}  		var a = ipos - bigger / 2;  		var b = a + bigger;  		if (a < 0)  			a = 0;  		if (b >= slots.Length)  			b = slots.Length - 1;  		bool canDraw = true;  		for (int x = a; x <= b; x++) {  			if (slots [x]) {  				canDraw = false;  				break;  			}  		}  		if (canDraw) {  			//fill slots  			for (int x = a; x <= b; x++) {  				slots [x] = true;  			}  			if (dock == Dock.Top) {  				//draw major label text  				var yd = len + 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  				//draw minor label text  				yd += size;  				dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  			}  			else {  				//draw major label text  				var yd = area.Height - len - 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  				//draw minor label text  				yd -= size;  				dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (var segment in segmentGroup) {  	int prio = segment.Key;  	var len = 5 + prio * 10.0;  	var size = 11.0 + prio * 2.5;  	var pen = dc.GetTickPen (prio);  	var brush = dc.GetTickBrush (prio);  	var face = dc.GetTickFace (prio);  	foreach (ChartTickInfo ti in segment) {  		//calculate major and minor label texts  		var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  		var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  		int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  		var ipos = (int)Math.Round (ti.PixelPosition);  		var pos = ti.PixelPosition;  		if (dock == Dock.Top) {  			//draw tick line  			dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  		}  		else {  			//draw tick line  			dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  		}  		var a = ipos - bigger / 2;  		var b = a + bigger;  		if (a < 0)  			a = 0;  		if (b >= slots.Length)  			b = slots.Length - 1;  		bool canDraw = true;  		for (int x = a; x <= b; x++) {  			if (slots [x]) {  				canDraw = false;  				break;  			}  		}  		if (canDraw) {  			//fill slots  			for (int x = a; x <= b; x++) {  				slots [x] = true;  			}  			if (dock == Dock.Top) {  				//draw major label text  				var yd = len + 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  				//draw minor label text  				yd += size;  				dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  			}  			else {  				//draw major label text  				var yd = area.Height - len - 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  				//draw minor label text  				yd -= size;  				dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (var segment in segmentGroup) {  	int prio = segment.Key;  	var len = 5 + prio * 10.0;  	var size = 11.0 + prio * 2.5;  	var pen = dc.GetTickPen (prio);  	var brush = dc.GetTickBrush (prio);  	var face = dc.GetTickFace (prio);  	foreach (ChartTickInfo ti in segment) {  		//calculate major and minor label texts  		var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  		var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  		int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  		var ipos = (int)Math.Round (ti.PixelPosition);  		var pos = ti.PixelPosition;  		if (dock == Dock.Top) {  			//draw tick line  			dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  		}  		else {  			//draw tick line  			dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  		}  		var a = ipos - bigger / 2;  		var b = a + bigger;  		if (a < 0)  			a = 0;  		if (b >= slots.Length)  			b = slots.Length - 1;  		bool canDraw = true;  		for (int x = a; x <= b; x++) {  			if (slots [x]) {  				canDraw = false;  				break;  			}  		}  		if (canDraw) {  			//fill slots  			for (int x = a; x <= b; x++) {  				slots [x] = true;  			}  			if (dock == Dock.Top) {  				//draw major label text  				var yd = len + 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  				//draw minor label text  				yd += size;  				dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  			}  			else {  				//draw major label text  				var yd = area.Height - len - 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  				//draw minor label text  				yd -= size;  				dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (var segment in segmentGroup) {  	int prio = segment.Key;  	var len = 5 + prio * 10.0;  	var size = 11.0 + prio * 2.5;  	var pen = dc.GetTickPen (prio);  	var brush = dc.GetTickBrush (prio);  	var face = dc.GetTickFace (prio);  	foreach (ChartTickInfo ti in segment) {  		//calculate major and minor label texts  		var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  		var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  		int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  		var ipos = (int)Math.Round (ti.PixelPosition);  		var pos = ti.PixelPosition;  		if (dock == Dock.Top) {  			//draw tick line  			dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  		}  		else {  			//draw tick line  			dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  		}  		var a = ipos - bigger / 2;  		var b = a + bigger;  		if (a < 0)  			a = 0;  		if (b >= slots.Length)  			b = slots.Length - 1;  		bool canDraw = true;  		for (int x = a; x <= b; x++) {  			if (slots [x]) {  				canDraw = false;  				break;  			}  		}  		if (canDraw) {  			//fill slots  			for (int x = a; x <= b; x++) {  				slots [x] = true;  			}  			if (dock == Dock.Top) {  				//draw major label text  				var yd = len + 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  				//draw minor label text  				yd += size;  				dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  			}  			else {  				//draw major label text  				var yd = area.Height - len - 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  				//draw minor label text  				yd -= size;  				dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (var segment in segmentGroup) {  	int prio = segment.Key;  	var len = 5 + prio * 10.0;  	var size = 11.0 + prio * 2.5;  	var pen = dc.GetTickPen (prio);  	var brush = dc.GetTickBrush (prio);  	var face = dc.GetTickFace (prio);  	foreach (ChartTickInfo ti in segment) {  		//calculate major and minor label texts  		var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  		var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  		int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  		var ipos = (int)Math.Round (ti.PixelPosition);  		var pos = ti.PixelPosition;  		if (dock == Dock.Top) {  			//draw tick line  			dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  		}  		else {  			//draw tick line  			dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  		}  		var a = ipos - bigger / 2;  		var b = a + bigger;  		if (a < 0)  			a = 0;  		if (b >= slots.Length)  			b = slots.Length - 1;  		bool canDraw = true;  		for (int x = a; x <= b; x++) {  			if (slots [x]) {  				canDraw = false;  				break;  			}  		}  		if (canDraw) {  			//fill slots  			for (int x = a; x <= b; x++) {  				slots [x] = true;  			}  			if (dock == Dock.Top) {  				//draw major label text  				var yd = len + 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  				//draw minor label text  				yd += size;  				dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  			}  			else {  				//draw major label text  				var yd = area.Height - len - 4;  				dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  				//draw minor label text  				yd -= size;  				dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  			}  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (ChartTickInfo ti in segment) {  	//calculate major and minor label texts  	var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  	var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  	int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  	var ipos = (int)Math.Round (ti.PixelPosition);  	var pos = ti.PixelPosition;  	if (dock == Dock.Top) {  		//draw tick line  		dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  	}  	else {  		//draw tick line  		dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  	}  	var a = ipos - bigger / 2;  	var b = a + bigger;  	if (a < 0)  		a = 0;  	if (b >= slots.Length)  		b = slots.Length - 1;  	bool canDraw = true;  	for (int x = a; x <= b; x++) {  		if (slots [x]) {  			canDraw = false;  			break;  		}  	}  	if (canDraw) {  		//fill slots  		for (int x = a; x <= b; x++) {  			slots [x] = true;  		}  		if (dock == Dock.Top) {  			//draw major label text  			var yd = len + 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  			//draw minor label text  			yd += size;  			dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  		}  		else {  			//draw major label text  			var yd = area.Height - len - 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  			//draw minor label text  			yd -= size;  			dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (ChartTickInfo ti in segment) {  	//calculate major and minor label texts  	var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  	var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  	int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  	var ipos = (int)Math.Round (ti.PixelPosition);  	var pos = ti.PixelPosition;  	if (dock == Dock.Top) {  		//draw tick line  		dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  	}  	else {  		//draw tick line  		dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  	}  	var a = ipos - bigger / 2;  	var b = a + bigger;  	if (a < 0)  		a = 0;  	if (b >= slots.Length)  		b = slots.Length - 1;  	bool canDraw = true;  	for (int x = a; x <= b; x++) {  		if (slots [x]) {  			canDraw = false;  			break;  		}  	}  	if (canDraw) {  		//fill slots  		for (int x = a; x <= b; x++) {  			slots [x] = true;  		}  		if (dock == Dock.Top) {  			//draw major label text  			var yd = len + 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  			//draw minor label text  			yd += size;  			dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  		}  		else {  			//draw major label text  			var yd = area.Height - len - 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  			//draw minor label text  			yd -= size;  			dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (ChartTickInfo ti in segment) {  	//calculate major and minor label texts  	var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  	var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  	int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  	var ipos = (int)Math.Round (ti.PixelPosition);  	var pos = ti.PixelPosition;  	if (dock == Dock.Top) {  		//draw tick line  		dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  	}  	else {  		//draw tick line  		dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  	}  	var a = ipos - bigger / 2;  	var b = a + bigger;  	if (a < 0)  		a = 0;  	if (b >= slots.Length)  		b = slots.Length - 1;  	bool canDraw = true;  	for (int x = a; x <= b; x++) {  		if (slots [x]) {  			canDraw = false;  			break;  		}  	}  	if (canDraw) {  		//fill slots  		for (int x = a; x <= b; x++) {  			slots [x] = true;  		}  		if (dock == Dock.Top) {  			//draw major label text  			var yd = len + 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  			//draw minor label text  			yd += size;  			dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  		}  		else {  			//draw major label text  			var yd = area.Height - len - 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  			//draw minor label text  			yd -= size;  			dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (ChartTickInfo ti in segment) {  	//calculate major and minor label texts  	var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  	var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  	int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  	var ipos = (int)Math.Round (ti.PixelPosition);  	var pos = ti.PixelPosition;  	if (dock == Dock.Top) {  		//draw tick line  		dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  	}  	else {  		//draw tick line  		dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  	}  	var a = ipos - bigger / 2;  	var b = a + bigger;  	if (a < 0)  		a = 0;  	if (b >= slots.Length)  		b = slots.Length - 1;  	bool canDraw = true;  	for (int x = a; x <= b; x++) {  		if (slots [x]) {  			canDraw = false;  			break;  		}  	}  	if (canDraw) {  		//fill slots  		for (int x = a; x <= b; x++) {  			slots [x] = true;  		}  		if (dock == Dock.Top) {  			//draw major label text  			var yd = len + 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  			//draw minor label text  			yd += size;  			dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  		}  		else {  			//draw major label text  			var yd = area.Height - len - 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  			//draw minor label text  			yd -= size;  			dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (ChartTickInfo ti in segment) {  	//calculate major and minor label texts  	var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  	var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  	int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  	var ipos = (int)Math.Round (ti.PixelPosition);  	var pos = ti.PixelPosition;  	if (dock == Dock.Top) {  		//draw tick line  		dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  	}  	else {  		//draw tick line  		dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  	}  	var a = ipos - bigger / 2;  	var b = a + bigger;  	if (a < 0)  		a = 0;  	if (b >= slots.Length)  		b = slots.Length - 1;  	bool canDraw = true;  	for (int x = a; x <= b; x++) {  		if (slots [x]) {  			canDraw = false;  			break;  		}  	}  	if (canDraw) {  		//fill slots  		for (int x = a; x <= b; x++) {  			slots [x] = true;  		}  		if (dock == Dock.Top) {  			//draw major label text  			var yd = len + 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  			//draw minor label text  			yd += size;  			dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  		}  		else {  			//draw major label text  			var yd = area.Height - len - 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  			//draw minor label text  			yd -= size;  			dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (ChartTickInfo ti in segment) {  	//calculate major and minor label texts  	var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  	var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  	int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  	var ipos = (int)Math.Round (ti.PixelPosition);  	var pos = ti.PixelPosition;  	if (dock == Dock.Top) {  		//draw tick line  		dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  	}  	else {  		//draw tick line  		dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  	}  	var a = ipos - bigger / 2;  	var b = a + bigger;  	if (a < 0)  		a = 0;  	if (b >= slots.Length)  		b = slots.Length - 1;  	bool canDraw = true;  	for (int x = a; x <= b; x++) {  		if (slots [x]) {  			canDraw = false;  			break;  		}  	}  	if (canDraw) {  		//fill slots  		for (int x = a; x <= b; x++) {  			slots [x] = true;  		}  		if (dock == Dock.Top) {  			//draw major label text  			var yd = len + 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  			//draw minor label text  			yd += size;  			dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  		}  		else {  			//draw major label text  			var yd = area.Height - len - 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  			//draw minor label text  			yd -= size;  			dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (ChartTickInfo ti in segment) {  	//calculate major and minor label texts  	var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  	var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  	int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  	var ipos = (int)Math.Round (ti.PixelPosition);  	var pos = ti.PixelPosition;  	if (dock == Dock.Top) {  		//draw tick line  		dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  	}  	else {  		//draw tick line  		dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  	}  	var a = ipos - bigger / 2;  	var b = a + bigger;  	if (a < 0)  		a = 0;  	if (b >= slots.Length)  		b = slots.Length - 1;  	bool canDraw = true;  	for (int x = a; x <= b; x++) {  		if (slots [x]) {  			canDraw = false;  			break;  		}  	}  	if (canDraw) {  		//fill slots  		for (int x = a; x <= b; x++) {  			slots [x] = true;  		}  		if (dock == Dock.Top) {  			//draw major label text  			var yd = len + 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  			//draw minor label text  			yd += size;  			dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  		}  		else {  			//draw major label text  			var yd = area.Height - len - 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  			//draw minor label text  			yd -= size;  			dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: foreach (ChartTickInfo ti in segment) {  	//calculate major and minor label texts  	var szMajor = dc.MeasureText (ti.MajorText ?? string.Empty' face' size);  	var szMinor = dc.MeasureText (ti.MinorText ?? string.Empty' face' size);  	int bigger = 2 + (int)Math.Max (szMajor.Width' szMinor.Width);  	var ipos = (int)Math.Round (ti.PixelPosition);  	var pos = ti.PixelPosition;  	if (dock == Dock.Top) {  		//draw tick line  		dc.DrawLine (pen' new Point (pos' 0)' new Point (pos' len));  	}  	else {  		//draw tick line  		dc.DrawLine (pen' new Point (pos' area.Height)' new Point (pos' area.Height - len));  	}  	var a = ipos - bigger / 2;  	var b = a + bigger;  	if (a < 0)  		a = 0;  	if (b >= slots.Length)  		b = slots.Length - 1;  	bool canDraw = true;  	for (int x = a; x <= b; x++) {  		if (slots [x]) {  			canDraw = false;  			break;  		}  	}  	if (canDraw) {  		//fill slots  		for (int x = a; x <= b; x++) {  			slots [x] = true;  		}  		if (dock == Dock.Top) {  			//draw major label text  			var yd = len + 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  			//draw minor label text  			yd += size;  			dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  		}  		else {  			//draw major label text  			var yd = area.Height - len - 4;  			dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  			//draw minor label text  			yd -= size;  			dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  		}  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (canDraw) {  	//fill slots  	for (int x = a; x <= b; x++) {  		slots [x] = true;  	}  	if (dock == Dock.Top) {  		//draw major label text  		var yd = len + 4;  		dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  		//draw minor label text  		yd += size;  		dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  	}  	else {  		//draw major label text  		var yd = area.Height - len - 4;  		dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  		//draw minor label text  		yd -= size;  		dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (canDraw) {  	//fill slots  	for (int x = a; x <= b; x++) {  		slots [x] = true;  	}  	if (dock == Dock.Top) {  		//draw major label text  		var yd = len + 4;  		dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  		//draw minor label text  		yd += size;  		dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  	}  	else {  		//draw major label text  		var yd = area.Height - len - 4;  		dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  		//draw minor label text  		yd -= size;  		dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (canDraw) {  	//fill slots  	for (int x = a; x <= b; x++) {  		slots [x] = true;  	}  	if (dock == Dock.Top) {  		//draw major label text  		var yd = len + 4;  		dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  		//draw minor label text  		yd += size;  		dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  	}  	else {  		//draw major label text  		var yd = area.Height - len - 4;  		dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  		//draw minor label text  		yd -= size;  		dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (canDraw) {  	//fill slots  	for (int x = a; x <= b; x++) {  		slots [x] = true;  	}  	if (dock == Dock.Top) {  		//draw major label text  		var yd = len + 4;  		dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  		//draw minor label text  		yd += size;  		dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  	}  	else {  		//draw major label text  		var yd = area.Height - len - 4;  		dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  		//draw minor label text  		yd -= size;  		dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (canDraw) {  	//fill slots  	for (int x = a; x <= b; x++) {  		slots [x] = true;  	}  	if (dock == Dock.Top) {  		//draw major label text  		var yd = len + 4;  		dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  		//draw minor label text  		yd += size;  		dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  	}  	else {  		//draw major label text  		var yd = area.Height - len - 4;  		dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  		//draw minor label text  		yd -= size;  		dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (canDraw) {  	//fill slots  	for (int x = a; x <= b; x++) {  		slots [x] = true;  	}  	if (dock == Dock.Top) {  		//draw major label text  		var yd = len + 4;  		dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  		//draw minor label text  		yd += size;  		dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  	}  	else {  		//draw major label text  		var yd = area.Height - len - 4;  		dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  		//draw minor label text  		yd -= size;  		dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  	}  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Top) {  	//draw major label text  	var yd = len + 4;  	dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  	//draw minor label text  	yd += size;  	dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  }  else {  	//draw major label text  	var yd = area.Height - len - 4;  	dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  	//draw minor label text  	yd -= size;  	dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Top) {  	//draw major label text  	var yd = len + 4;  	dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  	//draw minor label text  	yd += size;  	dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  }  else {  	//draw major label text  	var yd = area.Height - len - 4;  	dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  	//draw minor label text  	yd -= size;  	dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Top) {  	//draw major label text  	var yd = len + 4;  	dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  	//draw minor label text  	yd += size;  	dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  }  else {  	//draw major label text  	var yd = area.Height - len - 4;  	dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  	//draw minor label text  	yd -= size;  	dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Top) {  	//draw major label text  	var yd = len + 4;  	dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  	//draw minor label text  	yd += size;  	dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  }  else {  	//draw major label text  	var yd = area.Height - len - 4;  	dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  	//draw minor label text  	yd -= size;  	dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Top) {  	//draw major label text  	var yd = len + 4;  	dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  	//draw minor label text  	yd += size;  	dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  }  else {  	//draw major label text  	var yd = area.Height - len - 4;  	dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  	//draw minor label text  	yd -= size;  	dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: if (dock == Dock.Top) {  	//draw major label text  	var yd = len + 4;  	dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  	//draw minor label text  	yd += size;  	dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  }  else {  	//draw major label text  	var yd = area.Height - len - 4;  	dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  	//draw minor label text  	yd -= size;  	dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  }  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: dc.DrawText (ti.MajorText ?? string.Empty' face' size' brush' new Point (pos - szMajor.Width / 2' yd));  
Magic Number,Cet.UI.Chart,DrawingHelpers,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Misc\DrawingHelpers.cs,DrawTicks,The following statement contains a magic number: dc.DrawText (ti.MinorText ?? string.Empty' face' size' brush' new Point (pos - szMinor.Width / 2' yd));  
Magic Number,Cet.UI.Chart,ChartAxisBoolean,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Axis\ChartAxisBoolean.cs,ConvertToAbsolute,The following statement contains a magic number: return relative >= 0.5;  
Magic Number,Cet.UI.Chart,ChartAxisDouble,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Axis\ChartAxisDouble.cs,OnRender,The following statement contains a magic number: if (this.VerticalMajorDivisionCount > 1 && this.VerticalMinorDivisionCount > 1) {  	//draw ticks  	int totalDivisionCount = this.VerticalMajorDivisionCount * this.VerticalMinorDivisionCount;  	for (int major = 0; major <= this.VerticalMajorDivisionCount; major++) {  		double relativePosition = (double)major / this.VerticalMajorDivisionCount;  		var pattern = "{0:S}";  		//var pattern = major == 0//this.VerticalMajorDivisionCount  		//    ? "{0:SU}"  		//    : "{0:S}";  		var tick = new ChartTickInfo ();  		tick.PixelPosition = dc.ClientArea.Height * relativePosition;  		tick.Priority = 1;  		tick.MajorText = string.Format (this.Formatter' pattern' this.ConvertToAbsolute (relativePosition));  		segm.Add (tick);  		for (int minor = 1; minor < this.VerticalMinorDivisionCount; minor++) {  			relativePosition = (double)(major * this.VerticalMinorDivisionCount + minor) / totalDivisionCount;  			if (relativePosition > 1.001)  				break;  			tick = new ChartTickInfo ();  			tick.PixelPosition = dc.ClientArea.Height * relativePosition;  			tick.Priority = 0;  			tick.MajorText = string.Format (this.Formatter' "{0:S}"' this.ConvertToAbsolute (relativePosition));  			segm.Add (tick);  		}  	}  }  
Magic Number,Cet.UI.Chart,ChartAxisDouble,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Axis\ChartAxisDouble.cs,OnRender,The following statement contains a magic number: for (int major = 0; major <= this.VerticalMajorDivisionCount; major++) {  	double relativePosition = (double)major / this.VerticalMajorDivisionCount;  	var pattern = "{0:S}";  	//var pattern = major == 0//this.VerticalMajorDivisionCount  	//    ? "{0:SU}"  	//    : "{0:S}";  	var tick = new ChartTickInfo ();  	tick.PixelPosition = dc.ClientArea.Height * relativePosition;  	tick.Priority = 1;  	tick.MajorText = string.Format (this.Formatter' pattern' this.ConvertToAbsolute (relativePosition));  	segm.Add (tick);  	for (int minor = 1; minor < this.VerticalMinorDivisionCount; minor++) {  		relativePosition = (double)(major * this.VerticalMinorDivisionCount + minor) / totalDivisionCount;  		if (relativePosition > 1.001)  			break;  		tick = new ChartTickInfo ();  		tick.PixelPosition = dc.ClientArea.Height * relativePosition;  		tick.Priority = 0;  		tick.MajorText = string.Format (this.Formatter' "{0:S}"' this.ConvertToAbsolute (relativePosition));  		segm.Add (tick);  	}  }  
Magic Number,Cet.UI.Chart,ChartAxisDouble,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Axis\ChartAxisDouble.cs,OnRender,The following statement contains a magic number: for (int minor = 1; minor < this.VerticalMinorDivisionCount; minor++) {  	relativePosition = (double)(major * this.VerticalMinorDivisionCount + minor) / totalDivisionCount;  	if (relativePosition > 1.001)  		break;  	tick = new ChartTickInfo ();  	tick.PixelPosition = dc.ClientArea.Height * relativePosition;  	tick.Priority = 0;  	tick.MajorText = string.Format (this.Formatter' "{0:S}"' this.ConvertToAbsolute (relativePosition));  	segm.Add (tick);  }  
Magic Number,Cet.UI.Chart,ChartAxisDouble,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Axis\ChartAxisDouble.cs,OnRender,The following statement contains a magic number: if (relativePosition > 1.001)  	break;  
Magic Number,Cet.UI.Chart,ChartAxisDouble,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Axis\ChartAxisDouble.cs,OnRender,The following statement contains a magic number: if (this.Formatter != null) {  	//indicazione unità di misura  	//var attr = this.Formatter  	//    .GetType()  	//    .GetCustomAttributes(false)  	//    .OfType<MeasureUnitAttribute>()  	//    .FirstOrDefault();  	//if (attr != null)  	{  		var fface = dc.GetTickFace (1);  		var fsize = 13.0;  		var sz = dc.MeasureText (this.Formatter.MeasureUnit ?? string.Empty' fface' fsize);  		var y = (segm [segm.Count - 2].PixelPosition + segm [segm.Count - 1].PixelPosition) / 2.0;  		var pt = new Point (dc.ClientArea.Width - 6.0 - sz.Width' y - sz.Height * 0.5);  		dc.DrawText (this.Formatter.MeasureUnit ?? string.Empty' fface' fsize' dc.GetTickBrush (1)' pt);  	}  }  
Magic Number,Cet.UI.Chart,ChartAxisDouble,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Axis\ChartAxisDouble.cs,OnRender,The following statement contains a magic number: if (this.Formatter != null) {  	//indicazione unità di misura  	//var attr = this.Formatter  	//    .GetType()  	//    .GetCustomAttributes(false)  	//    .OfType<MeasureUnitAttribute>()  	//    .FirstOrDefault();  	//if (attr != null)  	{  		var fface = dc.GetTickFace (1);  		var fsize = 13.0;  		var sz = dc.MeasureText (this.Formatter.MeasureUnit ?? string.Empty' fface' fsize);  		var y = (segm [segm.Count - 2].PixelPosition + segm [segm.Count - 1].PixelPosition) / 2.0;  		var pt = new Point (dc.ClientArea.Width - 6.0 - sz.Width' y - sz.Height * 0.5);  		dc.DrawText (this.Formatter.MeasureUnit ?? string.Empty' fface' fsize' dc.GetTickBrush (1)' pt);  	}  }  
Magic Number,Cet.UI.Chart,ChartAxisDouble,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Axis\ChartAxisDouble.cs,OnRender,The following statement contains a magic number: if (this.Formatter != null) {  	//indicazione unità di misura  	//var attr = this.Formatter  	//    .GetType()  	//    .GetCustomAttributes(false)  	//    .OfType<MeasureUnitAttribute>()  	//    .FirstOrDefault();  	//if (attr != null)  	{  		var fface = dc.GetTickFace (1);  		var fsize = 13.0;  		var sz = dc.MeasureText (this.Formatter.MeasureUnit ?? string.Empty' fface' fsize);  		var y = (segm [segm.Count - 2].PixelPosition + segm [segm.Count - 1].PixelPosition) / 2.0;  		var pt = new Point (dc.ClientArea.Width - 6.0 - sz.Width' y - sz.Height * 0.5);  		dc.DrawText (this.Formatter.MeasureUnit ?? string.Empty' fface' fsize' dc.GetTickBrush (1)' pt);  	}  }  
Magic Number,Cet.UI.Chart,ChartAxisDouble,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Axis\ChartAxisDouble.cs,OnRender,The following statement contains a magic number: if (this.Formatter != null) {  	//indicazione unità di misura  	//var attr = this.Formatter  	//    .GetType()  	//    .GetCustomAttributes(false)  	//    .OfType<MeasureUnitAttribute>()  	//    .FirstOrDefault();  	//if (attr != null)  	{  		var fface = dc.GetTickFace (1);  		var fsize = 13.0;  		var sz = dc.MeasureText (this.Formatter.MeasureUnit ?? string.Empty' fface' fsize);  		var y = (segm [segm.Count - 2].PixelPosition + segm [segm.Count - 1].PixelPosition) / 2.0;  		var pt = new Point (dc.ClientArea.Width - 6.0 - sz.Width' y - sz.Height * 0.5);  		dc.DrawText (this.Formatter.MeasureUnit ?? string.Empty' fface' fsize' dc.GetTickBrush (1)' pt);  	}  }  
Magic Number,Cet.UI.Chart,ChartAxisDouble,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Axis\ChartAxisDouble.cs,OnRender,The following statement contains a magic number: if (this.Formatter != null) {  	//indicazione unità di misura  	//var attr = this.Formatter  	//    .GetType()  	//    .GetCustomAttributes(false)  	//    .OfType<MeasureUnitAttribute>()  	//    .FirstOrDefault();  	//if (attr != null)  	{  		var fface = dc.GetTickFace (1);  		var fsize = 13.0;  		var sz = dc.MeasureText (this.Formatter.MeasureUnit ?? string.Empty' fface' fsize);  		var y = (segm [segm.Count - 2].PixelPosition + segm [segm.Count - 1].PixelPosition) / 2.0;  		var pt = new Point (dc.ClientArea.Width - 6.0 - sz.Width' y - sz.Height * 0.5);  		dc.DrawText (this.Formatter.MeasureUnit ?? string.Empty' fface' fsize' dc.GetTickBrush (1)' pt);  	}  }  
Magic Number,Cet.UI.Chart,ChartPlotCartesianBoolean,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Plot\ChartPlotCartesianBoolean.cs,OnRender,The following statement contains a magic number: dc.PushTransform (new ScaleTransform (1.0' 1.0 - VerticalPadding * 2));  
Magic Number,Cet.UI.Chart,ChartPlotCartesianEvent,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Plot\ChartPlotCartesianEvent.cs,RenderCore,The following statement contains a magic number: for (int i = 0' count = this.Points.Count; i < count; i++) {  	ChartPointEvent pt = this.Points [i];  	double xrel = axisX.ConvertToRelative (pt.X);  	double x = Math.Round (xrel * dc.ClientArea.Width + areaLeft);  	if (x < (dc.ClientArea.Width + areaLeft) && x >= areaLeft) {  		dc.DrawLine (pen' new Point (x' y0)' new Point (x' y1));  		//TODO: controllare sovrapposizione scritte  		if (string.IsNullOrWhiteSpace (pt.Description) == false) {  			var fface = dc.GetTickFace (0);  			var fsize = 10.0;  			var sz = dc.MeasureText (pt.Description' fface' fsize);  			var pos = new Point (x - 0.0 - sz.Height' yt - sz.Width * 0.5);  			dc.PushTransform (new TranslateTransform (pos.X' pos.Y));  			dc.PushTransform (new RotateTransform (-90.0));  			dc.DrawText (pt.Description' fface' fsize' dc.GetTickBrush (0)' new Point ());  			dc.Pop ();  			dc.Pop ();  		}  	}  }  
Magic Number,Cet.UI.Chart,ChartPlotCartesianEvent,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Plot\ChartPlotCartesianEvent.cs,RenderCore,The following statement contains a magic number: for (int i = 0' count = this.Points.Count; i < count; i++) {  	ChartPointEvent pt = this.Points [i];  	double xrel = axisX.ConvertToRelative (pt.X);  	double x = Math.Round (xrel * dc.ClientArea.Width + areaLeft);  	if (x < (dc.ClientArea.Width + areaLeft) && x >= areaLeft) {  		dc.DrawLine (pen' new Point (x' y0)' new Point (x' y1));  		//TODO: controllare sovrapposizione scritte  		if (string.IsNullOrWhiteSpace (pt.Description) == false) {  			var fface = dc.GetTickFace (0);  			var fsize = 10.0;  			var sz = dc.MeasureText (pt.Description' fface' fsize);  			var pos = new Point (x - 0.0 - sz.Height' yt - sz.Width * 0.5);  			dc.PushTransform (new TranslateTransform (pos.X' pos.Y));  			dc.PushTransform (new RotateTransform (-90.0));  			dc.DrawText (pt.Description' fface' fsize' dc.GetTickBrush (0)' new Point ());  			dc.Pop ();  			dc.Pop ();  		}  	}  }  
Magic Number,Cet.UI.Chart,ChartPlotCartesianEvent,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Plot\ChartPlotCartesianEvent.cs,RenderCore,The following statement contains a magic number: for (int i = 0' count = this.Points.Count; i < count; i++) {  	ChartPointEvent pt = this.Points [i];  	double xrel = axisX.ConvertToRelative (pt.X);  	double x = Math.Round (xrel * dc.ClientArea.Width + areaLeft);  	if (x < (dc.ClientArea.Width + areaLeft) && x >= areaLeft) {  		dc.DrawLine (pen' new Point (x' y0)' new Point (x' y1));  		//TODO: controllare sovrapposizione scritte  		if (string.IsNullOrWhiteSpace (pt.Description) == false) {  			var fface = dc.GetTickFace (0);  			var fsize = 10.0;  			var sz = dc.MeasureText (pt.Description' fface' fsize);  			var pos = new Point (x - 0.0 - sz.Height' yt - sz.Width * 0.5);  			dc.PushTransform (new TranslateTransform (pos.X' pos.Y));  			dc.PushTransform (new RotateTransform (-90.0));  			dc.DrawText (pt.Description' fface' fsize' dc.GetTickBrush (0)' new Point ());  			dc.Pop ();  			dc.Pop ();  		}  	}  }  
Magic Number,Cet.UI.Chart,ChartPlotCartesianEvent,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Plot\ChartPlotCartesianEvent.cs,RenderCore,The following statement contains a magic number: if (x < (dc.ClientArea.Width + areaLeft) && x >= areaLeft) {  	dc.DrawLine (pen' new Point (x' y0)' new Point (x' y1));  	//TODO: controllare sovrapposizione scritte  	if (string.IsNullOrWhiteSpace (pt.Description) == false) {  		var fface = dc.GetTickFace (0);  		var fsize = 10.0;  		var sz = dc.MeasureText (pt.Description' fface' fsize);  		var pos = new Point (x - 0.0 - sz.Height' yt - sz.Width * 0.5);  		dc.PushTransform (new TranslateTransform (pos.X' pos.Y));  		dc.PushTransform (new RotateTransform (-90.0));  		dc.DrawText (pt.Description' fface' fsize' dc.GetTickBrush (0)' new Point ());  		dc.Pop ();  		dc.Pop ();  	}  }  
Magic Number,Cet.UI.Chart,ChartPlotCartesianEvent,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Plot\ChartPlotCartesianEvent.cs,RenderCore,The following statement contains a magic number: if (x < (dc.ClientArea.Width + areaLeft) && x >= areaLeft) {  	dc.DrawLine (pen' new Point (x' y0)' new Point (x' y1));  	//TODO: controllare sovrapposizione scritte  	if (string.IsNullOrWhiteSpace (pt.Description) == false) {  		var fface = dc.GetTickFace (0);  		var fsize = 10.0;  		var sz = dc.MeasureText (pt.Description' fface' fsize);  		var pos = new Point (x - 0.0 - sz.Height' yt - sz.Width * 0.5);  		dc.PushTransform (new TranslateTransform (pos.X' pos.Y));  		dc.PushTransform (new RotateTransform (-90.0));  		dc.DrawText (pt.Description' fface' fsize' dc.GetTickBrush (0)' new Point ());  		dc.Pop ();  		dc.Pop ();  	}  }  
Magic Number,Cet.UI.Chart,ChartPlotCartesianEvent,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Plot\ChartPlotCartesianEvent.cs,RenderCore,The following statement contains a magic number: if (x < (dc.ClientArea.Width + areaLeft) && x >= areaLeft) {  	dc.DrawLine (pen' new Point (x' y0)' new Point (x' y1));  	//TODO: controllare sovrapposizione scritte  	if (string.IsNullOrWhiteSpace (pt.Description) == false) {  		var fface = dc.GetTickFace (0);  		var fsize = 10.0;  		var sz = dc.MeasureText (pt.Description' fface' fsize);  		var pos = new Point (x - 0.0 - sz.Height' yt - sz.Width * 0.5);  		dc.PushTransform (new TranslateTransform (pos.X' pos.Y));  		dc.PushTransform (new RotateTransform (-90.0));  		dc.DrawText (pt.Description' fface' fsize' dc.GetTickBrush (0)' new Point ());  		dc.Pop ();  		dc.Pop ();  	}  }  
Magic Number,Cet.UI.Chart,ChartPlotCartesianEvent,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Plot\ChartPlotCartesianEvent.cs,RenderCore,The following statement contains a magic number: if (string.IsNullOrWhiteSpace (pt.Description) == false) {  	var fface = dc.GetTickFace (0);  	var fsize = 10.0;  	var sz = dc.MeasureText (pt.Description' fface' fsize);  	var pos = new Point (x - 0.0 - sz.Height' yt - sz.Width * 0.5);  	dc.PushTransform (new TranslateTransform (pos.X' pos.Y));  	dc.PushTransform (new RotateTransform (-90.0));  	dc.DrawText (pt.Description' fface' fsize' dc.GetTickBrush (0)' new Point ());  	dc.Pop ();  	dc.Pop ();  }  
Magic Number,Cet.UI.Chart,ChartPlotCartesianEvent,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Plot\ChartPlotCartesianEvent.cs,RenderCore,The following statement contains a magic number: if (string.IsNullOrWhiteSpace (pt.Description) == false) {  	var fface = dc.GetTickFace (0);  	var fsize = 10.0;  	var sz = dc.MeasureText (pt.Description' fface' fsize);  	var pos = new Point (x - 0.0 - sz.Height' yt - sz.Width * 0.5);  	dc.PushTransform (new TranslateTransform (pos.X' pos.Y));  	dc.PushTransform (new RotateTransform (-90.0));  	dc.DrawText (pt.Description' fface' fsize' dc.GetTickBrush (0)' new Point ());  	dc.Pop ();  	dc.Pop ();  }  
Magic Number,Cet.UI.Chart,ChartPlotCartesianEvent,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Plot\ChartPlotCartesianEvent.cs,RenderCore,The following statement contains a magic number: if (string.IsNullOrWhiteSpace (pt.Description) == false) {  	var fface = dc.GetTickFace (0);  	var fsize = 10.0;  	var sz = dc.MeasureText (pt.Description' fface' fsize);  	var pos = new Point (x - 0.0 - sz.Height' yt - sz.Width * 0.5);  	dc.PushTransform (new TranslateTransform (pos.X' pos.Y));  	dc.PushTransform (new RotateTransform (-90.0));  	dc.DrawText (pt.Description' fface' fsize' dc.GetTickBrush (0)' new Point ());  	dc.Pop ();  	dc.Pop ();  }  
Magic Number,Cet.UI.Chart,ChartPlotCartesianEvent,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Models\Plot\ChartPlotCartesianEvent.cs,RenderCore,The following statement contains a magic number: dc.PushTransform (new RotateTransform (-90.0));  
Magic Number,Cet.UI.Chart,TimelineCalculateSegmentTickArgs,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Timeline\Models\TimelineCalculateSegmentTickArgs.cs,Validate,The following statement contains a magic number: this._isValid = this._extent > 0 && this._width >= 2;  
Magic Number,Cet.UI.Chart,TimelineHelper,C:\repos\highfield_azure-veneziano\part03\AzureVeneziano.WebJob3\Cet.UI.Chart\Timeline\Models\TimelineHelper.cs,AccumulateTickInfo,The following statement contains a magic number: for (int x = 0; x <= endX; x++) {  	//calcola l'istante nominale ed i due estremi  	long tnom = segment.LowerBound + pixelExtent * x;  	//calcola i due estremi attorno al valore nominale  	long tmin = tnom - pixelExtent / 2;  	long tmax = tmin + pixelExtent;  	#if LOGFILE  	                _file.WriteLine(                     "X={0}; t={1}; {2}; min={3}; max={4}"'                     x'                     t'                     new DateTime(t)'                     new DateTime(tmin)'                     new DateTime(tmax)); #endif  	TimelineTickInfo info = null;  	//se per il segmento corrente è previsto un gap'  	//allora assicura la presenza dell'istanza info  	if (x == endX && segment.GapDuration.HasValue) {  		info = new TimelineTickInfo ();  		info.PixelPosition = x + segment.StartPixel;  		info.Gap = segment.GapDuration;  	}  	//prova tutti gli snappers da quello di riferimento in poi  	for (int y = _snappers.IndexOf (referenceSnapper); y < _snappers.Count; y++) {  		//gli snappers successivi a quello di riferimento  		//potrebbero non essere disponibili' quindi  		//controlla l'effettiva usabilità  		var testSnapper = _snappers [y];  		if (object.Equals (referenceSnapper' testSnapper) == false && testSnapper.CanBeUsed (referenceSnapper) == false) {  			continue;  		}  		//richiede la versione arrotondata del valore nominale  		var snapped = testSnapper.Snap (tnom);  		//controlla se cade entro l'intervallo  		if (tmin <= snapped && snapped <= tmax) {  			//aggiorna l'istanza info con i migliori parametri trovati  			if (info == null) {  				info = new TimelineTickInfo ();  				info.PixelPosition = x + segment.StartPixel;  			}  			info.TopIndex = y;  			info.UserTimestamp = new DateTime (snapped);  		}  		#if LOGFILE  		                    _file.WriteLine(                         "Y={0}; Ext={1}; {2}; Snap={3}; {4}; Info={5}"'                         y'                         _snappers[y].NominalExtent'                         TimeSpan.FromTicks(_snappers[y].NominalExtent)'                         snapped'                         new DateTime(snapped)'                         info); #endif  	}  	//restituisce l'istanza se è non nulla  	if (info != null)  		collection.Add (info);  }  
