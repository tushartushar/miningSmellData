Implementation smell,Namespace,Class,File,Method,Description
Long Method,DBreeze.DataTypes,DataTypesConvertor,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataTypes\DataTypesConvertor.cs,InitDict,The method has 110 lines of code.
Long Method,DBreeze,DBreezeResources,C:\repos\hhblaze_DBreeze\DBreeze\Engine\DBreezeResources.cs,Insert,The method has 109 lines of code.
Long Method,DBreeze,Scheme,C:\repos\hhblaze_DBreeze\DBreeze\Engine\Scheme.cs,GetTable,The method has 164 lines of code.
Long Method,DBreeze.Exceptions,DBreezeException,C:\repos\hhblaze_DBreeze\DBreeze\Exceptions\DBreezeException.cs,GenerateException,The method has 127 lines of code.
Long Method,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,SetupKidWithValue,The method has 133 lines of code.
Long Method,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The method has 312 lines of code.
Long Method,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The method has 195 lines of code.
Long Method,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,WriteSelf,The method has 119 lines of code.
Long Method,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The method has 158 lines of code.
Long Method,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,WriteDynamicDataBlock,The method has 149 lines of code.
Long Method,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,GetTable,The method has 113 lines of code.
Long Method,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,AddKey,The method has 109 lines of code.
Long Method,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,AddKeyPartially,The method has 110 lines of code.
Long Method,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,GetKey,The method has 111 lines of code.
Long Method,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,DoPackage,The method has 102 lines of code.
Long Method,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,Table_Read,The method has 194 lines of code.
Long Method,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,Table_Read,The method has 169 lines of code.
Long Method,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,Table_Read,The method has 212 lines of code.
Long Method,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The method has 135 lines of code.
Long Method,DBreeze.Transactions,TransactionsCoordinator,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Transactions\TransactionsCoordinator.cs,RegisterWriteTablesForTransaction,The method has 102 lines of code.
Long Method,DBreeze.Transactions,TransactionsCoordinator,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Transactions\TransactionsCoordinator.cs,Commit,The method has 117 lines of code.
Long Method,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,GetReadTableFromBuffer,The method has 104 lines of code.
Long Method,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,ObjectInsert,The method has 195 lines of code.
Long Method,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Decode_DICT_PROTO_STRING_BYTEARRAYHASHSET,The method has 106 lines of code.
Long Method,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Decode_DICT_PROTO_STRING_UINTHASHSET,The method has 102 lines of code.
Long Method,DBreeze.LianaTrie.Iterations,Backward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Backward.cs,IterateBackwardStartFrom,The method has 116 lines of code.
Long Method,DBreeze.LianaTrie.Iterations,Backward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Backward.cs,ItBwdFromTo,The method has 116 lines of code.
Long Method,DBreeze.LianaTrie.Iterations,Backward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Backward.cs,IterateBackwardFromTo,The method has 120 lines of code.
Long Method,DBreeze.LianaTrie.Iterations,Backward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Backward.cs,ItBwdSkipFrom,The method has 102 lines of code.
Long Method,DBreeze.LianaTrie.Iterations,Backward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Backward.cs,IterateBackwardSkipFrom,The method has 113 lines of code.
Long Method,DBreeze.LianaTrie.Iterations,Backward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Backward.cs,ItBwdStartsWith,The method has 142 lines of code.
Long Method,DBreeze.LianaTrie.Iterations,Forward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Forward.cs,IterateForwardStartFrom,The method has 102 lines of code.
Long Method,DBreeze.LianaTrie.Iterations,Forward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Forward.cs,ItFrwFromTo,The method has 120 lines of code.
Long Method,DBreeze.LianaTrie.Iterations,Forward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Forward.cs,IterateForwardFromTo,The method has 120 lines of code.
Long Method,DBreeze.LianaTrie.Iterations,Forward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Forward.cs,ItFrwSkipFrom,The method has 103 lines of code.
Long Method,DBreeze.LianaTrie.Iterations,Forward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Forward.cs,IterateForwardSkipFrom,The method has 110 lines of code.
Long Method,DBreeze.LianaTrie.Iterations,Forward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Forward.cs,ItFrwStartsWith,The method has 141 lines of code.
Long Method,DBreeze.LianaTrie.Iterations,Forward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Forward.cs,ItFrwStartsWith_Prefix_Helper,The method has 117 lines of code.
Long Method,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,InsertDocumentText,The method has 104 lines of code.
Long Method,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The method has 258 lines of code.
Long Method,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,ComputeWordsOrigin,The method has 100 lines of code.
Long Method,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_AND_logic,The method has 141 lines of code.
Complex Method,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,AddNodes,Cyclomatic complexity of the method is 8
Complex Method,DBreeze.DataTypes,DataTypesConvertor,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataTypes\DataTypesConvertor.cs,ConvertValue,Cyclomatic complexity of the method is 8
Complex Method,DBreeze.DataTypes,DataTypesConvertor,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataTypes\DataTypesConvertor.cs,ConvertBack,Cyclomatic complexity of the method is 8
Complex Method,DBreeze,TransactionTablesLocker,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Transactions\TransactionTablesLocker.cs,AddSession,Cyclomatic complexity of the method is 13
Complex Method,DBreeze,DBreezeResources,C:\repos\hhblaze_DBreeze\DBreeze\Engine\DBreezeResources.cs,Insert,Cyclomatic complexity of the method is 10
Complex Method,DBreeze,DBreezeResources,C:\repos\hhblaze_DBreeze\DBreeze\Engine\DBreezeResources.cs,Insert,Cyclomatic complexity of the method is 13
Complex Method,DBreeze,DBreezeResources,C:\repos\hhblaze_DBreeze\DBreeze\Engine\DBreezeResources.cs,Select,Cyclomatic complexity of the method is 11
Complex Method,DBreeze,DBreezeResources,C:\repos\hhblaze_DBreeze\DBreeze\Engine\DBreezeResources.cs,Select,Cyclomatic complexity of the method is 8
Complex Method,DBreeze,Scheme,C:\repos\hhblaze_DBreeze\DBreeze\Engine\Scheme.cs,GetTable,Cyclomatic complexity of the method is 8
Complex Method,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,Cyclomatic complexity of the method is 8
Complex Method,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,GetQuantityOfReservationSlots,Cyclomatic complexity of the method is 9
Complex Method,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,Cyclomatic complexity of the method is 10
Complex Method,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetKidsForward,Cyclomatic complexity of the method is 8
Complex Method,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValuePartially,Cyclomatic complexity of the method is 8
Complex Method,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,GetTable,Cyclomatic complexity of the method is 8
Complex Method,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,AddKey,Cyclomatic complexity of the method is 12
Complex Method,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,AddKeyPartially,Cyclomatic complexity of the method is 13
Complex Method,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,RemoveKey,Cyclomatic complexity of the method is 10
Complex Method,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,GetKey,Cyclomatic complexity of the method is 17
Complex Method,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,FlushRandomBuffer,Cyclomatic complexity of the method is 9
Complex Method,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,FlushRandomBuffer,Cyclomatic complexity of the method is 9
Complex Method,DBreeze.Transactions,RandomKeySorter,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\RandomKeySorter.cs,Flush,Cyclomatic complexity of the method is 8
Complex Method,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,GetReadTableFromBuffer,Cyclomatic complexity of the method is 9
Complex Method,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,ObjectInsert,Cyclomatic complexity of the method is 24
Complex Method,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Encode_DICT_PROTO_STRING_BYTEARRAYHASHSET,Cyclomatic complexity of the method is 8
Complex Method,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,TruncateUTF8,Cyclomatic complexity of the method is 9
Complex Method,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,BytesAction_GoOneBitDown_NoArrayGrow_BigEndian,Cyclomatic complexity of the method is 8
Complex Method,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,IfStringArraySmallerThen,Cyclomatic complexity of the method is 9
Complex Method,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,IfStringArraySmallerOrEqualThen,Cyclomatic complexity of the method is 9
Complex Method,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,IfStringArrayBiggerThen,Cyclomatic complexity of the method is 9
Complex Method,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,IfStringArrayBiggerOrEqualThen,Cyclomatic complexity of the method is 9
Complex Method,DBreeze.LianaTrie.Iterations,Backward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Backward.cs,ItBwdFromTo,Cyclomatic complexity of the method is 8
Complex Method,DBreeze.LianaTrie.Iterations,Backward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Backward.cs,ItBwdSkipFrom,Cyclomatic complexity of the method is 8
Complex Method,DBreeze.LianaTrie.Iterations,Forward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Forward.cs,ItFrwFromTo,Cyclomatic complexity of the method is 8
Complex Method,DBreeze.LianaTrie.Iterations,Forward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Forward.cs,ItFrwSkipFrom,Cyclomatic complexity of the method is 8
Complex Method,DBreeze.TextSearch,SBlock,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\SBlock.cs,GetArrays,Cyclomatic complexity of the method is 9
Complex Method,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,Cyclomatic complexity of the method is 24
Complex Method,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,GetWordsDefinitionFromText,Cyclomatic complexity of the method is 8
Complex Method,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,ComputeWordsOrigin,Cyclomatic complexity of the method is 13
Complex Method,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_AND_logic,Cyclomatic complexity of the method is 14
Complex Method,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_OR_logic,Cyclomatic complexity of the method is 10
Long Parameter List,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,Insert,The method has 5 parameters. Parameters: key' value' refToInsertedValue' WasUpdated' dontUpdateIfExists
Long Parameter List,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,InsertPart,The method has 5 parameters. Parameters: key' value' startIndex' refToInsertedValue' WasUpdated
Long Parameter List,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectForwardFromTo,The method has 5 parameters. Parameters: startKey' includeStartKey' stopKey' includeStopKey' AsReadVisibilityScope
Long Parameter List,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectBackwardFromTo,The method has 5 parameters. Parameters: startKey' includeStartKey' stopKey' includeStopKey' AsReadVisibilityScope
Long Parameter List,DBreeze.DataTypes,NestedTableInternal,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTableInternal.cs,NestedTableInternal,The method has 7 parameters. Parameters: tableExists' masterTrie' rootStart' shiftFromValueStart' useCache' parentTrie' key
Long Parameter List,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,SetupKidWithValue,The method has 7 parameters. Parameters: kid' lastElementOfTheKey' fullKey' value' useExistingPointerToValue' WasUpdated' dontUpdateIfExists
Long Parameter List,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,SetupKidWithValuePartially,The method has 8 parameters. Parameters: kid' lastElementOfTheKey' fullKey' value' useExistingPointerToValue' startIndex' valueStartPtr' WasUpdated
Long Parameter List,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,RemoveKid,The method has 6 parameters. Parameters: kid' lastElementOfTheKey' key' WasRemoved' retrieveDeletedValue' deletedValue
Long Parameter List,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The method has 5 parameters. Parameters: ptr' value' fullKey' startIndex' valueStartPtr
Long Parameter List,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,WriteKidValuePartially,The method has 6 parameters. Parameters: fullKey' value' tryToOverwrite' overWritePointer' startIndex' valueStartPtr
Long Parameter List,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKeyValue,The method has 6 parameters. Parameters: useCache' pointer' valueStartPtr' valueLength' key' val
Long Parameter List,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValuePartially,The method has 6 parameters. Parameters: pointer' startIndex' length' useCache' valueStartPtr' valueLength
Long Parameter List,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,GetTable,The method has 6 parameters. Parameters: row' btKey' tableIndex' masterTrie' insertTable' useCache
Long Parameter List,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,AddPartially,The method has 5 parameters. Parameters: key' value' startIndex' valueStartPtr' WasUpdated
Long Parameter List,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,IterateForwardFromTo,The method has 6 parameters. Parameters: startKey' stopKey' includeStartKey' includeStopKey' useCache' ValuesLazyLoadingIsOn
Long Parameter List,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,IterateForwardFromTo,The method has 6 parameters. Parameters: startKey' stopKey' includeStartKey' includeStopKey' readRootNode' ValuesLazyLoadingIsOn
Long Parameter List,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,IterateBackwardFromTo,The method has 6 parameters. Parameters: startKey' stopKey' includeStartKey' includeStopKey' useCache' ValuesLazyLoadingIsOn
Long Parameter List,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,IterateBackwardFromTo,The method has 6 parameters. Parameters: startKey' stopKey' includeStartKey' includeStopKey' readRootNode' ValuesLazyLoadingIsOn
Long Parameter List,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,AddKeyPartially,The method has 5 parameters. Parameters: key' value' startIndex' valueStartPtr' WasUpdated
Long Parameter List,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,RemoveKey,The method has 5 parameters. Parameters: tableName' key' WasRemoved' retrieveDeletedValue' deletedValue
Long Parameter List,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,ChangeKey,The method has 5 parameters. Parameters: tableName' oldKey' newKey' ptrToNewKey' WasChanged
Long Parameter List,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,Insert,The method has 5 parameters. Parameters: tableName' key' value' refToInsertedValue' WasUpdated
Long Parameter List,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,Insert,The method has 6 parameters. Parameters: tableName' key' value' refToInsertedValue' WasUpdated' dontUpdateIfExists
Long Parameter List,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,InsertPart,The method has 5 parameters. Parameters: tableName' key' value' startIndex' refToInsertedValue
Long Parameter List,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,InsertPart,The method has 6 parameters. Parameters: tableName' key' value' startIndex' refToInsertedValue' WasUpdated
Long Parameter List,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,InsertDictionary,The method has 5 parameters. Parameters: tableName' key' value' tableIndex' withValuesRemove
Long Parameter List,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,InsertHashSet,The method has 5 parameters. Parameters: tableName' key' value' tableIndex' withValuesRemove
Long Parameter List,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,TextInsert,The method has 6 parameters. Parameters: tableName' documentId' containsWords' fullMatchWords' deferredIndexing' containsMinimalLength
Long Parameter List,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,TextAppend,The method has 6 parameters. Parameters: tableName' documentId' containsWords' fullMatchWords' deferredIndexing' containsMinimalLength
Long Parameter List,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,TextRemove,The method has 5 parameters. Parameters: tableName' documentId' fullMatchWords' deferredIndexing' containsMinimalLength
Long Parameter List,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,SelectForwardFromTo,The method has 6 parameters. Parameters: tableName' startKey' includeStartKey' stopKey' includeStopKey' AsReadVisibilityScope
Long Parameter List,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,SelectBackwardFromTo,The method has 6 parameters. Parameters: tableName' startKey' includeStartKey' stopKey' includeStopKey' AsReadVisibilityScope
Long Parameter List,DBreeze.Utils.Async,AsyncOperations,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\AsyncOperations.cs,DoAsync,The method has 5 parameters. Parameters: f' arg' arg1' arg2' arg3
Long Parameter List,DBreeze.Utils,Filter<T>,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BloomFilter.cs,Filter,The method has 5 parameters. Parameters: capacity' errorRate' hashFunction' m' k
Long Parameter List,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,CopyInside,The method has 5 parameters. Parameters: destArray' destOffset' srcArray' srcOffset' quantity
Long Parameter List,DBreeze.LianaTrie.Iterations,Backward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Backward.cs,IterateBackwardFromTo,The method has 5 parameters. Parameters: initKey' stopKey' inclStartKey' inclStopKey' useCache
Long Parameter List,DBreeze.LianaTrie.Iterations,Forward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Forward.cs,IterateForwardFromTo,The method has 5 parameters. Parameters: initKey' stopKey' inclStartKey' inclStopKey' useCache
Long Parameter List,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,InsertDocumentText,The method has 8 parameters. Parameters: tran' tableName' documentId' containsWords' fullMatchWords' deferredIndexing' containsMinimalLength' iMode
Long Identifier,DBreeze,DBreezeEngine,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Engine\DBreezeEngine.cs,,The length of the parameter BackgroundTasksExternalNotifier is 31.
Long Identifier,DBreeze.Storage,Backup,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\Backup.cs,,The length of the parameter _IncrementalBackupFileIntervalMin is 33.
Long Identifier,DBreeze.Transactions,TransactionsCoordinator,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Transactions\TransactionsCoordinator.cs,RegisterWriteTablesForTransaction,The length of the parameter toWaitTillTransactionIsFinished is 31.
Long Identifier,DBreeze.Transactions,TransactionUnit,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Transactions\TransactionUnit.cs,,The length of the parameter _transactionWriteTablesAwaitingReservation is 42.
Long Identifier,DBreeze.Transactions,RandomKeySorter,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\RandomKeySorter.cs,,The length of the parameter AutomaticFlushLimitQuantityPerTable is 35.
Long Identifier,DBreeze.Transactions,RandomKeySorter,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\RandomKeySorter.cs,,The length of the parameter _tablesWithOverwriteIsNotAllowed is 32.
Long Identifier,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,,The length of the parameter ReadVisibilityScopeModifier_GenerateNewTableForRead is 51.
Long Identifier,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,,The length of the parameter ReadVisibilityScopeModifier_DirtyRead is 37.
Long Statement,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,SetupWriteTables,The length of the statement  "                this.RootNode.nt2Write = this.RootNode.Transaction.InsertTable(this.RootNode.DBreezeTableName' new byte[] { 2 }' 0);  //here is a structure table   " is 145.
Long Statement,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,SetupWriteTables,The length of the statement  "                this.RootNode.nt3Write = this.RootNode.Transaction.InsertTable(this.RootNode.DBreezeTableName' new byte[] { 3 }' 0);  //here is a search by NodeName table " is 154.
Long Statement,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,GetNodeByParentIdAndNodeId,The length of the statement  "            var row = this.RootNode.nt2Read.Select<byte[]' byte[]>(parentNodeId.To_8_bytes_array_BigEndian().Concat(nodeId.To_8_bytes_array_BigEndian())); " is 142.
Long Statement,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,RemoveNode,The length of the statement  "            var oldRow = this.RootNode.nt2Write.Select<byte[]' byte[]>(parentNodeId.To_8_bytes_array_BigEndian().Concat(nodeId.To_8_bytes_array_BigEndian())); " is 146.
Long Statement,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,RemoveNode,The length of the statement  "                RemoveOldNodeFromNameIndex(oldNode.NodeName' parentNodeId.To_8_bytes_array_BigEndian().Concat(nodeId.To_8_bytes_array_BigEndian())); " is 132.
Long Statement,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,RemoveNode,The length of the statement  "            this.RootNode.nt2Write.RemoveKey<byte[]>(parentNodeId.To_8_bytes_array_BigEndian().Concat(nodeId.To_8_bytes_array_BigEndian())); " is 128.
Long Statement,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,AddNodes,The length of the statement  "                    var oldRow = this.RootNode.nt2Write.Select<byte[]' byte[]>(node.ParentNodeId.To_8_bytes_array_BigEndian().Concat(node.NodeId.To_8_bytes_array_BigEndian())); " is 156.
Long Statement,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,AddNodes,The length of the statement  "                            RemoveOldNodeFromNameIndex(oldNode.NodeName' node.ParentNodeId.To_8_bytes_array_BigEndian().Concat(node.NodeId.To_8_bytes_array_BigEndian())); " is 142.
Long Statement,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,AddNode,The length of the statement  "                var oldRow = this.RootNode.nt2Write.Select<byte[]' byte[]>(node.ParentNodeId.To_8_bytes_array_BigEndian().Concat(node.NodeId.To_8_bytes_array_BigEndian())); " is 156.
Long Statement,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,AddNode,The length of the statement  "                        RemoveOldNodeFromNameIndex(oldNode.NodeName' node.ParentNodeId.To_8_bytes_array_BigEndian().Concat(node.NodeId.To_8_bytes_array_BigEndian())); " is 142.
Long Statement,DBreeze.DataTypes,Row<TKey;TValue>,C:\repos\hhblaze_DBreeze\DBreeze\DataTypes\Row.cs,GetTable,The length of the statement  "            ///////////  FOR NOW allow insert from master is always false' later we have to change Transaction.Insert' and insertPart to return also a row??? " is 145.
Long Statement,DBreeze.DataTypes,Row<TKey;TValue>,C:\repos\hhblaze_DBreeze\DBreeze\DataTypes\Row.cs,GetTable,The length of the statement  "                var nt = _row.Root.Tree.GetTable(_row' ref _row.Key' tableIndex' _masterTrie' nestedTable._insertAllowed' this._useCache); " is 122.
Long Statement,DBreeze.DataTypes,Row<TKey;TValue>,C:\repos\hhblaze_DBreeze\DBreeze\DataTypes\Row.cs,GetValuePart,The length of the statement  "                //return this._root.Tree.Cache.ReadValuePartially(this._ptrToValue' startIndex' length' this._useCache' out valueStartPointer' out valueFullLength); " is 148.
Long Statement,DBreeze.DataTypes,Row<TKey;TValue>,C:\repos\hhblaze_DBreeze\DBreeze\DataTypes\Row.cs,GetValuePart,The length of the statement  "                return this._row.Root.Tree.Cache.ReadValuePartially(this._row.LinkToValue' startIndex' length' this._useCache' out valueStartPointer' out valueFullLength); " is 155.
Long Statement,DBreeze.DataTypes,Row<TKey;TValue>,C:\repos\hhblaze_DBreeze\DBreeze\DataTypes\Row.cs,GetValuePart,The length of the statement  "                return this._row.Root.Tree.Cache.ReadValuePartially(this._row.LinkToValue' startIndex' length' this._useCache' out valueStartPointer' out valueFullLength); " is 155.
Long Statement,DBreeze.DataTypes,Row<TKey;TValue>,C:\repos\hhblaze_DBreeze\DBreeze\DataTypes\Row.cs,GetDataBlock,The length of the statement  "                dataBlockId = this._row.Root.Tree.Cache.ReadValuePartially(this._row.LinkToValue' startIndex' 16' this._useCache' out valueStartPointer' out valueFullLength); " is 158.
Long Statement,DBreeze.DataTypes,Row<TKey;TValue>,C:\repos\hhblaze_DBreeze\DBreeze\DataTypes\Row.cs,GetDataBlockWithFixedAddress,The length of the statement  "                    //return DataTypesConvertor.ConvertBack<TValue>(this._row.Root.Tree.Cache.ReadDynamicDataBlock(ref dataBlockId' this._useCache)); " is 129.
Long Statement,DBreeze.DataTypes,Row<TKey;TValue>,C:\repos\hhblaze_DBreeze\DBreeze\DataTypes\Row.cs,GetDataBlockWithFixedAddress,The length of the statement  "                dataBlockId = this._row.Root.Tree.Cache.ReadValuePartially(this._row.LinkToValue' startIndex' 16' this._useCache' out valueStartPointer' out valueFullLength); " is 158.
Long Statement,DBreeze.DataTypes,Row<TKey;TValue>,C:\repos\hhblaze_DBreeze\DBreeze\DataTypes\Row.cs,GetDataBlockWithFixedAddress,The length of the statement  "                //return DataTypesConvertor.ConvertBack<TValue>(this._row.Root.Tree.Cache.ReadDynamicDataBlock(ref dataBlockId' this._useCache)); " is 129.
Long Statement,DBreeze.DataTypes,Row<TKey;TValue>,C:\repos\hhblaze_DBreeze\DBreeze\DataTypes\Row.cs,GetDataBlockWithFixedAddress,The length of the statement  "            return DataTypesConvertor.ConvertBack<TVal>(this._row.Root.Tree.Cache.ReadDynamicDataBlock(ref dataBlockId' this._useCache)); " is 125.
Long Statement,DBreeze.DataTypes,Row<TKey;TValue>,C:\repos\hhblaze_DBreeze\DBreeze\DataTypes\Row.cs,ObjectGet,The length of the statement  "                    dataBlockId = this._row.Root.Tree.Cache.ReadValuePartially(this._row.LinkToValue' (uint)startIndex' 16' this._useCache' out valueStartPointer' out valueFullLength); " is 164.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectDataBlock,The length of the statement  "                bool useCache = (_tbl._masterTrie.NestedTablesCoordinator.ModificationThreadId != System.Threading.Thread.CurrentThread.ManagedThreadId); " is 137.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,Select,The length of the statement  "                bool useCache = (_tbl._masterTrie.NestedTablesCoordinator.ModificationThreadId != System.Threading.Thread.CurrentThread.ManagedThreadId); " is 137.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectDirect,The length of the statement  "                refToInsertedValue = refToInsertedValue.RemoveLeadingElement(0).EnlargeByteArray_BigEndian(_tbl._masterTrie.Storage.TrieSettings.POINTER_LENGTH); " is 145.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectDirect,The length of the statement  "                bool useCache = (_tbl._masterTrie.NestedTablesCoordinator.ModificationThreadId != System.Threading.Thread.CurrentThread.ManagedThreadId); " is 137.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,Count,The length of the statement  "                bool useCache = (_tbl._masterTrie.NestedTablesCoordinator.ModificationThreadId != System.Threading.Thread.CurrentThread.ManagedThreadId); " is 137.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,Max,The length of the statement  "                bool useCache = (_tbl._masterTrie.NestedTablesCoordinator.ModificationThreadId != System.Threading.Thread.CurrentThread.ManagedThreadId); " is 137.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,Min,The length of the statement  "                bool useCache = (_tbl._masterTrie.NestedTablesCoordinator.ModificationThreadId != System.Threading.Thread.CurrentThread.ManagedThreadId); " is 137.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectForward,The length of the statement  "                bool useCache = (_tbl._masterTrie.NestedTablesCoordinator.ModificationThreadId != System.Threading.Thread.CurrentThread.ManagedThreadId); " is 137.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectBackward,The length of the statement  "                bool useCache = (_tbl._masterTrie.NestedTablesCoordinator.ModificationThreadId != System.Threading.Thread.CurrentThread.ManagedThreadId); " is 137.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectForwardStartFrom,The length of the statement  "                bool useCache = (_tbl._masterTrie.NestedTablesCoordinator.ModificationThreadId != System.Threading.Thread.CurrentThread.ManagedThreadId); " is 137.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectForwardStartFrom,The length of the statement  "                foreach (var xrow in _tbl.table.IterateForwardStartFrom(btKey' includeStartFromKey' useCache' this._valuesLazyLoadingIsOn)) " is 123.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectBackwardStartFrom,The length of the statement  "                bool useCache = (_tbl._masterTrie.NestedTablesCoordinator.ModificationThreadId != System.Threading.Thread.CurrentThread.ManagedThreadId); " is 137.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectBackwardStartFrom,The length of the statement  "                foreach (var xrow in _tbl.table.IterateBackwardStartFrom(btKey' includeStartFromKey' useCache' this._valuesLazyLoadingIsOn)) " is 124.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectForwardFromTo,The length of the statement  "                bool useCache = (_tbl._masterTrie.NestedTablesCoordinator.ModificationThreadId != System.Threading.Thread.CurrentThread.ManagedThreadId); " is 137.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectForwardFromTo,The length of the statement  "                foreach (var xrow in _tbl.table.IterateForwardFromTo(btStartKey' btStopKey' includeStartKey' includeStopKey' useCache' this._valuesLazyLoadingIsOn)) " is 148.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectBackwardFromTo,The length of the statement  "                bool useCache = (_tbl._masterTrie.NestedTablesCoordinator.ModificationThreadId != System.Threading.Thread.CurrentThread.ManagedThreadId); " is 137.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectBackwardFromTo,The length of the statement  "                foreach (var xrow in _tbl.table.IterateBackwardFromTo(btStartKey' btStopKey' includeStartKey' includeStopKey' useCache' this._valuesLazyLoadingIsOn)) " is 149.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectForwardStartsWith,The length of the statement  "                bool useCache = (_tbl._masterTrie.NestedTablesCoordinator.ModificationThreadId != System.Threading.Thread.CurrentThread.ManagedThreadId); " is 137.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectForwardStartsWithClosestToPrefix,The length of the statement  "                bool useCache = (_tbl._masterTrie.NestedTablesCoordinator.ModificationThreadId != System.Threading.Thread.CurrentThread.ManagedThreadId); " is 137.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectForwardStartsWithClosestToPrefix,The length of the statement  "                foreach (var xrow in _tbl.table.IterateForwardStartsWithClosestToPrefix(btStartKey' useCache' this._valuesLazyLoadingIsOn)) " is 123.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectBackwardStartsWithClosestToPrefix,The length of the statement  "                bool useCache = (_tbl._masterTrie.NestedTablesCoordinator.ModificationThreadId != System.Threading.Thread.CurrentThread.ManagedThreadId); " is 137.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectBackwardStartsWithClosestToPrefix,The length of the statement  "                foreach (var xrow in _tbl.table.IterateBackwardStartsWithClosestToPrefix(btStartKey' useCache' this._valuesLazyLoadingIsOn)) " is 124.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectBackwardStartsWith,The length of the statement  "                bool useCache = (_tbl._masterTrie.NestedTablesCoordinator.ModificationThreadId != System.Threading.Thread.CurrentThread.ManagedThreadId); " is 137.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectForwardSkip,The length of the statement  "                bool useCache = (_tbl._masterTrie.NestedTablesCoordinator.ModificationThreadId != System.Threading.Thread.CurrentThread.ManagedThreadId); " is 137.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectBackwardSkip,The length of the statement  "                bool useCache = (_tbl._masterTrie.NestedTablesCoordinator.ModificationThreadId != System.Threading.Thread.CurrentThread.ManagedThreadId); " is 137.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectForwardSkipFrom,The length of the statement  "            //    bool useCache = (_tbl._masterTrie.NestedTablesCoordinator.ModificationThreadId != System.Threading.Thread.CurrentThread.ManagedThreadId); " is 143.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectForwardSkipFrom,The length of the statement  "                bool useCache = (_tbl._masterTrie.NestedTablesCoordinator.ModificationThreadId != System.Threading.Thread.CurrentThread.ManagedThreadId); " is 137.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectBackwardSkipFrom,The length of the statement  "            //    bool useCache = (_tbl._masterTrie.NestedTablesCoordinator.ModificationThreadId != System.Threading.Thread.CurrentThread.ManagedThreadId); " is 143.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectBackwardSkipFrom,The length of the statement  "                bool useCache = (_tbl._masterTrie.NestedTablesCoordinator.ModificationThreadId != System.Threading.Thread.CurrentThread.ManagedThreadId); " is 137.
Long Statement,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,SelectBackwardSkipFrom,The length of the statement  "                foreach (var xrow in _tbl.table.IterateBackwardSkipFrom(btKey' skippingQuantity' useCache' this._valuesLazyLoadingIsOn)) " is 120.
Long Statement,DBreeze.Diagnostic,SpeedStatistic,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Diagnostic\SpeedStatistic.cs,PrintOut,The length of the statement  "            //        Console.WriteLine("{0}: {1}; Time: {2} ms; {3} ticks "' counterName' cnt.QuantityRuns' cnt.ElapsedMs' cnt.ElapsedTicks); " is 130.
Long Statement,DBreeze.Diagnostic,SpeedStatistic,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Diagnostic\SpeedStatistic.cs,PrintOut,The length of the statement  "                    string output = String.Format("{0}: {1}; Time: {2} ms; {3} ticks "' counterName' cnt.QuantityRuns' cnt.ElapsedMs' cnt.ElapsedTicks); " is 132.
Long Statement,DBreeze.Diagnostic,SpeedStatistic,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Diagnostic\SpeedStatistic.cs,PrintOut,The length of the statement  "                    string output = String.Format("{0}: {1}; Time: {2} ms; {3} ticks "' cnt.Key' cnt.Value.QuantityRuns' cnt.Value.ElapsedMs' cnt.Value.ElapsedTicks); " is 146.
Long Statement,DBreeze.Diagnostic,Counter,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Diagnostic\SpeedStatistic.cs,PrintOut,The length of the statement  "                string output = String.Format("{0}: {1}; Time: {2} ms; {3} ticks "' this.name' cnt' sw.ElapsedMilliseconds' sw.ElapsedTicks); " is 125.
Long Statement,DBreeze,DBreezeEngine,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Engine\DBreezeEngine.cs,ConstructFromConfiguration,The length of the statement  "                throw new Exception("DBreeze.DBreezeEngine.DBreezeEngine: remote instance must be initiated via new DBreezeRemoteEngine"); " is 122.
Long Statement,DBreeze,DBreezeEngine,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Engine\DBreezeEngine.cs,ConstructFromConfiguration,The length of the statement  "            //Console.WriteLine("DBreeze notification: Don't forget in the dispose function of your DLL or main application thread"); " is 121.
Long Statement,DBreeze,DBreezeEngine,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Engine\DBreezeEngine.cs,GetTransaction,The length of the statement  "                throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DB_IS_NOT_OPERABLE'DBisOperableReason'new Exception());               " is 120.
Long Statement,DBreeze,DBreezeEngine,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Engine\DBreezeEngine.cs,GetTransaction,The length of the statement  "                throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DB_IS_NOT_OPERABLE' DBisOperableReason' new Exception()); " is 122.
Long Statement,DBreeze,DBreezeResources,C:\repos\hhblaze_DBreeze\DBreeze\Engine\DBreezeResources.cs,SelectStartsWith,The length of the statement  "                    yield return new KeyValuePair<string' TValue>(rn.Substring(1)' val == null ? default(TValue) : DataTypesConvertor.ConvertBack<TValue>(val)); " is 140.
Long Statement,DBreeze,Scheme,C:\repos\hhblaze_DBreeze\DBreeze\Engine\Scheme.cs,GetPhysicalPathToTheUserTable,The length of the statement  "                throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.GENERAL_EXCEPTION_DB_NOT_OPERABLE' this.Engine.DBisOperableReason' ex); " is 136.
Long Statement,DBreeze,Scheme,C:\repos\hhblaze_DBreeze\DBreeze\Engine\Scheme.cs,GetTable,The length of the statement  "            //TODO pattern based mapping If table doesn't exist we create it with properties which could be supplied after db init as regex theme. " is 134.
Long Statement,DBreeze,Scheme,C:\repos\hhblaze_DBreeze\DBreeze\Engine\Scheme.cs,GetTable,The length of the statement  "            //For protocol 1: first 8 bytes will be TheFileName' starting from db10000-dbN (0-N ulong). up to 10000 are reserved for dbreeze. " is 129.
Long Statement,DBreeze,Scheme,C:\repos\hhblaze_DBreeze\DBreeze\Engine\Scheme.cs,GetTable,The length of the statement  "                            storage = new StorageLayer(Path.Combine(ts.AlternativeTableStorageFolder' fileName.ToString())' ts' Engine.Configuration); " is 122.
Long Statement,DBreeze,Scheme,C:\repos\hhblaze_DBreeze\DBreeze\Engine\Scheme.cs,IfUserTableExists,The length of the statement  "            ////First trying to acquire memory storage' without lock but inside of "ignoring" try-catch' if answer is failed refer to the disk " is 130.
Long Statement,DBreeze,Scheme,C:\repos\hhblaze_DBreeze\DBreeze\Engine\Scheme.cs,GetUserTableNamesStartingWith,The length of the statement  "            //No lock here' while IterateForwardStartsWith of the LTrie is safe (new root is created)' and we don't acquire value from the key (which could be delete). " is 155.
Long Statement,DBreeze,Scheme,C:\repos\hhblaze_DBreeze\DBreeze\Engine\Scheme.cs,GetUserTableNamesStartingWith,The length of the statement  "                //try       //try-catch could be necessary in case if we acquire value' which was deleted by other thread. Here we don't acquire value. " is 135.
Long Statement,DBreeze.Exceptions,DBreezeException,C:\repos\hhblaze_DBreeze\DBreeze\Exceptions\DBreezeException.cs,GenerateException,The length of the statement  "                    return new DBreezeException(String.Format("Database is not operable' please find out the problem and restart the engine! {0}"'message)' innerException); " is 152.
Long Statement,DBreeze.Exceptions,DBreezeException,C:\repos\hhblaze_DBreeze\DBreeze\Exceptions\DBreezeException.cs,GenerateException,The length of the statement  "                    return new DBreezeException(String.Format("Database is not operable' please find out the problem and restart the engine! {0}"' message)' innerException); " is 153.
Long Statement,DBreeze.Exceptions,DBreezeException,C:\repos\hhblaze_DBreeze\DBreeze\Exceptions\DBreezeException.cs,GenerateException,The length of the statement  "                // return new DBreezeException(String.Format("{0}creation of the database folder failed: {1}"' ExceptionHeader' originalException.ToString())); " is 143.
Long Statement,DBreeze.Exceptions,DBreezeException,C:\repos\hhblaze_DBreeze\DBreeze\Exceptions\DBreezeException.cs,GenerateException,The length of the statement  "                    return new DBreezeException(String.Format("Table name can not contain reserved symbols like * # @ \\ ^ $ ~ ´")' innerException); " is 128.
Long Statement,DBreeze.Exceptions,DBreezeException,C:\repos\hhblaze_DBreeze\DBreeze\Exceptions\DBreezeException.cs,GenerateException,The length of the statement  "                    return new DBreezeException(String.Format("Table \"{0}\" commit failed!"' message)' innerException);     //ADD TABLE NAME!!! " is 124.
Long Statement,DBreeze.Exceptions,DBreezeException,C:\repos\hhblaze_DBreeze\DBreeze\Exceptions\DBreezeException.cs,GenerateException,The length of the statement  "                    //return new DBreezeException(String.Format("{0}rollback of the file \"{1}\" is not operatable: {2}"' ExceptionHeader' description' originalException.ToString())); " is 163.
Long Statement,DBreeze.Exceptions,DBreezeException,C:\repos\hhblaze_DBreeze\DBreeze\Exceptions\DBreezeException.cs,GenerateException,The length of the statement  "                    return new DBreezeException(String.Format("Transaction rollback failed on the table \"{0}\"!"' message)' innerException); " is 121.
Long Statement,DBreeze.Exceptions,DBreezeException,C:\repos\hhblaze_DBreeze\DBreeze\Exceptions\DBreezeException.cs,GenerateException,The length of the statement  "                    return new DBreezeException(String.Format("Key is too long' maximal key size is: {0}!"' UInt16.MaxValue.ToString())' innerException); " is 133.
Long Statement,DBreeze.Exceptions,DBreezeException,C:\repos\hhblaze_DBreeze\DBreeze\Exceptions\DBreezeException.cs,GenerateException,The length of the statement  "                        return new DBreezeException(String.Format("Table was changed (Table Recrete' Table RestoreTableFromTheOtherTable)' links are not actual' repeat reading operation!")' innerException); " is 182.
Long Statement,DBreeze.Exceptions,DBreezeException,C:\repos\hhblaze_DBreeze\DBreeze\Exceptions\DBreezeException.cs,GenerateException,The length of the statement  "                    return new DBreezeException(String.Format("Transaction journal couldn't clean rollback files of the finished transactions!")' innerException); " is 142.
Long Statement,DBreeze.Exceptions,DBreezeException,C:\repos\hhblaze_DBreeze\DBreeze\Exceptions\DBreezeException.cs,GenerateException,The length of the statement  "                    return new DBreezeException(String.Format("Transaction is in a deadlock state and will be terminated. To avoid such case use Transaction.SynchronizeTables!")' innerException); " is 175.
Long Statement,DBreeze.Exceptions,DBreezeException,C:\repos\hhblaze_DBreeze\DBreeze\Exceptions\DBreezeException.cs,GenerateException,The length of the statement  "                    return new DBreezeException(String.Format("Reservation tables for modification or synchronized read failed! Use SynchronizeTables before any modification!")' innerException); " is 174.
Long Statement,DBreeze.Exceptions,DBreezeException,C:\repos\hhblaze_DBreeze\DBreeze\Exceptions\DBreezeException.cs,GenerateException,The length of the statement  "                    return new DBreezeException(String.Format("Reservation tables for modification or synchronized read failed! Only one synchronization call permitted per transaction!")' innerException); " is 184.
Long Statement,DBreeze.Exceptions,DBreezeException,C:\repos\hhblaze_DBreeze\DBreeze\Exceptions\DBreezeException.cs,GenerateException,The length of the statement  "                    return new DBreezeException(String.Format("Reservation tables for modification or synchronized read failed! Synchronization list must be filled!")' innerException); " is 164.
Long Statement,DBreeze.Exceptions,DBreezeException,C:\repos\hhblaze_DBreeze\DBreeze\Exceptions\DBreezeException.cs,GenerateException,The length of the statement  "                    return new DBreezeException(String.Format("Changing data after SelectTable is not permitted' use InsertTable instead!")' innerException); " is 137.
Long Statement,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,RemoveKid,The length of the statement  "                //Trying to delete value' as result we must receive bool true' if value existed (and we can change here also count and setup ToWrite = true) " is 140.
Long Statement,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,RemoveKid,The length of the statement  "                        deletedValue = this._root.Tree.Cache.ReadValue(KidsInNode.GetKidValue().Ptr' false' out valueStartPtr' out valueLength);                         " is 120.
Long Statement,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The length of the statement  "            //1 byte - ValueWriteProtocol identification (0 - without FULL reserved size[used after first insert]' 1 - with extra reservation space)'  " is 137.
Long Statement,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The length of the statement  "            int initRead = 111; //Where 100 is standard max size of the key in case of words (even 50 must be enough)' in case of sentences can be much longer' probably we can setup it later " is 178.
Long Statement,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,WriteKidValuePartially,The length of the statement  "            //1 byte protocol'FullKeyLen (2 bytes)' FullValueLen (4 bytes)'[4 bytes reeserved space if protocol 1' if 0 nothing]'FullKey'FullValue " is 134.
Long Statement,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The length of the statement  "            //1 byte - ValueWriteProtocol identification (0 - without FULL reserved size[used after first insert]' 1 - with extra reservation space)'  " is 137.
Long Statement,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The length of the statement  "            int initRead = 111; //Where 100 is standard max size of the key in case of words (even 50 must be enough)' in case of sentences can be much longer' probably we can setup it later " is 178.
Long Statement,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,WriteKidValue,The length of the statement  "            //1 byte protocol'FullKeyLen (2 bytes)' FullValueLen (4 bytes)'[4 bytes reeserved space if protocol 1' if 0 nothing]'FullKey'FullValue " is 134.
Long Statement,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,WriteSelf,The length of the statement  "            // * Problem can appear after remove' previous node still has link to the empty line and it influences backward and forward work' inside of for(;;) going only down            " is 163.
Long Statement,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,WriteSelf,The length of the statement  "            //We need correction for the case when we use one cursor for Select (with standard "write" visibility scope) and Insert statement in one transaction             " is 148.
Long Statement,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,WriteSelf,The length of the statement  "                //byte[] rollBackData = ((short)KidsBeforeModification.Length).To_2_bytes_array_BigEndian().Concat(KidsBeforeModification); " is 123.
Long Statement,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,WriteSelf,The length of the statement  "                //    throw new Exception(String.Format("!!!DBreeze debug exception' LTrieGenNode KBM null' Reservation: {0}; QRS: {1};"'reservation'this.QuantityReservationSlots)); " is 165.
Long Statement,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,WriteSelf,The length of the statement  "            //2. Generation.WriteSelf works in 2 cases' when we need to load other generation node (then it's safe) and after Commit " is 120.
Long Statement,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,WriteSelf,The length of the statement  "            //   in this case generation node stays' but we change KidsBeforeModification in commit in case of mistake we clean generation map " is 130.
Long Statement,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,AddKid,The length of the statement  "                //It's balanced on upper level' but here we save only pointer to the value' and this kid will definetely has not busy place' " is 124.
Long Statement,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ReplaceValueLinkOnKidLink,The length of the statement  "            //Here we appear only in case if we want to setup kid on the busy place. This busy place can be resided by link to the other kid or link to the value. " is 150.
Long Statement,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ReplaceValueLinkOnKidLink,The length of the statement  "            //If it's busy by link to the kid we return null' if by link to the value then we clean flag "Link to the value" an return back this pointer. " is 141.
Long Statement,DBreeze.LianaTrie,LTrieRow,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieRow.cs,GetPartialValue,The length of the statement  "                return this._root.Tree.Cache.ReadValuePartially(this.LinkToValue' startIndex' length' useCache' out ValueStartPointer' out ValueFullLength); " is 140.
Long Statement,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,GenerationNodeRead,The length of the statement  "                    //Here node can be also of empty length [0] - it means that cachedGenerationMapLine exists but old kids were empty' it will be checked on upper levels " is 150.
Long Statement,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadDynamicDataBlock,The length of the statement  "            //Link to the block (initPtr) is represented by 8+4+4=16 bytes: 8 pointer (ulong)' 4 bytes Block Length(ulong)' 4 bytes data length (uint) " is 138.
Long Statement,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,WriteDynamicDataBlock,The length of the statement  "            //Link to the block (initPtr) is represented by 8+4+4=16 bytes: 8 pointer (ulong)' 4 bytes Block Length(ulong)' 4 bytes data length (uint) " is 138.
Long Statement,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ValueWritingEnd,The length of the statement  "            //    //READ threads will try to get this value by newly received pointer. we have to bind it to the old value which resides in the StorageFile (not in Rollback) " is 161.
Long Statement,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ValueWritingEnd,The length of the statement  "            //                //creating new hash from the newly written pointer and explaining that it must be taken from real DbStorage' so it was completely moved to the new place " is 170.
Long Statement,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ValueWritingEnd,The length of the statement  "            //                    ResidesInRollbackFile = diOld.ResidesInRollbackFile       //Pointer to the old value resides in the storage file " is 134.
Long Statement,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ValueWritingOver,The length of the statement  "            ////OverWriting of a value [used by WRITE FUNC] and Reading Key or Value [used by READ FUNC] must come via one Synchro lock _sync_data " is 134.
Long Statement,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKeyValue,The length of the statement  "            //int initRead = 111; //Where 100 is standard max size of the key in case of words (even 50 must be enough)' in case of sentences can be much longer' probably we can setup it later " is 180.
Long Statement,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKey,The length of the statement  "            int initRead = 111; //Where 100 is standard max size of the key in case of words (even 50 must be enough)' in case of sentences can be much longer' probably we can setup it later " is 178.
Long Statement,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValue,The length of the statement  "            //int initRead = 111; //Where 100 is standard max size of the key in case of words (even 50 must be enough)' in case of sentences can be much longer' probably we can setup it later " is 180.
Long Statement,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValuePartially,The length of the statement  "            int initRead = 111; //Where 100 is standard max size of the key in case of words (even 50 must be enough)' in case of sentences can be much longer' probably we can setup it later " is 178.
Long Statement,DBreeze.LianaTrie,NestedTablesCoordinator,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\NestedTables\NestedTablesCoordinator.cs,CloseTable,The length of the statement  "            //Must close refered nested table and in cascade include tables' for memory efficiency while reading master table with nested tables " is 132.
Long Statement,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,GetTable,The length of the statement  "                    val = row.GetPartialValue(tableIndex * this.Storage.TrieSettings.ROOT_SIZE' this.Storage.TrieSettings.ROOT_SIZE' useCache); " is 123.
Long Statement,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,GetTable,The length of the statement  "                        fullValuePointer = this.AddPartially(ref btKey' ref btValue' tableIndex * this.Storage.TrieSettings.ROOT_SIZE' out valueStartPointer); " is 134.
Long Statement,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,GetTable,The length of the statement  "                            dit = new DataTypes.NestedTableInternal(true' masterTrie' Id_RootStart' (tableIndex * this.Storage.TrieSettings.ROOT_SIZE)' false'this'ref btKey); " is 146.
Long Statement,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,GetTable,The length of the statement  "                            this.NestedTablesCoordinator.AddNestedTable(ref btKey' fullValuePointer.DynamicLength_To_UInt64_BigEndian()' Id_RootStart' dit); " is 128.
Long Statement,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,GetTable,The length of the statement  "                                dit = new DataTypes.NestedTableInternal(true' masterTrie' Id_RootStart' (tableIndex * this.Storage.TrieSettings.ROOT_SIZE)' useCache' this' ref btKey); " is 151.
Long Statement,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,GetTable,The length of the statement  "                                this.NestedTablesCoordinator.AddNestedTable(ref btKey' fullValuePointer.DynamicLength_To_UInt64_BigEndian()' Id_RootStart' dit); " is 128.
Long Statement,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,GetTable,The length of the statement  "                    fullValuePointer = this.AddPartially(ref btKey' ref btValue' tableIndex * this.Storage.TrieSettings.ROOT_SIZE' out valueStartPointer); " is 134.
Long Statement,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,GetTable,The length of the statement  "                        dit = new DataTypes.NestedTableInternal(true' masterTrie' Id_RootStart' (tableIndex * this.Storage.TrieSettings.ROOT_SIZE)' false' this' ref btKey); " is 148.
Long Statement,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,GetTable,The length of the statement  "                        this.NestedTablesCoordinator.AddNestedTable(ref btKey' fullValuePointer.DynamicLength_To_UInt64_BigEndian()' Id_RootStart' dit); " is 128.
Long Statement,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,GetTable,The length of the statement  "                //this.NestedTablesCoordinator.AddNestedTable(ref btKey' fullValuePointer.DynamicLength_To_UInt64_BigEndian()' Id_RootStart' dit); " is 130.
Long Statement,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,AddPartially,The length of the statement  "            //    this.NestedTablesCoordinator.MoveNestedTablesRootStart(ref key' linkToVal.DynamicLength_To_UInt64_BigEndian()' valueStartPtr); " is 132.
Long Statement,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,AddPartially,The length of the statement  "                this.NestedTablesCoordinator.MoveNestedTablesRootStart(ref key' linkToVal.DynamicLength_To_UInt64_BigEndian()' valueStartPtr); " is 126.
Long Statement,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,ChangeKey,The length of the statement  "                        this.NestedTablesCoordinator.ChangeKeyAndMoveNestedTablesRootStart(ref oldKey' ref newKey' row.LinkToValue.DynamicLength_To_UInt64_BigEndian()' row.ValueStartPointer); " is 167.
Long Statement,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,ChangeKey,The length of the statement  "                        this.NestedTablesCoordinator.ChangeKeyAndMoveNestedTablesRootStart(ref oldKey' ref newKey' row.LinkToValue.DynamicLength_To_UInt64_BigEndian()' row.ValueStartPointer); " is 167.
Long Statement,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,ITRRollBack,The length of the statement  "            //This rollback differs from the SingleRollBack' by cleaning in memorey _rootOldCopy' in case if table was already Committed inside of cascade(Transactional) commit " is 164.
Long Statement,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,ReadRootNode,The length of the statement  "            //if (me.Length == 0 || me[0] == 0)   //Support of the memory where field is reserved or DbInTable where initial bytes are filled with 0 " is 136.
Long Statement,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,DeserializeRootNode,The length of the statement  "            //First byte is identifier: 1 if from memory' if 0 from File - under discussion' probably we don't need this logical element. " is 125.
Long Statement,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,SerializeRootNode,The length of the statement  "            byte[] dbreeze = new byte[] { 0x64' 0x62' 0x72' 0x65' 0x65' 0x7A' 0x65' 0x2E' 0x74' 0x69' 0x65' 0x73' 0x6B' 0x79' 0x2E' 0x63' 0x6F' 0x6D }; " is 139.
Long Statement,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,TransactionalRollBack,The length of the statement  "                throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.TRANSACTIONAL_ROLLBACK_FAILED' this.Tree.TableName' ex); " is 121.
Long Statement,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,Save_GM_nodes_Starting_From,The length of the statement  "                //and record them as Key into memory dictionary with value byte[] oldKids' later reader will be able on every iteration point to request these kids from memory " is 159.
Long Statement,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,Save_GM_nodes_Starting_From,The length of the statement  "                    //this.Tree.Cache.AddMapKids(_generationMap.GenerateMapNodesValuesUpToIndex(gmMaxIndex--)' gn.Value.KidsBeforeModification);                  " is 124.
Long Statement,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,AddKey,The length of the statement  "                res = _generationMap[0].SetupKidWithValue((byte)0' true' ref key' ref value' false' out WasUpdated' dontUpdateIfExists); " is 120.
Long Statement,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,AddKey,The length of the statement  "                    //In case if i>0' it's not the first element and we have to compare if there are generation mapsstarting from this point. " is 121.
Long Statement,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,AddKey,The length of the statement  "                        gn.Pointer = new byte[DefaultPointerLen];       //!!!!!!!!!!!!! Check if it'S really necessary or we can leave it as null " is 121.
Long Statement,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,AddKey,The length of the statement  "                //If Kids==0 && Value Link is not Default Empty Pointer' then this value-link refers to the sentence which can go after this last character' so also to the value. " is 162.
Long Statement,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,AddKey,The length of the statement  "                        _generationMap[i].SetupKidWithValue(res.KeyOldKid[i]' false' ref key1' ref val1' true' out WasUpdated' dontUpdateIfExists); " is 123.
Long Statement,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,AddKey,The length of the statement  "                res = _generationMap[i].SetupKidWithValue(((i == key.Length) ? (byte)0 : key[i])' (i == key.Length)' ref key' ref value' false' out WasUpdated' dontUpdateIfExists); " is 164.
Long Statement,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,AddKeyPartially,The length of the statement  "                res = _generationMap[0].SetupKidWithValuePartially((byte)0' true' ref key' ref value' false' startIndex' out valueStartPtr' out WasUpdated); " is 140.
Long Statement,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,AddKeyPartially,The length of the statement  "                    //In case if i>0' it's not the first element and we have to compare if there are generation mapsstarting from this point. " is 121.
Long Statement,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,AddKeyPartially,The length of the statement  "                        gn.Pointer = new byte[DefaultPointerLen];       //!!!!!!!!!!!!! Check if it'S really necessary or we can leave it as null " is 121.
Long Statement,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,AddKeyPartially,The length of the statement  "                //If Kids==0 && Value Link is not Default Empty Pointer' then this value-link refers to the sentence which can go after this last character' so also to the value. " is 162.
Long Statement,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,AddKeyPartially,The length of the statement  "                        _generationMap[i].SetupKidWithValuePartially((byte)0' true' ref key1' ref val1' true' startIndex' out valueStartPtr' out WasUpdated); " is 133.
Long Statement,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,AddKeyPartially,The length of the statement  "                        _generationMap[i].SetupKidWithValuePartially(res.KeyOldKid[i]' false' ref key1' ref val1' true' startIndex' out valueStartPtr' out WasUpdated); " is 143.
Long Statement,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,AddKeyPartially,The length of the statement  "                res = _generationMap[i].SetupKidWithValuePartially(((i == key.Length) ? (byte)0 : key[i])' (i == key.Length)' ref key' ref value' false' startIndex' out valueStartPtr' out WasUpdated); " is 184.
Long Statement,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,ChangeKey,The length of the statement  "            //just changing pointers to the value will give nothing' because in the value also the full key is written' so we will need  " is 123.
Long Statement,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,RemoveKey,The length of the statement  "                    //In case if i>0' it's not the first element and we have to compare if there are generation mapsstarting from this point. " is 121.
Long Statement,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,RemoveKey,The length of the statement  "                        gn.Pointer = new byte[DefaultPointerLen];       //!!!!!!!!!!!!! Check if it'S really necessary or we can leave it as null " is 121.
Long Statement,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,RemoveKey,The length of the statement  "                iterateFurther = _generationMap[i].RemoveKid((i == key.Length) ? (byte)0 : key[i]' (i == key.Length)' ref key' out WasRemoved' retrieveDeletedValue' out deletedValue); " is 167.
Long Statement,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,GetKey,The length of the statement  "                //If kid is a link to next node we iterate further' if link on the value' we retrieve full key and value as link for TreeKVP stoping iteration " is 142.
Long Statement,DBreeze.Storage,Backup,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\Backup.cs,InitBackupFolder,The length of the statement  "                //bmFs = new FileStream(Path.Combine(this._backupFolderName' "DBreezeBM.mg1")' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None' _bufferSize); " is 153.
Long Statement,DBreeze.Storage,Backup,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\Backup.cs,WriteBackupElement,The length of the statement  "            //Console.WriteLine(String.Format("{0}> FN: {1} - {2}; at {3} q {4}"' writeTime.ToString("dd.MM.yyyy HH:mm:ss")' fileNumber' type.ToString()' pos.ToString()'  " is 157.
Long Statement,DBreeze.Storage,Backup,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\Backup.cs,GetFileStream,The length of the statement  "                //fs = new FileStream(fullBackupFileName' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None'_bufferSize'FileOptions.WriteThrough); " is 140.
Long Statement,DBreeze.Storage,Backup,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\Backup.cs,GetFileStream,The length of the statement  "                fs = new FileStream(fullBackupFileName' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None' _bufferSize'FileOptions.WriteThrough); " is 139.
Long Statement,DBreeze.Storage,Backup,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\Backup.cs,GetFileStream,The length of the statement  "                    //fs = new FileStream(fullBackupFileName' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None' _bufferSize' FileOptions.WriteThrough); " is 142.
Long Statement,DBreeze.Storage,Backup,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\Backup.cs,GetFileStream,The length of the statement  "                    fs = new FileStream(fullBackupFileName' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None' _bufferSize' FileOptions.WriteThrough); " is 140.
Long Statement,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,DoPackage,The length of the statement  "            // 0 - table file' 1 - rollback file' 2 - rollbackhelper' 3 - recreate table file (only table file)' 4 - recreate rollback file (only rollback file)' 5 - removing complete table " is 177.
Long Statement,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,InitFiles,The length of the statement  "                this._fsData = new FileStream(this._fileName' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None' _fileStreamBufferSize' FileOptions.WriteThrough); " is 156.
Long Statement,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,InitFiles,The length of the statement  "                this._fsRollback = new FileStream(this._fileName + ".rol"' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None' _fileStreamBufferSize' FileOptions.WriteThrough); " is 169.
Long Statement,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,InitFiles,The length of the statement  "                this._fsRollbackHelper = new FileStream(this._fileName + ".rhp"' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None' _fileStreamBufferSize' FileOptions.WriteThrough); " is 175.
Long Statement,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,InitFiles,The length of the statement  "                throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DB_IS_NOT_OPERABLE' "FSR INIT FAILED: " + this._fileName' ex); " is 127.
Long Statement,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,InitRollback,The length of the statement  "                    this._fsRollback = new FileStream(this._fileName + ".rol"' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None' _fileStreamBufferSize' FileOptions.WriteThrough); " is 169.
Long Statement,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,InitRollback,The length of the statement  "                this._fsRollback = new FileStream(this._fileName + ".rol"' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None' _fileStreamBufferSize' FileOptions.WriteThrough); " is 169.
Long Statement,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,InitRollback,The length of the statement  "            //    throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.RESTORE_ROLLBACK_DATA_FAILED' this._fileName' ex); " is 121.
Long Statement,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,DoProtocol1,The length of the statement  "            //Protocol: type of Rollback record - 1 byte; Offset - size is trie.Storage.TreeSettings.POINTER_LENGTH (Default pointer length); data length - 4 bytes; data " is 157.
Long Statement,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,DoProtocol1,The length of the statement  "            //If full value cant be read we can think that this part of protocol is corrupted and definitely not written to the original file' " is 130.
Long Statement,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,DoProtocol1,The length of the statement  "                //Console.WriteLine("Of: {0}; DL: {1}"' offset.ToBytesString("")' data.Length.To_4_bytes_array_BigEndian().ToBytesString("")); " is 126.
Long Statement,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,Table_WriteByOffset,The length of the statement  "            //!! This is a cutted implementation for DBreeze we dont take care buffer elements overlapping (start+len U some elements -> should be not possible) " is 148.
Long Statement,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,Table_WriteByOffset,The length of the statement  "                    //We put data to the buffer first and flush it if buffer > allowed space. We dont take care if data is bigger then buffer. " is 122.
Long Statement,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,Table_Read,The length of the statement  "                        var qkvp = _randBuf.OrderByDescending(r => r.Key).Where(r => r.Key < offset).Take(1).Where(r => (r.Key + r.Value.Length - 1) >= offset); " is 136.
Long Statement,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,Table_Read,The length of the statement  "                        var qkvp = _rollbackCache.OrderByDescending(r => r.Key).Where(r => r.Key < offset).Take(1).Where(r => (r.Key + r.Value.l - 1) >= offset); " is 137.
Long Statement,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,Table_Read,The length of the statement  "                         * Transaction with minimum 2 tables. T2 is inserted' reference to T2 KVP is taken' then this reference is saved into T1. " is 120.
Long Statement,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,Table_Read,The length of the statement  "                         * then Commit procedure for each table calls TransactionalCommitIsFinished (this proc will clear rollback refs and moves eofData for every table). " is 146.
Long Statement,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,Table_Read,The length of the statement  "                         * To avoid such specific case we use for calculation this._fsData.Length instead of eofData in case if (eofData < offset && TransactionalCommitIsStarted)             " is 153.
Long Statement,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,InitFiles,The length of the statement  "                throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DB_IS_NOT_OPERABLE' "MSR INIT FAILED: " + this._fileName' ex); " is 127.
Long Statement,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,Table_WriteByOffset,The length of the statement  "            //!! This is a cutted implementation for DBreeze we dont take care buffer elements overlapping (start+len U some elements -> should be not possible) " is 148.
Long Statement,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,Table_WriteByOffset,The length of the statement  "                    //We put data to the buffer first and flush it if buffer > allowed space. We dont take care if data is bigger then buffer. " is 122.
Long Statement,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,FlushRandomBuffer,The length of the statement  "                _rollbackCache.Add(de.Key' new r { o = eofRollback + 1 + offset.Length + 4' l = de.Value.Length });  //10 is size of protocol data " is 130.
Long Statement,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,Table_Read,The length of the statement  "                        var qkvp = _randBuf.OrderByDescending(r => r.Key).Where(r => r.Key < offset).Take(1).Where(r => (r.Key + r.Value.Length - 1) >= offset); " is 136.
Long Statement,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,Table_Read,The length of the statement  "                        var qkvp = _rollbackCache.OrderByDescending(r => r.Key).Where(r => r.Key < offset).Take(1).Where(r => (r.Key + r.Value.l - 1) >= offset); " is 137.
Long Statement,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,Table_Read,The length of the statement  "                         * Transaction with minimum 2 tables. T2 is inserted' reference to T2 KVP is taken' then this reference is saved into T1. " is 120.
Long Statement,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,Table_Read,The length of the statement  "                         * then Commit procedure for each table calls TransactionalCommitIsFinished (this proc will clear rollback refs and moves eofData for every table). " is 146.
Long Statement,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,Table_Read,The length of the statement  "                         * To avoid such specific case we use for calculation this._fsData.Length instead of eofData in case if (eofData < offset && TransactionalCommitIsStarted)             " is 153.
Long Statement,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,InitFiles,The length of the statement  "                //this._fsData = new FileStream(this._fileName' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None' _fileStreamBufferSize' FileOptions.WriteThrough); " is 158.
Long Statement,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,InitFiles,The length of the statement  "                //this._fsRollback = new FileStream(this._fileName + ".rol"' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None' _fileStreamBufferSize' FileOptions.WriteThrough); " is 171.
Long Statement,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,InitFiles,The length of the statement  "                //this._fsRollbackHelper = new FileStream(this._fileName + ".rhp"' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None' _fileStreamBufferSize' FileOptions.WriteThrough); " is 177.
Long Statement,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,InitFiles,The length of the statement  "                throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DB_IS_NOT_OPERABLE' "RISR INIT FAILED: " + this._fileName' ex); " is 128.
Long Statement,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,InitRollback,The length of the statement  "                    //this._fsRollback = new FileStream(this._fileName + ".rol"' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None' _fileStreamBufferSize' FileOptions.WriteThrough); " is 171.
Long Statement,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,InitRollback,The length of the statement  "                //this._fsRollback = new FileStream(this._fileName + ".rol"' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None' _fileStreamBufferSize' FileOptions.WriteThrough); " is 171.
Long Statement,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,DoProtocol1,The length of the statement  "            //Protocol: type of Rollback record - 1 byte; Offset - size is trie.Storage.TreeSettings.POINTER_LENGTH (Default pointer length); data length - 4 bytes; data " is 157.
Long Statement,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,DoProtocol1,The length of the statement  "            //If full value cant be read we can think that this part of protocol is corrupted and definitely not written to the original file' " is 130.
Long Statement,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,DoProtocol1,The length of the statement  "                //Console.WriteLine("Of: {0}; DL: {1}"' offset.ToBytesString("")' data.Length.To_4_bytes_array_BigEndian().ToBytesString("")); " is 126.
Long Statement,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,Table_WriteByOffset,The length of the statement  "            //!! This is a cutted implementation for DBreeze we dont take care buffer elements overlapping (start+len U some elements -> should be not possible) " is 148.
Long Statement,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,Table_WriteByOffset,The length of the statement  "                    //We put data to the buffer first and flush it if buffer > allowed space. We dont take care if data is bigger then buffer. " is 122.
Long Statement,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,Table_Read,The length of the statement  "                        var qkvp = _randBuf.OrderByDescending(r => r.Key).Where(r => r.Key < offset).Take(1).Where(r => (r.Key + r.Value.Length - 1) >= offset); " is 136.
Long Statement,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,Table_Read,The length of the statement  "                        var qkvp = _rollbackCache.OrderByDescending(r => r.Key).Where(r => r.Key < offset).Take(1).Where(r => (r.Key + r.Value.l - 1) >= offset); " is 137.
Long Statement,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,Table_Read,The length of the statement  "                         * Transaction with minimum 2 tables. T2 is inserted' reference to T2 KVP is taken' then this reference is saved into T1. " is 120.
Long Statement,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,Table_Read,The length of the statement  "                         * then Commit procedure for each table calls TransactionalCommitIsFinished (this proc will clear rollback refs and moves eofData for every table). " is 146.
Long Statement,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,Table_Read,The length of the statement  "                         * To avoid such specific case we use for calculation this._fsData.Length instead of eofData in case if (eofData < offset && TransactionalCommitIsStarted)             " is 153.
Long Statement,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,RollbackHelperFileWrite,The length of the statement  "                throw new Exception("DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.RollbackHelperFileWrite: remote exception"); " is 120.
Long Statement,DBreeze.Storage.RemoteInstance,RemoteTable,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTable.cs,OpenRemoteTable,The length of the statement  "                    this._fsData = new FileStream(this._fileName' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None' _fileStreamBufferSize' FileOptions.WriteThrough); " is 156.
Long Statement,DBreeze.Storage.RemoteInstance,RemoteTable,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTable.cs,OpenRemoteTable,The length of the statement  "                    this._fsRollback = new FileStream(this._fileName + ".rol"' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None' _fileStreamBufferSize' FileOptions.WriteThrough); " is 169.
Long Statement,DBreeze.Storage.RemoteInstance,RemoteTable,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTable.cs,OpenRemoteTable,The length of the statement  "                    this._fsRollbackHelper = new FileStream(this._fileName + ".rhp"' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None' _fileStreamBufferSize' FileOptions.WriteThrough); " is 175.
Long Statement,DBreeze.Storage.RemoteInstance,RemoteTable,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTable.cs,RollbackFileRecreate,The length of the statement  "                this._fsRollback = new FileStream(this._fileName + ".rol"' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None' _fileStreamBufferSize' FileOptions.WriteThrough); " is 169.
Long Statement,DBreeze.Transactions,TransactionsCoordinator,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Transactions\TransactionsCoordinator.cs,GetTransaction,The length of the statement  "            //Transaction must have 2 classes one class is for the user' with appropriate methods' second for technical purposes TransactionDetails' where we store different transaction information " is 185.
Long Statement,DBreeze.Transactions,TransactionsCoordinator,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Transactions\TransactionsCoordinator.cs,RegisterWriteTablesForTransaction,The length of the statement  "                                    //++++++++++++++ if thread' who has locked this table has another table in a "waiting for reservation" blocked by this thread - it's a deadlock                                     " is 143.
Long Statement,DBreeze.Transactions,TransactionsCoordinator,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Transactions\TransactionsCoordinator.cs,RegisterWriteTablesForTransaction,The length of the statement  "                                    //if (transactionUnit.GetTransactionWriteTablesNames().Intersect(tu.Value.GetTransactionWriteTablesAwaitingReservation()).Count() > 0) " is 134.
Long Statement,DBreeze.Transactions,TransactionsCoordinator,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Transactions\TransactionsCoordinator.cs,RegisterWriteTablesForTransaction,The length of the statement  "                                    if (DbUserTables.TableNamesIntersect(transactionUnit.GetTransactionWriteTablesNames()'tu.Value.GetTransactionWriteTablesAwaitingReservation())) " is 143.
Long Statement,DBreeze.Transactions,TransactionsCoordinator,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Transactions\TransactionsCoordinator.cs,RegisterWriteTablesForTransaction,The length of the statement  "                    //ThreadsGator.PutGateHere(20000);    //every 20 second (or by Gate open we give a chance to re-try' for safety reasons of hanged threads' if programmer didn't dispose DBreeze process after the programm end) " is 207.
Long Statement,DBreeze.Transactions,TransactionsCoordinator,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Transactions\TransactionsCoordinator.cs,Commit,The length of the statement  "                throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DB_IS_NOT_OPERABLE'this._engine.DBisOperableReason'new Exception()); " is 133.
Long Statement,DBreeze.Transactions,TransactionsCoordinator,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Transactions\TransactionsCoordinator.cs,Commit,The length of the statement  "                     //Here we appear if all tables were succesfully commited (but it's not visible still for READING THREDS and all tables still have their rollback files active) " is 158.
Long Statement,DBreeze.Transactions,TransactionsJournal,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Transactions\TransactionsJournal.cs,RestoreNotFinishedTransactions,The length of the statement  "                //Settigns and storage for Committed tables !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   MUST BE TAKEN FROM SCHEMA' FOR NOW DEFAULT " is 128.
Long Statement,DBreeze.Transactions,TransactionsJournal,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Transactions\TransactionsJournal.cs,RestoreNotFinishedTransactions,The length of the statement  "                throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.CLEAN_ROLLBACK_FILES_FOR_FINISHED_TRANSACTIONS_FAILED); " is 120.
Long Statement,DBreeze.Transactions,TransactionUnit,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Transactions\TransactionUnit.cs,Dispose,The length of the statement  "                _transactionWriteTablesAwaitingReservation.Clear(); //holds tables with awaiting reservation' means that transaction thread is blocked " is 134.
Long Statement,DBreeze.Transactions,TransactionUnit,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Transactions\TransactionUnit.cs,If_TableIsReservedForWrite,The length of the statement  "                //var kvp = _transactionWriteTables.Where(r => r.Key.Equals(tableName' StringComparison.OrdinalIgnoreCase)).FirstOrDefault(); " is 125.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,SynchronizeTables,The length of the statement  "            this._transactionUnit.TransactionsCoordinator.RegisterWriteTablesForTransaction(this.ManagedThreadId' correctedPatterns'true); " is 126.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,CheckIfTransactionHasTablesRegisteredForWrite,The length of the statement  "                throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.TRANSACTION_TABLES_RESERVATION_CANBEDONE_ONCE' new Exception()); " is 129.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,CheckIfTransactionHasTablesRegisteredForWrite,The length of the statement  "                throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.TRANSACTION_TABLES_RESERVATION_LIST_MUSTBEFILLED' new Exception()); " is 132.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,CheckIfTransactionHasTablesRegisteredForWrite,The length of the statement  "                throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.TRANSACTION_TABLES_RESERVATION_FAILED' new Exception()); " is 121.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,GetWriteTableFromBuffer,The length of the statement  "                    throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DB_IS_NOT_OPERABLE' this._transactionUnit.TransactionsCoordinator.GetSchema.Engine.DBisOperableReason'new Exception()); " is 184.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,GetReadTableFromBuffer,The length of the statement  "            ////In discussion' if we need to compare threadsIds' normally transaction can be used only from one thread' but it will be checked " is 130.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,GetReadTableFromBuffer,The length of the statement  "            //In discussion' if we need to compare threadsIds' normally transaction can be used only from one thread' but it will be checked " is 128.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,GetReadTableFromBuffer,The length of the statement  "            //Parallel read queries inside of one transaction' to use in TPL in manner Task.WaitAll(Task.Run(() => tran.Select...'Task.Run(() => tran.Select...'...); " is 153.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,GetReadTableFromBuffer,The length of the statement  "                table = this._transactionUnit.TransactionsCoordinator.GetTable_READ(tableName' this.ManagedThreadId' ignoreThreadIdCheck: ignoreThreadIdCheck); " is 143.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,ObjectGetNewIdentity,The length of the statement  "                throw new Exception("DBreeze.Transaction.ObjectGetNewIdentity: not acceptable identity type. (Only (long'ulong'int'uint'short'ushort))"); " is 137.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,InsertTable,The length of the statement  "            var nt = table.GetTable(row'ref btKey' tableIndex' null' true' false); //<-masterTrie argument equals to null in case if it is a first level of nested tables " is 157.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,InsertTable,The length of the statement  "            //return table.InsertTable(btKey' tableIndex'null); //<-masterTrie argument equals to null in case if it is a first level of nested tables " is 138.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,SelectTable,The length of the statement  "                 * (readRoot == null) ? WRITING TABLE TRANSACTION' doesn't use cache for getting value : READING TABLE TRANSACTION' always uses value via cache " is 142.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,SelectDictionary,The length of the statement  "            foreach (var row in this.SelectTable<TTableKey>(tableName' key' tableIndex).SelectForward<TDictionaryKey' TDictionaryValue>()) " is 126.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,Max,The length of the statement  "                 * (readRoot == null) ? WRITING TABLE TRANSACTION' doesn't use cache for getting value : READING TABLE TRANSACTION' always uses value via cache " is 142.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,Min,The length of the statement  "                 * (readRoot == null) ? WRITING TABLE TRANSACTION' doesn't use cache for getting value : READING TABLE TRANSACTION' always uses value via cache " is 142.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,TextInsert,The length of the statement  "            tsh.InsertDocumentText(this' tableName' documentId' containsWords' fullMatchWords' deferredIndexing' containsMinimalLength' TextSearchHandler.eInsertMode.Insert); " is 162.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,TextAppend,The length of the statement  "            tsh.InsertDocumentText(this' tableName' documentId' containsWords' fullMatchWords' deferredIndexing' containsMinimalLength' TextSearchHandler.eInsertMode.Append); " is 162.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,TextRemove,The length of the statement  "            tsh.InsertDocumentText(this' tableName' documentId' ""' fullMatchWords' deferredIndexing' containsMinimalLength' TextSearchHandler.eInsertMode.Remove); " is 151.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,TextRemoveAll,The length of the statement  "            tsh.InsertDocumentText(this' tableName' documentId' String.Empty'String.Empty' deferredIndexing'3' TextSearchHandler.eInsertMode.Insert); " is 137.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,Select,The length of the statement  "                 * (readRoot == null) ? WRITING TABLE TRANSACTION' doesn't use cache for getting value : READING TABLE TRANSACTION' always uses value via cache " is 142.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,SelectDirect,The length of the statement  "                refToInsertedValue = refToInsertedValue.RemoveLeadingElement(0).EnlargeByteArray_BigEndian(table.Storage.TrieSettings.POINTER_LENGTH); " is 134.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,SelectDirect,The length of the statement  "                table.Cache.ReadKeyValue(!(readRoot == null)' refToInsertedValue' out valueStartPtr' out ValueLength' out xKey' out xValue); " is 124.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,SelectForwardFromTo,The length of the statement  "                foreach (var xrow in table.IterateForwardFromTo(btStartKey' btStopKey' includeStartKey' includeStopKey' readRoot' this._valuesLazyLoadingIsOn)) " is 143.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,SelectBackwardFromTo,The length of the statement  "                foreach (var xrow in table.IterateBackwardFromTo(btStartKey' btStopKey' includeStartKey' includeStopKey' readRoot' this._valuesLazyLoadingIsOn)) " is 144.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,SelectForwardStartsWithClosestToPrefix,The length of the statement  "                foreach (var xrow in table.IterateForwardStartsWithClosestToPrefix(btStartWithKeyPart' readRoot' this._valuesLazyLoadingIsOn)) " is 126.
Long Statement,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,SelectBackwardStartsWithClosestToPrefix,The length of the statement  "                foreach (var xrow in table.IterateBackwardStartsWithClosestToPrefix(btStartWithKeyPart' readRoot' this._valuesLazyLoadingIsOn)) " is 127.
Long Statement,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Encode_DICT_PROTO_UINT_BYTEARRAY,The length of the statement  "                tar = el.Value == null ? new byte[] { 0 } : GetVarintBytes((uint)el.Value.Length); //Supporting 0 length' will be null then " is 123.
Long Statement,DBreeze.Utils,Filter<T>,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BloomFilter.cs,bestErrorRate,The length of the statement  "                    return (float)Math.Pow(0.6185' int.MaxValue / capacity); // http://www.cs.princeton.edu/courses/archive/spring02/cs493/lec7.pdf " is 127.
Long Statement,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_DateTime_NULL,The length of the statement  "            return new DateTime((long)(new byte[] { value[1]' value[2]' value[3]' value[4]' value[5]' value[6]' value[7]' value[8] }.To_UInt64_BigEndian())); " is 145.
Long Statement,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int64_BigEndian_NULL,The length of the statement  "            return (long?)((new byte[] { value[1]' value[2]' value[3]' value[4]' value[5]' value[6]' value[7]' value[8] }).To_UInt64_BigEndian() - (ulong)Math.Abs(long.MinValue + 1) - 1); " is 175.
Long Statement,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int64_LittleEndian_NULL,The length of the statement  "            return (long?)((new byte[] { value[1]' value[2]' value[3]' value[4]' value[5]' value[6]' value[7]' value[8]}).To_UInt64_LittleEndian() - (ulong)Math.Abs(long.MinValue + 1) - 1); " is 177.
Long Statement,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian,The length of the statement  "            return (ulong)(((ulong)value[0] << 56) + ((ulong)value[1] << 48) + ((ulong)value[2] << 40) + ((ulong)value[3] << 32) + ((ulong)value[4] << 24) + ((ulong)value[5] << 16) + ((ulong)value[6] << 8) + (ulong)value[7]); " is 213.
Long Statement,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian,The length of the statement  "            return (ulong)(((ulong)value[7] << 56) + ((ulong)value[6] << 48) + ((ulong)value[5] << 40) + ((ulong)value[4] << 32) + ((ulong)value[3] << 24) + ((ulong)value[2] << 16) + ((ulong)value[1] << 8) + (ulong)value[0]); " is 213.
Long Statement,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian_NULL,The length of the statement  "            return (ulong)(((ulong)value[1] << 56) + ((ulong)value[2] << 48) + ((ulong)value[3] << 40) + ((ulong)value[4] << 32) + ((ulong)value[5] << 24) + ((ulong)value[6] << 16) + ((ulong)value[7] << 8) + (ulong)value[8]); " is 213.
Long Statement,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian_NULL,The length of the statement  "            return (ulong)(((ulong)value[8] << 56) + ((ulong)value[7] << 48) + ((ulong)value[6] << 40) + ((ulong)value[5] << 32) + ((ulong)value[4] << 24) + ((ulong)value[3] << 16) + ((ulong)value[2] << 8) + (ulong)value[1]); " is 213.
Long Statement,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian,The length of the statement  "            ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]); " is 275.
Long Statement,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian,The length of the statement  "            double.TryParse(resultDouble' System.Globalization.NumberStyles.Any' System.Globalization.CultureInfo.InvariantCulture' out result); " is 132.
Long Statement,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian_NULL,The length of the statement  "            ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]); " is 275.
Long Statement,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian_NULL,The length of the statement  "            double.TryParse(resultDouble' System.Globalization.NumberStyles.Any' System.Globalization.CultureInfo.InvariantCulture' out result); " is 132.
Long Statement,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Float_BigEndian,The length of the statement  "            float.TryParse(resultFloat' System.Globalization.NumberStyles.Any' System.Globalization.CultureInfo.InvariantCulture' out result); " is 130.
Long Statement,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Float_BigEndian_NULL,The length of the statement  "            float.TryParse(resultFloat' System.Globalization.NumberStyles.Any' System.Globalization.CultureInfo.InvariantCulture' out result); " is 130.
Long Statement,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_ByteArrayEquals,The length of the statement  "            if (b1 == b2) return true;      //if both arrays are null returns true' if byte arrays have same content returns false' cause checking instances " is 144.
Long Statement,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_ByteArrayEquals_EqualityBrokenIndex,The length of the statement  "            // if (b1 == b2) return -1;      //if both arrays are null returns true' if byte arrays have same content returns false' cause checking instances " is 145.
Long Statement,DBreeze.Utils,StringProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\StringProcessing.cs,ReplaceMultiple,The length of the statement  "            var regex = new System.Text.RegularExpressions.Regex(String.Join("|"' replaceWith.Keys.Select(k => System.Text.RegularExpressions.Regex.Escape(k)))); " is 149.
Long Statement,DBreeze.Utils,XmlSerializator,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\XmlSerializator.cs,SerializeXml,The length of the statement  "            //System.Xml.Serialization.XmlSerializer xs = new System.Xml.Serialization.XmlSerializer(objectForSerialization.GetType()); " is 123.
Long Statement,DBreeze.TextSearch,SBlock,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\SBlock.cs,CreateBlock,The length of the statement  "            if (ignoreOnEmptyParameters && String.IsNullOrEmpty(block._fullMatchWords) && String.IsNullOrEmpty(block._containsWords)) " is 121.
Long Statement,DBreeze.TextSearch,SBlock,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\SBlock.cs,CreateBlock,The length of the statement  "                this._tsm.WordsPrepare(block._fullMatchWords.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries).Where(r => r.Length > 2)' true' ref block.ParsedWords); " is 165.
Long Statement,DBreeze.TextSearch,SBlock,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\SBlock.cs,CreateBlock,The length of the statement  "                this._tsm.WordsPrepare(block._containsWords.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries).Where(r => r.Length > 2)' false' ref block.ParsedWords); " is 165.
Long Statement,DBreeze.TextSearch,SBlock,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\SBlock.cs,And,The length of the statement  "                return this.CreateBlock(blockAnd ? (SBlock)(new BlockAnd(containsWords' fullMatchWords)) : (new BlockOr(containsWords' fullMatchWords))'  " is 136.
Long Statement,DBreeze.TextSearch,SBlock,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\SBlock.cs,And,The length of the statement  "            return this.CreateBlock(blockAnd ? (SBlock)(new BlockAnd(containsWords' fullMatchWords)) : (new BlockOr(containsWords' fullMatchWords))'  " is 136.
Long Statement,DBreeze.TextSearch,SBlock,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\SBlock.cs,Or,The length of the statement  "            return this.CreateBlock(blockAnd ? (SBlock)(new BlockAnd(containsWords' fullMatchWords)) : (new BlockOr(containsWords' fullMatchWords))'  " is 136.
Long Statement,DBreeze.TextSearch,SBlock,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\SBlock.cs,Xor,The length of the statement  "                return this.CreateBlock(blockAnd ? (SBlock)(new BlockAnd(containsWords' fullMatchWords)) : (new BlockOr(containsWords' fullMatchWords))' " is 136.
Long Statement,DBreeze.TextSearch,SBlock,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\SBlock.cs,Xor,The length of the statement  "            return this.CreateBlock(blockAnd ? (SBlock)(new BlockAnd(containsWords' fullMatchWords)) : (new BlockOr(containsWords' fullMatchWords))'  " is 136.
Long Statement,DBreeze.TextSearch,SBlock,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\SBlock.cs,Exclude,The length of the statement  "                return this.CreateBlock(blockAnd ? (SBlock)(new BlockAnd(containsWords' fullMatchWords)) : (new BlockOr(containsWords' fullMatchWords))' " is 136.
Long Statement,DBreeze.TextSearch,SBlock,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\SBlock.cs,Exclude,The length of the statement  "            return this.CreateBlock(blockAnd ? (SBlock)(new BlockAnd(containsWords' fullMatchWords)) : (new BlockOr(containsWords' fullMatchWords))'  " is 136.
Long Statement,DBreeze.TextSearch,TextDeferredIndexer,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextDeferredIndexer.cs,Add,The length of the statement  "                var bt = DBreeze.Utils.Biser.Encode_DICT_PROTO_STRING_UINTHASHSET(defferedDocIds' Compression.eCompressionMethod.NoCompression);                 " is 128.
Long Statement,DBreeze.TextSearch,TextDeferredIndexer,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextDeferredIndexer.cs,Indexer,The length of the statement  "            Dictionary<byte[]' Dictionary<string' HashSet<uint>>> defTasks = new Dictionary<byte[]' Dictionary<string' HashSet<uint>>>(); " is 125.
Long Statement,DBreeze.TextSearch,TextDeferredIndexer,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextDeferredIndexer.cs,Indexer,The length of the statement  "                        DBreeze.Utils.Biser.Decode_DICT_PROTO_STRING_UINTHASHSET(row.GetFullValue(true)' defTask' Compression.eCompressionMethod.NoCompression);                         " is 136.
Long Statement,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,GetDocumentsSearchables,The length of the statement  "                    byte[] oldSrch = its.srch.Select<byte[]' byte[]>(r1.Value.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value; " is 125.
Long Statement,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,InsertDocumentText,The length of the statement  "            if ((iMode == eInsertMode.Append || iMode == eInsertMode.Remove) && (String.IsNullOrEmpty(containsWords) && String.IsNullOrEmpty(fullMatchWords))) " is 146.
Long Statement,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,InsertDocumentText,The length of the statement  "            SortedDictionary<string' WordDefinition> pST = this.GetWordsDefinitionFromText(containsWords' fullMatchWords' containsMinimalLength' " is 132.
Long Statement,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,InsertDocumentText,The length of the statement  "                tran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MaximalWordSize); //flattend searchables " is 125.
Long Statement,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,InsertDocumentText,The length of the statement  "                byte[] oldSrch = its.srch.Select<byte[]' byte[]>(iId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value; " is 120.
Long Statement,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,InsertDocumentText,The length of the statement  "            its.srch.Insert<byte[]' byte[]>(iId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' GetByteArrayFromSearchbles(sbPs.ToString())); " is 136.
Long Statement,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The length of the statement  "                //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added " is 137.
Long Statement,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The length of the statement  "                Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>(); " is 143.
Long Statement,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The length of the statement  "                            if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block " is 170.
Long Statement,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The length of the statement  "                            // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian())); " is 137.
Long Statement,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The length of the statement  "                                // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian())); " is 137.
Long Statement,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The length of the statement  "                    //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables  " is 141.
Long Statement,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The length of the statement  "                    //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })); " is 151.
Long Statement,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The length of the statement  "                                if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv " is 159.
Long Statement,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The length of the statement  "                                    tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes]; " is 128.
Long Statement,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The length of the statement  "                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve " is 160.
Long Statement,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The length of the statement  "                        tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes]; " is 128.
Long Statement,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,GetWordsDefinitionFromText,The length of the statement  "                foreach (var nswrd in fullMatchWords.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries).Where(r => r.Length >= containsMinimalLength)) " is 148.
Long Statement,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,Block,The length of the statement  "            return blockAnd ? BlockAnd(containsWords' fullMatchWords' ignoreOnEmptyParameters) : BlockOr(containsWords' fullMatchWords' ignoreOnEmptyParameters); " is 149.
Long Statement,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,BlockAnd,The length of the statement  "            this.WordsPrepare(fullMatchWords.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries).Where(r => r.Length > 2)' true' ref sb.ParsedWords); " is 150.
Long Statement,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,BlockAnd,The length of the statement  "            this.WordsPrepare(containsWords.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries).Where(r => r.Length > 2)' false' ref sb.ParsedWords); " is 150.
Long Statement,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,BlockOr,The length of the statement  "            this.WordsPrepare(fullMatchWords.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries).Where(r => r.Length > 2)' true' ref sb.ParsedWords); " is 150.
Long Statement,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,BlockOr,The length of the statement  "            this.WordsPrepare(containsWords.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries).Where(r => r.Length > 2)' false' ref sb.ParsedWords); " is 150.
Long Statement,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,GetCompressedByteArray,The length of the statement  "            //Compression is currently off' cause the whole dataBlock will be compressed and while searching we don't need to decompress every found word's WAH again " is 153.
Complex Conditional,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,AddKey,The conditional expression  "cleanCheck && i != 0 && _generationMap.ContainsKey(i) && _generationMap[i].Value != key[i - 1]"  is complex.
Complex Conditional,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,AddKeyPartially,The conditional expression  "cleanCheck && i != 0 && _generationMap.ContainsKey(i) && _generationMap[i].Value != key[i - 1]"  is complex.
Complex Conditional,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,RemoveKey,The conditional expression  "cleanCheck && i != 0 && _generationMap.ContainsKey(i) && _generationMap[i].Value != key[i - 1]"  is complex.
Complex Conditional,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,GetKey,The conditional expression  "cleanCheck && i != 0 && _generationMap.ContainsKey(i) && _generationMap[i].Value != key[i - 1]"  is complex.
Complex Conditional,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,ObjectInsert,The conditional expression  "!toInsert.NewEntity && toInsert.ptrToExisingEntity == null && primary == null && idx.IndexNoPrefix != null"  is complex.
Complex Conditional,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,IndexOfByteArray,The conditional expression  "ar == null || search == null || ar.Length == 0 || search.Length == 0"  is complex.
Complex Conditional,DBreeze.TextSearch,SBlock,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\SBlock.cs,GetArrays,The conditional expression  "la == null || ra == null || la.Count == 0 || ra.Count == 0"  is complex.
Complex Conditional,DBreeze.TextSearch,SBlock,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\SBlock.cs,GetArrays,The conditional expression  "la == null || ra == null || la.Count == 0 || ra.Count == 0"  is complex.
Complex Conditional,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,InsertDocumentText,The conditional expression  "(iMode == eInsertMode.Append || iMode == eInsertMode.Remove) && (String.IsNullOrEmpty(containsWords) && String.IsNullOrEmpty(fullMatchWords))"  is complex.
Complex Conditional,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,BlockAnd,The conditional expression  "(containsWords == null || containsWords.Count() == 0 || containsWords.Where(r=>r.Trim().Length > 0).Count() < 1)                      &&                     (fullMatchWords == null || fullMatchWords.Count() == 0 || fullMatchWords.Where(r => r.Trim().Length > 0).Count() < 1)"  is complex.
Complex Conditional,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,BlockOr,The conditional expression  "(containsWords == null || containsWords.Count() == 0 || containsWords.Where(r => r.Trim().Length > 0).Count() < 1)                      &&                     (fullMatchWords == null || fullMatchWords.Count() == 0 || fullMatchWords.Where(r => r.Trim().Length > 0).Count() < 1)"  is complex.
Empty Catch Block,DBreeze,DBreezeEngine,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Engine\DBreezeEngine.cs,BackgroundNotify,The method has an empty catch block.
Empty Catch Block,DBreeze,TransactionTablesLocker,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Transactions\TransactionTablesLocker.cs,RemoveSession,The method has an empty catch block.
Empty Catch Block,DBreeze,DBreezeResources,C:\repos\hhblaze_DBreeze\DBreeze\Engine\DBreezeResources.cs,SelectStartsWith,The method has an empty catch block.
Empty Catch Block,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,Dispose,The method has an empty catch block.
Empty Catch Block,DBreeze.LianaTrie,LTrie,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LianaTrie.cs,Dispose,The method has an empty catch block.
Empty Catch Block,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,GetWordsDefinitionFromText,The method has an empty catch block.
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,DataAsTree,The following statement contains a magic number: if (name.To_UTF8Bytes().Length > 256)                  throw new Exception("Node name can't be more then 256");
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,SetupReadTables,The following statement contains a magic number: if (this.RootNode.nt2Read == null)              {                  this.RootNode.nt2Read = this.RootNode.Transaction.SelectTable(this.RootNode.DBreezeTableName' new byte[] { 2 }' 0);                  this.RootNode.nt2Read.ValuesLazyLoadingIsOn = false;                  this.RootNode.nt3Read = this.RootNode.Transaction.SelectTable(this.RootNode.DBreezeTableName' new byte[] { 3 }' 0);                  this.RootNode.nt3Read.ValuesLazyLoadingIsOn = false;              }
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,SetupReadTables,The following statement contains a magic number: if (this.RootNode.nt2Read == null)              {                  this.RootNode.nt2Read = this.RootNode.Transaction.SelectTable(this.RootNode.DBreezeTableName' new byte[] { 2 }' 0);                  this.RootNode.nt2Read.ValuesLazyLoadingIsOn = false;                  this.RootNode.nt3Read = this.RootNode.Transaction.SelectTable(this.RootNode.DBreezeTableName' new byte[] { 3 }' 0);                  this.RootNode.nt3Read.ValuesLazyLoadingIsOn = false;              }
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,SetupWriteTables,The following statement contains a magic number: if (this.RootNode.nt2Write == null)              {                  //under new byte[] { 1 }  we store Id of the entity(long)                  this.RootNode.nt2Write = this.RootNode.Transaction.InsertTable(this.RootNode.DBreezeTableName' new byte[] { 2 }' 0);  //here is a structure table                    this.RootNode.nt2Write.ValuesLazyLoadingIsOn = false;                  this.RootNode.nt3Write = this.RootNode.Transaction.InsertTable(this.RootNode.DBreezeTableName' new byte[] { 3 }' 0);  //here is a search by NodeName table                  this.RootNode.nt3Write.ValuesLazyLoadingIsOn = false;              }
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,SetupWriteTables,The following statement contains a magic number: if (this.RootNode.nt2Write == null)              {                  //under new byte[] { 1 }  we store Id of the entity(long)                  this.RootNode.nt2Write = this.RootNode.Transaction.InsertTable(this.RootNode.DBreezeTableName' new byte[] { 2 }' 0);  //here is a structure table                    this.RootNode.nt2Write.ValuesLazyLoadingIsOn = false;                  this.RootNode.nt3Write = this.RootNode.Transaction.InsertTable(this.RootNode.DBreezeTableName' new byte[] { 3 }' 0);  //here is a search by NodeName table                  this.RootNode.nt3Write.ValuesLazyLoadingIsOn = false;              }
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,GetNodesByName,The following statement contains a magic number: foreach (var row in this.RootNode.nt3Read.SelectForwardStartsWith<string' byte[]>(nameStartsWithPart))              {                  val = row.Value;                  int i = 0;                  while ((prt = val.Substring(i' 16)) != null)                  {                      nodeRow = this.RootNode.nt2Read.Select<byte[]' byte[]>(prt);                      if (nodeRow.Exists)                          yield return SetupNodeFromRow(nodeRow);                      i += 16;                  }              }
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,GetNodesByName,The following statement contains a magic number: foreach (var row in this.RootNode.nt3Read.SelectForwardStartsWith<string' byte[]>(nameStartsWithPart))              {                  val = row.Value;                  int i = 0;                  while ((prt = val.Substring(i' 16)) != null)                  {                      nodeRow = this.RootNode.nt2Read.Select<byte[]' byte[]>(prt);                      if (nodeRow.Exists)                          yield return SetupNodeFromRow(nodeRow);                      i += 16;                  }              }
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,SetupValueRowFromNode,The following statement contains a magic number: if (name.Length > 256)                  throw new Exception("Node name can't be more then 256");
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,SetupNodeFromRow,The following statement contains a magic number: switch (val[0])              {                  case 1: //First protocol type                          /*                          Protocol:                              1byte - protocol version (starting from 1)                              16bytes link to content (or 0)                              1byte - lenght of NodeName                                              Nbytes - Name                                                                             */                        if ((val[1] | val[2] | val[3] | val[4] | val[5] | val[6] | val[7] | val[8]) != 0)                      {                          //We got content                          node.ContentRef = val.Substring(1' 16);                      }                      node.NodeName = System.Text.Encoding.UTF8.GetString(val.Substring(18' val[17]));                      break;              }
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,SetupNodeFromRow,The following statement contains a magic number: switch (val[0])              {                  case 1: //First protocol type                          /*                          Protocol:                              1byte - protocol version (starting from 1)                              16bytes link to content (or 0)                              1byte - lenght of NodeName                                              Nbytes - Name                                                                             */                        if ((val[1] | val[2] | val[3] | val[4] | val[5] | val[6] | val[7] | val[8]) != 0)                      {                          //We got content                          node.ContentRef = val.Substring(1' 16);                      }                      node.NodeName = System.Text.Encoding.UTF8.GetString(val.Substring(18' val[17]));                      break;              }
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,SetupNodeFromRow,The following statement contains a magic number: switch (val[0])              {                  case 1: //First protocol type                          /*                          Protocol:                              1byte - protocol version (starting from 1)                              16bytes link to content (or 0)                              1byte - lenght of NodeName                                              Nbytes - Name                                                                             */                        if ((val[1] | val[2] | val[3] | val[4] | val[5] | val[6] | val[7] | val[8]) != 0)                      {                          //We got content                          node.ContentRef = val.Substring(1' 16);                      }                      node.NodeName = System.Text.Encoding.UTF8.GetString(val.Substring(18' val[17]));                      break;              }
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,SetupNodeFromRow,The following statement contains a magic number: switch (val[0])              {                  case 1: //First protocol type                          /*                          Protocol:                              1byte - protocol version (starting from 1)                              16bytes link to content (or 0)                              1byte - lenght of NodeName                                              Nbytes - Name                                                                             */                        if ((val[1] | val[2] | val[3] | val[4] | val[5] | val[6] | val[7] | val[8]) != 0)                      {                          //We got content                          node.ContentRef = val.Substring(1' 16);                      }                      node.NodeName = System.Text.Encoding.UTF8.GetString(val.Substring(18' val[17]));                      break;              }
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,SetupNodeFromRow,The following statement contains a magic number: switch (val[0])              {                  case 1: //First protocol type                          /*                          Protocol:                              1byte - protocol version (starting from 1)                              16bytes link to content (or 0)                              1byte - lenght of NodeName                                              Nbytes - Name                                                                             */                        if ((val[1] | val[2] | val[3] | val[4] | val[5] | val[6] | val[7] | val[8]) != 0)                      {                          //We got content                          node.ContentRef = val.Substring(1' 16);                      }                      node.NodeName = System.Text.Encoding.UTF8.GetString(val.Substring(18' val[17]));                      break;              }
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,SetupNodeFromRow,The following statement contains a magic number: switch (val[0])              {                  case 1: //First protocol type                          /*                          Protocol:                              1byte - protocol version (starting from 1)                              16bytes link to content (or 0)                              1byte - lenght of NodeName                                              Nbytes - Name                                                                             */                        if ((val[1] | val[2] | val[3] | val[4] | val[5] | val[6] | val[7] | val[8]) != 0)                      {                          //We got content                          node.ContentRef = val.Substring(1' 16);                      }                      node.NodeName = System.Text.Encoding.UTF8.GetString(val.Substring(18' val[17]));                      break;              }
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,SetupNodeFromRow,The following statement contains a magic number: switch (val[0])              {                  case 1: //First protocol type                          /*                          Protocol:                              1byte - protocol version (starting from 1)                              16bytes link to content (or 0)                              1byte - lenght of NodeName                                              Nbytes - Name                                                                             */                        if ((val[1] | val[2] | val[3] | val[4] | val[5] | val[6] | val[7] | val[8]) != 0)                      {                          //We got content                          node.ContentRef = val.Substring(1' 16);                      }                      node.NodeName = System.Text.Encoding.UTF8.GetString(val.Substring(18' val[17]));                      break;              }
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,SetupNodeFromRow,The following statement contains a magic number: switch (val[0])              {                  case 1: //First protocol type                          /*                          Protocol:                              1byte - protocol version (starting from 1)                              16bytes link to content (or 0)                              1byte - lenght of NodeName                                              Nbytes - Name                                                                             */                        if ((val[1] | val[2] | val[3] | val[4] | val[5] | val[6] | val[7] | val[8]) != 0)                      {                          //We got content                          node.ContentRef = val.Substring(1' 16);                      }                      node.NodeName = System.Text.Encoding.UTF8.GetString(val.Substring(18' val[17]));                      break;              }
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,SetupNodeFromRow,The following statement contains a magic number: switch (val[0])              {                  case 1: //First protocol type                          /*                          Protocol:                              1byte - protocol version (starting from 1)                              16bytes link to content (or 0)                              1byte - lenght of NodeName                                              Nbytes - Name                                                                             */                        if ((val[1] | val[2] | val[3] | val[4] | val[5] | val[6] | val[7] | val[8]) != 0)                      {                          //We got content                          node.ContentRef = val.Substring(1' 16);                      }                      node.NodeName = System.Text.Encoding.UTF8.GetString(val.Substring(18' val[17]));                      break;              }
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,SetupNodeFromRow,The following statement contains a magic number: switch (val[0])              {                  case 1: //First protocol type                          /*                          Protocol:                              1byte - protocol version (starting from 1)                              16bytes link to content (or 0)                              1byte - lenght of NodeName                                              Nbytes - Name                                                                             */                        if ((val[1] | val[2] | val[3] | val[4] | val[5] | val[6] | val[7] | val[8]) != 0)                      {                          //We got content                          node.ContentRef = val.Substring(1' 16);                      }                      node.NodeName = System.Text.Encoding.UTF8.GetString(val.Substring(18' val[17]));                      break;              }
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,SetupNodeFromRow,The following statement contains a magic number: node.ParentNodeId = row.Key.Substring(0' 8).To_Int64_BigEndian();
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,SetupNodeFromRow,The following statement contains a magic number: node.NodeId = row.Key.Substring(8' 8).To_Int64_BigEndian();
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,SetupNodeFromRow,The following statement contains a magic number: node.NodeId = row.Key.Substring(8' 8).To_Int64_BigEndian();
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,RemoveOldNodeFromNameIndex,The following statement contains a magic number: if (oldNodeNameIndexRow.Exists)              {                  byte[] val = oldNodeNameIndexRow.Value;                  byte[] prt = null;                  int i = 0;                  List<byte[]> keys = new List<byte[]>();                  int size = 0;                  while ((prt = val.Substring(i' 16)) != null)                  {                      i += 16;                      if (prt._ByteArrayEquals(keyToRemove))                          continue;                      size += 16;                      keys.Add(prt);                  }                    if (keys.Count > 0)                  {                      byte[] newVal = new byte[size];                      i = 0;                      foreach (var key in keys)                      {                          newVal.CopyInside(i' key);                          i += 16;                      }                        this.RootNode.nt3Write.Insert<string' byte[]>(oldNodeName.ToLower()' newVal);                  }                  else                  {                      this.RootNode.nt3Write.RemoveKey<string>(oldNodeName.ToLower());                  }                }
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,RemoveOldNodeFromNameIndex,The following statement contains a magic number: if (oldNodeNameIndexRow.Exists)              {                  byte[] val = oldNodeNameIndexRow.Value;                  byte[] prt = null;                  int i = 0;                  List<byte[]> keys = new List<byte[]>();                  int size = 0;                  while ((prt = val.Substring(i' 16)) != null)                  {                      i += 16;                      if (prt._ByteArrayEquals(keyToRemove))                          continue;                      size += 16;                      keys.Add(prt);                  }                    if (keys.Count > 0)                  {                      byte[] newVal = new byte[size];                      i = 0;                      foreach (var key in keys)                      {                          newVal.CopyInside(i' key);                          i += 16;                      }                        this.RootNode.nt3Write.Insert<string' byte[]>(oldNodeName.ToLower()' newVal);                  }                  else                  {                      this.RootNode.nt3Write.RemoveKey<string>(oldNodeName.ToLower());                  }                }
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,RemoveOldNodeFromNameIndex,The following statement contains a magic number: if (oldNodeNameIndexRow.Exists)              {                  byte[] val = oldNodeNameIndexRow.Value;                  byte[] prt = null;                  int i = 0;                  List<byte[]> keys = new List<byte[]>();                  int size = 0;                  while ((prt = val.Substring(i' 16)) != null)                  {                      i += 16;                      if (prt._ByteArrayEquals(keyToRemove))                          continue;                      size += 16;                      keys.Add(prt);                  }                    if (keys.Count > 0)                  {                      byte[] newVal = new byte[size];                      i = 0;                      foreach (var key in keys)                      {                          newVal.CopyInside(i' key);                          i += 16;                      }                        this.RootNode.nt3Write.Insert<string' byte[]>(oldNodeName.ToLower()' newVal);                  }                  else                  {                      this.RootNode.nt3Write.RemoveKey<string>(oldNodeName.ToLower());                  }                }
Magic Number,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,RemoveOldNodeFromNameIndex,The following statement contains a magic number: if (oldNodeNameIndexRow.Exists)              {                  byte[] val = oldNodeNameIndexRow.Value;                  byte[] prt = null;                  int i = 0;                  List<byte[]> keys = new List<byte[]>();                  int size = 0;                  while ((prt = val.Substring(i' 16)) != null)                  {                      i += 16;                      if (prt._ByteArrayEquals(keyToRemove))                          continue;                      size += 16;                      keys.Add(prt);                  }                    if (keys.Count > 0)                  {                      byte[] newVal = new byte[size];                      i = 0;                      foreach (var key in keys)                      {                          newVal.CopyInside(i' key);                          i += 16;                      }                        this.RootNode.nt3Write.Insert<string' byte[]>(oldNodeName.ToLower()' newVal);                  }                  else                  {                      this.RootNode.nt3Write.RemoveKey<string>(oldNodeName.ToLower());                  }                }
Magic Number,DBreeze.DataTypes,Row<TKey;TValue>,C:\repos\hhblaze_DBreeze\DBreeze\DataTypes\Row.cs,GetDataBlock,The following statement contains a magic number: if (_exists)              {                  if (_row.ValueIsReadOut)                  {                      if (_row.Value == null)                          return null;                        dataBlockId = _row.Value.Substring((int)startIndex' 16);                        return this._row.Root.Tree.Cache.ReadDynamicDataBlock(ref dataBlockId' this._useCache);                  }                    long valueStartPointer = 0;                  uint valueFullLength = 0;                  dataBlockId = this._row.Root.Tree.Cache.ReadValuePartially(this._row.LinkToValue' startIndex' 16' this._useCache' out valueStartPointer' out valueFullLength);                  return this._row.Root.Tree.Cache.ReadDynamicDataBlock(ref dataBlockId' this._useCache);              }
Magic Number,DBreeze.DataTypes,Row<TKey;TValue>,C:\repos\hhblaze_DBreeze\DBreeze\DataTypes\Row.cs,GetDataBlock,The following statement contains a magic number: if (_exists)              {                  if (_row.ValueIsReadOut)                  {                      if (_row.Value == null)                          return null;                        dataBlockId = _row.Value.Substring((int)startIndex' 16);                        return this._row.Root.Tree.Cache.ReadDynamicDataBlock(ref dataBlockId' this._useCache);                  }                    long valueStartPointer = 0;                  uint valueFullLength = 0;                  dataBlockId = this._row.Root.Tree.Cache.ReadValuePartially(this._row.LinkToValue' startIndex' 16' this._useCache' out valueStartPointer' out valueFullLength);                  return this._row.Root.Tree.Cache.ReadDynamicDataBlock(ref dataBlockId' this._useCache);              }
Magic Number,DBreeze.DataTypes,Row<TKey;TValue>,C:\repos\hhblaze_DBreeze\DBreeze\DataTypes\Row.cs,GetDataBlockWithFixedAddress,The following statement contains a magic number: if (_exists)              {                  if (_row.ValueIsReadOut)                  {                      if (_row.Value == null)                          return default(TVal);                        dataBlockId = _row.Value.Substring((int)startIndex' 16);                        //dataBlockId=this._row.Root.Tree.Cache.ReadDynamicDataBlock(ref dataBlockId' this._useCache);                      //return DataTypesConvertor.ConvertBack<TValue>(this._row.Root.Tree.Cache.ReadDynamicDataBlock(ref dataBlockId' this._useCache));                        //return this._row.Root.Tree.Cache.ReadDynamicDataBlock(ref dataBlockId' this._useCache);                    }                    long valueStartPointer = 0;                  uint valueFullLength = 0;                  dataBlockId = this._row.Root.Tree.Cache.ReadValuePartially(this._row.LinkToValue' startIndex' 16' this._useCache' out valueStartPointer' out valueFullLength);                  //return this._row.Root.Tree.Cache.ReadDynamicDataBlock(ref dataBlockId' this._useCache);                    //dataBlockId = this._row.Root.Tree.Cache.ReadDynamicDataBlock(ref dataBlockId' this._useCache);                  //return DataTypesConvertor.ConvertBack<TValue>(this._row.Root.Tree.Cache.ReadDynamicDataBlock(ref dataBlockId' this._useCache));              }
Magic Number,DBreeze.DataTypes,Row<TKey;TValue>,C:\repos\hhblaze_DBreeze\DBreeze\DataTypes\Row.cs,GetDataBlockWithFixedAddress,The following statement contains a magic number: if (_exists)              {                  if (_row.ValueIsReadOut)                  {                      if (_row.Value == null)                          return default(TVal);                        dataBlockId = _row.Value.Substring((int)startIndex' 16);                        //dataBlockId=this._row.Root.Tree.Cache.ReadDynamicDataBlock(ref dataBlockId' this._useCache);                      //return DataTypesConvertor.ConvertBack<TValue>(this._row.Root.Tree.Cache.ReadDynamicDataBlock(ref dataBlockId' this._useCache));                        //return this._row.Root.Tree.Cache.ReadDynamicDataBlock(ref dataBlockId' this._useCache);                    }                    long valueStartPointer = 0;                  uint valueFullLength = 0;                  dataBlockId = this._row.Root.Tree.Cache.ReadValuePartially(this._row.LinkToValue' startIndex' 16' this._useCache' out valueStartPointer' out valueFullLength);                  //return this._row.Root.Tree.Cache.ReadDynamicDataBlock(ref dataBlockId' this._useCache);                    //dataBlockId = this._row.Root.Tree.Cache.ReadDynamicDataBlock(ref dataBlockId' this._useCache);                  //return DataTypesConvertor.ConvertBack<TValue>(this._row.Root.Tree.Cache.ReadDynamicDataBlock(ref dataBlockId' this._useCache));              }
Magic Number,DBreeze.DataTypes,Row<TKey;TValue>,C:\repos\hhblaze_DBreeze\DBreeze\DataTypes\Row.cs,ObjectGet,The following statement contains a magic number: if (_exists)              {                  if (_row.ValueIsReadOut)                  {                      if (_row.Value == null)                          return null;                        dataBlockId = _row.Value.Substring(startIndex' 16);                  }                  else                  {                      long valueStartPointer = 0;                      uint valueFullLength = 0;                      dataBlockId = this._row.Root.Tree.Cache.ReadValuePartially(this._row.LinkToValue' (uint)startIndex' 16' this._useCache' out valueStartPointer' out valueFullLength);                  }              }              else                  return null;
Magic Number,DBreeze.DataTypes,Row<TKey;TValue>,C:\repos\hhblaze_DBreeze\DBreeze\DataTypes\Row.cs,ObjectGet,The following statement contains a magic number: if (_exists)              {                  if (_row.ValueIsReadOut)                  {                      if (_row.Value == null)                          return null;                        dataBlockId = _row.Value.Substring(startIndex' 16);                  }                  else                  {                      long valueStartPointer = 0;                      uint valueFullLength = 0;                      dataBlockId = this._row.Root.Tree.Cache.ReadValuePartially(this._row.LinkToValue' (uint)startIndex' 16' this._useCache' out valueStartPointer' out valueFullLength);                  }              }              else                  return null;
Magic Number,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,Insert,The following statement contains a magic number: if (refToInsertedValue != null)                  refToInsertedValue = refToInsertedValue.EnlargeByteArray_BigEndian(8);
Magic Number,DBreeze.DataTypes,NestedTable,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\NestedTables\NestedTable.cs,InsertPart,The following statement contains a magic number: if (refToInsertedValue != null)                  refToInsertedValue = refToInsertedValue.EnlargeByteArray_BigEndian(8);
Magic Number,DBreeze,Scheme,C:\repos\hhblaze_DBreeze\DBreeze\Engine\Scheme.cs,GetPhysicalPathToTheUserTable,The following statement contains a magic number: try              {                  byte[] btTableName = GetUserTableNameAsByte(userTableName);                  ulong fileName = 0;                      //Getting file name                  LTrieRow row = LTrie.GetKey(btTableName' false' false);                    if (row.Exists)                  {                      byte[] fullValue = row.GetFullValue(true);                      //Can be parsed different. First protocol version is 1                      ushort schemeProtocol = fullValue.Substring(0' 2).To_UInt16_BigEndian();                        switch (schemeProtocol)                      {                          case 1:                              fileName = fullValue.Substring(2' 8).To_UInt64_BigEndian();                              break;                          default:                              throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.SCHEME_FILE_PROTOCOL_IS_UNKNOWN);                      }                  }                  else                      return String.Empty;                      //Getting folder                    //For now returns path inside working folder' later re-make' take into consideration mapping of DB to tother folders.                    string alternativeTableLocation = String.Empty;                    if (CheckAlternativeTableLocationsIntersections(userTableName' out alternativeTableLocation))                  {                      if (alternativeTableLocation == String.Empty)                      {                          //In memory table                          //return Path.Combine(Engine.MainFolder' fileName.ToString());                          return "MEMORY";                      }                      else                      {                          //returning alternative folder + fileName                          return Path.Combine(alternativeTableLocation' fileName.ToString());                      }                  }                  else                  {                      //Standard path (Dbreeze mainFolder + fileName)                      return Path.Combine(Engine.MainFolder' fileName.ToString());                  }              }              //catch (System.Threading.ThreadAbortException ex)              //{              //    //We don'T make DBisOperable = false;                              //    throw ex;              //}              catch (Exception ex)              {                  this.Engine.DBisOperable = false;                  this.Engine.DBisOperableReason = "GetPhysicalPathToTheUserTable";                  throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.GENERAL_EXCEPTION_DB_NOT_OPERABLE' this.Engine.DBisOperableReason' ex);                }
Magic Number,DBreeze,Scheme,C:\repos\hhblaze_DBreeze\DBreeze\Engine\Scheme.cs,GetPhysicalPathToTheUserTable,The following statement contains a magic number: try              {                  byte[] btTableName = GetUserTableNameAsByte(userTableName);                  ulong fileName = 0;                      //Getting file name                  LTrieRow row = LTrie.GetKey(btTableName' false' false);                    if (row.Exists)                  {                      byte[] fullValue = row.GetFullValue(true);                      //Can be parsed different. First protocol version is 1                      ushort schemeProtocol = fullValue.Substring(0' 2).To_UInt16_BigEndian();                        switch (schemeProtocol)                      {                          case 1:                              fileName = fullValue.Substring(2' 8).To_UInt64_BigEndian();                              break;                          default:                              throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.SCHEME_FILE_PROTOCOL_IS_UNKNOWN);                      }                  }                  else                      return String.Empty;                      //Getting folder                    //For now returns path inside working folder' later re-make' take into consideration mapping of DB to tother folders.                    string alternativeTableLocation = String.Empty;                    if (CheckAlternativeTableLocationsIntersections(userTableName' out alternativeTableLocation))                  {                      if (alternativeTableLocation == String.Empty)                      {                          //In memory table                          //return Path.Combine(Engine.MainFolder' fileName.ToString());                          return "MEMORY";                      }                      else                      {                          //returning alternative folder + fileName                          return Path.Combine(alternativeTableLocation' fileName.ToString());                      }                  }                  else                  {                      //Standard path (Dbreeze mainFolder + fileName)                      return Path.Combine(Engine.MainFolder' fileName.ToString());                  }              }              //catch (System.Threading.ThreadAbortException ex)              //{              //    //We don'T make DBisOperable = false;                              //    throw ex;              //}              catch (Exception ex)              {                  this.Engine.DBisOperable = false;                  this.Engine.DBisOperableReason = "GetPhysicalPathToTheUserTable";                  throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.GENERAL_EXCEPTION_DB_NOT_OPERABLE' this.Engine.DBisOperableReason' ex);                }
Magic Number,DBreeze,Scheme,C:\repos\hhblaze_DBreeze\DBreeze\Engine\Scheme.cs,GetPhysicalPathToTheUserTable,The following statement contains a magic number: try              {                  byte[] btTableName = GetUserTableNameAsByte(userTableName);                  ulong fileName = 0;                      //Getting file name                  LTrieRow row = LTrie.GetKey(btTableName' false' false);                    if (row.Exists)                  {                      byte[] fullValue = row.GetFullValue(true);                      //Can be parsed different. First protocol version is 1                      ushort schemeProtocol = fullValue.Substring(0' 2).To_UInt16_BigEndian();                        switch (schemeProtocol)                      {                          case 1:                              fileName = fullValue.Substring(2' 8).To_UInt64_BigEndian();                              break;                          default:                              throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.SCHEME_FILE_PROTOCOL_IS_UNKNOWN);                      }                  }                  else                      return String.Empty;                      //Getting folder                    //For now returns path inside working folder' later re-make' take into consideration mapping of DB to tother folders.                    string alternativeTableLocation = String.Empty;                    if (CheckAlternativeTableLocationsIntersections(userTableName' out alternativeTableLocation))                  {                      if (alternativeTableLocation == String.Empty)                      {                          //In memory table                          //return Path.Combine(Engine.MainFolder' fileName.ToString());                          return "MEMORY";                      }                      else                      {                          //returning alternative folder + fileName                          return Path.Combine(alternativeTableLocation' fileName.ToString());                      }                  }                  else                  {                      //Standard path (Dbreeze mainFolder + fileName)                      return Path.Combine(Engine.MainFolder' fileName.ToString());                  }              }              //catch (System.Threading.ThreadAbortException ex)              //{              //    //We don'T make DBisOperable = false;                              //    throw ex;              //}              catch (Exception ex)              {                  this.Engine.DBisOperable = false;                  this.Engine.DBisOperableReason = "GetPhysicalPathToTheUserTable";                  throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.GENERAL_EXCEPTION_DB_NOT_OPERABLE' this.Engine.DBisOperableReason' ex);                }
Magic Number,DBreeze,Scheme,C:\repos\hhblaze_DBreeze\DBreeze\Engine\Scheme.cs,GetTablePathFromTableName,The following statement contains a magic number: try              {                  byte[] btTableName = GetUserTableNameAsByte(userTableName);                    LTrieRow row = LTrie.GetKey(btTableName' true' false);                    if (!row.Exists)                  {                      return String.Empty;                  }                    byte[] fullValue = row.GetFullValue(true);                  //Can be parsed different. First protocol version is 1                  ushort schemeProtocol = fullValue.Substring(0' 2).To_UInt16_BigEndian();                  ulong fileName = 0;                  switch (schemeProtocol)                  {                      case 1:                          fileName = fullValue.Substring(2' 8).To_UInt64_BigEndian();                          break;                      default:                          throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.SCHEME_FILE_PROTOCOL_IS_UNKNOWN);                  }                    string alternativeTableLocation = String.Empty;                    if (CheckAlternativeTableLocationsIntersections(userTableName' out alternativeTableLocation))                  {                      if (alternativeTableLocation == String.Empty)                          return "MEMORY";                      else                          return Path.Combine(alternativeTableLocation' fileName.ToString());                  }                  else                  {                      return Path.Combine(Engine.MainFolder' fileName.ToString());                  }              }              finally              {                  _sync_openTablesHolder.ExitReadLock();              }
Magic Number,DBreeze,Scheme,C:\repos\hhblaze_DBreeze\DBreeze\Engine\Scheme.cs,GetTablePathFromTableName,The following statement contains a magic number: try              {                  byte[] btTableName = GetUserTableNameAsByte(userTableName);                    LTrieRow row = LTrie.GetKey(btTableName' true' false);                    if (!row.Exists)                  {                      return String.Empty;                  }                    byte[] fullValue = row.GetFullValue(true);                  //Can be parsed different. First protocol version is 1                  ushort schemeProtocol = fullValue.Substring(0' 2).To_UInt16_BigEndian();                  ulong fileName = 0;                  switch (schemeProtocol)                  {                      case 1:                          fileName = fullValue.Substring(2' 8).To_UInt64_BigEndian();                          break;                      default:                          throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.SCHEME_FILE_PROTOCOL_IS_UNKNOWN);                  }                    string alternativeTableLocation = String.Empty;                    if (CheckAlternativeTableLocationsIntersections(userTableName' out alternativeTableLocation))                  {                      if (alternativeTableLocation == String.Empty)                          return "MEMORY";                      else                          return Path.Combine(alternativeTableLocation' fileName.ToString());                  }                  else                  {                      return Path.Combine(Engine.MainFolder' fileName.ToString());                  }              }              finally              {                  _sync_openTablesHolder.ExitReadLock();              }
Magic Number,DBreeze,Scheme,C:\repos\hhblaze_DBreeze\DBreeze\Engine\Scheme.cs,GetTablePathFromTableName,The following statement contains a magic number: try              {                  byte[] btTableName = GetUserTableNameAsByte(userTableName);                    LTrieRow row = LTrie.GetKey(btTableName' true' false);                    if (!row.Exists)                  {                      return String.Empty;                  }                    byte[] fullValue = row.GetFullValue(true);                  //Can be parsed different. First protocol version is 1                  ushort schemeProtocol = fullValue.Substring(0' 2).To_UInt16_BigEndian();                  ulong fileName = 0;                  switch (schemeProtocol)                  {                      case 1:                          fileName = fullValue.Substring(2' 8).To_UInt64_BigEndian();                          break;                      default:                          throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.SCHEME_FILE_PROTOCOL_IS_UNKNOWN);                  }                    string alternativeTableLocation = String.Empty;                    if (CheckAlternativeTableLocationsIntersections(userTableName' out alternativeTableLocation))                  {                      if (alternativeTableLocation == String.Empty)                          return "MEMORY";                      else                          return Path.Combine(alternativeTableLocation' fileName.ToString());                  }                  else                  {                      return Path.Combine(Engine.MainFolder' fileName.ToString());                  }              }              finally              {                  _sync_openTablesHolder.ExitReadLock();              }
Magic Number,DBreeze,Scheme,C:\repos\hhblaze_DBreeze\DBreeze\Engine\Scheme.cs,GetTable,The following statement contains a magic number: try              {                    _openTablesHolder.TryGetValue(tableName' out otl);                    if (otl != null)                  {                      //Try to increase usage and return LTrie                      otl.Add();                      return otl.Trie;                  }                      //Probably table Exists in db but not in openTablesHolder                    _sync_openTablesHolder.EnterWriteLock();                  try                  {                      //UpgradeableRead recheck                      _openTablesHolder.TryGetValue(tableName' out otl);                        if (otl != null)                      {                          //Try to increase usage and return LTrie                          otl.Add();                          return otl.Trie;                      }                            byte[] btTableName = GetUserTableNameAsByte(userTableName);                        //Trying to get fileName from cache                      fileName = this.cachedTableNames.GetFileName(tableName);                      // LTrieRow row = null;                      bool tableExists = false;                        if (fileName == 0)                      {                          LTrieRow row = LTrie.GetKey(btTableName' false' false);                              if (row.Exists)                          {                              tableExists = true;                                byte[] fullValue = row.GetFullValue(false);                              //Can be parsed different. First protocol version is 1                              ushort schemeProtocol = fullValue.Substring(0' 2).To_UInt16_BigEndian();                                switch (schemeProtocol)                              {                                  case 1:                                      fileName = fullValue.Substring(2' 8).To_UInt64_BigEndian();                                      break;                                  default:                                      throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.SCHEME_FILE_PROTOCOL_IS_UNKNOWN);                              }                          }                          else                          {                              tableExists = false;                              //Creating new table.                                //Checking table name validity                                //this will throw exception' if not valid                              DbUserTables.UserTableNameIsOk(userTableName);                                  //Creating such table and renewing LastFileNumber counter                                //Adding to LastFileNumber                              LastFileNumber++;                                  ////Deleting physical files related to the table' if they existed - normally they should not                              //DeleteAllReleatedTableFiles(Path.Combine(Engine.MainFolder' LastFileNumber.ToString()));                                byte[] lft = LastFileNumber.To_8_bytes_array_BigEndian();                                //Writing this number to Schema file                              LTrie.Add(Encoding.UTF8.GetBytes(LastFileNumberKeyName)' lft);                                //Creating table self and writing to Schema file                                LTrie.Add(btTableName'                                  new byte[] { 0' 1 }     //Protocol version 1                                  .Concat(lft));          //Number of the file                                //Committing both records                              LTrie.Commit();                                fileName = LastFileNumber;                                this.cachedTableNames.Add(tableName' fileName);                          }                      }                      else                          tableExists = true;                        //Creating LTrie' adding it to _openTablesHolder                        //Seeting up Trie TableName' OTHER SETTINGS                        TrieSettings ts = new TrieSettings();                      IStorage storage = null;                          ////Checking if default Flusg Disk behaviour was overriden                      //ts.DiskFlushBehaviour = Engine.Configuration.DiskFlushBehaviour;                      ////Checking if we have alternative DiskFlush behaviour                      //foreach (var pattern in Engine.Configuration.AlternativeDiskFlushBehaviour)                      //{                      //    //pattern.Key                      //    if (DbUserTables.PatternsIntersect(pattern.Key' userTableName))                      //    {                        //        ts.DiskFlushBehaviour = pattern.Value;                      //        break;                      //    }                      //}                        string alternativeTableLocation = String.Empty;                        if (CheckAlternativeTableLocationsIntersections(userTableName' out alternativeTableLocation))                      {                          ts.StorageWasOverriden = true;                            if (alternativeTableLocation == String.Empty)                          {                              ts.AlternativeTableStorageType = DBreezeConfiguration.eStorage.MEMORY;                                storage = new StorageLayer(Path.Combine(Engine.MainFolder' fileName.ToString())' ts' Engine.Configuration);                          }                          else                          {                              ts.AlternativeTableStorageType = DBreezeConfiguration.eStorage.DISK;                              ts.AlternativeTableStorageFolder = alternativeTableLocation;                                DirectoryInfo diAlt = new DirectoryInfo(alternativeTableLocation);                              if (!diAlt.Exists)                                  diAlt.Create();                                if (!tableExists)                              {                                  //Deleting physical files related to the table' if they existed - normally they should not                                  DeleteAllReleatedTableFiles(Path.Combine(ts.AlternativeTableStorageFolder' LastFileNumber.ToString()));                              }                                storage = new StorageLayer(Path.Combine(ts.AlternativeTableStorageFolder' fileName.ToString())' ts' Engine.Configuration);                          }                      }                      else                      {                          if (!tableExists)                          {                              //Deleting physical files related to the table' if they existed - normally they should not                              DeleteAllReleatedTableFiles(Path.Combine(Engine.MainFolder' LastFileNumber.ToString()));                          }                            storage = new StorageLayer(Path.Combine(Engine.MainFolder' fileName.ToString())' ts' Engine.Configuration);                      }                        //storage = new StorageLayer(Path.Combine(Engine.MainFolder' fileName.ToString())' ts' Engine.Configuration);                        LTrie trie = new LTrie(storage);                        //Setting LTrie user table name                      trie.TableName = userTableName;                        //_openTablesHolder.Add(tableName' trie);                        //Automatically increased usage in OpenTable constructor                      _openTablesHolder.Add(tableName' new OpenTable(trie));                        return trie;                  }                  catch (System.Exception ex)                  {                      //CASCADE                      throw ex;                  }                  finally                  {                      _sync_openTablesHolder.ExitWriteLock();                  }              }              catch (Exception ex)              {                  throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.SCHEME_GET_TABLE_WRITE_FAILED' tableName' ex);              }              finally              {                  _sync_openTablesHolder.ExitUpgradeableReadLock();              }
Magic Number,DBreeze,Scheme,C:\repos\hhblaze_DBreeze\DBreeze\Engine\Scheme.cs,GetTable,The following statement contains a magic number: try              {                    _openTablesHolder.TryGetValue(tableName' out otl);                    if (otl != null)                  {                      //Try to increase usage and return LTrie                      otl.Add();                      return otl.Trie;                  }                      //Probably table Exists in db but not in openTablesHolder                    _sync_openTablesHolder.EnterWriteLock();                  try                  {                      //UpgradeableRead recheck                      _openTablesHolder.TryGetValue(tableName' out otl);                        if (otl != null)                      {                          //Try to increase usage and return LTrie                          otl.Add();                          return otl.Trie;                      }                            byte[] btTableName = GetUserTableNameAsByte(userTableName);                        //Trying to get fileName from cache                      fileName = this.cachedTableNames.GetFileName(tableName);                      // LTrieRow row = null;                      bool tableExists = false;                        if (fileName == 0)                      {                          LTrieRow row = LTrie.GetKey(btTableName' false' false);                              if (row.Exists)                          {                              tableExists = true;                                byte[] fullValue = row.GetFullValue(false);                              //Can be parsed different. First protocol version is 1                              ushort schemeProtocol = fullValue.Substring(0' 2).To_UInt16_BigEndian();                                switch (schemeProtocol)                              {                                  case 1:                                      fileName = fullValue.Substring(2' 8).To_UInt64_BigEndian();                                      break;                                  default:                                      throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.SCHEME_FILE_PROTOCOL_IS_UNKNOWN);                              }                          }                          else                          {                              tableExists = false;                              //Creating new table.                                //Checking table name validity                                //this will throw exception' if not valid                              DbUserTables.UserTableNameIsOk(userTableName);                                  //Creating such table and renewing LastFileNumber counter                                //Adding to LastFileNumber                              LastFileNumber++;                                  ////Deleting physical files related to the table' if they existed - normally they should not                              //DeleteAllReleatedTableFiles(Path.Combine(Engine.MainFolder' LastFileNumber.ToString()));                                byte[] lft = LastFileNumber.To_8_bytes_array_BigEndian();                                //Writing this number to Schema file                              LTrie.Add(Encoding.UTF8.GetBytes(LastFileNumberKeyName)' lft);                                //Creating table self and writing to Schema file                                LTrie.Add(btTableName'                                  new byte[] { 0' 1 }     //Protocol version 1                                  .Concat(lft));          //Number of the file                                //Committing both records                              LTrie.Commit();                                fileName = LastFileNumber;                                this.cachedTableNames.Add(tableName' fileName);                          }                      }                      else                          tableExists = true;                        //Creating LTrie' adding it to _openTablesHolder                        //Seeting up Trie TableName' OTHER SETTINGS                        TrieSettings ts = new TrieSettings();                      IStorage storage = null;                          ////Checking if default Flusg Disk behaviour was overriden                      //ts.DiskFlushBehaviour = Engine.Configuration.DiskFlushBehaviour;                      ////Checking if we have alternative DiskFlush behaviour                      //foreach (var pattern in Engine.Configuration.AlternativeDiskFlushBehaviour)                      //{                      //    //pattern.Key                      //    if (DbUserTables.PatternsIntersect(pattern.Key' userTableName))                      //    {                        //        ts.DiskFlushBehaviour = pattern.Value;                      //        break;                      //    }                      //}                        string alternativeTableLocation = String.Empty;                        if (CheckAlternativeTableLocationsIntersections(userTableName' out alternativeTableLocation))                      {                          ts.StorageWasOverriden = true;                            if (alternativeTableLocation == String.Empty)                          {                              ts.AlternativeTableStorageType = DBreezeConfiguration.eStorage.MEMORY;                                storage = new StorageLayer(Path.Combine(Engine.MainFolder' fileName.ToString())' ts' Engine.Configuration);                          }                          else                          {                              ts.AlternativeTableStorageType = DBreezeConfiguration.eStorage.DISK;                              ts.AlternativeTableStorageFolder = alternativeTableLocation;                                DirectoryInfo diAlt = new DirectoryInfo(alternativeTableLocation);                              if (!diAlt.Exists)                                  diAlt.Create();                                if (!tableExists)                              {                                  //Deleting physical files related to the table' if they existed - normally they should not                                  DeleteAllReleatedTableFiles(Path.Combine(ts.AlternativeTableStorageFolder' LastFileNumber.ToString()));                              }                                storage = new StorageLayer(Path.Combine(ts.AlternativeTableStorageFolder' fileName.ToString())' ts' Engine.Configuration);                          }                      }                      else                      {                          if (!tableExists)                          {                              //Deleting physical files related to the table' if they existed - normally they should not                              DeleteAllReleatedTableFiles(Path.Combine(Engine.MainFolder' LastFileNumber.ToString()));                          }                            storage = new StorageLayer(Path.Combine(Engine.MainFolder' fileName.ToString())' ts' Engine.Configuration);                      }                        //storage = new StorageLayer(Path.Combine(Engine.MainFolder' fileName.ToString())' ts' Engine.Configuration);                        LTrie trie = new LTrie(storage);                        //Setting LTrie user table name                      trie.TableName = userTableName;                        //_openTablesHolder.Add(tableName' trie);                        //Automatically increased usage in OpenTable constructor                      _openTablesHolder.Add(tableName' new OpenTable(trie));                        return trie;                  }                  catch (System.Exception ex)                  {                      //CASCADE                      throw ex;                  }                  finally                  {                      _sync_openTablesHolder.ExitWriteLock();                  }              }              catch (Exception ex)              {                  throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.SCHEME_GET_TABLE_WRITE_FAILED' tableName' ex);              }              finally              {                  _sync_openTablesHolder.ExitUpgradeableReadLock();              }
Magic Number,DBreeze,Scheme,C:\repos\hhblaze_DBreeze\DBreeze\Engine\Scheme.cs,GetTable,The following statement contains a magic number: try              {                    _openTablesHolder.TryGetValue(tableName' out otl);                    if (otl != null)                  {                      //Try to increase usage and return LTrie                      otl.Add();                      return otl.Trie;                  }                      //Probably table Exists in db but not in openTablesHolder                    _sync_openTablesHolder.EnterWriteLock();                  try                  {                      //UpgradeableRead recheck                      _openTablesHolder.TryGetValue(tableName' out otl);                        if (otl != null)                      {                          //Try to increase usage and return LTrie                          otl.Add();                          return otl.Trie;                      }                            byte[] btTableName = GetUserTableNameAsByte(userTableName);                        //Trying to get fileName from cache                      fileName = this.cachedTableNames.GetFileName(tableName);                      // LTrieRow row = null;                      bool tableExists = false;                        if (fileName == 0)                      {                          LTrieRow row = LTrie.GetKey(btTableName' false' false);                              if (row.Exists)                          {                              tableExists = true;                                byte[] fullValue = row.GetFullValue(false);                              //Can be parsed different. First protocol version is 1                              ushort schemeProtocol = fullValue.Substring(0' 2).To_UInt16_BigEndian();                                switch (schemeProtocol)                              {                                  case 1:                                      fileName = fullValue.Substring(2' 8).To_UInt64_BigEndian();                                      break;                                  default:                                      throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.SCHEME_FILE_PROTOCOL_IS_UNKNOWN);                              }                          }                          else                          {                              tableExists = false;                              //Creating new table.                                //Checking table name validity                                //this will throw exception' if not valid                              DbUserTables.UserTableNameIsOk(userTableName);                                  //Creating such table and renewing LastFileNumber counter                                //Adding to LastFileNumber                              LastFileNumber++;                                  ////Deleting physical files related to the table' if they existed - normally they should not                              //DeleteAllReleatedTableFiles(Path.Combine(Engine.MainFolder' LastFileNumber.ToString()));                                byte[] lft = LastFileNumber.To_8_bytes_array_BigEndian();                                //Writing this number to Schema file                              LTrie.Add(Encoding.UTF8.GetBytes(LastFileNumberKeyName)' lft);                                //Creating table self and writing to Schema file                                LTrie.Add(btTableName'                                  new byte[] { 0' 1 }     //Protocol version 1                                  .Concat(lft));          //Number of the file                                //Committing both records                              LTrie.Commit();                                fileName = LastFileNumber;                                this.cachedTableNames.Add(tableName' fileName);                          }                      }                      else                          tableExists = true;                        //Creating LTrie' adding it to _openTablesHolder                        //Seeting up Trie TableName' OTHER SETTINGS                        TrieSettings ts = new TrieSettings();                      IStorage storage = null;                          ////Checking if default Flusg Disk behaviour was overriden                      //ts.DiskFlushBehaviour = Engine.Configuration.DiskFlushBehaviour;                      ////Checking if we have alternative DiskFlush behaviour                      //foreach (var pattern in Engine.Configuration.AlternativeDiskFlushBehaviour)                      //{                      //    //pattern.Key                      //    if (DbUserTables.PatternsIntersect(pattern.Key' userTableName))                      //    {                        //        ts.DiskFlushBehaviour = pattern.Value;                      //        break;                      //    }                      //}                        string alternativeTableLocation = String.Empty;                        if (CheckAlternativeTableLocationsIntersections(userTableName' out alternativeTableLocation))                      {                          ts.StorageWasOverriden = true;                            if (alternativeTableLocation == String.Empty)                          {                              ts.AlternativeTableStorageType = DBreezeConfiguration.eStorage.MEMORY;                                storage = new StorageLayer(Path.Combine(Engine.MainFolder' fileName.ToString())' ts' Engine.Configuration);                          }                          else                          {                              ts.AlternativeTableStorageType = DBreezeConfiguration.eStorage.DISK;                              ts.AlternativeTableStorageFolder = alternativeTableLocation;                                DirectoryInfo diAlt = new DirectoryInfo(alternativeTableLocation);                              if (!diAlt.Exists)                                  diAlt.Create();                                if (!tableExists)                              {                                  //Deleting physical files related to the table' if they existed - normally they should not                                  DeleteAllReleatedTableFiles(Path.Combine(ts.AlternativeTableStorageFolder' LastFileNumber.ToString()));                              }                                storage = new StorageLayer(Path.Combine(ts.AlternativeTableStorageFolder' fileName.ToString())' ts' Engine.Configuration);                          }                      }                      else                      {                          if (!tableExists)                          {                              //Deleting physical files related to the table' if they existed - normally they should not                              DeleteAllReleatedTableFiles(Path.Combine(Engine.MainFolder' LastFileNumber.ToString()));                          }                            storage = new StorageLayer(Path.Combine(Engine.MainFolder' fileName.ToString())' ts' Engine.Configuration);                      }                        //storage = new StorageLayer(Path.Combine(Engine.MainFolder' fileName.ToString())' ts' Engine.Configuration);                        LTrie trie = new LTrie(storage);                        //Setting LTrie user table name                      trie.TableName = userTableName;                        //_openTablesHolder.Add(tableName' trie);                        //Automatically increased usage in OpenTable constructor                      _openTablesHolder.Add(tableName' new OpenTable(trie));                        return trie;                  }                  catch (System.Exception ex)                  {                      //CASCADE                      throw ex;                  }                  finally                  {                      _sync_openTablesHolder.ExitWriteLock();                  }              }              catch (Exception ex)              {                  throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.SCHEME_GET_TABLE_WRITE_FAILED' tableName' ex);              }              finally              {                  _sync_openTablesHolder.ExitUpgradeableReadLock();              }
Magic Number,DBreeze,Scheme,C:\repos\hhblaze_DBreeze\DBreeze\Engine\Scheme.cs,DeleteAllReleatedTableFiles,The following statement contains a magic number: try              {                  //Deleting DB File                  if (File.Exists(fullTableFilePath))                      File.Delete(fullTableFilePath);                    //Deleting Rollback File                  if (File.Exists(fullTableFilePath + ".rol"))                      File.Delete(fullTableFilePath + ".rol");                    //Deleting Rollback Help File                  if (File.Exists(fullTableFilePath + ".rhp"))                      File.Delete(fullTableFilePath + ".rhp");                    /* Handling backup*/                  if (this.Engine.Configuration.Backup.IsActive)                  {                      string exactFileName = Path.GetFileName(fullTableFilePath);                      ulong ulFileName = this.Engine.Configuration.Backup.BackupFNP.ParseFilename(exactFileName);                      long backup_filePosition = 0;                      byte[] data = null;                      this.Engine.Configuration.Backup.WriteBackupElement(ulFileName' 5' backup_filePosition' data);                  }                  /*****************/                }              catch (Exception ex)              {                  //CASCADE                  throw ex;              }
Magic Number,DBreeze,Scheme,C:\repos\hhblaze_DBreeze\DBreeze\Engine\Scheme.cs,GetUserTableNamesStartingWith,The following statement contains a magic number: foreach (var row in LTrie.IterateForwardStartsWith(btKeyName' true' false))              {                  //try       //try-catch could be necessary in case if we acquire value' which was deleted by other thread. Here we don't acquire value.                  //{                  ret.Add(System.Text.Encoding.UTF8.GetString(row.Key).Substring(3));                  //}                  //catch                  //{}                                  }
Magic Number,DBreeze,Scheme,C:\repos\hhblaze_DBreeze\DBreeze\Engine\Scheme.cs,RenameTable,The following statement contains a magic number: for (; ; )              {                  if (_disposed)                      return;                    if (RenameTableInternal(oldUserTableName' newUserTableName))                      return;    #if NET35 || NETr40                  System.Threading.Thread.Sleep(200);  #else                  System.Threading.Tasks.Task.Delay(TimeSpan.FromMilliseconds(200));  #endif               }
Magic Number,DBreeze.LianaTrie,LTrieGenerationMap,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationMap.cs,Add,The following statement contains a magic number: if((_d.Length-1) < key)              {                  Array.Resize(ref _d' key*2);              }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,LTrieGenerationNode,The following statement contains a magic number: MaximumKidLineLength = 2 + DefaultPointerLen + (256 * (DefaultPointerLen + 2));
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,LTrieGenerationNode,The following statement contains a magic number: MaximumKidLineLength = 2 + DefaultPointerLen + (256 * (DefaultPointerLen + 2));
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,LTrieGenerationNode,The following statement contains a magic number: MaximumKidLineLength = 2 + DefaultPointerLen + (256 * (DefaultPointerLen + 2));
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,SetupKidWithValue,The following statement contains a magic number: if (lastElementOfTheKey)              {                  //We must setup Kid value                  if (!useExistingPointerToValue)     //Hack for oldKid link replacement                  {                      //Here we also can decide if kid existed' probably we could overwrite it (in total 3 places also in the bottom)                                        lKid = KidsInNode.GetKidValue();                                            if (!lKid.Exists)                      {                          tryToOverWrite = false;                          this._root.RecordsCount++;                      }                        WasUpdated = tryToOverWrite;                        if (WasUpdated && dontUpdateIfExists)                      {                          //Value exists' but we don't want to update it                          ptr = lKid.Ptr;                      }                      else                      {                          ptr = this.WriteKidValue(ref fullKey' ref value' tryToOverWrite' lKid.Ptr);                      }                  }                  else                      ptr = value;                    if (WasUpdated && dontUpdateIfExists)                  {                      //Value exists' but we don't want to update it                  }                  else                  {                      KidsInNode.AddKid(256' ptr);                  }                    res.ValueLink = ptr;                  res.IterateFurther = false;                  return res;              }              else              {                  //If element is not the last one                  //we have to check if its kid place already resides with some other value' if yes then we have to move further.                  //And also probably move further the element who resides its place.                  //finding empty slot for our value(s). If place is empty then we save our element.                    if (KidsInNode.ContainsKid(kid))                  {                      //When we Setup Old Kid we should never come here                        lKid = KidsInNode.GetKid(kid);                        if (!lKid.LinkToNode)                      {                          //Here we have link to the value                                                                                                    ptr = this._root.Tree.Cache.ReadKey(false' lKid.Ptr);                                                      if (fullKey._ByteArrayEquals(ptr))                          {                              //Insert key equals to storedKey' it means - UPDATE                                //We write for now always on the new place value and update reference                              WasUpdated = true;                                if (dontUpdateIfExists)                              {                                  ptr = lKid.Ptr;                              }                              else                              {                                  ptr = this.WriteKidValue(ref fullKey' ref value' true' lKid.Ptr);                                    KidsInNode.AddKid(kid' ptr);                              }                                res.ValueLink = ptr;                              res.IterateFurther = false;                              return res;                          }                          else                          {                              //Remembering old Key                              res.KeyOldKid = ptr;                              //Remembering old link                              res.ValPtrOldKid = KidsInNode.ReplaceValueLinkOnKidLink(kid);                          }                        }                                              res.IterateFurther = true;                      return res;                  }                  else                  {                      //Just save this one                      if (!useExistingPointerToValue)                      {                          //Here we also can decide if kid existed' probably we could overwrite it (2 places also check up there)                          lKid = KidsInNode.GetKid(kid);                            if (!lKid.Exists)                          {                              tryToOverWrite = false;                              this._root.RecordsCount++;                          }                            WasUpdated = tryToOverWrite;                            if (WasUpdated && dontUpdateIfExists)                          {                              //Value exists' but we don't want to update it                              ptr = lKid.Ptr;                          }                          else                          {                              ptr = this.WriteKidValue(ref fullKey' ref value' tryToOverWrite' lKid.Ptr);                          }                      }                      else                          ptr = value;       //Hack for oldKid link replacement                        if (WasUpdated && dontUpdateIfExists)                      {                          //Value exists' but we don't want to update it                      }                      else                      {                          KidsInNode.AddKid(kid' ptr);                      }                      res.ValueLink = ptr;                      res.IterateFurther = false;                      return res;                  }              }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,SetupKidWithValuePartially,The following statement contains a magic number: if (lastElementOfTheKey)              {                  //We must setup Kid value                  if (!useExistingPointerToValue)     //Hack for oldKid link replacement                  {                      //Here we also can decide if kid existed' probably we could overwrite it (in total 3 places also in the bottom)                                        lKid = KidsInNode.GetKidValue();                        if (!lKid.Exists)                      {                          tryToOverWrite = false;                          this._root.RecordsCount++;                      }                        WasUpdated = tryToOverWrite;                      ptr = this.WriteKidValuePartially(ref fullKey' ref value' tryToOverWrite' lKid.Ptr' startIndex' out valueStartPtr);                  }                  else                  {                      valueStartPtr = -1;                      ptr = value;                  }                    KidsInNode.AddKid(256' ptr);                  res.ValueLink = ptr;                  res.IterateFurther = false;                  return res;              }              else              {                                     if (KidsInNode.ContainsKid(kid))                  {                      //When we Setup Old Kid we should never come here                        lKid = KidsInNode.GetKid(kid);                        if (!lKid.LinkToNode)                      {                          //Here we have link to the value                            //We will check here if it's the same key                                           ptr = this._root.Tree.Cache.ReadKey(false' lKid.Ptr);                                             if (fullKey._ByteArrayEquals(ptr))                          {                              //Insert key equals to storedKey' it means - UPDATE                                //We write for now always on the new place value and update reference                              WasUpdated = true;                              ptr = this.WriteKidValuePartially(ref fullKey' ref value' true' lKid.Ptr' startIndex' out valueStartPtr);                                KidsInNode.AddKid(kid' ptr);                              res.ValueLink = ptr;                              res.IterateFurther = false;                              return res;                          }                          else                          {                              //Remembering old Key                              res.KeyOldKid = ptr;                              //Remembering old link                              res.ValPtrOldKid = KidsInNode.ReplaceValueLinkOnKidLink(kid);                          }                        }                        valueStartPtr = -1;                      res.IterateFurther = true;                      return res;                  }                  else                  {                      //Just save this one                      if (!useExistingPointerToValue)                      {                          //Here we also can decide if kid existed' probably we could overwrite it (2 places also check up there)                          lKid = KidsInNode.GetKid(kid);                            if (!lKid.Exists)                          {                              tryToOverWrite = false;                              this._root.RecordsCount++;                          }                            WasUpdated = tryToOverWrite;                          ptr = this.WriteKidValuePartially(ref fullKey' ref value' tryToOverWrite' lKid.Ptr' startIndex' out valueStartPtr);                      }                      else                      {                          valueStartPtr = -1;                          ptr = value;       //Hack for oldKid link replacement                      }                        KidsInNode.AddKid(kid' ptr);                      res.ValueLink = ptr;                      res.IterateFurther = false;                                          return res;                  }              }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: int initRead = 111;
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: byte[] btKeySize = new byte[] { data[1]' data[2] };
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: byte[] btValueSize = new byte[] { data[3]' data[4]' data[5]' data[6] };
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: byte[] btValueSize = new byte[] { data[3]' data[4]' data[5]' data[6] };
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: byte[] btValueSize = new byte[] { data[3]' data[4]' data[5]' data[6] };
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: byte[] btValueSize = new byte[] { data[3]' data[4]' data[5]' data[6] };
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: if ((data[3] & 0x80) > 0)              {                  //NULL                  valueSize = 0;              }              else              {                  valueSize = (int)btValueSize.To_UInt32_BigEndian();              }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                                         break;                  case 1:                      btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      totalReservedSize = (int)btTotalReservedSize.To_UInt32_BigEndian();                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                                         break;                  case 1:                      btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      totalReservedSize = (int)btTotalReservedSize.To_UInt32_BigEndian();                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                                         break;                  case 1:                      btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      totalReservedSize = (int)btTotalReservedSize.To_UInt32_BigEndian();                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                                         break;                  case 1:                      btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      totalReservedSize = (int)btTotalReservedSize.To_UInt32_BigEndian();                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) <= totalReservedSize)                                                if (newValueRealLength <= totalReservedSize)                                                {                      //OVERWRITE' LEAVING PROTOCOL 1                      //btValueSize = value.Length.To_4_bytes_array_BigEndian();                        /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      //Reading full                       /******************/                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                                            newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          //no need to make this operation here                          //oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        btTotalReservedSize = btValueSize;                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              newValue                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                    }              }              else              {                  //Protocol 0 (after first insert)                  /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) == valueSize)                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        //newData =                      //    new byte[] { 0 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                      {                          oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                                          /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        newData =                         new byte[] { 0 }.ConcatMany(                             btKeySize'                             btValueSize'                                                   fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 7 + fullKey.Length;                        return ptr;                  }                  ///*NULL SUPPORT*/                  //else if ((newValueRealLength + 4 + (int)startIndex) <= valueSize)                  //{                  //    //we can change protocol to 1' staying with this update on the same place                    //    //OVERWRITE CHANGING PROTOCOL TO 1                  //    btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                        //    //btValueSize = value.Length.To_4_bytes_array_BigEndian();                    //    //newData =                  //    //    new byte[] { 1 }.ConcatMany(                  //    //        btKeySize'                  //    //        btValueSize'                  //    //        btTotalReservedSize'                  //    //        fullKey'                  //    //        value                  //    //    );                    //    //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                  //    //Checking if old data already in memory' if not re-read PROTOCOL 1 here                  //    if (data.Length >= (7 + keySize + valueSize))                  //    {                  //        oldData = data.Substring(0' 7 + keySize + valueSize);                    //        oldValue = data.Substring(7 + keySize' valueSize);                   //    }                  //    else                  //    {                  //        oldData = this._root.Tree.Storage.Read(lPtr' 7 + keySize + valueSize);                    //        oldValue = oldData.Substring(7 + keySize' valueSize);                  //    }                      //    /*FORMING NEW DATA*/                  //    //For now we have to read the full value and copy into it our value                  //    /*NULL SUPPORT*/                  //    //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                  //    newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                  //    /**************/                                           //    btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                    //    newData =                  //       new byte[] { 1 }.ConcatMany(                  //           btKeySize'                  //           btValueSize'                  //           btTotalReservedSize'                  //           fullKey'                  //           newValue                  //   );                      //    //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                  //    //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                  //    /////////////////////////////////////////////////                    //    //this._root.Tree.Storage.WriteByOffset(ptr' newData);                    //    this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                    //    valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                    //    return ptr;                  //}                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        if (data.Length >= (7 + keySize + valueSize))                      {                          //no need to do this operation here' we don't store oldData                          //oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                      btTotalReservedSize = btValueSize;                        newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                                                    newValue                     );                        //btValueSize = value.Length.To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                        btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                  }                }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) <= totalReservedSize)                                                if (newValueRealLength <= totalReservedSize)                                                {                      //OVERWRITE' LEAVING PROTOCOL 1                      //btValueSize = value.Length.To_4_bytes_array_BigEndian();                        /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      //Reading full                       /******************/                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                                            newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          //no need to make this operation here                          //oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        btTotalReservedSize = btValueSize;                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              newValue                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                    }              }              else              {                  //Protocol 0 (after first insert)                  /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) == valueSize)                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        //newData =                      //    new byte[] { 0 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                      {                          oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                                          /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        newData =                         new byte[] { 0 }.ConcatMany(                             btKeySize'                             btValueSize'                                                   fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 7 + fullKey.Length;                        return ptr;                  }                  ///*NULL SUPPORT*/                  //else if ((newValueRealLength + 4 + (int)startIndex) <= valueSize)                  //{                  //    //we can change protocol to 1' staying with this update on the same place                    //    //OVERWRITE CHANGING PROTOCOL TO 1                  //    btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                        //    //btValueSize = value.Length.To_4_bytes_array_BigEndian();                    //    //newData =                  //    //    new byte[] { 1 }.ConcatMany(                  //    //        btKeySize'                  //    //        btValueSize'                  //    //        btTotalReservedSize'                  //    //        fullKey'                  //    //        value                  //    //    );                    //    //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                  //    //Checking if old data already in memory' if not re-read PROTOCOL 1 here                  //    if (data.Length >= (7 + keySize + valueSize))                  //    {                  //        oldData = data.Substring(0' 7 + keySize + valueSize);                    //        oldValue = data.Substring(7 + keySize' valueSize);                   //    }                  //    else                  //    {                  //        oldData = this._root.Tree.Storage.Read(lPtr' 7 + keySize + valueSize);                    //        oldValue = oldData.Substring(7 + keySize' valueSize);                  //    }                      //    /*FORMING NEW DATA*/                  //    //For now we have to read the full value and copy into it our value                  //    /*NULL SUPPORT*/                  //    //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                  //    newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                  //    /**************/                                           //    btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                    //    newData =                  //       new byte[] { 1 }.ConcatMany(                  //           btKeySize'                  //           btValueSize'                  //           btTotalReservedSize'                  //           fullKey'                  //           newValue                  //   );                      //    //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                  //    //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                  //    /////////////////////////////////////////////////                    //    //this._root.Tree.Storage.WriteByOffset(ptr' newData);                    //    this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                    //    valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                    //    return ptr;                  //}                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        if (data.Length >= (7 + keySize + valueSize))                      {                          //no need to do this operation here' we don't store oldData                          //oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                      btTotalReservedSize = btValueSize;                        newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                                                    newValue                     );                        //btValueSize = value.Length.To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                        btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                  }                }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) <= totalReservedSize)                                                if (newValueRealLength <= totalReservedSize)                                                {                      //OVERWRITE' LEAVING PROTOCOL 1                      //btValueSize = value.Length.To_4_bytes_array_BigEndian();                        /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      //Reading full                       /******************/                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                                            newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          //no need to make this operation here                          //oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        btTotalReservedSize = btValueSize;                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              newValue                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                    }              }              else              {                  //Protocol 0 (after first insert)                  /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) == valueSize)                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        //newData =                      //    new byte[] { 0 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                      {                          oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                                          /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        newData =                         new byte[] { 0 }.ConcatMany(                             btKeySize'                             btValueSize'                                                   fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 7 + fullKey.Length;                        return ptr;                  }                  ///*NULL SUPPORT*/                  //else if ((newValueRealLength + 4 + (int)startIndex) <= valueSize)                  //{                  //    //we can change protocol to 1' staying with this update on the same place                    //    //OVERWRITE CHANGING PROTOCOL TO 1                  //    btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                        //    //btValueSize = value.Length.To_4_bytes_array_BigEndian();                    //    //newData =                  //    //    new byte[] { 1 }.ConcatMany(                  //    //        btKeySize'                  //    //        btValueSize'                  //    //        btTotalReservedSize'                  //    //        fullKey'                  //    //        value                  //    //    );                    //    //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                  //    //Checking if old data already in memory' if not re-read PROTOCOL 1 here                  //    if (data.Length >= (7 + keySize + valueSize))                  //    {                  //        oldData = data.Substring(0' 7 + keySize + valueSize);                    //        oldValue = data.Substring(7 + keySize' valueSize);                   //    }                  //    else                  //    {                  //        oldData = this._root.Tree.Storage.Read(lPtr' 7 + keySize + valueSize);                    //        oldValue = oldData.Substring(7 + keySize' valueSize);                  //    }                      //    /*FORMING NEW DATA*/                  //    //For now we have to read the full value and copy into it our value                  //    /*NULL SUPPORT*/                  //    //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                  //    newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                  //    /**************/                                           //    btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                    //    newData =                  //       new byte[] { 1 }.ConcatMany(                  //           btKeySize'                  //           btValueSize'                  //           btTotalReservedSize'                  //           fullKey'                  //           newValue                  //   );                      //    //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                  //    //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                  //    /////////////////////////////////////////////////                    //    //this._root.Tree.Storage.WriteByOffset(ptr' newData);                    //    this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                    //    valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                    //    return ptr;                  //}                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        if (data.Length >= (7 + keySize + valueSize))                      {                          //no need to do this operation here' we don't store oldData                          //oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                      btTotalReservedSize = btValueSize;                        newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                                                    newValue                     );                        //btValueSize = value.Length.To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                        btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                  }                }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) <= totalReservedSize)                                                if (newValueRealLength <= totalReservedSize)                                                {                      //OVERWRITE' LEAVING PROTOCOL 1                      //btValueSize = value.Length.To_4_bytes_array_BigEndian();                        /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      //Reading full                       /******************/                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                                            newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          //no need to make this operation here                          //oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        btTotalReservedSize = btValueSize;                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              newValue                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                    }              }              else              {                  //Protocol 0 (after first insert)                  /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) == valueSize)                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        //newData =                      //    new byte[] { 0 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                      {                          oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                                          /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        newData =                         new byte[] { 0 }.ConcatMany(                             btKeySize'                             btValueSize'                                                   fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 7 + fullKey.Length;                        return ptr;                  }                  ///*NULL SUPPORT*/                  //else if ((newValueRealLength + 4 + (int)startIndex) <= valueSize)                  //{                  //    //we can change protocol to 1' staying with this update on the same place                    //    //OVERWRITE CHANGING PROTOCOL TO 1                  //    btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                        //    //btValueSize = value.Length.To_4_bytes_array_BigEndian();                    //    //newData =                  //    //    new byte[] { 1 }.ConcatMany(                  //    //        btKeySize'                  //    //        btValueSize'                  //    //        btTotalReservedSize'                  //    //        fullKey'                  //    //        value                  //    //    );                    //    //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                  //    //Checking if old data already in memory' if not re-read PROTOCOL 1 here                  //    if (data.Length >= (7 + keySize + valueSize))                  //    {                  //        oldData = data.Substring(0' 7 + keySize + valueSize);                    //        oldValue = data.Substring(7 + keySize' valueSize);                   //    }                  //    else                  //    {                  //        oldData = this._root.Tree.Storage.Read(lPtr' 7 + keySize + valueSize);                    //        oldValue = oldData.Substring(7 + keySize' valueSize);                  //    }                      //    /*FORMING NEW DATA*/                  //    //For now we have to read the full value and copy into it our value                  //    /*NULL SUPPORT*/                  //    //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                  //    newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                  //    /**************/                                           //    btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                    //    newData =                  //       new byte[] { 1 }.ConcatMany(                  //           btKeySize'                  //           btValueSize'                  //           btTotalReservedSize'                  //           fullKey'                  //           newValue                  //   );                      //    //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                  //    //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                  //    /////////////////////////////////////////////////                    //    //this._root.Tree.Storage.WriteByOffset(ptr' newData);                    //    this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                    //    valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                    //    return ptr;                  //}                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        if (data.Length >= (7 + keySize + valueSize))                      {                          //no need to do this operation here' we don't store oldData                          //oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                      btTotalReservedSize = btValueSize;                        newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                                                    newValue                     );                        //btValueSize = value.Length.To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                        btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                  }                }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) <= totalReservedSize)                                                if (newValueRealLength <= totalReservedSize)                                                {                      //OVERWRITE' LEAVING PROTOCOL 1                      //btValueSize = value.Length.To_4_bytes_array_BigEndian();                        /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      //Reading full                       /******************/                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                                            newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          //no need to make this operation here                          //oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        btTotalReservedSize = btValueSize;                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              newValue                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                    }              }              else              {                  //Protocol 0 (after first insert)                  /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) == valueSize)                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        //newData =                      //    new byte[] { 0 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                      {                          oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                                          /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        newData =                         new byte[] { 0 }.ConcatMany(                             btKeySize'                             btValueSize'                                                   fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 7 + fullKey.Length;                        return ptr;                  }                  ///*NULL SUPPORT*/                  //else if ((newValueRealLength + 4 + (int)startIndex) <= valueSize)                  //{                  //    //we can change protocol to 1' staying with this update on the same place                    //    //OVERWRITE CHANGING PROTOCOL TO 1                  //    btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                        //    //btValueSize = value.Length.To_4_bytes_array_BigEndian();                    //    //newData =                  //    //    new byte[] { 1 }.ConcatMany(                  //    //        btKeySize'                  //    //        btValueSize'                  //    //        btTotalReservedSize'                  //    //        fullKey'                  //    //        value                  //    //    );                    //    //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                  //    //Checking if old data already in memory' if not re-read PROTOCOL 1 here                  //    if (data.Length >= (7 + keySize + valueSize))                  //    {                  //        oldData = data.Substring(0' 7 + keySize + valueSize);                    //        oldValue = data.Substring(7 + keySize' valueSize);                   //    }                  //    else                  //    {                  //        oldData = this._root.Tree.Storage.Read(lPtr' 7 + keySize + valueSize);                    //        oldValue = oldData.Substring(7 + keySize' valueSize);                  //    }                      //    /*FORMING NEW DATA*/                  //    //For now we have to read the full value and copy into it our value                  //    /*NULL SUPPORT*/                  //    //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                  //    newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                  //    /**************/                                           //    btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                    //    newData =                  //       new byte[] { 1 }.ConcatMany(                  //           btKeySize'                  //           btValueSize'                  //           btTotalReservedSize'                  //           fullKey'                  //           newValue                  //   );                      //    //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                  //    //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                  //    /////////////////////////////////////////////////                    //    //this._root.Tree.Storage.WriteByOffset(ptr' newData);                    //    this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                    //    valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                    //    return ptr;                  //}                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        if (data.Length >= (7 + keySize + valueSize))                      {                          //no need to do this operation here' we don't store oldData                          //oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                      btTotalReservedSize = btValueSize;                        newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                                                    newValue                     );                        //btValueSize = value.Length.To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                        btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                  }                }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) <= totalReservedSize)                                                if (newValueRealLength <= totalReservedSize)                                                {                      //OVERWRITE' LEAVING PROTOCOL 1                      //btValueSize = value.Length.To_4_bytes_array_BigEndian();                        /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      //Reading full                       /******************/                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                                            newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          //no need to make this operation here                          //oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        btTotalReservedSize = btValueSize;                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              newValue                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                    }              }              else              {                  //Protocol 0 (after first insert)                  /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) == valueSize)                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        //newData =                      //    new byte[] { 0 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                      {                          oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                                          /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        newData =                         new byte[] { 0 }.ConcatMany(                             btKeySize'                             btValueSize'                                                   fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 7 + fullKey.Length;                        return ptr;                  }                  ///*NULL SUPPORT*/                  //else if ((newValueRealLength + 4 + (int)startIndex) <= valueSize)                  //{                  //    //we can change protocol to 1' staying with this update on the same place                    //    //OVERWRITE CHANGING PROTOCOL TO 1                  //    btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                        //    //btValueSize = value.Length.To_4_bytes_array_BigEndian();                    //    //newData =                  //    //    new byte[] { 1 }.ConcatMany(                  //    //        btKeySize'                  //    //        btValueSize'                  //    //        btTotalReservedSize'                  //    //        fullKey'                  //    //        value                  //    //    );                    //    //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                  //    //Checking if old data already in memory' if not re-read PROTOCOL 1 here                  //    if (data.Length >= (7 + keySize + valueSize))                  //    {                  //        oldData = data.Substring(0' 7 + keySize + valueSize);                    //        oldValue = data.Substring(7 + keySize' valueSize);                   //    }                  //    else                  //    {                  //        oldData = this._root.Tree.Storage.Read(lPtr' 7 + keySize + valueSize);                    //        oldValue = oldData.Substring(7 + keySize' valueSize);                  //    }                      //    /*FORMING NEW DATA*/                  //    //For now we have to read the full value and copy into it our value                  //    /*NULL SUPPORT*/                  //    //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                  //    newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                  //    /**************/                                           //    btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                    //    newData =                  //       new byte[] { 1 }.ConcatMany(                  //           btKeySize'                  //           btValueSize'                  //           btTotalReservedSize'                  //           fullKey'                  //           newValue                  //   );                      //    //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                  //    //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                  //    /////////////////////////////////////////////////                    //    //this._root.Tree.Storage.WriteByOffset(ptr' newData);                    //    this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                    //    valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                    //    return ptr;                  //}                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        if (data.Length >= (7 + keySize + valueSize))                      {                          //no need to do this operation here' we don't store oldData                          //oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                      btTotalReservedSize = btValueSize;                        newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                                                    newValue                     );                        //btValueSize = value.Length.To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                        btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                  }                }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) <= totalReservedSize)                                                if (newValueRealLength <= totalReservedSize)                                                {                      //OVERWRITE' LEAVING PROTOCOL 1                      //btValueSize = value.Length.To_4_bytes_array_BigEndian();                        /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      //Reading full                       /******************/                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                                            newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          //no need to make this operation here                          //oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        btTotalReservedSize = btValueSize;                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              newValue                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                    }              }              else              {                  //Protocol 0 (after first insert)                  /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) == valueSize)                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        //newData =                      //    new byte[] { 0 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                      {                          oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                                          /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        newData =                         new byte[] { 0 }.ConcatMany(                             btKeySize'                             btValueSize'                                                   fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 7 + fullKey.Length;                        return ptr;                  }                  ///*NULL SUPPORT*/                  //else if ((newValueRealLength + 4 + (int)startIndex) <= valueSize)                  //{                  //    //we can change protocol to 1' staying with this update on the same place                    //    //OVERWRITE CHANGING PROTOCOL TO 1                  //    btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                        //    //btValueSize = value.Length.To_4_bytes_array_BigEndian();                    //    //newData =                  //    //    new byte[] { 1 }.ConcatMany(                  //    //        btKeySize'                  //    //        btValueSize'                  //    //        btTotalReservedSize'                  //    //        fullKey'                  //    //        value                  //    //    );                    //    //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                  //    //Checking if old data already in memory' if not re-read PROTOCOL 1 here                  //    if (data.Length >= (7 + keySize + valueSize))                  //    {                  //        oldData = data.Substring(0' 7 + keySize + valueSize);                    //        oldValue = data.Substring(7 + keySize' valueSize);                   //    }                  //    else                  //    {                  //        oldData = this._root.Tree.Storage.Read(lPtr' 7 + keySize + valueSize);                    //        oldValue = oldData.Substring(7 + keySize' valueSize);                  //    }                      //    /*FORMING NEW DATA*/                  //    //For now we have to read the full value and copy into it our value                  //    /*NULL SUPPORT*/                  //    //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                  //    newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                  //    /**************/                                           //    btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                    //    newData =                  //       new byte[] { 1 }.ConcatMany(                  //           btKeySize'                  //           btValueSize'                  //           btTotalReservedSize'                  //           fullKey'                  //           newValue                  //   );                      //    //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                  //    //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                  //    /////////////////////////////////////////////////                    //    //this._root.Tree.Storage.WriteByOffset(ptr' newData);                    //    this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                    //    valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                    //    return ptr;                  //}                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        if (data.Length >= (7 + keySize + valueSize))                      {                          //no need to do this operation here' we don't store oldData                          //oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                      btTotalReservedSize = btValueSize;                        newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                                                    newValue                     );                        //btValueSize = value.Length.To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                        btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                  }                }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) <= totalReservedSize)                                                if (newValueRealLength <= totalReservedSize)                                                {                      //OVERWRITE' LEAVING PROTOCOL 1                      //btValueSize = value.Length.To_4_bytes_array_BigEndian();                        /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      //Reading full                       /******************/                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                                            newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          //no need to make this operation here                          //oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        btTotalReservedSize = btValueSize;                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              newValue                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                    }              }              else              {                  //Protocol 0 (after first insert)                  /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) == valueSize)                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        //newData =                      //    new byte[] { 0 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                      {                          oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                                          /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        newData =                         new byte[] { 0 }.ConcatMany(                             btKeySize'                             btValueSize'                                                   fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 7 + fullKey.Length;                        return ptr;                  }                  ///*NULL SUPPORT*/                  //else if ((newValueRealLength + 4 + (int)startIndex) <= valueSize)                  //{                  //    //we can change protocol to 1' staying with this update on the same place                    //    //OVERWRITE CHANGING PROTOCOL TO 1                  //    btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                        //    //btValueSize = value.Length.To_4_bytes_array_BigEndian();                    //    //newData =                  //    //    new byte[] { 1 }.ConcatMany(                  //    //        btKeySize'                  //    //        btValueSize'                  //    //        btTotalReservedSize'                  //    //        fullKey'                  //    //        value                  //    //    );                    //    //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                  //    //Checking if old data already in memory' if not re-read PROTOCOL 1 here                  //    if (data.Length >= (7 + keySize + valueSize))                  //    {                  //        oldData = data.Substring(0' 7 + keySize + valueSize);                    //        oldValue = data.Substring(7 + keySize' valueSize);                   //    }                  //    else                  //    {                  //        oldData = this._root.Tree.Storage.Read(lPtr' 7 + keySize + valueSize);                    //        oldValue = oldData.Substring(7 + keySize' valueSize);                  //    }                      //    /*FORMING NEW DATA*/                  //    //For now we have to read the full value and copy into it our value                  //    /*NULL SUPPORT*/                  //    //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                  //    newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                  //    /**************/                                           //    btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                    //    newData =                  //       new byte[] { 1 }.ConcatMany(                  //           btKeySize'                  //           btValueSize'                  //           btTotalReservedSize'                  //           fullKey'                  //           newValue                  //   );                      //    //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                  //    //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                  //    /////////////////////////////////////////////////                    //    //this._root.Tree.Storage.WriteByOffset(ptr' newData);                    //    this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                    //    valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                    //    return ptr;                  //}                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        if (data.Length >= (7 + keySize + valueSize))                      {                          //no need to do this operation here' we don't store oldData                          //oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                      btTotalReservedSize = btValueSize;                        newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                                                    newValue                     );                        //btValueSize = value.Length.To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                        btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                  }                }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) <= totalReservedSize)                                                if (newValueRealLength <= totalReservedSize)                                                {                      //OVERWRITE' LEAVING PROTOCOL 1                      //btValueSize = value.Length.To_4_bytes_array_BigEndian();                        /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      //Reading full                       /******************/                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                                            newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          //no need to make this operation here                          //oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        btTotalReservedSize = btValueSize;                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              newValue                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                    }              }              else              {                  //Protocol 0 (after first insert)                  /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) == valueSize)                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        //newData =                      //    new byte[] { 0 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                      {                          oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                                          /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        newData =                         new byte[] { 0 }.ConcatMany(                             btKeySize'                             btValueSize'                                                   fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 7 + fullKey.Length;                        return ptr;                  }                  ///*NULL SUPPORT*/                  //else if ((newValueRealLength + 4 + (int)startIndex) <= valueSize)                  //{                  //    //we can change protocol to 1' staying with this update on the same place                    //    //OVERWRITE CHANGING PROTOCOL TO 1                  //    btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                        //    //btValueSize = value.Length.To_4_bytes_array_BigEndian();                    //    //newData =                  //    //    new byte[] { 1 }.ConcatMany(                  //    //        btKeySize'                  //    //        btValueSize'                  //    //        btTotalReservedSize'                  //    //        fullKey'                  //    //        value                  //    //    );                    //    //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                  //    //Checking if old data already in memory' if not re-read PROTOCOL 1 here                  //    if (data.Length >= (7 + keySize + valueSize))                  //    {                  //        oldData = data.Substring(0' 7 + keySize + valueSize);                    //        oldValue = data.Substring(7 + keySize' valueSize);                   //    }                  //    else                  //    {                  //        oldData = this._root.Tree.Storage.Read(lPtr' 7 + keySize + valueSize);                    //        oldValue = oldData.Substring(7 + keySize' valueSize);                  //    }                      //    /*FORMING NEW DATA*/                  //    //For now we have to read the full value and copy into it our value                  //    /*NULL SUPPORT*/                  //    //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                  //    newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                  //    /**************/                                           //    btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                    //    newData =                  //       new byte[] { 1 }.ConcatMany(                  //           btKeySize'                  //           btValueSize'                  //           btTotalReservedSize'                  //           fullKey'                  //           newValue                  //   );                      //    //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                  //    //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                  //    /////////////////////////////////////////////////                    //    //this._root.Tree.Storage.WriteByOffset(ptr' newData);                    //    this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                    //    valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                    //    return ptr;                  //}                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        if (data.Length >= (7 + keySize + valueSize))                      {                          //no need to do this operation here' we don't store oldData                          //oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                      btTotalReservedSize = btValueSize;                        newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                                                    newValue                     );                        //btValueSize = value.Length.To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                        btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                  }                }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) <= totalReservedSize)                                                if (newValueRealLength <= totalReservedSize)                                                {                      //OVERWRITE' LEAVING PROTOCOL 1                      //btValueSize = value.Length.To_4_bytes_array_BigEndian();                        /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      //Reading full                       /******************/                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                                            newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          //no need to make this operation here                          //oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        btTotalReservedSize = btValueSize;                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              newValue                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                    }              }              else              {                  //Protocol 0 (after first insert)                  /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) == valueSize)                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        //newData =                      //    new byte[] { 0 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                      {                          oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                                          /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        newData =                         new byte[] { 0 }.ConcatMany(                             btKeySize'                             btValueSize'                                                   fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 7 + fullKey.Length;                        return ptr;                  }                  ///*NULL SUPPORT*/                  //else if ((newValueRealLength + 4 + (int)startIndex) <= valueSize)                  //{                  //    //we can change protocol to 1' staying with this update on the same place                    //    //OVERWRITE CHANGING PROTOCOL TO 1                  //    btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                        //    //btValueSize = value.Length.To_4_bytes_array_BigEndian();                    //    //newData =                  //    //    new byte[] { 1 }.ConcatMany(                  //    //        btKeySize'                  //    //        btValueSize'                  //    //        btTotalReservedSize'                  //    //        fullKey'                  //    //        value                  //    //    );                    //    //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                  //    //Checking if old data already in memory' if not re-read PROTOCOL 1 here                  //    if (data.Length >= (7 + keySize + valueSize))                  //    {                  //        oldData = data.Substring(0' 7 + keySize + valueSize);                    //        oldValue = data.Substring(7 + keySize' valueSize);                   //    }                  //    else                  //    {                  //        oldData = this._root.Tree.Storage.Read(lPtr' 7 + keySize + valueSize);                    //        oldValue = oldData.Substring(7 + keySize' valueSize);                  //    }                      //    /*FORMING NEW DATA*/                  //    //For now we have to read the full value and copy into it our value                  //    /*NULL SUPPORT*/                  //    //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                  //    newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                  //    /**************/                                           //    btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                    //    newData =                  //       new byte[] { 1 }.ConcatMany(                  //           btKeySize'                  //           btValueSize'                  //           btTotalReservedSize'                  //           fullKey'                  //           newValue                  //   );                      //    //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                  //    //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                  //    /////////////////////////////////////////////////                    //    //this._root.Tree.Storage.WriteByOffset(ptr' newData);                    //    this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                    //    valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                    //    return ptr;                  //}                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        if (data.Length >= (7 + keySize + valueSize))                      {                          //no need to do this operation here' we don't store oldData                          //oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                      btTotalReservedSize = btValueSize;                        newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                                                    newValue                     );                        //btValueSize = value.Length.To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                        btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                  }                }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) <= totalReservedSize)                                                if (newValueRealLength <= totalReservedSize)                                                {                      //OVERWRITE' LEAVING PROTOCOL 1                      //btValueSize = value.Length.To_4_bytes_array_BigEndian();                        /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      //Reading full                       /******************/                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                                            newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          //no need to make this operation here                          //oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        btTotalReservedSize = btValueSize;                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              newValue                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                    }              }              else              {                  //Protocol 0 (after first insert)                  /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) == valueSize)                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        //newData =                      //    new byte[] { 0 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                      {                          oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                                          /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        newData =                         new byte[] { 0 }.ConcatMany(                             btKeySize'                             btValueSize'                                                   fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 7 + fullKey.Length;                        return ptr;                  }                  ///*NULL SUPPORT*/                  //else if ((newValueRealLength + 4 + (int)startIndex) <= valueSize)                  //{                  //    //we can change protocol to 1' staying with this update on the same place                    //    //OVERWRITE CHANGING PROTOCOL TO 1                  //    btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                        //    //btValueSize = value.Length.To_4_bytes_array_BigEndian();                    //    //newData =                  //    //    new byte[] { 1 }.ConcatMany(                  //    //        btKeySize'                  //    //        btValueSize'                  //    //        btTotalReservedSize'                  //    //        fullKey'                  //    //        value                  //    //    );                    //    //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                  //    //Checking if old data already in memory' if not re-read PROTOCOL 1 here                  //    if (data.Length >= (7 + keySize + valueSize))                  //    {                  //        oldData = data.Substring(0' 7 + keySize + valueSize);                    //        oldValue = data.Substring(7 + keySize' valueSize);                   //    }                  //    else                  //    {                  //        oldData = this._root.Tree.Storage.Read(lPtr' 7 + keySize + valueSize);                    //        oldValue = oldData.Substring(7 + keySize' valueSize);                  //    }                      //    /*FORMING NEW DATA*/                  //    //For now we have to read the full value and copy into it our value                  //    /*NULL SUPPORT*/                  //    //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                  //    newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                  //    /**************/                                           //    btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                    //    newData =                  //       new byte[] { 1 }.ConcatMany(                  //           btKeySize'                  //           btValueSize'                  //           btTotalReservedSize'                  //           fullKey'                  //           newValue                  //   );                      //    //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                  //    //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                  //    /////////////////////////////////////////////////                    //    //this._root.Tree.Storage.WriteByOffset(ptr' newData);                    //    this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                    //    valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                    //    return ptr;                  //}                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        if (data.Length >= (7 + keySize + valueSize))                      {                          //no need to do this operation here' we don't store oldData                          //oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                      btTotalReservedSize = btValueSize;                        newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                                                    newValue                     );                        //btValueSize = value.Length.To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                        btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                  }                }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) <= totalReservedSize)                                                if (newValueRealLength <= totalReservedSize)                                                {                      //OVERWRITE' LEAVING PROTOCOL 1                      //btValueSize = value.Length.To_4_bytes_array_BigEndian();                        /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      //Reading full                       /******************/                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                                            newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          //no need to make this operation here                          //oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        btTotalReservedSize = btValueSize;                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              newValue                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                    }              }              else              {                  //Protocol 0 (after first insert)                  /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) == valueSize)                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        //newData =                      //    new byte[] { 0 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                      {                          oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                                          /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        newData =                         new byte[] { 0 }.ConcatMany(                             btKeySize'                             btValueSize'                                                   fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 7 + fullKey.Length;                        return ptr;                  }                  ///*NULL SUPPORT*/                  //else if ((newValueRealLength + 4 + (int)startIndex) <= valueSize)                  //{                  //    //we can change protocol to 1' staying with this update on the same place                    //    //OVERWRITE CHANGING PROTOCOL TO 1                  //    btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                        //    //btValueSize = value.Length.To_4_bytes_array_BigEndian();                    //    //newData =                  //    //    new byte[] { 1 }.ConcatMany(                  //    //        btKeySize'                  //    //        btValueSize'                  //    //        btTotalReservedSize'                  //    //        fullKey'                  //    //        value                  //    //    );                    //    //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                  //    //Checking if old data already in memory' if not re-read PROTOCOL 1 here                  //    if (data.Length >= (7 + keySize + valueSize))                  //    {                  //        oldData = data.Substring(0' 7 + keySize + valueSize);                    //        oldValue = data.Substring(7 + keySize' valueSize);                   //    }                  //    else                  //    {                  //        oldData = this._root.Tree.Storage.Read(lPtr' 7 + keySize + valueSize);                    //        oldValue = oldData.Substring(7 + keySize' valueSize);                  //    }                      //    /*FORMING NEW DATA*/                  //    //For now we have to read the full value and copy into it our value                  //    /*NULL SUPPORT*/                  //    //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                  //    newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                  //    /**************/                                           //    btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                    //    newData =                  //       new byte[] { 1 }.ConcatMany(                  //           btKeySize'                  //           btValueSize'                  //           btTotalReservedSize'                  //           fullKey'                  //           newValue                  //   );                      //    //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                  //    //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                  //    /////////////////////////////////////////////////                    //    //this._root.Tree.Storage.WriteByOffset(ptr' newData);                    //    this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                    //    valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                    //    return ptr;                  //}                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        if (data.Length >= (7 + keySize + valueSize))                      {                          //no need to do this operation here' we don't store oldData                          //oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                      btTotalReservedSize = btValueSize;                        newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                                                    newValue                     );                        //btValueSize = value.Length.To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                        btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                  }                }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) <= totalReservedSize)                                                if (newValueRealLength <= totalReservedSize)                                                {                      //OVERWRITE' LEAVING PROTOCOL 1                      //btValueSize = value.Length.To_4_bytes_array_BigEndian();                        /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      //Reading full                       /******************/                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                                            newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          //no need to make this operation here                          //oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        btTotalReservedSize = btValueSize;                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              newValue                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                    }              }              else              {                  //Protocol 0 (after first insert)                  /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) == valueSize)                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        //newData =                      //    new byte[] { 0 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                      {                          oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                                          /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        newData =                         new byte[] { 0 }.ConcatMany(                             btKeySize'                             btValueSize'                                                   fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 7 + fullKey.Length;                        return ptr;                  }                  ///*NULL SUPPORT*/                  //else if ((newValueRealLength + 4 + (int)startIndex) <= valueSize)                  //{                  //    //we can change protocol to 1' staying with this update on the same place                    //    //OVERWRITE CHANGING PROTOCOL TO 1                  //    btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                        //    //btValueSize = value.Length.To_4_bytes_array_BigEndian();                    //    //newData =                  //    //    new byte[] { 1 }.ConcatMany(                  //    //        btKeySize'                  //    //        btValueSize'                  //    //        btTotalReservedSize'                  //    //        fullKey'                  //    //        value                  //    //    );                    //    //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                  //    //Checking if old data already in memory' if not re-read PROTOCOL 1 here                  //    if (data.Length >= (7 + keySize + valueSize))                  //    {                  //        oldData = data.Substring(0' 7 + keySize + valueSize);                    //        oldValue = data.Substring(7 + keySize' valueSize);                   //    }                  //    else                  //    {                  //        oldData = this._root.Tree.Storage.Read(lPtr' 7 + keySize + valueSize);                    //        oldValue = oldData.Substring(7 + keySize' valueSize);                  //    }                      //    /*FORMING NEW DATA*/                  //    //For now we have to read the full value and copy into it our value                  //    /*NULL SUPPORT*/                  //    //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                  //    newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                  //    /**************/                                           //    btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                    //    newData =                  //       new byte[] { 1 }.ConcatMany(                  //           btKeySize'                  //           btValueSize'                  //           btTotalReservedSize'                  //           fullKey'                  //           newValue                  //   );                      //    //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                  //    //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                  //    /////////////////////////////////////////////////                    //    //this._root.Tree.Storage.WriteByOffset(ptr' newData);                    //    this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                    //    valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                    //    return ptr;                  //}                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        if (data.Length >= (7 + keySize + valueSize))                      {                          //no need to do this operation here' we don't store oldData                          //oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                      btTotalReservedSize = btValueSize;                        newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                                                    newValue                     );                        //btValueSize = value.Length.To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                        btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                  }                }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) <= totalReservedSize)                                                if (newValueRealLength <= totalReservedSize)                                                {                      //OVERWRITE' LEAVING PROTOCOL 1                      //btValueSize = value.Length.To_4_bytes_array_BigEndian();                        /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      //Reading full                       /******************/                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                                            newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          //no need to make this operation here                          //oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        btTotalReservedSize = btValueSize;                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              newValue                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                    }              }              else              {                  //Protocol 0 (after first insert)                  /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) == valueSize)                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        //newData =                      //    new byte[] { 0 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                      {                          oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                                          /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        newData =                         new byte[] { 0 }.ConcatMany(                             btKeySize'                             btValueSize'                                                   fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 7 + fullKey.Length;                        return ptr;                  }                  ///*NULL SUPPORT*/                  //else if ((newValueRealLength + 4 + (int)startIndex) <= valueSize)                  //{                  //    //we can change protocol to 1' staying with this update on the same place                    //    //OVERWRITE CHANGING PROTOCOL TO 1                  //    btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                        //    //btValueSize = value.Length.To_4_bytes_array_BigEndian();                    //    //newData =                  //    //    new byte[] { 1 }.ConcatMany(                  //    //        btKeySize'                  //    //        btValueSize'                  //    //        btTotalReservedSize'                  //    //        fullKey'                  //    //        value                  //    //    );                    //    //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                  //    //Checking if old data already in memory' if not re-read PROTOCOL 1 here                  //    if (data.Length >= (7 + keySize + valueSize))                  //    {                  //        oldData = data.Substring(0' 7 + keySize + valueSize);                    //        oldValue = data.Substring(7 + keySize' valueSize);                   //    }                  //    else                  //    {                  //        oldData = this._root.Tree.Storage.Read(lPtr' 7 + keySize + valueSize);                    //        oldValue = oldData.Substring(7 + keySize' valueSize);                  //    }                      //    /*FORMING NEW DATA*/                  //    //For now we have to read the full value and copy into it our value                  //    /*NULL SUPPORT*/                  //    //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                  //    newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                  //    /**************/                                           //    btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                    //    newData =                  //       new byte[] { 1 }.ConcatMany(                  //           btKeySize'                  //           btValueSize'                  //           btTotalReservedSize'                  //           fullKey'                  //           newValue                  //   );                      //    //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                  //    //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                  //    /////////////////////////////////////////////////                    //    //this._root.Tree.Storage.WriteByOffset(ptr' newData);                    //    this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                    //    valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                    //    return ptr;                  //}                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        if (data.Length >= (7 + keySize + valueSize))                      {                          //no need to do this operation here' we don't store oldData                          //oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                      btTotalReservedSize = btValueSize;                        newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                                                    newValue                     );                        //btValueSize = value.Length.To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                        btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                  }                }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) <= totalReservedSize)                                                if (newValueRealLength <= totalReservedSize)                                                {                      //OVERWRITE' LEAVING PROTOCOL 1                      //btValueSize = value.Length.To_4_bytes_array_BigEndian();                        /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      //Reading full                       /******************/                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                                            newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          //no need to make this operation here                          //oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        btTotalReservedSize = btValueSize;                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              newValue                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                    }              }              else              {                  //Protocol 0 (after first insert)                  /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) == valueSize)                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        //newData =                      //    new byte[] { 0 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                      {                          oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                                          /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        newData =                         new byte[] { 0 }.ConcatMany(                             btKeySize'                             btValueSize'                                                   fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 7 + fullKey.Length;                        return ptr;                  }                  ///*NULL SUPPORT*/                  //else if ((newValueRealLength + 4 + (int)startIndex) <= valueSize)                  //{                  //    //we can change protocol to 1' staying with this update on the same place                    //    //OVERWRITE CHANGING PROTOCOL TO 1                  //    btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                        //    //btValueSize = value.Length.To_4_bytes_array_BigEndian();                    //    //newData =                  //    //    new byte[] { 1 }.ConcatMany(                  //    //        btKeySize'                  //    //        btValueSize'                  //    //        btTotalReservedSize'                  //    //        fullKey'                  //    //        value                  //    //    );                    //    //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                  //    //Checking if old data already in memory' if not re-read PROTOCOL 1 here                  //    if (data.Length >= (7 + keySize + valueSize))                  //    {                  //        oldData = data.Substring(0' 7 + keySize + valueSize);                    //        oldValue = data.Substring(7 + keySize' valueSize);                   //    }                  //    else                  //    {                  //        oldData = this._root.Tree.Storage.Read(lPtr' 7 + keySize + valueSize);                    //        oldValue = oldData.Substring(7 + keySize' valueSize);                  //    }                      //    /*FORMING NEW DATA*/                  //    //For now we have to read the full value and copy into it our value                  //    /*NULL SUPPORT*/                  //    //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                  //    newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                  //    /**************/                                           //    btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                    //    newData =                  //       new byte[] { 1 }.ConcatMany(                  //           btKeySize'                  //           btValueSize'                  //           btTotalReservedSize'                  //           fullKey'                  //           newValue                  //   );                      //    //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                  //    //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                  //    /////////////////////////////////////////////////                    //    //this._root.Tree.Storage.WriteByOffset(ptr' newData);                    //    this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                    //    valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                    //    return ptr;                  //}                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        if (data.Length >= (7 + keySize + valueSize))                      {                          //no need to do this operation here' we don't store oldData                          //oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                      btTotalReservedSize = btValueSize;                        newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                                                    newValue                     );                        //btValueSize = value.Length.To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                        btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                  }                }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) <= totalReservedSize)                                                if (newValueRealLength <= totalReservedSize)                                                {                      //OVERWRITE' LEAVING PROTOCOL 1                      //btValueSize = value.Length.To_4_bytes_array_BigEndian();                        /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      //Reading full                       /******************/                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                                            newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          //no need to make this operation here                          //oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        btTotalReservedSize = btValueSize;                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              newValue                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                    }              }              else              {                  //Protocol 0 (after first insert)                  /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) == valueSize)                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        //newData =                      //    new byte[] { 0 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                      {                          oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                                          /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        newData =                         new byte[] { 0 }.ConcatMany(                             btKeySize'                             btValueSize'                                                   fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 7 + fullKey.Length;                        return ptr;                  }                  ///*NULL SUPPORT*/                  //else if ((newValueRealLength + 4 + (int)startIndex) <= valueSize)                  //{                  //    //we can change protocol to 1' staying with this update on the same place                    //    //OVERWRITE CHANGING PROTOCOL TO 1                  //    btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                        //    //btValueSize = value.Length.To_4_bytes_array_BigEndian();                    //    //newData =                  //    //    new byte[] { 1 }.ConcatMany(                  //    //        btKeySize'                  //    //        btValueSize'                  //    //        btTotalReservedSize'                  //    //        fullKey'                  //    //        value                  //    //    );                    //    //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                  //    //Checking if old data already in memory' if not re-read PROTOCOL 1 here                  //    if (data.Length >= (7 + keySize + valueSize))                  //    {                  //        oldData = data.Substring(0' 7 + keySize + valueSize);                    //        oldValue = data.Substring(7 + keySize' valueSize);                   //    }                  //    else                  //    {                  //        oldData = this._root.Tree.Storage.Read(lPtr' 7 + keySize + valueSize);                    //        oldValue = oldData.Substring(7 + keySize' valueSize);                  //    }                      //    /*FORMING NEW DATA*/                  //    //For now we have to read the full value and copy into it our value                  //    /*NULL SUPPORT*/                  //    //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                  //    newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                  //    /**************/                                           //    btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                    //    newData =                  //       new byte[] { 1 }.ConcatMany(                  //           btKeySize'                  //           btValueSize'                  //           btTotalReservedSize'                  //           fullKey'                  //           newValue                  //   );                      //    //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                  //    //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                  //    /////////////////////////////////////////////////                    //    //this._root.Tree.Storage.WriteByOffset(ptr' newData);                    //    this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                    //    valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                    //    return ptr;                  //}                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        if (data.Length >= (7 + keySize + valueSize))                      {                          //no need to do this operation here' we don't store oldData                          //oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                      btTotalReservedSize = btValueSize;                        newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                                                    newValue                     );                        //btValueSize = value.Length.To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                        btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                  }                }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) <= totalReservedSize)                                                if (newValueRealLength <= totalReservedSize)                                                {                      //OVERWRITE' LEAVING PROTOCOL 1                      //btValueSize = value.Length.To_4_bytes_array_BigEndian();                        /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      //Reading full                       /******************/                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                                            newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          //no need to make this operation here                          //oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        btTotalReservedSize = btValueSize;                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              newValue                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                    }              }              else              {                  //Protocol 0 (after first insert)                  /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) == valueSize)                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        //newData =                      //    new byte[] { 0 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                      {                          oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                                          /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        newData =                         new byte[] { 0 }.ConcatMany(                             btKeySize'                             btValueSize'                                                   fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 7 + fullKey.Length;                        return ptr;                  }                  ///*NULL SUPPORT*/                  //else if ((newValueRealLength + 4 + (int)startIndex) <= valueSize)                  //{                  //    //we can change protocol to 1' staying with this update on the same place                    //    //OVERWRITE CHANGING PROTOCOL TO 1                  //    btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                        //    //btValueSize = value.Length.To_4_bytes_array_BigEndian();                    //    //newData =                  //    //    new byte[] { 1 }.ConcatMany(                  //    //        btKeySize'                  //    //        btValueSize'                  //    //        btTotalReservedSize'                  //    //        fullKey'                  //    //        value                  //    //    );                    //    //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                  //    //Checking if old data already in memory' if not re-read PROTOCOL 1 here                  //    if (data.Length >= (7 + keySize + valueSize))                  //    {                  //        oldData = data.Substring(0' 7 + keySize + valueSize);                    //        oldValue = data.Substring(7 + keySize' valueSize);                   //    }                  //    else                  //    {                  //        oldData = this._root.Tree.Storage.Read(lPtr' 7 + keySize + valueSize);                    //        oldValue = oldData.Substring(7 + keySize' valueSize);                  //    }                      //    /*FORMING NEW DATA*/                  //    //For now we have to read the full value and copy into it our value                  //    /*NULL SUPPORT*/                  //    //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                  //    newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                  //    /**************/                                           //    btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                    //    newData =                  //       new byte[] { 1 }.ConcatMany(                  //           btKeySize'                  //           btValueSize'                  //           btTotalReservedSize'                  //           fullKey'                  //           newValue                  //   );                      //    //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                  //    //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                  //    /////////////////////////////////////////////////                    //    //this._root.Tree.Storage.WriteByOffset(ptr' newData);                    //    this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                    //    valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                    //    return ptr;                  //}                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        if (data.Length >= (7 + keySize + valueSize))                      {                          //no need to do this operation here' we don't store oldData                          //oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                      btTotalReservedSize = btValueSize;                        newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                                                    newValue                     );                        //btValueSize = value.Length.To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                        btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                  }                }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) <= totalReservedSize)                                                if (newValueRealLength <= totalReservedSize)                                                {                      //OVERWRITE' LEAVING PROTOCOL 1                      //btValueSize = value.Length.To_4_bytes_array_BigEndian();                        /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      //Reading full                       /******************/                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                                            newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          //no need to make this operation here                          //oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        btTotalReservedSize = btValueSize;                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              newValue                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                    }              }              else              {                  //Protocol 0 (after first insert)                  /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) == valueSize)                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        //newData =                      //    new byte[] { 0 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                      {                          oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                                          /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        newData =                         new byte[] { 0 }.ConcatMany(                             btKeySize'                             btValueSize'                                                   fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 7 + fullKey.Length;                        return ptr;                  }                  ///*NULL SUPPORT*/                  //else if ((newValueRealLength + 4 + (int)startIndex) <= valueSize)                  //{                  //    //we can change protocol to 1' staying with this update on the same place                    //    //OVERWRITE CHANGING PROTOCOL TO 1                  //    btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                        //    //btValueSize = value.Length.To_4_bytes_array_BigEndian();                    //    //newData =                  //    //    new byte[] { 1 }.ConcatMany(                  //    //        btKeySize'                  //    //        btValueSize'                  //    //        btTotalReservedSize'                  //    //        fullKey'                  //    //        value                  //    //    );                    //    //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                  //    //Checking if old data already in memory' if not re-read PROTOCOL 1 here                  //    if (data.Length >= (7 + keySize + valueSize))                  //    {                  //        oldData = data.Substring(0' 7 + keySize + valueSize);                    //        oldValue = data.Substring(7 + keySize' valueSize);                   //    }                  //    else                  //    {                  //        oldData = this._root.Tree.Storage.Read(lPtr' 7 + keySize + valueSize);                    //        oldValue = oldData.Substring(7 + keySize' valueSize);                  //    }                      //    /*FORMING NEW DATA*/                  //    //For now we have to read the full value and copy into it our value                  //    /*NULL SUPPORT*/                  //    //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                  //    newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                  //    /**************/                                           //    btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                    //    newData =                  //       new byte[] { 1 }.ConcatMany(                  //           btKeySize'                  //           btValueSize'                  //           btTotalReservedSize'                  //           fullKey'                  //           newValue                  //   );                      //    //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                  //    //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                  //    /////////////////////////////////////////////////                    //    //this._root.Tree.Storage.WriteByOffset(ptr' newData);                    //    this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                    //    valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                    //    return ptr;                  //}                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        if (data.Length >= (7 + keySize + valueSize))                      {                          //no need to do this operation here' we don't store oldData                          //oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                      btTotalReservedSize = btValueSize;                        newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                                                    newValue                     );                        //btValueSize = value.Length.To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                        btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                  }                }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) <= totalReservedSize)                                                if (newValueRealLength <= totalReservedSize)                                                {                      //OVERWRITE' LEAVING PROTOCOL 1                      //btValueSize = value.Length.To_4_bytes_array_BigEndian();                        /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      //Reading full                       /******************/                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                                            newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          //no need to make this operation here                          //oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        btTotalReservedSize = btValueSize;                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              newValue                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                    }              }              else              {                  //Protocol 0 (after first insert)                  /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) == valueSize)                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        //newData =                      //    new byte[] { 0 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                      {                          oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                                          /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        newData =                         new byte[] { 0 }.ConcatMany(                             btKeySize'                             btValueSize'                                                   fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 7 + fullKey.Length;                        return ptr;                  }                  ///*NULL SUPPORT*/                  //else if ((newValueRealLength + 4 + (int)startIndex) <= valueSize)                  //{                  //    //we can change protocol to 1' staying with this update on the same place                    //    //OVERWRITE CHANGING PROTOCOL TO 1                  //    btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                        //    //btValueSize = value.Length.To_4_bytes_array_BigEndian();                    //    //newData =                  //    //    new byte[] { 1 }.ConcatMany(                  //    //        btKeySize'                  //    //        btValueSize'                  //    //        btTotalReservedSize'                  //    //        fullKey'                  //    //        value                  //    //    );                    //    //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                  //    //Checking if old data already in memory' if not re-read PROTOCOL 1 here                  //    if (data.Length >= (7 + keySize + valueSize))                  //    {                  //        oldData = data.Substring(0' 7 + keySize + valueSize);                    //        oldValue = data.Substring(7 + keySize' valueSize);                   //    }                  //    else                  //    {                  //        oldData = this._root.Tree.Storage.Read(lPtr' 7 + keySize + valueSize);                    //        oldValue = oldData.Substring(7 + keySize' valueSize);                  //    }                      //    /*FORMING NEW DATA*/                  //    //For now we have to read the full value and copy into it our value                  //    /*NULL SUPPORT*/                  //    //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                  //    newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                  //    /**************/                                           //    btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                    //    newData =                  //       new byte[] { 1 }.ConcatMany(                  //           btKeySize'                  //           btValueSize'                  //           btTotalReservedSize'                  //           fullKey'                  //           newValue                  //   );                      //    //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                  //    //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                  //    /////////////////////////////////////////////////                    //    //this._root.Tree.Storage.WriteByOffset(ptr' newData);                    //    this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                    //    valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                    //    return ptr;                  //}                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        if (data.Length >= (7 + keySize + valueSize))                      {                          //no need to do this operation here' we don't store oldData                          //oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                      btTotalReservedSize = btValueSize;                        newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                                                    newValue                     );                        //btValueSize = value.Length.To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                        btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                  }                }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) <= totalReservedSize)                                                if (newValueRealLength <= totalReservedSize)                                                {                      //OVERWRITE' LEAVING PROTOCOL 1                      //btValueSize = value.Length.To_4_bytes_array_BigEndian();                        /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      //Reading full                       /******************/                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                                            newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          //no need to make this operation here                          //oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        btTotalReservedSize = btValueSize;                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              newValue                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                    }              }              else              {                  //Protocol 0 (after first insert)                  /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) == valueSize)                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        //newData =                      //    new byte[] { 0 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                      {                          oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                                          /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        newData =                         new byte[] { 0 }.ConcatMany(                             btKeySize'                             btValueSize'                                                   fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 7 + fullKey.Length;                        return ptr;                  }                  ///*NULL SUPPORT*/                  //else if ((newValueRealLength + 4 + (int)startIndex) <= valueSize)                  //{                  //    //we can change protocol to 1' staying with this update on the same place                    //    //OVERWRITE CHANGING PROTOCOL TO 1                  //    btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                        //    //btValueSize = value.Length.To_4_bytes_array_BigEndian();                    //    //newData =                  //    //    new byte[] { 1 }.ConcatMany(                  //    //        btKeySize'                  //    //        btValueSize'                  //    //        btTotalReservedSize'                  //    //        fullKey'                  //    //        value                  //    //    );                    //    //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                  //    //Checking if old data already in memory' if not re-read PROTOCOL 1 here                  //    if (data.Length >= (7 + keySize + valueSize))                  //    {                  //        oldData = data.Substring(0' 7 + keySize + valueSize);                    //        oldValue = data.Substring(7 + keySize' valueSize);                   //    }                  //    else                  //    {                  //        oldData = this._root.Tree.Storage.Read(lPtr' 7 + keySize + valueSize);                    //        oldValue = oldData.Substring(7 + keySize' valueSize);                  //    }                      //    /*FORMING NEW DATA*/                  //    //For now we have to read the full value and copy into it our value                  //    /*NULL SUPPORT*/                  //    //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                  //    newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                  //    /**************/                                           //    btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                    //    newData =                  //       new byte[] { 1 }.ConcatMany(                  //           btKeySize'                  //           btValueSize'                  //           btTotalReservedSize'                  //           fullKey'                  //           newValue                  //   );                      //    //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                  //    //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                  //    /////////////////////////////////////////////////                    //    //this._root.Tree.Storage.WriteByOffset(ptr' newData);                    //    this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                    //    valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                    //    return ptr;                  //}                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        if (data.Length >= (7 + keySize + valueSize))                      {                          //no need to do this operation here' we don't store oldData                          //oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                      btTotalReservedSize = btValueSize;                        newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                                                    newValue                     );                        //btValueSize = value.Length.To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                        btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                  }                }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) <= totalReservedSize)                                                if (newValueRealLength <= totalReservedSize)                                                {                      //OVERWRITE' LEAVING PROTOCOL 1                      //btValueSize = value.Length.To_4_bytes_array_BigEndian();                        /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      //Reading full                       /******************/                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                                            newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          //no need to make this operation here                          //oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        btTotalReservedSize = btValueSize;                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              newValue                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                    }              }              else              {                  //Protocol 0 (after first insert)                  /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) == valueSize)                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        //newData =                      //    new byte[] { 0 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                      {                          oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                                          /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        newData =                         new byte[] { 0 }.ConcatMany(                             btKeySize'                             btValueSize'                                                   fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 7 + fullKey.Length;                        return ptr;                  }                  ///*NULL SUPPORT*/                  //else if ((newValueRealLength + 4 + (int)startIndex) <= valueSize)                  //{                  //    //we can change protocol to 1' staying with this update on the same place                    //    //OVERWRITE CHANGING PROTOCOL TO 1                  //    btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                        //    //btValueSize = value.Length.To_4_bytes_array_BigEndian();                    //    //newData =                  //    //    new byte[] { 1 }.ConcatMany(                  //    //        btKeySize'                  //    //        btValueSize'                  //    //        btTotalReservedSize'                  //    //        fullKey'                  //    //        value                  //    //    );                    //    //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                  //    //Checking if old data already in memory' if not re-read PROTOCOL 1 here                  //    if (data.Length >= (7 + keySize + valueSize))                  //    {                  //        oldData = data.Substring(0' 7 + keySize + valueSize);                    //        oldValue = data.Substring(7 + keySize' valueSize);                   //    }                  //    else                  //    {                  //        oldData = this._root.Tree.Storage.Read(lPtr' 7 + keySize + valueSize);                    //        oldValue = oldData.Substring(7 + keySize' valueSize);                  //    }                      //    /*FORMING NEW DATA*/                  //    //For now we have to read the full value and copy into it our value                  //    /*NULL SUPPORT*/                  //    //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                  //    newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                  //    /**************/                                           //    btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                    //    newData =                  //       new byte[] { 1 }.ConcatMany(                  //           btKeySize'                  //           btValueSize'                  //           btTotalReservedSize'                  //           fullKey'                  //           newValue                  //   );                      //    //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                  //    //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                  //    /////////////////////////////////////////////////                    //    //this._root.Tree.Storage.WriteByOffset(ptr' newData);                    //    this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                    //    valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                    //    return ptr;                  //}                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        if (data.Length >= (7 + keySize + valueSize))                      {                          //no need to do this operation here' we don't store oldData                          //oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                      btTotalReservedSize = btValueSize;                        newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                                                    newValue                     );                        //btValueSize = value.Length.To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                        btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                  }                }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) <= totalReservedSize)                                                if (newValueRealLength <= totalReservedSize)                                                {                      //OVERWRITE' LEAVING PROTOCOL 1                      //btValueSize = value.Length.To_4_bytes_array_BigEndian();                        /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      //Reading full                       /******************/                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                                            newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                      if (data.Length >= (11 + totalReservedSize + keySize))                      {                          //no need to make this operation here                          //oldData = data.Substring(0' 11 + totalReservedSize + keySize);                            oldValue = data.Substring(11 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                            oldValue = oldData.Substring(11 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        btTotalReservedSize = btValueSize;                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              newValue                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                    }              }              else              {                  //Protocol 0 (after first insert)                  /*NULL SUPPORT*/                  //if ((newValueRealLength + (int)startIndex) == valueSize)                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        //newData =                      //    new byte[] { 0 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        fullKey'                      //        value                      //    );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                      {                          oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                       }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                                          /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                        newData =                         new byte[] { 0 }.ConcatMany(                             btKeySize'                             btValueSize'                                                   fullKey'                             newValue                     );                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 7 + fullKey.Length;                        return ptr;                  }                  ///*NULL SUPPORT*/                  //else if ((newValueRealLength + 4 + (int)startIndex) <= valueSize)                  //{                  //    //we can change protocol to 1' staying with this update on the same place                    //    //OVERWRITE CHANGING PROTOCOL TO 1                  //    btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                        //    //btValueSize = value.Length.To_4_bytes_array_BigEndian();                    //    //newData =                  //    //    new byte[] { 1 }.ConcatMany(                  //    //        btKeySize'                  //    //        btValueSize'                  //    //        btTotalReservedSize'                  //    //        fullKey'                  //    //        value                  //    //    );                    //    //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                  //    //Checking if old data already in memory' if not re-read PROTOCOL 1 here                  //    if (data.Length >= (7 + keySize + valueSize))                  //    {                  //        oldData = data.Substring(0' 7 + keySize + valueSize);                    //        oldValue = data.Substring(7 + keySize' valueSize);                   //    }                  //    else                  //    {                  //        oldData = this._root.Tree.Storage.Read(lPtr' 7 + keySize + valueSize);                    //        oldValue = oldData.Substring(7 + keySize' valueSize);                  //    }                      //    /*FORMING NEW DATA*/                  //    //For now we have to read the full value and copy into it our value                  //    /*NULL SUPPORT*/                  //    //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                  //    newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                  //    /**************/                                           //    btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                    //    newData =                  //       new byte[] { 1 }.ConcatMany(                  //           btKeySize'                  //           btValueSize'                  //           btTotalReservedSize'                  //           fullKey'                  //           newValue                  //   );                      //    //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                  //    //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                  //    /////////////////////////////////////////////////                    //    //this._root.Tree.Storage.WriteByOffset(ptr' newData);                    //    this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                    //    valueStartPtr = (long)ptr.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                    //    return ptr;                  //}                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        if (data.Length >= (7 + keySize + valueSize))                      {                          //no need to do this operation here' we don't store oldData                          //oldData = data.Substring(0' 7 + keySize + valueSize);                            oldValue = data.Substring(7 + keySize' valueSize);                       }                      else                      {                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                            oldValue = oldData.Substring(7 + keySize' valueSize);                      }                          /*FORMING NEW DATA*/                      //For now we have to read the full value and copy into it our value                      /*NULL SUPPORT*/                      //newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' value);                      newValue = oldValue.CopyInsideArrayCanGrow((int)startIndex' ((value == null) ? new byte[0] : value));                      /**************/                        btValueSize = ((uint)newValue.Length).To_4_bytes_array_BigEndian();                      btTotalReservedSize = btValueSize;                        newData =                         new byte[] { 1 }.ConcatMany(                             btKeySize'                             btValueSize'                             btTotalReservedSize'                             fullKey'                                                    newValue                     );                        //btValueSize = value.Length.To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        //newData =                      //    new byte[] { 1 }.ConcatMany(                      //        btKeySize'                      //        btValueSize'                      //        btTotalReservedSize'                      //        fullKey'                      //        value                      //    );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                        btFullValueStart = this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                        valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 11 + fullKey.Length;                        return btFullValueStart;                  }                }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,WriteKidValuePartially,The following statement contains a magic number: valueStartPtr = (long)btFullValueStart.DynamicLength_To_UInt64_BigEndian() + 7 + fullKey.Length;
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The following statement contains a magic number: int initRead = 111;
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The following statement contains a magic number: byte[] btKeySize = new byte[] { data[1]' data[2] };
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The following statement contains a magic number: byte[] btValueSize = new byte[] { data[3]' data[4]' data[5]' data[6] };
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The following statement contains a magic number: byte[] btValueSize = new byte[] { data[3]' data[4]' data[5]' data[6] };
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The following statement contains a magic number: byte[] btValueSize = new byte[] { data[3]' data[4]' data[5]' data[6] };
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The following statement contains a magic number: byte[] btValueSize = new byte[] { data[3]' data[4]' data[5]' data[6] };
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The following statement contains a magic number: if ((data[3] & 0x80) > 0)              {                  //NULL                  valueSize = 0;              }              else              {                  valueSize = (int)btValueSize.To_UInt32_BigEndian();              }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The following statement contains a magic number: uint newValueLength = 2147483648;
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                                         break;                  case 1:                      btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      totalReservedSize = (int)btTotalReservedSize.To_UInt32_BigEndian();                                          break;              }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                                         break;                  case 1:                      btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      totalReservedSize = (int)btTotalReservedSize.To_UInt32_BigEndian();                                          break;              }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                                         break;                  case 1:                      btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      totalReservedSize = (int)btTotalReservedSize.To_UInt32_BigEndian();                                          break;              }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                                         break;                  case 1:                      btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      totalReservedSize = (int)btTotalReservedSize.To_UInt32_BigEndian();                                          break;              }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  if (newValueRealLength <= totalReservedSize)                  {                      //OVERWRITE' LEAVING PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /**************/                                            newData =                          new byte[] {1}.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        return ptr;                  }                  else                  {                                         //NO OVERWRITE' CREATE NEW PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      btTotalReservedSize = newValueRealLength.To_4_bytes_array_BigEndian();                      /**************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      return this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                                        }              }              else              {                  //Protocol 0 (after first insert)                    /*NULL SUPPORT*/                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        /*NULL SUPPORT*/                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /**************/                        newData =                          new byte[] { 0 }.ConcatMany(                              btKeySize'                              btValueSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                          oldData = data.Substring(0' 7 + keySize + valueSize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        return ptr;                  }                  /*NULL SUPPORT*/                  else if ((newValueRealLength + 4) <= valueSize)                  {                      //we can change protocol to 1' staying with this update on the same place                        //OVERWRITE CHANGING PROTOCOL TO 1                      /*NULL SUPPORT*/                      btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /***************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                          oldData = data.Substring(0' 7 + keySize + valueSize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                          return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      btTotalReservedSize = newValueRealLength.To_4_bytes_array_BigEndian();                      /***************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                                            //return this._root.Tree.Storage.WriteToTheEnd(newData);                      return this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                  }                               }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  if (newValueRealLength <= totalReservedSize)                  {                      //OVERWRITE' LEAVING PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /**************/                                            newData =                          new byte[] {1}.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        return ptr;                  }                  else                  {                                         //NO OVERWRITE' CREATE NEW PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      btTotalReservedSize = newValueRealLength.To_4_bytes_array_BigEndian();                      /**************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      return this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                                        }              }              else              {                  //Protocol 0 (after first insert)                    /*NULL SUPPORT*/                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        /*NULL SUPPORT*/                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /**************/                        newData =                          new byte[] { 0 }.ConcatMany(                              btKeySize'                              btValueSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                          oldData = data.Substring(0' 7 + keySize + valueSize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        return ptr;                  }                  /*NULL SUPPORT*/                  else if ((newValueRealLength + 4) <= valueSize)                  {                      //we can change protocol to 1' staying with this update on the same place                        //OVERWRITE CHANGING PROTOCOL TO 1                      /*NULL SUPPORT*/                      btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /***************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                          oldData = data.Substring(0' 7 + keySize + valueSize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                          return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      btTotalReservedSize = newValueRealLength.To_4_bytes_array_BigEndian();                      /***************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                                            //return this._root.Tree.Storage.WriteToTheEnd(newData);                      return this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                  }                               }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  if (newValueRealLength <= totalReservedSize)                  {                      //OVERWRITE' LEAVING PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /**************/                                            newData =                          new byte[] {1}.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        return ptr;                  }                  else                  {                                         //NO OVERWRITE' CREATE NEW PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      btTotalReservedSize = newValueRealLength.To_4_bytes_array_BigEndian();                      /**************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      return this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                                        }              }              else              {                  //Protocol 0 (after first insert)                    /*NULL SUPPORT*/                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        /*NULL SUPPORT*/                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /**************/                        newData =                          new byte[] { 0 }.ConcatMany(                              btKeySize'                              btValueSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                          oldData = data.Substring(0' 7 + keySize + valueSize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        return ptr;                  }                  /*NULL SUPPORT*/                  else if ((newValueRealLength + 4) <= valueSize)                  {                      //we can change protocol to 1' staying with this update on the same place                        //OVERWRITE CHANGING PROTOCOL TO 1                      /*NULL SUPPORT*/                      btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /***************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                          oldData = data.Substring(0' 7 + keySize + valueSize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                          return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      btTotalReservedSize = newValueRealLength.To_4_bytes_array_BigEndian();                      /***************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                                            //return this._root.Tree.Storage.WriteToTheEnd(newData);                      return this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                  }                               }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  if (newValueRealLength <= totalReservedSize)                  {                      //OVERWRITE' LEAVING PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /**************/                                            newData =                          new byte[] {1}.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        return ptr;                  }                  else                  {                                         //NO OVERWRITE' CREATE NEW PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      btTotalReservedSize = newValueRealLength.To_4_bytes_array_BigEndian();                      /**************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      return this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                                        }              }              else              {                  //Protocol 0 (after first insert)                    /*NULL SUPPORT*/                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        /*NULL SUPPORT*/                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /**************/                        newData =                          new byte[] { 0 }.ConcatMany(                              btKeySize'                              btValueSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                          oldData = data.Substring(0' 7 + keySize + valueSize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        return ptr;                  }                  /*NULL SUPPORT*/                  else if ((newValueRealLength + 4) <= valueSize)                  {                      //we can change protocol to 1' staying with this update on the same place                        //OVERWRITE CHANGING PROTOCOL TO 1                      /*NULL SUPPORT*/                      btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /***************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                          oldData = data.Substring(0' 7 + keySize + valueSize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                          return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      btTotalReservedSize = newValueRealLength.To_4_bytes_array_BigEndian();                      /***************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                                            //return this._root.Tree.Storage.WriteToTheEnd(newData);                      return this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                  }                               }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  if (newValueRealLength <= totalReservedSize)                  {                      //OVERWRITE' LEAVING PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /**************/                                            newData =                          new byte[] {1}.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        return ptr;                  }                  else                  {                                         //NO OVERWRITE' CREATE NEW PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      btTotalReservedSize = newValueRealLength.To_4_bytes_array_BigEndian();                      /**************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      return this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                                        }              }              else              {                  //Protocol 0 (after first insert)                    /*NULL SUPPORT*/                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        /*NULL SUPPORT*/                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /**************/                        newData =                          new byte[] { 0 }.ConcatMany(                              btKeySize'                              btValueSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                          oldData = data.Substring(0' 7 + keySize + valueSize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        return ptr;                  }                  /*NULL SUPPORT*/                  else if ((newValueRealLength + 4) <= valueSize)                  {                      //we can change protocol to 1' staying with this update on the same place                        //OVERWRITE CHANGING PROTOCOL TO 1                      /*NULL SUPPORT*/                      btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /***************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                          oldData = data.Substring(0' 7 + keySize + valueSize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                          return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      btTotalReservedSize = newValueRealLength.To_4_bytes_array_BigEndian();                      /***************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                                            //return this._root.Tree.Storage.WriteToTheEnd(newData);                      return this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                  }                               }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  if (newValueRealLength <= totalReservedSize)                  {                      //OVERWRITE' LEAVING PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /**************/                                            newData =                          new byte[] {1}.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        return ptr;                  }                  else                  {                                         //NO OVERWRITE' CREATE NEW PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      btTotalReservedSize = newValueRealLength.To_4_bytes_array_BigEndian();                      /**************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      return this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                                        }              }              else              {                  //Protocol 0 (after first insert)                    /*NULL SUPPORT*/                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        /*NULL SUPPORT*/                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /**************/                        newData =                          new byte[] { 0 }.ConcatMany(                              btKeySize'                              btValueSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                          oldData = data.Substring(0' 7 + keySize + valueSize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        return ptr;                  }                  /*NULL SUPPORT*/                  else if ((newValueRealLength + 4) <= valueSize)                  {                      //we can change protocol to 1' staying with this update on the same place                        //OVERWRITE CHANGING PROTOCOL TO 1                      /*NULL SUPPORT*/                      btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /***************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                          oldData = data.Substring(0' 7 + keySize + valueSize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                          return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      btTotalReservedSize = newValueRealLength.To_4_bytes_array_BigEndian();                      /***************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                                            //return this._root.Tree.Storage.WriteToTheEnd(newData);                      return this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                  }                               }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  if (newValueRealLength <= totalReservedSize)                  {                      //OVERWRITE' LEAVING PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /**************/                                            newData =                          new byte[] {1}.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        return ptr;                  }                  else                  {                                         //NO OVERWRITE' CREATE NEW PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      btTotalReservedSize = newValueRealLength.To_4_bytes_array_BigEndian();                      /**************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      return this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                                        }              }              else              {                  //Protocol 0 (after first insert)                    /*NULL SUPPORT*/                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        /*NULL SUPPORT*/                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /**************/                        newData =                          new byte[] { 0 }.ConcatMany(                              btKeySize'                              btValueSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                          oldData = data.Substring(0' 7 + keySize + valueSize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        return ptr;                  }                  /*NULL SUPPORT*/                  else if ((newValueRealLength + 4) <= valueSize)                  {                      //we can change protocol to 1' staying with this update on the same place                        //OVERWRITE CHANGING PROTOCOL TO 1                      /*NULL SUPPORT*/                      btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /***************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                          oldData = data.Substring(0' 7 + keySize + valueSize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                          return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      btTotalReservedSize = newValueRealLength.To_4_bytes_array_BigEndian();                      /***************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                                            //return this._root.Tree.Storage.WriteToTheEnd(newData);                      return this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                  }                               }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  if (newValueRealLength <= totalReservedSize)                  {                      //OVERWRITE' LEAVING PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /**************/                                            newData =                          new byte[] {1}.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        return ptr;                  }                  else                  {                                         //NO OVERWRITE' CREATE NEW PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      btTotalReservedSize = newValueRealLength.To_4_bytes_array_BigEndian();                      /**************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      return this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                                        }              }              else              {                  //Protocol 0 (after first insert)                    /*NULL SUPPORT*/                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        /*NULL SUPPORT*/                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /**************/                        newData =                          new byte[] { 0 }.ConcatMany(                              btKeySize'                              btValueSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                          oldData = data.Substring(0' 7 + keySize + valueSize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        return ptr;                  }                  /*NULL SUPPORT*/                  else if ((newValueRealLength + 4) <= valueSize)                  {                      //we can change protocol to 1' staying with this update on the same place                        //OVERWRITE CHANGING PROTOCOL TO 1                      /*NULL SUPPORT*/                      btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /***************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                          oldData = data.Substring(0' 7 + keySize + valueSize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                          return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      btTotalReservedSize = newValueRealLength.To_4_bytes_array_BigEndian();                      /***************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                                            //return this._root.Tree.Storage.WriteToTheEnd(newData);                      return this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                  }                               }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  if (newValueRealLength <= totalReservedSize)                  {                      //OVERWRITE' LEAVING PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /**************/                                            newData =                          new byte[] {1}.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        return ptr;                  }                  else                  {                                         //NO OVERWRITE' CREATE NEW PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      btTotalReservedSize = newValueRealLength.To_4_bytes_array_BigEndian();                      /**************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      return this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                                        }              }              else              {                  //Protocol 0 (after first insert)                    /*NULL SUPPORT*/                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        /*NULL SUPPORT*/                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /**************/                        newData =                          new byte[] { 0 }.ConcatMany(                              btKeySize'                              btValueSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                          oldData = data.Substring(0' 7 + keySize + valueSize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        return ptr;                  }                  /*NULL SUPPORT*/                  else if ((newValueRealLength + 4) <= valueSize)                  {                      //we can change protocol to 1' staying with this update on the same place                        //OVERWRITE CHANGING PROTOCOL TO 1                      /*NULL SUPPORT*/                      btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /***************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                          oldData = data.Substring(0' 7 + keySize + valueSize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                          return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      btTotalReservedSize = newValueRealLength.To_4_bytes_array_BigEndian();                      /***************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                                            //return this._root.Tree.Storage.WriteToTheEnd(newData);                      return this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                  }                               }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  if (newValueRealLength <= totalReservedSize)                  {                      //OVERWRITE' LEAVING PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /**************/                                            newData =                          new byte[] {1}.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        return ptr;                  }                  else                  {                                         //NO OVERWRITE' CREATE NEW PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      btTotalReservedSize = newValueRealLength.To_4_bytes_array_BigEndian();                      /**************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      return this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                                        }              }              else              {                  //Protocol 0 (after first insert)                    /*NULL SUPPORT*/                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        /*NULL SUPPORT*/                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /**************/                        newData =                          new byte[] { 0 }.ConcatMany(                              btKeySize'                              btValueSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                          oldData = data.Substring(0' 7 + keySize + valueSize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        return ptr;                  }                  /*NULL SUPPORT*/                  else if ((newValueRealLength + 4) <= valueSize)                  {                      //we can change protocol to 1' staying with this update on the same place                        //OVERWRITE CHANGING PROTOCOL TO 1                      /*NULL SUPPORT*/                      btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /***************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                          oldData = data.Substring(0' 7 + keySize + valueSize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                          return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      btTotalReservedSize = newValueRealLength.To_4_bytes_array_BigEndian();                      /***************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                                            //return this._root.Tree.Storage.WriteToTheEnd(newData);                      return this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                  }                               }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The following statement contains a magic number: if (totalReservedSize > 0)              {                  //Protocol 1                    //We are checking if current value can placed over existing value                    /*NULL SUPPORT*/                  if (newValueRealLength <= totalReservedSize)                  {                      //OVERWRITE' LEAVING PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /**************/                                            newData =                          new byte[] {1}.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (11 + totalReservedSize + keySize))                          oldData = data.Substring(0' 11 + totalReservedSize + keySize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 11 + totalReservedSize + keySize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr'newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        return ptr;                  }                  else                  {                                         //NO OVERWRITE' CREATE NEW PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      btTotalReservedSize = newValueRealLength.To_4_bytes_array_BigEndian();                      /**************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //return this._root.Tree.Storage.WriteToTheEnd(newData);                      return this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                                        }              }              else              {                  //Protocol 0 (after first insert)                    /*NULL SUPPORT*/                  if (newValueRealLength == valueSize)                  {                      //new value resides the same space as previous we save it on top leaving protocol 0                        //OVERWRITE' LEAVING PROTOCOL 0                        /*NULL SUPPORT*/                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /**************/                        newData =                          new byte[] { 0 }.ConcatMany(                              btKeySize'                              btValueSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                          oldData = data.Substring(0' 7 + keySize + valueSize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                        return ptr;                  }                  /*NULL SUPPORT*/                  else if ((newValueRealLength + 4) <= valueSize)                  {                      //we can change protocol to 1' staying with this update on the same place                        //OVERWRITE CHANGING PROTOCOL TO 1                      /*NULL SUPPORT*/                      btTotalReservedSize = ((uint)(valueSize - 4)).To_4_bytes_array_BigEndian();                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      /***************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                        //!!!!!!!!!!!!!!!!!   ROLLBACK and READ THREADS                      //Checking if old data already in memory' if not re-read PROTOCOL 1 here                      if (data.Length >= (7 + keySize + valueSize))                          oldData = data.Substring(0' 7 + keySize + valueSize);                      else                          oldData = this._root.Tree.Storage.Table_Read(false' lPtr' 7 + keySize + valueSize);                        //rollBackFileDataPointer = this._root.Tree.RollerBack.WriteRollBackData(1' ptr' ref oldData);                      //this._root.Tree.Cache.AddPointerToTheValueInRollBackFile(ptr' rollBackFileDataPointer);                      /////////////////////////////////////////////////                        //this._root.Tree.Storage.WriteByOffset(ptr' newData);                        this._root.Tree.Cache.ValueWritingOver(ptr' ref oldData' ref newData' ref fullKey);                          return ptr;                  }                  else                  {                      //NO OVERWRITE' CREATE NEW PROTOCOL 1                        /*NULL SUPPORT*/                      //btValueSize = ((uint)value.Length).To_4_bytes_array_BigEndian();                      //btTotalReservedSize = btValueSize;                        btValueSize = newValueLength.To_4_bytes_array_BigEndian();                      btTotalReservedSize = newValueRealLength.To_4_bytes_array_BigEndian();                      /***************/                        newData =                          new byte[] { 1 }.ConcatMany(                              btKeySize'                              btValueSize'                              btTotalReservedSize'                              fullKey'                              value                          );                                            //return this._root.Tree.Storage.WriteToTheEnd(newData);                      return this._root.Tree.Cache.ValueWritingEnd(ref newData' ptr);                  }                               }
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,WriteKidValue,The following statement contains a magic number: uint valueLength = 2147483648;
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,GetQuantityOfReservationSlots,The following statement contains a magic number: if (kc < 2) return 1;
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,GetQuantityOfReservationSlots,The following statement contains a magic number: if (kc == 2) return 2;
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,GetQuantityOfReservationSlots,The following statement contains a magic number: if (kc == 2) return 2;
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,GetQuantityOfReservationSlots,The following statement contains a magic number: if (kc < 5) return 4;
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,GetQuantityOfReservationSlots,The following statement contains a magic number: if (kc < 5) return 4;
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,GetQuantityOfReservationSlots,The following statement contains a magic number: if (kc < 9) return 8;
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,GetQuantityOfReservationSlots,The following statement contains a magic number: if (kc < 9) return 8;
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,GetQuantityOfReservationSlots,The following statement contains a magic number: if (kc < 17) return 16;
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,GetQuantityOfReservationSlots,The following statement contains a magic number: if (kc < 17) return 16;
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,GetQuantityOfReservationSlots,The following statement contains a magic number: if (kc < 33) return 32;
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,GetQuantityOfReservationSlots,The following statement contains a magic number: if (kc < 33) return 32;
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,GetQuantityOfReservationSlots,The following statement contains a magic number: if (kc < 65) return 64;
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,GetQuantityOfReservationSlots,The following statement contains a magic number: if (kc < 65) return 64;
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,GetQuantityOfReservationSlots,The following statement contains a magic number: if (kc < 129) return 128;
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,GetQuantityOfReservationSlots,The following statement contains a magic number: if (kc < 129) return 128;
Magic Number,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,GetQuantityOfReservationSlots,The following statement contains a magic number: return 256;
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,LTrieKidsInNode,The following statement contains a magic number: _f = new byte[DefaultPointerLength + 2 + (256 * shift)];
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,LTrieKidsInNode,The following statement contains a magic number: _f = new byte[DefaultPointerLength + 2 + (256 * shift)];
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,AddKidPointer,The following statement contains a magic number: for (int i = 0; i < ptr.Length; i++)                        //Can be changed on substring              {                  _f[(kidPlace + 2) + i] = ptr[i];  //Setting up pointer              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: int step = 2 + DefaultPointerLength;
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ParseKids,The following statement contains a magic number: for (int j = DefaultPointerLength; j < kidLen; j += step)              {                    //notEmptyPointer = false;                  kid = bKids[j] + 1;                  //kid++;                  kidPlace = kid * shift;                      //checking if pointer is empty                  switch (DefaultPointerLength)                  {                      case 5:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                            notEmptyPointer = ((pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 6:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                            notEmptyPointer = ((pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      case 7:                          pb2 = bKids[j + 2];                          pb3 = bKids[j + 3];                          pb4 = bKids[j + 4];                          pb5 = bKids[j + 5];                          pb6 = bKids[j + 6];                          pb7 = bKids[j + 7];                          pb8 = bKids[j + 8];                            notEmptyPointer = ((pb8 != 0) || (pb7 != 0) || (pb6 != 0) || (pb5 != 0) || (pb4 != 0) || (pb3 != 0) || (pb2 != 0));                            break;                      default:                            notEmptyPointer = false;                            for (int ii = 0; ii < DefaultPointerLength; ii++)                          {                                if ((bKids[j + 2 + ii] != 0))                              {                                  notEmptyPointer = true;                                  break;                              }                              //notEmptyPointer |= (bKids[j + 2 + ii] != 0);                          }                          break;                    }                      if (notEmptyPointer)                  {                      switch (DefaultPointerLength)                      {                          case 5:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                                break;                          case 6:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                                break;                          case 7:                              _f[kidPlace + 2] = pb2;                              _f[kidPlace + 3] = pb3;                              _f[kidPlace + 4] = pb4;                              _f[kidPlace + 5] = pb5;                              _f[kidPlace + 6] = pb6;                              _f[kidPlace + 7] = pb7;                              _f[kidPlace + 8] = pb8;                                break;                          default:                              for (int ii = 0; ii < DefaultPointerLength; ii++)                              {                                  _f[kidPlace + 2 + ii] = bKids[j + 2 + ii];                              }                              break;                      }                        if (_f[kidPlace] == 0)                      {                          //Handling Extremums                          if (MaxKidNull || (kid > MaxKid))                          {                              MaxKidNull = false;                              MaxKid = kid;                          }                          if (MinKidNull || (kid < MinKid))                          {                              MinKidNull = false;                              MinKid = kid;                          }                          /*********************************/                          count++;                      }                        _f[kidPlace] = 1; //Kid Exists                         //if (bKids[j + 1] == 1) - //Link to the value                      //if (bKids[j + 1] == 0) - //Link to the Node                       _f[kidPlace + 1] = bKids[j + 1];                      }                    qrs++;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,AddKid,The following statement contains a magic number: if (kid == 256) //value              {                  //Settign up value element for this node                  bool notEmptyPointer = false;                    for (int i = 0; i < ptr.Length; i++)                    //Copy Into can be used                  {                        _f[i] = ptr[i];                        //Help for fast value retrieve                      notEmptyPointer |= (ptr[i] != 0);                      PtrToValue[i] = ptr[i];                      //-------------------------------                  }                      ValueIsEmpty = !notEmptyPointer;              }              else              {                  //Setting up kid                  //It's balanced on upper level' but here we save only pointer to the value' and this kid will definetely has not busy place'                  //so                    kid++;  //bringing kid to the real value                  int kidPlace = kid * shift;                    //Increasing count                  if (_f[kidPlace] == 0)                  {                      //SetupExtremums(kid);                      //Handling Extremums                      if (MaxKidNull || (kid > MaxKid))                      {                          MaxKidNull = false;                          MaxKid = kid;                      }                      if (MinKidNull || (kid < MinKid))                      {                          MinKidNull = false;                          MinKid = kid;                      }                      /*********************************/                      count++;                      }                      _f[kidPlace] = 1; //Kid Exists                   _f[kidPlace + 1] = 1; //Link to the value                    //ptr.Length or Default Pointer Length must be the same                  for (int i = 0; i < ptr.Length; i++)                        //Can be changed on substring (For faster then block copy)                  {                          _f[(kidPlace + 2) + i] = ptr[i];  //Settign up pointer                  }                    //slower then for                  //Buffer.BlockCopy(ptr' 0' _f' (kidPlace + 2)' ptr.Length);              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,AddKid,The following statement contains a magic number: if (kid == 256) //value              {                  //Settign up value element for this node                  bool notEmptyPointer = false;                    for (int i = 0; i < ptr.Length; i++)                    //Copy Into can be used                  {                        _f[i] = ptr[i];                        //Help for fast value retrieve                      notEmptyPointer |= (ptr[i] != 0);                      PtrToValue[i] = ptr[i];                      //-------------------------------                  }                      ValueIsEmpty = !notEmptyPointer;              }              else              {                  //Setting up kid                  //It's balanced on upper level' but here we save only pointer to the value' and this kid will definetely has not busy place'                  //so                    kid++;  //bringing kid to the real value                  int kidPlace = kid * shift;                    //Increasing count                  if (_f[kidPlace] == 0)                  {                      //SetupExtremums(kid);                      //Handling Extremums                      if (MaxKidNull || (kid > MaxKid))                      {                          MaxKidNull = false;                          MaxKid = kid;                      }                      if (MinKidNull || (kid < MinKid))                      {                          MinKidNull = false;                          MinKid = kid;                      }                      /*********************************/                      count++;                      }                      _f[kidPlace] = 1; //Kid Exists                   _f[kidPlace + 1] = 1; //Link to the value                    //ptr.Length or Default Pointer Length must be the same                  for (int i = 0; i < ptr.Length; i++)                        //Can be changed on substring (For faster then block copy)                  {                          _f[(kidPlace + 2) + i] = ptr[i];  //Settign up pointer                  }                    //slower then for                  //Buffer.BlockCopy(ptr' 0' _f' (kidPlace + 2)' ptr.Length);              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,RemoveAllKids,The following statement contains a magic number: _f = new byte[DefaultPointerLength + 2 + (256 * shift)];
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,RemoveAllKids,The following statement contains a magic number: _f = new byte[DefaultPointerLength + 2 + (256 * shift)];
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,FindNewMax,The following statement contains a magic number: for (int i = 256; i >= 1; i--)      //i>0              {                  if (_f[i * shift] == 1)                  {                      //setting up new Maximum                      MaxKid = i;                      return;                  }              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,FindNewMin,The following statement contains a magic number: for (int i = 1; i <= 256; i++)      //i<257              {                  if (_f[i * shift] == 1)                  {                      //setting up new Maximum                      MinKid = i;                      return;                  }              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetMinKid,The following statement contains a magic number: if (!ValueIsEmpty)              {                  //In case if we have value then it's a minimum                    ret.Ptr = PtrToValue;                  ret.Exists = true;                  ret.ValueKid = true;                  ret.Val = 256;              }              else              {                  SearchExtremums();                    if (MinKidNull)                      return ret;                    int kidPlace = MinKid * shift;                      ret.Exists = true;                  ret.Val = MinKid - 1;  //Bringing value to [0-255]                    //Copying Pointer                  ret.Ptr = new byte[DefaultPointerLength];                    for (int i = 0; i < DefaultPointerLength; i++)          //Can be changed on substring                  {                      ret.Ptr[i] = _f[(kidPlace + 2) + i];                  }                    //Setting up link to Node or to Value                  if (_f[kidPlace + 1] == 1)                      ret.LinkToNode = false;                }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetMinKid,The following statement contains a magic number: if (!ValueIsEmpty)              {                  //In case if we have value then it's a minimum                    ret.Ptr = PtrToValue;                  ret.Exists = true;                  ret.ValueKid = true;                  ret.Val = 256;              }              else              {                  SearchExtremums();                    if (MinKidNull)                      return ret;                    int kidPlace = MinKid * shift;                      ret.Exists = true;                  ret.Val = MinKid - 1;  //Bringing value to [0-255]                    //Copying Pointer                  ret.Ptr = new byte[DefaultPointerLength];                    for (int i = 0; i < DefaultPointerLength; i++)          //Can be changed on substring                  {                      ret.Ptr[i] = _f[(kidPlace + 2) + i];                  }                    //Setting up link to Node or to Value                  if (_f[kidPlace + 1] == 1)                      ret.LinkToNode = false;                }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetMaxKid,The following statement contains a magic number: if (MaxKidNull)              {                  if (!ValueIsEmpty)                  {                      //trying to take max kid                      ret.Ptr = PtrToValue;                      ret.Exists = true;                      ret.ValueKid = true;                      ret.Val = 256;                  }                    return ret;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetMaxKid,The following statement contains a magic number: for (int i = 0; i < DefaultPointerLength; i++)          //Can be changed on substring              {                  ret.Ptr[i] = _f[(kidPlace + 2) + i];              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetKidsForward,The following statement contains a magic number: if (startFrom == 256)              {                  if (!ValueIsEmpty)                  {                      ret = new LTrieKid();                        //trying to take max kid                      ret.Ptr = PtrToValue;                      ret.Exists = true;                      ret.ValueKid = true;                      ret.Val = 256;                        yield return ret;                  }                    startFrom = 0;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetKidsForward,The following statement contains a magic number: if (startFrom == 256)              {                  if (!ValueIsEmpty)                  {                      ret = new LTrieKid();                        //trying to take max kid                      ret.Ptr = PtrToValue;                      ret.Exists = true;                      ret.ValueKid = true;                      ret.Val = 256;                        yield return ret;                  }                    startFrom = 0;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetKidsForward,The following statement contains a magic number: if (this.count > 0)              {                    //Change back kid to normal                  startFrom += 1;                      //if (startFrom == 256)                  //    startFrom = 1;                  //else                  //    startFrom += 1;                    int kidPlace = 0;                  for (int i = startFrom; i <= 256; i++)                  {                      kidPlace = i * shift;                        if (_f[kidPlace] == 1)                      {                          ret = new LTrieKid();                          ret.Exists = true;                          ret.Val = i - 1;                            ret.Ptr = new byte[DefaultPointerLength];                          for (int j = 0; j < DefaultPointerLength; j++)          //Can be changed on substring                          {                              ret.Ptr[j] = _f[(kidPlace + 2) + j];                          }                            //Setting up link to Node or to Value                          if (_f[kidPlace + 1] == 1)                              ret.LinkToNode = false;                            yield return ret;                      }                  }              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetKidsForward,The following statement contains a magic number: if (this.count > 0)              {                    //Change back kid to normal                  startFrom += 1;                      //if (startFrom == 256)                  //    startFrom = 1;                  //else                  //    startFrom += 1;                    int kidPlace = 0;                  for (int i = startFrom; i <= 256; i++)                  {                      kidPlace = i * shift;                        if (_f[kidPlace] == 1)                      {                          ret = new LTrieKid();                          ret.Exists = true;                          ret.Val = i - 1;                            ret.Ptr = new byte[DefaultPointerLength];                          for (int j = 0; j < DefaultPointerLength; j++)          //Can be changed on substring                          {                              ret.Ptr[j] = _f[(kidPlace + 2) + j];                          }                            //Setting up link to Node or to Value                          if (_f[kidPlace + 1] == 1)                              ret.LinkToNode = false;                            yield return ret;                      }                  }              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetKidsForward,The following statement contains a magic number: if (!ValueIsEmpty)              {                  ret = new LTrieKid();                    //trying to take max kid                  ret.Ptr = PtrToValue;                  ret.Exists = true;                  ret.ValueKid = true;                  ret.Val = 256;                    yield return ret;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetKidsForward,The following statement contains a magic number: if (this.count > 0)              {                  int kidPlace = 0;                  for (int i = 1; i <= 256; i++)                  {                      kidPlace = i * shift;                        if (_f[kidPlace] == 1)                      {                          ret = new LTrieKid();                          ret.Exists = true;                          ret.Val = i - 1;                            ret.Ptr = new byte[DefaultPointerLength];                          for (int j = 0; j < DefaultPointerLength; j++)          //Can be changed on substring                          {                              ret.Ptr[j] = _f[(kidPlace + 2) + j];                          }                            //Setting up link to Node or to Value                          if (_f[kidPlace + 1] == 1)                              ret.LinkToNode = false;                            yield return ret;                      }                  }              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetKidsForward,The following statement contains a magic number: if (this.count > 0)              {                  int kidPlace = 0;                  for (int i = 1; i <= 256; i++)                  {                      kidPlace = i * shift;                        if (_f[kidPlace] == 1)                      {                          ret = new LTrieKid();                          ret.Exists = true;                          ret.Val = i - 1;                            ret.Ptr = new byte[DefaultPointerLength];                          for (int j = 0; j < DefaultPointerLength; j++)          //Can be changed on substring                          {                              ret.Ptr[j] = _f[(kidPlace + 2) + j];                          }                            //Setting up link to Node or to Value                          if (_f[kidPlace + 1] == 1)                              ret.LinkToNode = false;                            yield return ret;                      }                  }              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetKidsBackward,The following statement contains a magic number: if (this.count > 0 && startFrom != 256)              {                  startFrom += 1;                    int kidPlace = 0;                  for (int i = startFrom; i > 0; i--)                  {                      kidPlace = i * shift;                        if (_f[kidPlace] == 1)                      {                          ret = new LTrieKid();                          ret.Exists = true;                          ret.Val = i - 1;                            ret.Ptr = new byte[DefaultPointerLength];                          for (int j = 0; j < DefaultPointerLength; j++)          //Can be changed on substring                          {                              ret.Ptr[j] = _f[(kidPlace + 2) + j];                          }                            //Setting up link to Node or to Value                          if (_f[kidPlace + 1] == 1)                              ret.LinkToNode = false;                            yield return ret;                      }                  }              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetKidsBackward,The following statement contains a magic number: if (this.count > 0 && startFrom != 256)              {                  startFrom += 1;                    int kidPlace = 0;                  for (int i = startFrom; i > 0; i--)                  {                      kidPlace = i * shift;                        if (_f[kidPlace] == 1)                      {                          ret = new LTrieKid();                          ret.Exists = true;                          ret.Val = i - 1;                            ret.Ptr = new byte[DefaultPointerLength];                          for (int j = 0; j < DefaultPointerLength; j++)          //Can be changed on substring                          {                              ret.Ptr[j] = _f[(kidPlace + 2) + j];                          }                            //Setting up link to Node or to Value                          if (_f[kidPlace + 1] == 1)                              ret.LinkToNode = false;                            yield return ret;                      }                  }              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetKidsBackward,The following statement contains a magic number: if (!ValueIsEmpty)              {                  ret = new LTrieKid();                    //trying to take max kid                  ret.Ptr = PtrToValue;                  ret.Exists = true;                  ret.ValueKid = true;                  ret.Val = 256;                    yield return ret;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetKidsBackward,The following statement contains a magic number: if (this.count > 0)              {                  int kidPlace = 0;                  for (int i = 256; i > 0; i--)                  {                      kidPlace = i * shift;                        if (_f[kidPlace] == 1)                      {                          ret = new LTrieKid();                          ret.Exists = true;                          ret.Val = i - 1;                            ret.Ptr = new byte[DefaultPointerLength];                          for (int j = 0; j < DefaultPointerLength; j++)          //Can be changed on substring                          {                              ret.Ptr[j] = _f[(kidPlace + 2) + j];                          }                            //Setting up link to Node or to Value                          if (_f[kidPlace + 1] == 1)                              ret.LinkToNode = false;                            yield return ret;                      }                  }              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetKidsBackward,The following statement contains a magic number: if (this.count > 0)              {                  int kidPlace = 0;                  for (int i = 256; i > 0; i--)                  {                      kidPlace = i * shift;                        if (_f[kidPlace] == 1)                      {                          ret = new LTrieKid();                          ret.Exists = true;                          ret.Val = i - 1;                            ret.Ptr = new byte[DefaultPointerLength];                          for (int j = 0; j < DefaultPointerLength; j++)          //Can be changed on substring                          {                              ret.Ptr[j] = _f[(kidPlace + 2) + j];                          }                            //Setting up link to Node or to Value                          if (_f[kidPlace + 1] == 1)                              ret.LinkToNode = false;                            yield return ret;                      }                  }              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetKidsBackward,The following statement contains a magic number: if (!ValueIsEmpty)              {                  ret = new LTrieKid();                    //trying to take max kid                  ret.Ptr = PtrToValue;                  ret.Exists = true;                  ret.ValueKid = true;                  ret.Val = 256;                    yield return ret;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ReplaceValueLinkOnKidLink,The following statement contains a magic number: if (_f[kidPlace + 1] == 1)              {                  //We got link to the value                  _f[kidPlace + 1] = 0;   //We change it on link to the next node kid and then return reference on the previous value                    byte[] ptr = new byte[DefaultPointerLength];                    for (int i = 0; i < DefaultPointerLength; i++)          //Can be changed on substring                  {                      ptr[i] = _f[(kidPlace + 2) + i];                        //Cleaning up link' so it is empty and will be setup when we save generation node                      _f[(kidPlace + 2) + i] = 0;                  }                    return ptr;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,ReplaceValueLinkOnKidLink,The following statement contains a magic number: if (_f[kidPlace + 1] == 1)              {                  //We got link to the value                  _f[kidPlace + 1] = 0;   //We change it on link to the next node kid and then return reference on the previous value                    byte[] ptr = new byte[DefaultPointerLength];                    for (int i = 0; i < DefaultPointerLength; i++)          //Can be changed on substring                  {                      ptr[i] = _f[(kidPlace + 2) + i];                        //Cleaning up link' so it is empty and will be setup when we save generation node                      _f[(kidPlace + 2) + i] = 0;                  }                    return ptr;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetKidValue,The following statement contains a magic number: kidDef.Val = 256;
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetKid,The following statement contains a magic number: if (_f[kidPlace] == 1)              {                  kidDef.Exists = true;                    if (_f[kidPlace + 1] == 1)                      kidDef.LinkToNode = false;          //Link to Value                    kidDef.Ptr = new byte[DefaultPointerLength];                    Buffer.BlockCopy(_f' (kidPlace + 2)' kidDef.Ptr' 0' DefaultPointerLength);                    //for (int i = 0; i < DefaultPointerLength; i++)          //Can be changed on substring                  //{                  //    kidDef.Ptr[i] = _f[(kidPlace + 2) + i];                  //}                }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetPointerToTheKid,The following statement contains a magic number: if (_f[kidPlace] == 1 && _f[kidPlace + 1] == 0)              {                  byte[] ptr = new byte[DefaultPointerLength];                    Buffer.BlockCopy(_f' (kidPlace + 2)' ptr' 0' DefaultPointerLength);                    //for (int i = 0; i < DefaultPointerLength; i++)          //Can be changed on substring                  //{                  //    ptr[i] = _f[(kidPlace + 2) + i];                  //}                    return ptr;              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetKidsForSave,The following statement contains a magic number: byte[] ret = new byte[DefaultPointerLength + 2 + (256 * shift)];
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetKidsForSave,The following statement contains a magic number: byte[] ret = new byte[DefaultPointerLength + 2 + (256 * shift)];
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetKidsForSave,The following statement contains a magic number: for (int i = 1; i <= 256; i++)              {                  kidPlace = i * shift;                  if (_f[kidPlace] == 1)                  {                      ret[realcnt] = (byte)(i - 1);                      ret[realcnt + 1] = _f[kidPlace + 1];                      Buffer.BlockCopy(_f' kidPlace + 2' ret' realcnt + 2' DefaultPointerLength);                      realcnt += 2 + DefaultPointerLength;                  }              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetKidsForSave,The following statement contains a magic number: for (int i = 1; i <= 256; i++)              {                  kidPlace = i * shift;                  if (_f[kidPlace] == 1)                  {                      ret[realcnt] = (byte)(i - 1);                      ret[realcnt + 1] = _f[kidPlace + 1];                      Buffer.BlockCopy(_f' kidPlace + 2' ret' realcnt + 2' DefaultPointerLength);                      realcnt += 2 + DefaultPointerLength;                  }              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetKidsForSave,The following statement contains a magic number: for (int i = 1; i <= 256; i++)              {                  kidPlace = i * shift;                  if (_f[kidPlace] == 1)                  {                      ret[realcnt] = (byte)(i - 1);                      ret[realcnt + 1] = _f[kidPlace + 1];                      Buffer.BlockCopy(_f' kidPlace + 2' ret' realcnt + 2' DefaultPointerLength);                      realcnt += 2 + DefaultPointerLength;                  }              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetKidsForSave,The following statement contains a magic number: for (int i = 1; i <= 256; i++)              {                  kidPlace = i * shift;                  if (_f[kidPlace] == 1)                  {                      ret[realcnt] = (byte)(i - 1);                      ret[realcnt + 1] = _f[kidPlace + 1];                      Buffer.BlockCopy(_f' kidPlace + 2' ret' realcnt + 2' DefaultPointerLength);                      realcnt += 2 + DefaultPointerLength;                  }              }
Magic Number,DBreeze.LianaTrie,LTrieKidsInNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieKidsInNode.cs,GetKidsForSave,The following statement contains a magic number: if (toAdd > 0)              {                  int addSize = (2 + DefaultPointerLength) * toAdd;                  ret1 = new byte[realcnt + addSize];                  Buffer.BlockCopy(new byte[addSize]' 0' ret1' realcnt' addSize);                  Buffer.BlockCopy(ret' 0' ret1' 0' realcnt);              }              else              {                  ret1 = new byte[realcnt];                  Buffer.BlockCopy(ret' 0' ret1' 0' realcnt);              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,GenerationNodeRead,The following statement contains a magic number: if (line == null || line.Length < 2)                  return null;
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,GenerationNodeRead,The following statement contains a magic number: return line.Substring(2' sLen);
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadDynamicDataBlock,The following statement contains a magic number: try              {                  if (initPtr._IfDynamicDataPointerIsEmpty())                      return null;                    byte[] ptr = initPtr.Substring(8 - DefaultPointerLen' DefaultPointerLen);                  byte[] btDataLen = initPtr.Substring(12' 4);                    if ((btDataLen[0] & 0x80) > 0)                  {                      return null;    //no data                  }                    //value must be taken from DBstorage                  int dl = (int)btDataLen.To_UInt32_BigEndian();                  //returning value                  return Trie.Storage.Table_Read(useCache' ptr' dl);                    //ulong ptrHash = ptr.DynamicLength_To_UInt64_BigEndian();                    //if (useCache)                  //{                  //    //READER                  //    DataIdentifier di=null;                    //    _sync_dDynamicDataBlocks.EnterReadLock();                  //    try                  //    {                  //        if (dDynamicDataBlocks.TryGetValue(ptrHash' out di))                  //        {                  //            //value must be taken from Rollback                  //            if (di.Pointer == -1)                  //                return null;                    //            int dl = (int)btDataLen.To_UInt32_BigEndian();                    //            //returning value                  //            return this.RollerBack.ReadRollBackdata(di.Pointer' dl);                  //        }                  //        else                  //        {                  //            //value must be taken from DBstorage                  //            int dl = (int)btDataLen.To_UInt32_BigEndian();                  //            //returning value                  //            return Trie.Storage.Table_Read(ptr' dl);                  //        }                  //    }                  //    finally                  //    {                  //        _sync_dDynamicDataBlocks.ExitReadLock();                  //    }                    //}                  //else                  //{                  //    //WRITER                    //    //value must be taken from DBstorage                  //    int dl = (int)btDataLen.To_UInt32_BigEndian();                  //    //returning value                  //    return Trie.Storage.Table_Read(ptr' dl);                  //}              }              catch (Exception ex)              {                                  throw ex;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadDynamicDataBlock,The following statement contains a magic number: try              {                  if (initPtr._IfDynamicDataPointerIsEmpty())                      return null;                    byte[] ptr = initPtr.Substring(8 - DefaultPointerLen' DefaultPointerLen);                  byte[] btDataLen = initPtr.Substring(12' 4);                    if ((btDataLen[0] & 0x80) > 0)                  {                      return null;    //no data                  }                    //value must be taken from DBstorage                  int dl = (int)btDataLen.To_UInt32_BigEndian();                  //returning value                  return Trie.Storage.Table_Read(useCache' ptr' dl);                    //ulong ptrHash = ptr.DynamicLength_To_UInt64_BigEndian();                    //if (useCache)                  //{                  //    //READER                  //    DataIdentifier di=null;                    //    _sync_dDynamicDataBlocks.EnterReadLock();                  //    try                  //    {                  //        if (dDynamicDataBlocks.TryGetValue(ptrHash' out di))                  //        {                  //            //value must be taken from Rollback                  //            if (di.Pointer == -1)                  //                return null;                    //            int dl = (int)btDataLen.To_UInt32_BigEndian();                    //            //returning value                  //            return this.RollerBack.ReadRollBackdata(di.Pointer' dl);                  //        }                  //        else                  //        {                  //            //value must be taken from DBstorage                  //            int dl = (int)btDataLen.To_UInt32_BigEndian();                  //            //returning value                  //            return Trie.Storage.Table_Read(ptr' dl);                  //        }                  //    }                  //    finally                  //    {                  //        _sync_dDynamicDataBlocks.ExitReadLock();                  //    }                    //}                  //else                  //{                  //    //WRITER                    //    //value must be taken from DBstorage                  //    int dl = (int)btDataLen.To_UInt32_BigEndian();                  //    //returning value                  //    return Trie.Storage.Table_Read(ptr' dl);                  //}              }              catch (Exception ex)              {                                  throw ex;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadDynamicDataBlock,The following statement contains a magic number: try              {                  if (initPtr._IfDynamicDataPointerIsEmpty())                      return null;                    byte[] ptr = initPtr.Substring(8 - DefaultPointerLen' DefaultPointerLen);                  byte[] btDataLen = initPtr.Substring(12' 4);                    if ((btDataLen[0] & 0x80) > 0)                  {                      return null;    //no data                  }                    //value must be taken from DBstorage                  int dl = (int)btDataLen.To_UInt32_BigEndian();                  //returning value                  return Trie.Storage.Table_Read(useCache' ptr' dl);                    //ulong ptrHash = ptr.DynamicLength_To_UInt64_BigEndian();                    //if (useCache)                  //{                  //    //READER                  //    DataIdentifier di=null;                    //    _sync_dDynamicDataBlocks.EnterReadLock();                  //    try                  //    {                  //        if (dDynamicDataBlocks.TryGetValue(ptrHash' out di))                  //        {                  //            //value must be taken from Rollback                  //            if (di.Pointer == -1)                  //                return null;                    //            int dl = (int)btDataLen.To_UInt32_BigEndian();                    //            //returning value                  //            return this.RollerBack.ReadRollBackdata(di.Pointer' dl);                  //        }                  //        else                  //        {                  //            //value must be taken from DBstorage                  //            int dl = (int)btDataLen.To_UInt32_BigEndian();                  //            //returning value                  //            return Trie.Storage.Table_Read(ptr' dl);                  //        }                  //    }                  //    finally                  //    {                  //        _sync_dDynamicDataBlocks.ExitReadLock();                  //    }                    //}                  //else                  //{                  //    //WRITER                    //    //value must be taken from DBstorage                  //    int dl = (int)btDataLen.To_UInt32_BigEndian();                  //    //returning value                  //    return Trie.Storage.Table_Read(ptr' dl);                  //}              }              catch (Exception ex)              {                                  throw ex;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,WriteDynamicDataBlock,The following statement contains a magic number: try              {                                   if (data != null && data.LongCount() > Int32.MaxValue)                      throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DYNAMIC_DATA_BLOCK_VALUE_IS_BIG);                      if (initPtr._IfDynamicDataPointerIsEmpty() || !Trie.OverWriteIsAllowed)                  {                      //Init pointer  = null' so we write first time and to the end                      //Writing to the End ()                        //Special case value is nullable                      if (data == null)                          return new byte[] { 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0x80' 0' 0' 0 };    //indicating null value                        //First value write Returning 16 bytes.                      byte[] ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                      ret = ret.EnlargeByteArray_BigEndian(8);                      ret = ret.ConcatMany(                          ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                          ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          );                        return ret;                  }                  else                  {                                          if (data == null)                      {                          return initPtr.Substring(0' 12).Concat(new byte[] { 0x80' 0' 0' 0 });                                              }                        byte[] ret = null;                      byte[] btBlockLen = initPtr.Substring(8' 4);                      int blockLen = (int)btBlockLen.To_UInt32_BigEndian();                        if (blockLen == 0)                      {                          //Block was not reserved before we can write to the end                          //Data is not null' we create new block                            ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                          ret = ret.EnlargeByteArray_BigEndian(8);                          ret = ret.ConcatMany(                              ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                              ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                              );                            return ret;                      }                                              if (blockLen < data.Length)                      {                          //situation when we need to write in any case to the new block' because previous was too small                          ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                          ret = ret.EnlargeByteArray_BigEndian(8);                          ret = ret.ConcatMany(                              ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                              ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                              );                            return ret;                      }                      else                      {                          //Overwrite                          //original Data which we are going to overwrite' must be stored in RollBack                             byte[] ptr = initPtr.Substring(8 - DefaultPointerLen' DefaultPointerLen);                          byte[] btDataLen = initPtr.Substring(12' 4);                            //...Save new data                          Trie.Storage.Table_WriteByOffset(ptr' data);                            ptr = ptr.EnlargeByteArray_BigEndian(8);                          ret = ptr.ConcatMany(                          btBlockLen' //taking old block length                          ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          );                            return ret;                            //ulong ptrHash = ptr.DynamicLength_To_UInt64_BigEndian();                            //if ((btDataLen[0] & 0x80) > 0)                          //{                          //    //We have to store in RollbackCache info that previous block was of null size                                                //    //put to cache fake                          //    _sync_dDynamicDataBlocks.EnterWriteLock();                          //    try                          //    {                          //        if (!dDynamicDataBlocks.ContainsKey(ptrHash))                          //        {                          //            dDynamicDataBlocks.Add(ptrHash' new DataIdentifier()                          //            {                          //                Pointer = -1         //Means that we have null value' so reader can recognize it                          //            });                          //        }                          //    }                          //    finally                          //    {                          //        _sync_dDynamicDataBlocks.ExitWriteLock();                          //    }                            //    //...Save new data                          //    Trie.Storage.Table_WriteByOffset(ptr' data);                            //   ptr = ptr.EnlargeByteArray_BigEndian(8);                          //   ret = ptr.ConcatMany(                          //   btBlockLen' //taking old block length                          //   ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          //   );                            //   return ret;                          //}                          //else                          //{                          //    //int dl = (int)btDataLen.To_UInt32_BigEndian();                          //    //byte[] oldData = Trie.Storage.Table_Read(ptr' dl);                            //    ////put to Rollback                          //    //long rlbPtr = this.RollerBack.WriteRollBackData(1' ptr' ref oldData);                              //    //...Save new data                          //    Trie.Storage.Table_WriteByOffset(ptr' data);                            //    //put to cache                          //    _sync_dDynamicDataBlocks.EnterWriteLock();                          //    try                          //    {                          //        if (!dDynamicDataBlocks.ContainsKey(ptrHash))                          //        {                          //            dDynamicDataBlocks.Add(ptrHash' new DataIdentifier()                          //            {                          //                Pointer = (long)ptr.DynamicLength_To_UInt64_BigEndian()                                                                     //            });                          //        }                          //    }                          //    finally                          //    {                          //        _sync_dDynamicDataBlocks.ExitWriteLock();                          //    }                            //    ////...Save new data                          //    //Trie.Storage.Table_WriteByOffset(ptr' data);                            //    ptr = ptr.EnlargeByteArray_BigEndian(8);                            //    ret = ptr.ConcatMany(                          //       btBlockLen' //taking old block length                          //       ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          //       );                            //    return ret;                          //}                        }                  }              }              catch (Exception ex)              {                  throw ex;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,WriteDynamicDataBlock,The following statement contains a magic number: try              {                                   if (data != null && data.LongCount() > Int32.MaxValue)                      throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DYNAMIC_DATA_BLOCK_VALUE_IS_BIG);                      if (initPtr._IfDynamicDataPointerIsEmpty() || !Trie.OverWriteIsAllowed)                  {                      //Init pointer  = null' so we write first time and to the end                      //Writing to the End ()                        //Special case value is nullable                      if (data == null)                          return new byte[] { 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0x80' 0' 0' 0 };    //indicating null value                        //First value write Returning 16 bytes.                      byte[] ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                      ret = ret.EnlargeByteArray_BigEndian(8);                      ret = ret.ConcatMany(                          ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                          ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          );                        return ret;                  }                  else                  {                                          if (data == null)                      {                          return initPtr.Substring(0' 12).Concat(new byte[] { 0x80' 0' 0' 0 });                                              }                        byte[] ret = null;                      byte[] btBlockLen = initPtr.Substring(8' 4);                      int blockLen = (int)btBlockLen.To_UInt32_BigEndian();                        if (blockLen == 0)                      {                          //Block was not reserved before we can write to the end                          //Data is not null' we create new block                            ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                          ret = ret.EnlargeByteArray_BigEndian(8);                          ret = ret.ConcatMany(                              ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                              ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                              );                            return ret;                      }                                              if (blockLen < data.Length)                      {                          //situation when we need to write in any case to the new block' because previous was too small                          ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                          ret = ret.EnlargeByteArray_BigEndian(8);                          ret = ret.ConcatMany(                              ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                              ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                              );                            return ret;                      }                      else                      {                          //Overwrite                          //original Data which we are going to overwrite' must be stored in RollBack                             byte[] ptr = initPtr.Substring(8 - DefaultPointerLen' DefaultPointerLen);                          byte[] btDataLen = initPtr.Substring(12' 4);                            //...Save new data                          Trie.Storage.Table_WriteByOffset(ptr' data);                            ptr = ptr.EnlargeByteArray_BigEndian(8);                          ret = ptr.ConcatMany(                          btBlockLen' //taking old block length                          ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          );                            return ret;                            //ulong ptrHash = ptr.DynamicLength_To_UInt64_BigEndian();                            //if ((btDataLen[0] & 0x80) > 0)                          //{                          //    //We have to store in RollbackCache info that previous block was of null size                                                //    //put to cache fake                          //    _sync_dDynamicDataBlocks.EnterWriteLock();                          //    try                          //    {                          //        if (!dDynamicDataBlocks.ContainsKey(ptrHash))                          //        {                          //            dDynamicDataBlocks.Add(ptrHash' new DataIdentifier()                          //            {                          //                Pointer = -1         //Means that we have null value' so reader can recognize it                          //            });                          //        }                          //    }                          //    finally                          //    {                          //        _sync_dDynamicDataBlocks.ExitWriteLock();                          //    }                            //    //...Save new data                          //    Trie.Storage.Table_WriteByOffset(ptr' data);                            //   ptr = ptr.EnlargeByteArray_BigEndian(8);                          //   ret = ptr.ConcatMany(                          //   btBlockLen' //taking old block length                          //   ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          //   );                            //   return ret;                          //}                          //else                          //{                          //    //int dl = (int)btDataLen.To_UInt32_BigEndian();                          //    //byte[] oldData = Trie.Storage.Table_Read(ptr' dl);                            //    ////put to Rollback                          //    //long rlbPtr = this.RollerBack.WriteRollBackData(1' ptr' ref oldData);                              //    //...Save new data                          //    Trie.Storage.Table_WriteByOffset(ptr' data);                            //    //put to cache                          //    _sync_dDynamicDataBlocks.EnterWriteLock();                          //    try                          //    {                          //        if (!dDynamicDataBlocks.ContainsKey(ptrHash))                          //        {                          //            dDynamicDataBlocks.Add(ptrHash' new DataIdentifier()                          //            {                          //                Pointer = (long)ptr.DynamicLength_To_UInt64_BigEndian()                                                                     //            });                          //        }                          //    }                          //    finally                          //    {                          //        _sync_dDynamicDataBlocks.ExitWriteLock();                          //    }                            //    ////...Save new data                          //    //Trie.Storage.Table_WriteByOffset(ptr' data);                            //    ptr = ptr.EnlargeByteArray_BigEndian(8);                            //    ret = ptr.ConcatMany(                          //       btBlockLen' //taking old block length                          //       ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          //       );                            //    return ret;                          //}                        }                  }              }              catch (Exception ex)              {                  throw ex;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,WriteDynamicDataBlock,The following statement contains a magic number: try              {                                   if (data != null && data.LongCount() > Int32.MaxValue)                      throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DYNAMIC_DATA_BLOCK_VALUE_IS_BIG);                      if (initPtr._IfDynamicDataPointerIsEmpty() || !Trie.OverWriteIsAllowed)                  {                      //Init pointer  = null' so we write first time and to the end                      //Writing to the End ()                        //Special case value is nullable                      if (data == null)                          return new byte[] { 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0x80' 0' 0' 0 };    //indicating null value                        //First value write Returning 16 bytes.                      byte[] ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                      ret = ret.EnlargeByteArray_BigEndian(8);                      ret = ret.ConcatMany(                          ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                          ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          );                        return ret;                  }                  else                  {                                          if (data == null)                      {                          return initPtr.Substring(0' 12).Concat(new byte[] { 0x80' 0' 0' 0 });                                              }                        byte[] ret = null;                      byte[] btBlockLen = initPtr.Substring(8' 4);                      int blockLen = (int)btBlockLen.To_UInt32_BigEndian();                        if (blockLen == 0)                      {                          //Block was not reserved before we can write to the end                          //Data is not null' we create new block                            ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                          ret = ret.EnlargeByteArray_BigEndian(8);                          ret = ret.ConcatMany(                              ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                              ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                              );                            return ret;                      }                                              if (blockLen < data.Length)                      {                          //situation when we need to write in any case to the new block' because previous was too small                          ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                          ret = ret.EnlargeByteArray_BigEndian(8);                          ret = ret.ConcatMany(                              ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                              ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                              );                            return ret;                      }                      else                      {                          //Overwrite                          //original Data which we are going to overwrite' must be stored in RollBack                             byte[] ptr = initPtr.Substring(8 - DefaultPointerLen' DefaultPointerLen);                          byte[] btDataLen = initPtr.Substring(12' 4);                            //...Save new data                          Trie.Storage.Table_WriteByOffset(ptr' data);                            ptr = ptr.EnlargeByteArray_BigEndian(8);                          ret = ptr.ConcatMany(                          btBlockLen' //taking old block length                          ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          );                            return ret;                            //ulong ptrHash = ptr.DynamicLength_To_UInt64_BigEndian();                            //if ((btDataLen[0] & 0x80) > 0)                          //{                          //    //We have to store in RollbackCache info that previous block was of null size                                                //    //put to cache fake                          //    _sync_dDynamicDataBlocks.EnterWriteLock();                          //    try                          //    {                          //        if (!dDynamicDataBlocks.ContainsKey(ptrHash))                          //        {                          //            dDynamicDataBlocks.Add(ptrHash' new DataIdentifier()                          //            {                          //                Pointer = -1         //Means that we have null value' so reader can recognize it                          //            });                          //        }                          //    }                          //    finally                          //    {                          //        _sync_dDynamicDataBlocks.ExitWriteLock();                          //    }                            //    //...Save new data                          //    Trie.Storage.Table_WriteByOffset(ptr' data);                            //   ptr = ptr.EnlargeByteArray_BigEndian(8);                          //   ret = ptr.ConcatMany(                          //   btBlockLen' //taking old block length                          //   ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          //   );                            //   return ret;                          //}                          //else                          //{                          //    //int dl = (int)btDataLen.To_UInt32_BigEndian();                          //    //byte[] oldData = Trie.Storage.Table_Read(ptr' dl);                            //    ////put to Rollback                          //    //long rlbPtr = this.RollerBack.WriteRollBackData(1' ptr' ref oldData);                              //    //...Save new data                          //    Trie.Storage.Table_WriteByOffset(ptr' data);                            //    //put to cache                          //    _sync_dDynamicDataBlocks.EnterWriteLock();                          //    try                          //    {                          //        if (!dDynamicDataBlocks.ContainsKey(ptrHash))                          //        {                          //            dDynamicDataBlocks.Add(ptrHash' new DataIdentifier()                          //            {                          //                Pointer = (long)ptr.DynamicLength_To_UInt64_BigEndian()                                                                     //            });                          //        }                          //    }                          //    finally                          //    {                          //        _sync_dDynamicDataBlocks.ExitWriteLock();                          //    }                            //    ////...Save new data                          //    //Trie.Storage.Table_WriteByOffset(ptr' data);                            //    ptr = ptr.EnlargeByteArray_BigEndian(8);                            //    ret = ptr.ConcatMany(                          //       btBlockLen' //taking old block length                          //       ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          //       );                            //    return ret;                          //}                        }                  }              }              catch (Exception ex)              {                  throw ex;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,WriteDynamicDataBlock,The following statement contains a magic number: try              {                                   if (data != null && data.LongCount() > Int32.MaxValue)                      throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DYNAMIC_DATA_BLOCK_VALUE_IS_BIG);                      if (initPtr._IfDynamicDataPointerIsEmpty() || !Trie.OverWriteIsAllowed)                  {                      //Init pointer  = null' so we write first time and to the end                      //Writing to the End ()                        //Special case value is nullable                      if (data == null)                          return new byte[] { 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0x80' 0' 0' 0 };    //indicating null value                        //First value write Returning 16 bytes.                      byte[] ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                      ret = ret.EnlargeByteArray_BigEndian(8);                      ret = ret.ConcatMany(                          ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                          ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          );                        return ret;                  }                  else                  {                                          if (data == null)                      {                          return initPtr.Substring(0' 12).Concat(new byte[] { 0x80' 0' 0' 0 });                                              }                        byte[] ret = null;                      byte[] btBlockLen = initPtr.Substring(8' 4);                      int blockLen = (int)btBlockLen.To_UInt32_BigEndian();                        if (blockLen == 0)                      {                          //Block was not reserved before we can write to the end                          //Data is not null' we create new block                            ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                          ret = ret.EnlargeByteArray_BigEndian(8);                          ret = ret.ConcatMany(                              ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                              ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                              );                            return ret;                      }                                              if (blockLen < data.Length)                      {                          //situation when we need to write in any case to the new block' because previous was too small                          ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                          ret = ret.EnlargeByteArray_BigEndian(8);                          ret = ret.ConcatMany(                              ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                              ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                              );                            return ret;                      }                      else                      {                          //Overwrite                          //original Data which we are going to overwrite' must be stored in RollBack                             byte[] ptr = initPtr.Substring(8 - DefaultPointerLen' DefaultPointerLen);                          byte[] btDataLen = initPtr.Substring(12' 4);                            //...Save new data                          Trie.Storage.Table_WriteByOffset(ptr' data);                            ptr = ptr.EnlargeByteArray_BigEndian(8);                          ret = ptr.ConcatMany(                          btBlockLen' //taking old block length                          ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          );                            return ret;                            //ulong ptrHash = ptr.DynamicLength_To_UInt64_BigEndian();                            //if ((btDataLen[0] & 0x80) > 0)                          //{                          //    //We have to store in RollbackCache info that previous block was of null size                                                //    //put to cache fake                          //    _sync_dDynamicDataBlocks.EnterWriteLock();                          //    try                          //    {                          //        if (!dDynamicDataBlocks.ContainsKey(ptrHash))                          //        {                          //            dDynamicDataBlocks.Add(ptrHash' new DataIdentifier()                          //            {                          //                Pointer = -1         //Means that we have null value' so reader can recognize it                          //            });                          //        }                          //    }                          //    finally                          //    {                          //        _sync_dDynamicDataBlocks.ExitWriteLock();                          //    }                            //    //...Save new data                          //    Trie.Storage.Table_WriteByOffset(ptr' data);                            //   ptr = ptr.EnlargeByteArray_BigEndian(8);                          //   ret = ptr.ConcatMany(                          //   btBlockLen' //taking old block length                          //   ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          //   );                            //   return ret;                          //}                          //else                          //{                          //    //int dl = (int)btDataLen.To_UInt32_BigEndian();                          //    //byte[] oldData = Trie.Storage.Table_Read(ptr' dl);                            //    ////put to Rollback                          //    //long rlbPtr = this.RollerBack.WriteRollBackData(1' ptr' ref oldData);                              //    //...Save new data                          //    Trie.Storage.Table_WriteByOffset(ptr' data);                            //    //put to cache                          //    _sync_dDynamicDataBlocks.EnterWriteLock();                          //    try                          //    {                          //        if (!dDynamicDataBlocks.ContainsKey(ptrHash))                          //        {                          //            dDynamicDataBlocks.Add(ptrHash' new DataIdentifier()                          //            {                          //                Pointer = (long)ptr.DynamicLength_To_UInt64_BigEndian()                                                                     //            });                          //        }                          //    }                          //    finally                          //    {                          //        _sync_dDynamicDataBlocks.ExitWriteLock();                          //    }                            //    ////...Save new data                          //    //Trie.Storage.Table_WriteByOffset(ptr' data);                            //    ptr = ptr.EnlargeByteArray_BigEndian(8);                            //    ret = ptr.ConcatMany(                          //       btBlockLen' //taking old block length                          //       ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          //       );                            //    return ret;                          //}                        }                  }              }              catch (Exception ex)              {                  throw ex;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,WriteDynamicDataBlock,The following statement contains a magic number: try              {                                   if (data != null && data.LongCount() > Int32.MaxValue)                      throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DYNAMIC_DATA_BLOCK_VALUE_IS_BIG);                      if (initPtr._IfDynamicDataPointerIsEmpty() || !Trie.OverWriteIsAllowed)                  {                      //Init pointer  = null' so we write first time and to the end                      //Writing to the End ()                        //Special case value is nullable                      if (data == null)                          return new byte[] { 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0x80' 0' 0' 0 };    //indicating null value                        //First value write Returning 16 bytes.                      byte[] ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                      ret = ret.EnlargeByteArray_BigEndian(8);                      ret = ret.ConcatMany(                          ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                          ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          );                        return ret;                  }                  else                  {                                          if (data == null)                      {                          return initPtr.Substring(0' 12).Concat(new byte[] { 0x80' 0' 0' 0 });                                              }                        byte[] ret = null;                      byte[] btBlockLen = initPtr.Substring(8' 4);                      int blockLen = (int)btBlockLen.To_UInt32_BigEndian();                        if (blockLen == 0)                      {                          //Block was not reserved before we can write to the end                          //Data is not null' we create new block                            ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                          ret = ret.EnlargeByteArray_BigEndian(8);                          ret = ret.ConcatMany(                              ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                              ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                              );                            return ret;                      }                                              if (blockLen < data.Length)                      {                          //situation when we need to write in any case to the new block' because previous was too small                          ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                          ret = ret.EnlargeByteArray_BigEndian(8);                          ret = ret.ConcatMany(                              ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                              ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                              );                            return ret;                      }                      else                      {                          //Overwrite                          //original Data which we are going to overwrite' must be stored in RollBack                             byte[] ptr = initPtr.Substring(8 - DefaultPointerLen' DefaultPointerLen);                          byte[] btDataLen = initPtr.Substring(12' 4);                            //...Save new data                          Trie.Storage.Table_WriteByOffset(ptr' data);                            ptr = ptr.EnlargeByteArray_BigEndian(8);                          ret = ptr.ConcatMany(                          btBlockLen' //taking old block length                          ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          );                            return ret;                            //ulong ptrHash = ptr.DynamicLength_To_UInt64_BigEndian();                            //if ((btDataLen[0] & 0x80) > 0)                          //{                          //    //We have to store in RollbackCache info that previous block was of null size                                                //    //put to cache fake                          //    _sync_dDynamicDataBlocks.EnterWriteLock();                          //    try                          //    {                          //        if (!dDynamicDataBlocks.ContainsKey(ptrHash))                          //        {                          //            dDynamicDataBlocks.Add(ptrHash' new DataIdentifier()                          //            {                          //                Pointer = -1         //Means that we have null value' so reader can recognize it                          //            });                          //        }                          //    }                          //    finally                          //    {                          //        _sync_dDynamicDataBlocks.ExitWriteLock();                          //    }                            //    //...Save new data                          //    Trie.Storage.Table_WriteByOffset(ptr' data);                            //   ptr = ptr.EnlargeByteArray_BigEndian(8);                          //   ret = ptr.ConcatMany(                          //   btBlockLen' //taking old block length                          //   ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          //   );                            //   return ret;                          //}                          //else                          //{                          //    //int dl = (int)btDataLen.To_UInt32_BigEndian();                          //    //byte[] oldData = Trie.Storage.Table_Read(ptr' dl);                            //    ////put to Rollback                          //    //long rlbPtr = this.RollerBack.WriteRollBackData(1' ptr' ref oldData);                              //    //...Save new data                          //    Trie.Storage.Table_WriteByOffset(ptr' data);                            //    //put to cache                          //    _sync_dDynamicDataBlocks.EnterWriteLock();                          //    try                          //    {                          //        if (!dDynamicDataBlocks.ContainsKey(ptrHash))                          //        {                          //            dDynamicDataBlocks.Add(ptrHash' new DataIdentifier()                          //            {                          //                Pointer = (long)ptr.DynamicLength_To_UInt64_BigEndian()                                                                     //            });                          //        }                          //    }                          //    finally                          //    {                          //        _sync_dDynamicDataBlocks.ExitWriteLock();                          //    }                            //    ////...Save new data                          //    //Trie.Storage.Table_WriteByOffset(ptr' data);                            //    ptr = ptr.EnlargeByteArray_BigEndian(8);                            //    ret = ptr.ConcatMany(                          //       btBlockLen' //taking old block length                          //       ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          //       );                            //    return ret;                          //}                        }                  }              }              catch (Exception ex)              {                  throw ex;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,WriteDynamicDataBlock,The following statement contains a magic number: try              {                                   if (data != null && data.LongCount() > Int32.MaxValue)                      throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DYNAMIC_DATA_BLOCK_VALUE_IS_BIG);                      if (initPtr._IfDynamicDataPointerIsEmpty() || !Trie.OverWriteIsAllowed)                  {                      //Init pointer  = null' so we write first time and to the end                      //Writing to the End ()                        //Special case value is nullable                      if (data == null)                          return new byte[] { 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0x80' 0' 0' 0 };    //indicating null value                        //First value write Returning 16 bytes.                      byte[] ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                      ret = ret.EnlargeByteArray_BigEndian(8);                      ret = ret.ConcatMany(                          ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                          ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          );                        return ret;                  }                  else                  {                                          if (data == null)                      {                          return initPtr.Substring(0' 12).Concat(new byte[] { 0x80' 0' 0' 0 });                                              }                        byte[] ret = null;                      byte[] btBlockLen = initPtr.Substring(8' 4);                      int blockLen = (int)btBlockLen.To_UInt32_BigEndian();                        if (blockLen == 0)                      {                          //Block was not reserved before we can write to the end                          //Data is not null' we create new block                            ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                          ret = ret.EnlargeByteArray_BigEndian(8);                          ret = ret.ConcatMany(                              ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                              ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                              );                            return ret;                      }                                              if (blockLen < data.Length)                      {                          //situation when we need to write in any case to the new block' because previous was too small                          ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                          ret = ret.EnlargeByteArray_BigEndian(8);                          ret = ret.ConcatMany(                              ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                              ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                              );                            return ret;                      }                      else                      {                          //Overwrite                          //original Data which we are going to overwrite' must be stored in RollBack                             byte[] ptr = initPtr.Substring(8 - DefaultPointerLen' DefaultPointerLen);                          byte[] btDataLen = initPtr.Substring(12' 4);                            //...Save new data                          Trie.Storage.Table_WriteByOffset(ptr' data);                            ptr = ptr.EnlargeByteArray_BigEndian(8);                          ret = ptr.ConcatMany(                          btBlockLen' //taking old block length                          ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          );                            return ret;                            //ulong ptrHash = ptr.DynamicLength_To_UInt64_BigEndian();                            //if ((btDataLen[0] & 0x80) > 0)                          //{                          //    //We have to store in RollbackCache info that previous block was of null size                                                //    //put to cache fake                          //    _sync_dDynamicDataBlocks.EnterWriteLock();                          //    try                          //    {                          //        if (!dDynamicDataBlocks.ContainsKey(ptrHash))                          //        {                          //            dDynamicDataBlocks.Add(ptrHash' new DataIdentifier()                          //            {                          //                Pointer = -1         //Means that we have null value' so reader can recognize it                          //            });                          //        }                          //    }                          //    finally                          //    {                          //        _sync_dDynamicDataBlocks.ExitWriteLock();                          //    }                            //    //...Save new data                          //    Trie.Storage.Table_WriteByOffset(ptr' data);                            //   ptr = ptr.EnlargeByteArray_BigEndian(8);                          //   ret = ptr.ConcatMany(                          //   btBlockLen' //taking old block length                          //   ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          //   );                            //   return ret;                          //}                          //else                          //{                          //    //int dl = (int)btDataLen.To_UInt32_BigEndian();                          //    //byte[] oldData = Trie.Storage.Table_Read(ptr' dl);                            //    ////put to Rollback                          //    //long rlbPtr = this.RollerBack.WriteRollBackData(1' ptr' ref oldData);                              //    //...Save new data                          //    Trie.Storage.Table_WriteByOffset(ptr' data);                            //    //put to cache                          //    _sync_dDynamicDataBlocks.EnterWriteLock();                          //    try                          //    {                          //        if (!dDynamicDataBlocks.ContainsKey(ptrHash))                          //        {                          //            dDynamicDataBlocks.Add(ptrHash' new DataIdentifier()                          //            {                          //                Pointer = (long)ptr.DynamicLength_To_UInt64_BigEndian()                                                                     //            });                          //        }                          //    }                          //    finally                          //    {                          //        _sync_dDynamicDataBlocks.ExitWriteLock();                          //    }                            //    ////...Save new data                          //    //Trie.Storage.Table_WriteByOffset(ptr' data);                            //    ptr = ptr.EnlargeByteArray_BigEndian(8);                            //    ret = ptr.ConcatMany(                          //       btBlockLen' //taking old block length                          //       ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          //       );                            //    return ret;                          //}                        }                  }              }              catch (Exception ex)              {                  throw ex;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,WriteDynamicDataBlock,The following statement contains a magic number: try              {                                   if (data != null && data.LongCount() > Int32.MaxValue)                      throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DYNAMIC_DATA_BLOCK_VALUE_IS_BIG);                      if (initPtr._IfDynamicDataPointerIsEmpty() || !Trie.OverWriteIsAllowed)                  {                      //Init pointer  = null' so we write first time and to the end                      //Writing to the End ()                        //Special case value is nullable                      if (data == null)                          return new byte[] { 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0x80' 0' 0' 0 };    //indicating null value                        //First value write Returning 16 bytes.                      byte[] ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                      ret = ret.EnlargeByteArray_BigEndian(8);                      ret = ret.ConcatMany(                          ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                          ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          );                        return ret;                  }                  else                  {                                          if (data == null)                      {                          return initPtr.Substring(0' 12).Concat(new byte[] { 0x80' 0' 0' 0 });                                              }                        byte[] ret = null;                      byte[] btBlockLen = initPtr.Substring(8' 4);                      int blockLen = (int)btBlockLen.To_UInt32_BigEndian();                        if (blockLen == 0)                      {                          //Block was not reserved before we can write to the end                          //Data is not null' we create new block                            ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                          ret = ret.EnlargeByteArray_BigEndian(8);                          ret = ret.ConcatMany(                              ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                              ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                              );                            return ret;                      }                                              if (blockLen < data.Length)                      {                          //situation when we need to write in any case to the new block' because previous was too small                          ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                          ret = ret.EnlargeByteArray_BigEndian(8);                          ret = ret.ConcatMany(                              ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                              ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                              );                            return ret;                      }                      else                      {                          //Overwrite                          //original Data which we are going to overwrite' must be stored in RollBack                             byte[] ptr = initPtr.Substring(8 - DefaultPointerLen' DefaultPointerLen);                          byte[] btDataLen = initPtr.Substring(12' 4);                            //...Save new data                          Trie.Storage.Table_WriteByOffset(ptr' data);                            ptr = ptr.EnlargeByteArray_BigEndian(8);                          ret = ptr.ConcatMany(                          btBlockLen' //taking old block length                          ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          );                            return ret;                            //ulong ptrHash = ptr.DynamicLength_To_UInt64_BigEndian();                            //if ((btDataLen[0] & 0x80) > 0)                          //{                          //    //We have to store in RollbackCache info that previous block was of null size                                                //    //put to cache fake                          //    _sync_dDynamicDataBlocks.EnterWriteLock();                          //    try                          //    {                          //        if (!dDynamicDataBlocks.ContainsKey(ptrHash))                          //        {                          //            dDynamicDataBlocks.Add(ptrHash' new DataIdentifier()                          //            {                          //                Pointer = -1         //Means that we have null value' so reader can recognize it                          //            });                          //        }                          //    }                          //    finally                          //    {                          //        _sync_dDynamicDataBlocks.ExitWriteLock();                          //    }                            //    //...Save new data                          //    Trie.Storage.Table_WriteByOffset(ptr' data);                            //   ptr = ptr.EnlargeByteArray_BigEndian(8);                          //   ret = ptr.ConcatMany(                          //   btBlockLen' //taking old block length                          //   ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          //   );                            //   return ret;                          //}                          //else                          //{                          //    //int dl = (int)btDataLen.To_UInt32_BigEndian();                          //    //byte[] oldData = Trie.Storage.Table_Read(ptr' dl);                            //    ////put to Rollback                          //    //long rlbPtr = this.RollerBack.WriteRollBackData(1' ptr' ref oldData);                              //    //...Save new data                          //    Trie.Storage.Table_WriteByOffset(ptr' data);                            //    //put to cache                          //    _sync_dDynamicDataBlocks.EnterWriteLock();                          //    try                          //    {                          //        if (!dDynamicDataBlocks.ContainsKey(ptrHash))                          //        {                          //            dDynamicDataBlocks.Add(ptrHash' new DataIdentifier()                          //            {                          //                Pointer = (long)ptr.DynamicLength_To_UInt64_BigEndian()                                                                     //            });                          //        }                          //    }                          //    finally                          //    {                          //        _sync_dDynamicDataBlocks.ExitWriteLock();                          //    }                            //    ////...Save new data                          //    //Trie.Storage.Table_WriteByOffset(ptr' data);                            //    ptr = ptr.EnlargeByteArray_BigEndian(8);                            //    ret = ptr.ConcatMany(                          //       btBlockLen' //taking old block length                          //       ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          //       );                            //    return ret;                          //}                        }                  }              }              catch (Exception ex)              {                  throw ex;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,WriteDynamicDataBlock,The following statement contains a magic number: try              {                                   if (data != null && data.LongCount() > Int32.MaxValue)                      throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DYNAMIC_DATA_BLOCK_VALUE_IS_BIG);                      if (initPtr._IfDynamicDataPointerIsEmpty() || !Trie.OverWriteIsAllowed)                  {                      //Init pointer  = null' so we write first time and to the end                      //Writing to the End ()                        //Special case value is nullable                      if (data == null)                          return new byte[] { 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0x80' 0' 0' 0 };    //indicating null value                        //First value write Returning 16 bytes.                      byte[] ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                      ret = ret.EnlargeByteArray_BigEndian(8);                      ret = ret.ConcatMany(                          ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                          ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          );                        return ret;                  }                  else                  {                                          if (data == null)                      {                          return initPtr.Substring(0' 12).Concat(new byte[] { 0x80' 0' 0' 0 });                                              }                        byte[] ret = null;                      byte[] btBlockLen = initPtr.Substring(8' 4);                      int blockLen = (int)btBlockLen.To_UInt32_BigEndian();                        if (blockLen == 0)                      {                          //Block was not reserved before we can write to the end                          //Data is not null' we create new block                            ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                          ret = ret.EnlargeByteArray_BigEndian(8);                          ret = ret.ConcatMany(                              ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                              ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                              );                            return ret;                      }                                              if (blockLen < data.Length)                      {                          //situation when we need to write in any case to the new block' because previous was too small                          ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                          ret = ret.EnlargeByteArray_BigEndian(8);                          ret = ret.ConcatMany(                              ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                              ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                              );                            return ret;                      }                      else                      {                          //Overwrite                          //original Data which we are going to overwrite' must be stored in RollBack                             byte[] ptr = initPtr.Substring(8 - DefaultPointerLen' DefaultPointerLen);                          byte[] btDataLen = initPtr.Substring(12' 4);                            //...Save new data                          Trie.Storage.Table_WriteByOffset(ptr' data);                            ptr = ptr.EnlargeByteArray_BigEndian(8);                          ret = ptr.ConcatMany(                          btBlockLen' //taking old block length                          ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          );                            return ret;                            //ulong ptrHash = ptr.DynamicLength_To_UInt64_BigEndian();                            //if ((btDataLen[0] & 0x80) > 0)                          //{                          //    //We have to store in RollbackCache info that previous block was of null size                                                //    //put to cache fake                          //    _sync_dDynamicDataBlocks.EnterWriteLock();                          //    try                          //    {                          //        if (!dDynamicDataBlocks.ContainsKey(ptrHash))                          //        {                          //            dDynamicDataBlocks.Add(ptrHash' new DataIdentifier()                          //            {                          //                Pointer = -1         //Means that we have null value' so reader can recognize it                          //            });                          //        }                          //    }                          //    finally                          //    {                          //        _sync_dDynamicDataBlocks.ExitWriteLock();                          //    }                            //    //...Save new data                          //    Trie.Storage.Table_WriteByOffset(ptr' data);                            //   ptr = ptr.EnlargeByteArray_BigEndian(8);                          //   ret = ptr.ConcatMany(                          //   btBlockLen' //taking old block length                          //   ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          //   );                            //   return ret;                          //}                          //else                          //{                          //    //int dl = (int)btDataLen.To_UInt32_BigEndian();                          //    //byte[] oldData = Trie.Storage.Table_Read(ptr' dl);                            //    ////put to Rollback                          //    //long rlbPtr = this.RollerBack.WriteRollBackData(1' ptr' ref oldData);                              //    //...Save new data                          //    Trie.Storage.Table_WriteByOffset(ptr' data);                            //    //put to cache                          //    _sync_dDynamicDataBlocks.EnterWriteLock();                          //    try                          //    {                          //        if (!dDynamicDataBlocks.ContainsKey(ptrHash))                          //        {                          //            dDynamicDataBlocks.Add(ptrHash' new DataIdentifier()                          //            {                          //                Pointer = (long)ptr.DynamicLength_To_UInt64_BigEndian()                                                                     //            });                          //        }                          //    }                          //    finally                          //    {                          //        _sync_dDynamicDataBlocks.ExitWriteLock();                          //    }                            //    ////...Save new data                          //    //Trie.Storage.Table_WriteByOffset(ptr' data);                            //    ptr = ptr.EnlargeByteArray_BigEndian(8);                            //    ret = ptr.ConcatMany(                          //       btBlockLen' //taking old block length                          //       ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          //       );                            //    return ret;                          //}                        }                  }              }              catch (Exception ex)              {                  throw ex;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,WriteDynamicDataBlock,The following statement contains a magic number: try              {                                   if (data != null && data.LongCount() > Int32.MaxValue)                      throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DYNAMIC_DATA_BLOCK_VALUE_IS_BIG);                      if (initPtr._IfDynamicDataPointerIsEmpty() || !Trie.OverWriteIsAllowed)                  {                      //Init pointer  = null' so we write first time and to the end                      //Writing to the End ()                        //Special case value is nullable                      if (data == null)                          return new byte[] { 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0x80' 0' 0' 0 };    //indicating null value                        //First value write Returning 16 bytes.                      byte[] ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                      ret = ret.EnlargeByteArray_BigEndian(8);                      ret = ret.ConcatMany(                          ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                          ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          );                        return ret;                  }                  else                  {                                          if (data == null)                      {                          return initPtr.Substring(0' 12).Concat(new byte[] { 0x80' 0' 0' 0 });                                              }                        byte[] ret = null;                      byte[] btBlockLen = initPtr.Substring(8' 4);                      int blockLen = (int)btBlockLen.To_UInt32_BigEndian();                        if (blockLen == 0)                      {                          //Block was not reserved before we can write to the end                          //Data is not null' we create new block                            ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                          ret = ret.EnlargeByteArray_BigEndian(8);                          ret = ret.ConcatMany(                              ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                              ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                              );                            return ret;                      }                                              if (blockLen < data.Length)                      {                          //situation when we need to write in any case to the new block' because previous was too small                          ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                          ret = ret.EnlargeByteArray_BigEndian(8);                          ret = ret.ConcatMany(                              ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                              ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                              );                            return ret;                      }                      else                      {                          //Overwrite                          //original Data which we are going to overwrite' must be stored in RollBack                             byte[] ptr = initPtr.Substring(8 - DefaultPointerLen' DefaultPointerLen);                          byte[] btDataLen = initPtr.Substring(12' 4);                            //...Save new data                          Trie.Storage.Table_WriteByOffset(ptr' data);                            ptr = ptr.EnlargeByteArray_BigEndian(8);                          ret = ptr.ConcatMany(                          btBlockLen' //taking old block length                          ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          );                            return ret;                            //ulong ptrHash = ptr.DynamicLength_To_UInt64_BigEndian();                            //if ((btDataLen[0] & 0x80) > 0)                          //{                          //    //We have to store in RollbackCache info that previous block was of null size                                                //    //put to cache fake                          //    _sync_dDynamicDataBlocks.EnterWriteLock();                          //    try                          //    {                          //        if (!dDynamicDataBlocks.ContainsKey(ptrHash))                          //        {                          //            dDynamicDataBlocks.Add(ptrHash' new DataIdentifier()                          //            {                          //                Pointer = -1         //Means that we have null value' so reader can recognize it                          //            });                          //        }                          //    }                          //    finally                          //    {                          //        _sync_dDynamicDataBlocks.ExitWriteLock();                          //    }                            //    //...Save new data                          //    Trie.Storage.Table_WriteByOffset(ptr' data);                            //   ptr = ptr.EnlargeByteArray_BigEndian(8);                          //   ret = ptr.ConcatMany(                          //   btBlockLen' //taking old block length                          //   ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          //   );                            //   return ret;                          //}                          //else                          //{                          //    //int dl = (int)btDataLen.To_UInt32_BigEndian();                          //    //byte[] oldData = Trie.Storage.Table_Read(ptr' dl);                            //    ////put to Rollback                          //    //long rlbPtr = this.RollerBack.WriteRollBackData(1' ptr' ref oldData);                              //    //...Save new data                          //    Trie.Storage.Table_WriteByOffset(ptr' data);                            //    //put to cache                          //    _sync_dDynamicDataBlocks.EnterWriteLock();                          //    try                          //    {                          //        if (!dDynamicDataBlocks.ContainsKey(ptrHash))                          //        {                          //            dDynamicDataBlocks.Add(ptrHash' new DataIdentifier()                          //            {                          //                Pointer = (long)ptr.DynamicLength_To_UInt64_BigEndian()                                                                     //            });                          //        }                          //    }                          //    finally                          //    {                          //        _sync_dDynamicDataBlocks.ExitWriteLock();                          //    }                            //    ////...Save new data                          //    //Trie.Storage.Table_WriteByOffset(ptr' data);                            //    ptr = ptr.EnlargeByteArray_BigEndian(8);                            //    ret = ptr.ConcatMany(                          //       btBlockLen' //taking old block length                          //       ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          //       );                            //    return ret;                          //}                        }                  }              }              catch (Exception ex)              {                  throw ex;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,WriteDynamicDataBlock,The following statement contains a magic number: try              {                                   if (data != null && data.LongCount() > Int32.MaxValue)                      throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DYNAMIC_DATA_BLOCK_VALUE_IS_BIG);                      if (initPtr._IfDynamicDataPointerIsEmpty() || !Trie.OverWriteIsAllowed)                  {                      //Init pointer  = null' so we write first time and to the end                      //Writing to the End ()                        //Special case value is nullable                      if (data == null)                          return new byte[] { 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0x80' 0' 0' 0 };    //indicating null value                        //First value write Returning 16 bytes.                      byte[] ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                      ret = ret.EnlargeByteArray_BigEndian(8);                      ret = ret.ConcatMany(                          ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                          ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          );                        return ret;                  }                  else                  {                                          if (data == null)                      {                          return initPtr.Substring(0' 12).Concat(new byte[] { 0x80' 0' 0' 0 });                                              }                        byte[] ret = null;                      byte[] btBlockLen = initPtr.Substring(8' 4);                      int blockLen = (int)btBlockLen.To_UInt32_BigEndian();                        if (blockLen == 0)                      {                          //Block was not reserved before we can write to the end                          //Data is not null' we create new block                            ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                          ret = ret.EnlargeByteArray_BigEndian(8);                          ret = ret.ConcatMany(                              ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                              ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                              );                            return ret;                      }                                              if (blockLen < data.Length)                      {                          //situation when we need to write in any case to the new block' because previous was too small                          ret = Trie.Storage.Table_WriteToTheEnd(data);    //getting pointer                          ret = ret.EnlargeByteArray_BigEndian(8);                          ret = ret.ConcatMany(                              ((uint)data.Length).To_4_bytes_array_BigEndian()' //block size equals data length                              ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                              );                            return ret;                      }                      else                      {                          //Overwrite                          //original Data which we are going to overwrite' must be stored in RollBack                             byte[] ptr = initPtr.Substring(8 - DefaultPointerLen' DefaultPointerLen);                          byte[] btDataLen = initPtr.Substring(12' 4);                            //...Save new data                          Trie.Storage.Table_WriteByOffset(ptr' data);                            ptr = ptr.EnlargeByteArray_BigEndian(8);                          ret = ptr.ConcatMany(                          btBlockLen' //taking old block length                          ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          );                            return ret;                            //ulong ptrHash = ptr.DynamicLength_To_UInt64_BigEndian();                            //if ((btDataLen[0] & 0x80) > 0)                          //{                          //    //We have to store in RollbackCache info that previous block was of null size                                                //    //put to cache fake                          //    _sync_dDynamicDataBlocks.EnterWriteLock();                          //    try                          //    {                          //        if (!dDynamicDataBlocks.ContainsKey(ptrHash))                          //        {                          //            dDynamicDataBlocks.Add(ptrHash' new DataIdentifier()                          //            {                          //                Pointer = -1         //Means that we have null value' so reader can recognize it                          //            });                          //        }                          //    }                          //    finally                          //    {                          //        _sync_dDynamicDataBlocks.ExitWriteLock();                          //    }                            //    //...Save new data                          //    Trie.Storage.Table_WriteByOffset(ptr' data);                            //   ptr = ptr.EnlargeByteArray_BigEndian(8);                          //   ret = ptr.ConcatMany(                          //   btBlockLen' //taking old block length                          //   ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          //   );                            //   return ret;                          //}                          //else                          //{                          //    //int dl = (int)btDataLen.To_UInt32_BigEndian();                          //    //byte[] oldData = Trie.Storage.Table_Read(ptr' dl);                            //    ////put to Rollback                          //    //long rlbPtr = this.RollerBack.WriteRollBackData(1' ptr' ref oldData);                              //    //...Save new data                          //    Trie.Storage.Table_WriteByOffset(ptr' data);                            //    //put to cache                          //    _sync_dDynamicDataBlocks.EnterWriteLock();                          //    try                          //    {                          //        if (!dDynamicDataBlocks.ContainsKey(ptrHash))                          //        {                          //            dDynamicDataBlocks.Add(ptrHash' new DataIdentifier()                          //            {                          //                Pointer = (long)ptr.DynamicLength_To_UInt64_BigEndian()                                                                     //            });                          //        }                          //    }                          //    finally                          //    {                          //        _sync_dDynamicDataBlocks.ExitWriteLock();                          //    }                            //    ////...Save new data                          //    //Trie.Storage.Table_WriteByOffset(ptr' data);                            //    ptr = ptr.EnlargeByteArray_BigEndian(8);                            //    ret = ptr.ConcatMany(                          //       btBlockLen' //taking old block length                          //       ((uint)data.Length).To_4_bytes_array_BigEndian()  //data length                          //       );                            //    return ret;                          //}                        }                  }              }              catch (Exception ex)              {                  throw ex;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKeyValue,The following statement contains a magic number: int initRead = 4096;
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKeyValue,The following statement contains a magic number: ushort keySize = (new byte[] { data[1]' data[2] }).To_UInt16_BigEndian();
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKeyValue,The following statement contains a magic number: byte[] btValueSize = new byte[] { data[3]' data[4]' data[5]' data[6] };
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKeyValue,The following statement contains a magic number: byte[] btValueSize = new byte[] { data[3]' data[4]' data[5]' data[6] };
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKeyValue,The following statement contains a magic number: byte[] btValueSize = new byte[] { data[3]' data[4]' data[5]' data[6] };
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKeyValue,The following statement contains a magic number: byte[] btValueSize = new byte[] { data[3]' data[4]' data[5]' data[6] };
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKeyValue,The following statement contains a magic number: if ((data[3] & 0x80) > 0)              {                  //VALUE is NULL                  valueLength = 0;              }              else              {                  valueLength = btValueSize.To_UInt32_BigEndian();                  valueSize = (int)valueLength;                    if(valueSize == 0)                      val = new byte[0];              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKeyValue,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          initRead = keySize + valueSize + 7;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                        key = data.Substring(7' keySize);                        if (valueSize > 0)                      {                          valueStartPtr = lPtr + 7 + keySize;                                                  val = data.Substring(7 + keySize' valueSize);                      }                        break;                  case 1:                      //With Reserved space                        if ((keySize + valueSize + 11) > initRead)                      {                          initRead = keySize + valueSize + 11;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                          key = data.Substring(11' keySize);                        if (valueSize > 0)                      {                          valueStartPtr = lPtr + 11 + keySize;                                                                        val = data.Substring(11 + keySize' valueSize);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKeyValue,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          initRead = keySize + valueSize + 7;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                        key = data.Substring(7' keySize);                        if (valueSize > 0)                      {                          valueStartPtr = lPtr + 7 + keySize;                                                  val = data.Substring(7 + keySize' valueSize);                      }                        break;                  case 1:                      //With Reserved space                        if ((keySize + valueSize + 11) > initRead)                      {                          initRead = keySize + valueSize + 11;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                          key = data.Substring(11' keySize);                        if (valueSize > 0)                      {                          valueStartPtr = lPtr + 11 + keySize;                                                                        val = data.Substring(11 + keySize' valueSize);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKeyValue,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          initRead = keySize + valueSize + 7;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                        key = data.Substring(7' keySize);                        if (valueSize > 0)                      {                          valueStartPtr = lPtr + 7 + keySize;                                                  val = data.Substring(7 + keySize' valueSize);                      }                        break;                  case 1:                      //With Reserved space                        if ((keySize + valueSize + 11) > initRead)                      {                          initRead = keySize + valueSize + 11;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                          key = data.Substring(11' keySize);                        if (valueSize > 0)                      {                          valueStartPtr = lPtr + 11 + keySize;                                                                        val = data.Substring(11 + keySize' valueSize);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKeyValue,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          initRead = keySize + valueSize + 7;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                        key = data.Substring(7' keySize);                        if (valueSize > 0)                      {                          valueStartPtr = lPtr + 7 + keySize;                                                  val = data.Substring(7 + keySize' valueSize);                      }                        break;                  case 1:                      //With Reserved space                        if ((keySize + valueSize + 11) > initRead)                      {                          initRead = keySize + valueSize + 11;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                          key = data.Substring(11' keySize);                        if (valueSize > 0)                      {                          valueStartPtr = lPtr + 11 + keySize;                                                                        val = data.Substring(11 + keySize' valueSize);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKeyValue,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          initRead = keySize + valueSize + 7;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                        key = data.Substring(7' keySize);                        if (valueSize > 0)                      {                          valueStartPtr = lPtr + 7 + keySize;                                                  val = data.Substring(7 + keySize' valueSize);                      }                        break;                  case 1:                      //With Reserved space                        if ((keySize + valueSize + 11) > initRead)                      {                          initRead = keySize + valueSize + 11;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                          key = data.Substring(11' keySize);                        if (valueSize > 0)                      {                          valueStartPtr = lPtr + 11 + keySize;                                                                        val = data.Substring(11 + keySize' valueSize);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKeyValue,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          initRead = keySize + valueSize + 7;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                        key = data.Substring(7' keySize);                        if (valueSize > 0)                      {                          valueStartPtr = lPtr + 7 + keySize;                                                  val = data.Substring(7 + keySize' valueSize);                      }                        break;                  case 1:                      //With Reserved space                        if ((keySize + valueSize + 11) > initRead)                      {                          initRead = keySize + valueSize + 11;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                          key = data.Substring(11' keySize);                        if (valueSize > 0)                      {                          valueStartPtr = lPtr + 11 + keySize;                                                                        val = data.Substring(11 + keySize' valueSize);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKeyValue,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          initRead = keySize + valueSize + 7;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                        key = data.Substring(7' keySize);                        if (valueSize > 0)                      {                          valueStartPtr = lPtr + 7 + keySize;                                                  val = data.Substring(7 + keySize' valueSize);                      }                        break;                  case 1:                      //With Reserved space                        if ((keySize + valueSize + 11) > initRead)                      {                          initRead = keySize + valueSize + 11;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                          key = data.Substring(11' keySize);                        if (valueSize > 0)                      {                          valueStartPtr = lPtr + 11 + keySize;                                                                        val = data.Substring(11 + keySize' valueSize);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKeyValue,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          initRead = keySize + valueSize + 7;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                        key = data.Substring(7' keySize);                        if (valueSize > 0)                      {                          valueStartPtr = lPtr + 7 + keySize;                                                  val = data.Substring(7 + keySize' valueSize);                      }                        break;                  case 1:                      //With Reserved space                        if ((keySize + valueSize + 11) > initRead)                      {                          initRead = keySize + valueSize + 11;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                          key = data.Substring(11' keySize);                        if (valueSize > 0)                      {                          valueStartPtr = lPtr + 11 + keySize;                                                                        val = data.Substring(11 + keySize' valueSize);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKeyValue,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          initRead = keySize + valueSize + 7;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                        key = data.Substring(7' keySize);                        if (valueSize > 0)                      {                          valueStartPtr = lPtr + 7 + keySize;                                                  val = data.Substring(7 + keySize' valueSize);                      }                        break;                  case 1:                      //With Reserved space                        if ((keySize + valueSize + 11) > initRead)                      {                          initRead = keySize + valueSize + 11;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                          key = data.Substring(11' keySize);                        if (valueSize > 0)                      {                          valueStartPtr = lPtr + 11 + keySize;                                                                        val = data.Substring(11 + keySize' valueSize);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKeyValue,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          initRead = keySize + valueSize + 7;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                        key = data.Substring(7' keySize);                        if (valueSize > 0)                      {                          valueStartPtr = lPtr + 7 + keySize;                                                  val = data.Substring(7 + keySize' valueSize);                      }                        break;                  case 1:                      //With Reserved space                        if ((keySize + valueSize + 11) > initRead)                      {                          initRead = keySize + valueSize + 11;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                          key = data.Substring(11' keySize);                        if (valueSize > 0)                      {                          valueStartPtr = lPtr + 11 + keySize;                                                                        val = data.Substring(11 + keySize' valueSize);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKey,The following statement contains a magic number: int initRead = 111;
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKey,The following statement contains a magic number: ushort keySize = (new byte[] { data[1]' data[2] }).To_UInt16_BigEndian();
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKey,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //First insert - no reservation identifiers for the space                        //Expanding read if necessary                      if (keySize > (initRead - 7))   //>= ?                      {                          initRead = keySize + 7;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                                              }                        key = data.Substring(7' keySize);                        break;                  case 1:                      //Expanding read if necessary                      if (keySize > (initRead - 11))  //>= ?                      {                          initRead = keySize + 11;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                        key = data.Substring(11' keySize);                        break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKey,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //First insert - no reservation identifiers for the space                        //Expanding read if necessary                      if (keySize > (initRead - 7))   //>= ?                      {                          initRead = keySize + 7;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                                              }                        key = data.Substring(7' keySize);                        break;                  case 1:                      //Expanding read if necessary                      if (keySize > (initRead - 11))  //>= ?                      {                          initRead = keySize + 11;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                        key = data.Substring(11' keySize);                        break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKey,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //First insert - no reservation identifiers for the space                        //Expanding read if necessary                      if (keySize > (initRead - 7))   //>= ?                      {                          initRead = keySize + 7;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                                              }                        key = data.Substring(7' keySize);                        break;                  case 1:                      //Expanding read if necessary                      if (keySize > (initRead - 11))  //>= ?                      {                          initRead = keySize + 11;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                        key = data.Substring(11' keySize);                        break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKey,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //First insert - no reservation identifiers for the space                        //Expanding read if necessary                      if (keySize > (initRead - 7))   //>= ?                      {                          initRead = keySize + 7;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                                              }                        key = data.Substring(7' keySize);                        break;                  case 1:                      //Expanding read if necessary                      if (keySize > (initRead - 11))  //>= ?                      {                          initRead = keySize + 11;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                        key = data.Substring(11' keySize);                        break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKey,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //First insert - no reservation identifiers for the space                        //Expanding read if necessary                      if (keySize > (initRead - 7))   //>= ?                      {                          initRead = keySize + 7;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                                              }                        key = data.Substring(7' keySize);                        break;                  case 1:                      //Expanding read if necessary                      if (keySize > (initRead - 11))  //>= ?                      {                          initRead = keySize + 11;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                        key = data.Substring(11' keySize);                        break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKey,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //First insert - no reservation identifiers for the space                        //Expanding read if necessary                      if (keySize > (initRead - 7))   //>= ?                      {                          initRead = keySize + 7;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                                              }                        key = data.Substring(7' keySize);                        break;                  case 1:                      //Expanding read if necessary                      if (keySize > (initRead - 11))  //>= ?                      {                          initRead = keySize + 11;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                        key = data.Substring(11' keySize);                        break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValue,The following statement contains a magic number: int initRead = 4096;
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValue,The following statement contains a magic number: btValueSize = new byte[] { data[3]' data[4]' data[5]' data[6] };
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValue,The following statement contains a magic number: btValueSize = new byte[] { data[3]' data[4]' data[5]' data[6] };
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValue,The following statement contains a magic number: btValueSize = new byte[] { data[3]' data[4]' data[5]' data[6] };
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValue,The following statement contains a magic number: btValueSize = new byte[] { data[3]' data[4]' data[5]' data[6] };
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValue,The following statement contains a magic number: if ((data[3] & 0x80) > 0)              {                  //NULL                  return null;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValue,The following statement contains a magic number: keySize = (new byte[] { data[1]' data[2] }).To_UInt16_BigEndian();
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValue,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          lPtr += 7 + keySize;                          valueStartPtr = lPtr;                          val = Trie.Storage.Table_Read(useCache' lPtr' valueSize);                      }                      else                      {                          valueStartPtr = lPtr + 7 + keySize;                          val = data.Substring(7 + keySize' valueSize);                      }                        break;                  case 1:                      //btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      //totalReservedSize = btTotalReservedSize.To_Int32_BigEndian();                      if ((keySize + valueSize + 11) > initRead)                      {                          lPtr += 11 + keySize;                          valueStartPtr = lPtr;                          val = Trie.Storage.Table_Read(useCache' lPtr' valueSize);                      }                      else                      {                          valueStartPtr = lPtr + 11 + keySize;                          val = data.Substring(11 + keySize' valueSize);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValue,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          lPtr += 7 + keySize;                          valueStartPtr = lPtr;                          val = Trie.Storage.Table_Read(useCache' lPtr' valueSize);                      }                      else                      {                          valueStartPtr = lPtr + 7 + keySize;                          val = data.Substring(7 + keySize' valueSize);                      }                        break;                  case 1:                      //btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      //totalReservedSize = btTotalReservedSize.To_Int32_BigEndian();                      if ((keySize + valueSize + 11) > initRead)                      {                          lPtr += 11 + keySize;                          valueStartPtr = lPtr;                          val = Trie.Storage.Table_Read(useCache' lPtr' valueSize);                      }                      else                      {                          valueStartPtr = lPtr + 11 + keySize;                          val = data.Substring(11 + keySize' valueSize);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValue,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          lPtr += 7 + keySize;                          valueStartPtr = lPtr;                          val = Trie.Storage.Table_Read(useCache' lPtr' valueSize);                      }                      else                      {                          valueStartPtr = lPtr + 7 + keySize;                          val = data.Substring(7 + keySize' valueSize);                      }                        break;                  case 1:                      //btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      //totalReservedSize = btTotalReservedSize.To_Int32_BigEndian();                      if ((keySize + valueSize + 11) > initRead)                      {                          lPtr += 11 + keySize;                          valueStartPtr = lPtr;                          val = Trie.Storage.Table_Read(useCache' lPtr' valueSize);                      }                      else                      {                          valueStartPtr = lPtr + 11 + keySize;                          val = data.Substring(11 + keySize' valueSize);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValue,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          lPtr += 7 + keySize;                          valueStartPtr = lPtr;                          val = Trie.Storage.Table_Read(useCache' lPtr' valueSize);                      }                      else                      {                          valueStartPtr = lPtr + 7 + keySize;                          val = data.Substring(7 + keySize' valueSize);                      }                        break;                  case 1:                      //btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      //totalReservedSize = btTotalReservedSize.To_Int32_BigEndian();                      if ((keySize + valueSize + 11) > initRead)                      {                          lPtr += 11 + keySize;                          valueStartPtr = lPtr;                          val = Trie.Storage.Table_Read(useCache' lPtr' valueSize);                      }                      else                      {                          valueStartPtr = lPtr + 11 + keySize;                          val = data.Substring(11 + keySize' valueSize);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValue,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          lPtr += 7 + keySize;                          valueStartPtr = lPtr;                          val = Trie.Storage.Table_Read(useCache' lPtr' valueSize);                      }                      else                      {                          valueStartPtr = lPtr + 7 + keySize;                          val = data.Substring(7 + keySize' valueSize);                      }                        break;                  case 1:                      //btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      //totalReservedSize = btTotalReservedSize.To_Int32_BigEndian();                      if ((keySize + valueSize + 11) > initRead)                      {                          lPtr += 11 + keySize;                          valueStartPtr = lPtr;                          val = Trie.Storage.Table_Read(useCache' lPtr' valueSize);                      }                      else                      {                          valueStartPtr = lPtr + 11 + keySize;                          val = data.Substring(11 + keySize' valueSize);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValue,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          lPtr += 7 + keySize;                          valueStartPtr = lPtr;                          val = Trie.Storage.Table_Read(useCache' lPtr' valueSize);                      }                      else                      {                          valueStartPtr = lPtr + 7 + keySize;                          val = data.Substring(7 + keySize' valueSize);                      }                        break;                  case 1:                      //btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      //totalReservedSize = btTotalReservedSize.To_Int32_BigEndian();                      if ((keySize + valueSize + 11) > initRead)                      {                          lPtr += 11 + keySize;                          valueStartPtr = lPtr;                          val = Trie.Storage.Table_Read(useCache' lPtr' valueSize);                      }                      else                      {                          valueStartPtr = lPtr + 11 + keySize;                          val = data.Substring(11 + keySize' valueSize);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValue,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          lPtr += 7 + keySize;                          valueStartPtr = lPtr;                          val = Trie.Storage.Table_Read(useCache' lPtr' valueSize);                      }                      else                      {                          valueStartPtr = lPtr + 7 + keySize;                          val = data.Substring(7 + keySize' valueSize);                      }                        break;                  case 1:                      //btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      //totalReservedSize = btTotalReservedSize.To_Int32_BigEndian();                      if ((keySize + valueSize + 11) > initRead)                      {                          lPtr += 11 + keySize;                          valueStartPtr = lPtr;                          val = Trie.Storage.Table_Read(useCache' lPtr' valueSize);                      }                      else                      {                          valueStartPtr = lPtr + 11 + keySize;                          val = data.Substring(11 + keySize' valueSize);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValue,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          lPtr += 7 + keySize;                          valueStartPtr = lPtr;                          val = Trie.Storage.Table_Read(useCache' lPtr' valueSize);                      }                      else                      {                          valueStartPtr = lPtr + 7 + keySize;                          val = data.Substring(7 + keySize' valueSize);                      }                        break;                  case 1:                      //btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      //totalReservedSize = btTotalReservedSize.To_Int32_BigEndian();                      if ((keySize + valueSize + 11) > initRead)                      {                          lPtr += 11 + keySize;                          valueStartPtr = lPtr;                          val = Trie.Storage.Table_Read(useCache' lPtr' valueSize);                      }                      else                      {                          valueStartPtr = lPtr + 11 + keySize;                          val = data.Substring(11 + keySize' valueSize);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValuePartially,The following statement contains a magic number: int initRead = 111;
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValuePartially,The following statement contains a magic number: btValueSize = new byte[] { data[3]' data[4]' data[5]' data[6] };
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValuePartially,The following statement contains a magic number: btValueSize = new byte[] { data[3]' data[4]' data[5]' data[6] };
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValuePartially,The following statement contains a magic number: btValueSize = new byte[] { data[3]' data[4]' data[5]' data[6] };
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValuePartially,The following statement contains a magic number: btValueSize = new byte[] { data[3]' data[4]' data[5]' data[6] };
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValuePartially,The following statement contains a magic number: if ((data[3] & 0x80) > 0)              {                  //NULL                  return null;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValuePartially,The following statement contains a magic number: keySize = (new byte[] { data[1]' data[2] }).To_UInt16_BigEndian();
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValuePartially,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //lPtr += 7 + keySize;                          //val = this.DBStorage.Read(lPtr' valueSize);                          valueStartPtr = lPtr + 7 + keySize;                          lPtr += 7 + keySize + (int)startIndex;                          val = Trie.Storage.Table_Read(useCache' lPtr' (int)length);                      }                      else                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //val = data.Substring(7 + keySize' valueSize);                            //in partial read                          valueStartPtr = lPtr + 7 + keySize;                          val = data.Substring(7 + keySize + (int)startIndex' (int)length);                      }                        break;                  case 1:                      //btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      //totalReservedSize = btTotalReservedSize.To_Int32_BigEndian();                      if ((keySize + valueSize + 11) > initRead)                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //lPtr += 11 + keySize;                          //val = this.DBStorage.Read(lPtr' valueSize);                            //in partial read                          valueStartPtr = lPtr + 11 + keySize;                          lPtr += 11 + keySize + (int)startIndex;                          val = Trie.Storage.Table_Read(useCache' lPtr' (int)length);                      }                      else                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //val = data.Substring(11 + keySize' valueSize);                            //in partial read                          valueStartPtr = lPtr + 11 + keySize;                          val = data.Substring(11 + keySize + (int)startIndex' (int)length);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValuePartially,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //lPtr += 7 + keySize;                          //val = this.DBStorage.Read(lPtr' valueSize);                          valueStartPtr = lPtr + 7 + keySize;                          lPtr += 7 + keySize + (int)startIndex;                          val = Trie.Storage.Table_Read(useCache' lPtr' (int)length);                      }                      else                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //val = data.Substring(7 + keySize' valueSize);                            //in partial read                          valueStartPtr = lPtr + 7 + keySize;                          val = data.Substring(7 + keySize + (int)startIndex' (int)length);                      }                        break;                  case 1:                      //btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      //totalReservedSize = btTotalReservedSize.To_Int32_BigEndian();                      if ((keySize + valueSize + 11) > initRead)                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //lPtr += 11 + keySize;                          //val = this.DBStorage.Read(lPtr' valueSize);                            //in partial read                          valueStartPtr = lPtr + 11 + keySize;                          lPtr += 11 + keySize + (int)startIndex;                          val = Trie.Storage.Table_Read(useCache' lPtr' (int)length);                      }                      else                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //val = data.Substring(11 + keySize' valueSize);                            //in partial read                          valueStartPtr = lPtr + 11 + keySize;                          val = data.Substring(11 + keySize + (int)startIndex' (int)length);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValuePartially,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //lPtr += 7 + keySize;                          //val = this.DBStorage.Read(lPtr' valueSize);                          valueStartPtr = lPtr + 7 + keySize;                          lPtr += 7 + keySize + (int)startIndex;                          val = Trie.Storage.Table_Read(useCache' lPtr' (int)length);                      }                      else                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //val = data.Substring(7 + keySize' valueSize);                            //in partial read                          valueStartPtr = lPtr + 7 + keySize;                          val = data.Substring(7 + keySize + (int)startIndex' (int)length);                      }                        break;                  case 1:                      //btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      //totalReservedSize = btTotalReservedSize.To_Int32_BigEndian();                      if ((keySize + valueSize + 11) > initRead)                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //lPtr += 11 + keySize;                          //val = this.DBStorage.Read(lPtr' valueSize);                            //in partial read                          valueStartPtr = lPtr + 11 + keySize;                          lPtr += 11 + keySize + (int)startIndex;                          val = Trie.Storage.Table_Read(useCache' lPtr' (int)length);                      }                      else                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //val = data.Substring(11 + keySize' valueSize);                            //in partial read                          valueStartPtr = lPtr + 11 + keySize;                          val = data.Substring(11 + keySize + (int)startIndex' (int)length);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValuePartially,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //lPtr += 7 + keySize;                          //val = this.DBStorage.Read(lPtr' valueSize);                          valueStartPtr = lPtr + 7 + keySize;                          lPtr += 7 + keySize + (int)startIndex;                          val = Trie.Storage.Table_Read(useCache' lPtr' (int)length);                      }                      else                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //val = data.Substring(7 + keySize' valueSize);                            //in partial read                          valueStartPtr = lPtr + 7 + keySize;                          val = data.Substring(7 + keySize + (int)startIndex' (int)length);                      }                        break;                  case 1:                      //btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      //totalReservedSize = btTotalReservedSize.To_Int32_BigEndian();                      if ((keySize + valueSize + 11) > initRead)                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //lPtr += 11 + keySize;                          //val = this.DBStorage.Read(lPtr' valueSize);                            //in partial read                          valueStartPtr = lPtr + 11 + keySize;                          lPtr += 11 + keySize + (int)startIndex;                          val = Trie.Storage.Table_Read(useCache' lPtr' (int)length);                      }                      else                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //val = data.Substring(11 + keySize' valueSize);                            //in partial read                          valueStartPtr = lPtr + 11 + keySize;                          val = data.Substring(11 + keySize + (int)startIndex' (int)length);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValuePartially,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //lPtr += 7 + keySize;                          //val = this.DBStorage.Read(lPtr' valueSize);                          valueStartPtr = lPtr + 7 + keySize;                          lPtr += 7 + keySize + (int)startIndex;                          val = Trie.Storage.Table_Read(useCache' lPtr' (int)length);                      }                      else                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //val = data.Substring(7 + keySize' valueSize);                            //in partial read                          valueStartPtr = lPtr + 7 + keySize;                          val = data.Substring(7 + keySize + (int)startIndex' (int)length);                      }                        break;                  case 1:                      //btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      //totalReservedSize = btTotalReservedSize.To_Int32_BigEndian();                      if ((keySize + valueSize + 11) > initRead)                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //lPtr += 11 + keySize;                          //val = this.DBStorage.Read(lPtr' valueSize);                            //in partial read                          valueStartPtr = lPtr + 11 + keySize;                          lPtr += 11 + keySize + (int)startIndex;                          val = Trie.Storage.Table_Read(useCache' lPtr' (int)length);                      }                      else                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //val = data.Substring(11 + keySize' valueSize);                            //in partial read                          valueStartPtr = lPtr + 11 + keySize;                          val = data.Substring(11 + keySize + (int)startIndex' (int)length);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValuePartially,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //lPtr += 7 + keySize;                          //val = this.DBStorage.Read(lPtr' valueSize);                          valueStartPtr = lPtr + 7 + keySize;                          lPtr += 7 + keySize + (int)startIndex;                          val = Trie.Storage.Table_Read(useCache' lPtr' (int)length);                      }                      else                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //val = data.Substring(7 + keySize' valueSize);                            //in partial read                          valueStartPtr = lPtr + 7 + keySize;                          val = data.Substring(7 + keySize + (int)startIndex' (int)length);                      }                        break;                  case 1:                      //btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      //totalReservedSize = btTotalReservedSize.To_Int32_BigEndian();                      if ((keySize + valueSize + 11) > initRead)                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //lPtr += 11 + keySize;                          //val = this.DBStorage.Read(lPtr' valueSize);                            //in partial read                          valueStartPtr = lPtr + 11 + keySize;                          lPtr += 11 + keySize + (int)startIndex;                          val = Trie.Storage.Table_Read(useCache' lPtr' (int)length);                      }                      else                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //val = data.Substring(11 + keySize' valueSize);                            //in partial read                          valueStartPtr = lPtr + 11 + keySize;                          val = data.Substring(11 + keySize + (int)startIndex' (int)length);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValuePartially,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //lPtr += 7 + keySize;                          //val = this.DBStorage.Read(lPtr' valueSize);                          valueStartPtr = lPtr + 7 + keySize;                          lPtr += 7 + keySize + (int)startIndex;                          val = Trie.Storage.Table_Read(useCache' lPtr' (int)length);                      }                      else                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //val = data.Substring(7 + keySize' valueSize);                            //in partial read                          valueStartPtr = lPtr + 7 + keySize;                          val = data.Substring(7 + keySize + (int)startIndex' (int)length);                      }                        break;                  case 1:                      //btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      //totalReservedSize = btTotalReservedSize.To_Int32_BigEndian();                      if ((keySize + valueSize + 11) > initRead)                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //lPtr += 11 + keySize;                          //val = this.DBStorage.Read(lPtr' valueSize);                            //in partial read                          valueStartPtr = lPtr + 11 + keySize;                          lPtr += 11 + keySize + (int)startIndex;                          val = Trie.Storage.Table_Read(useCache' lPtr' (int)length);                      }                      else                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //val = data.Substring(11 + keySize' valueSize);                            //in partial read                          valueStartPtr = lPtr + 11 + keySize;                          val = data.Substring(11 + keySize + (int)startIndex' (int)length);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValuePartially,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //lPtr += 7 + keySize;                          //val = this.DBStorage.Read(lPtr' valueSize);                          valueStartPtr = lPtr + 7 + keySize;                          lPtr += 7 + keySize + (int)startIndex;                          val = Trie.Storage.Table_Read(useCache' lPtr' (int)length);                      }                      else                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //val = data.Substring(7 + keySize' valueSize);                            //in partial read                          valueStartPtr = lPtr + 7 + keySize;                          val = data.Substring(7 + keySize + (int)startIndex' (int)length);                      }                        break;                  case 1:                      //btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      //totalReservedSize = btTotalReservedSize.To_Int32_BigEndian();                      if ((keySize + valueSize + 11) > initRead)                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //lPtr += 11 + keySize;                          //val = this.DBStorage.Read(lPtr' valueSize);                            //in partial read                          valueStartPtr = lPtr + 11 + keySize;                          lPtr += 11 + keySize + (int)startIndex;                          val = Trie.Storage.Table_Read(useCache' lPtr' (int)length);                      }                      else                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //val = data.Substring(11 + keySize' valueSize);                            //in partial read                          valueStartPtr = lPtr + 11 + keySize;                          val = data.Substring(11 + keySize + (int)startIndex' (int)length);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValuePartially,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //lPtr += 7 + keySize;                          //val = this.DBStorage.Read(lPtr' valueSize);                          valueStartPtr = lPtr + 7 + keySize;                          lPtr += 7 + keySize + (int)startIndex;                          val = Trie.Storage.Table_Read(useCache' lPtr' (int)length);                      }                      else                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //val = data.Substring(7 + keySize' valueSize);                            //in partial read                          valueStartPtr = lPtr + 7 + keySize;                          val = data.Substring(7 + keySize + (int)startIndex' (int)length);                      }                        break;                  case 1:                      //btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      //totalReservedSize = btTotalReservedSize.To_Int32_BigEndian();                      if ((keySize + valueSize + 11) > initRead)                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //lPtr += 11 + keySize;                          //val = this.DBStorage.Read(lPtr' valueSize);                            //in partial read                          valueStartPtr = lPtr + 11 + keySize;                          lPtr += 11 + keySize + (int)startIndex;                          val = Trie.Storage.Table_Read(useCache' lPtr' (int)length);                      }                      else                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //val = data.Substring(11 + keySize' valueSize);                            //in partial read                          valueStartPtr = lPtr + 11 + keySize;                          val = data.Substring(11 + keySize + (int)startIndex' (int)length);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValuePartially,The following statement contains a magic number: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //lPtr += 7 + keySize;                          //val = this.DBStorage.Read(lPtr' valueSize);                          valueStartPtr = lPtr + 7 + keySize;                          lPtr += 7 + keySize + (int)startIndex;                          val = Trie.Storage.Table_Read(useCache' lPtr' (int)length);                      }                      else                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //val = data.Substring(7 + keySize' valueSize);                            //in partial read                          valueStartPtr = lPtr + 7 + keySize;                          val = data.Substring(7 + keySize + (int)startIndex' (int)length);                      }                        break;                  case 1:                      //btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      //totalReservedSize = btTotalReservedSize.To_Int32_BigEndian();                      if ((keySize + valueSize + 11) > initRead)                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //lPtr += 11 + keySize;                          //val = this.DBStorage.Read(lPtr' valueSize);                            //in partial read                          valueStartPtr = lPtr + 11 + keySize;                          lPtr += 11 + keySize + (int)startIndex;                          val = Trie.Storage.Table_Read(useCache' lPtr' (int)length);                      }                      else                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //val = data.Substring(11 + keySize' valueSize);                            //in partial read                          valueStartPtr = lPtr + 11 + keySize;                          val = data.Substring(11 + keySize + (int)startIndex' (int)length);                      }                      break;              }
Magic Number,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,DeserializeRootNode,The following statement contains a magic number: this.LinkToZeroNode = me.Substring(2' DefaultPointerLen);
Magic Number,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,DeserializeRootNode,The following statement contains a magic number: this.RecordsCount = me.Substring(2 + DefaultPointerLen' 8).To_UInt64_BigEndian();
Magic Number,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,DeserializeRootNode,The following statement contains a magic number: this.RecordsCount = me.Substring(2 + DefaultPointerLen' 8).To_UInt64_BigEndian();
Magic Number,DBreeze.LianaTrie,LTrieRootNode,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\LTrieRootNode.cs,ChangeKey,The following statement contains a magic number: if (row.Exists)              {                  byte[] oldKeyValue = row.GetFullValue(false);                  bool WasRemoved = false;                  byte[] deletedValue = null;                  this.RemoveKey(ref oldKey' out WasRemoved' false' out deletedValue);                  bool WasUpdated = false;                  refToInsertedValue = this.AddKey(ref newKey' ref oldKeyValue'out WasUpdated'false);                    refToInsertedValue = refToInsertedValue.EnlargeByteArray_BigEndian(8);                    return true;              }
Magic Number,DBreeze.SchemeInternal,DbUserTables,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\SchemeInternal\Sheme.UserTable.cs,UserTablePatternIsOk,The following statement contains a magic number: for (int i = 0; i < tableName.Length; i++)              {                  switch (tableName[i])                  {                      case '*':                          //Substring till * and return                          return tableName.Substring(0' i+1);                      case '$':                          //Substring till $ and return                          return tableName.Substring(0' i + 1);                      case '#':                            if ((i + 2) > (tableName.Length - 1))                              throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.TABLE_PATTERN_SYMBOLS_AFTER_SHARP);                             if (tableName[i + 1] != '/')                              throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.TABLE_PATTERN_SYMBOLS_AFTER_SHARP);                                                   break;                  }              }
Magic Number,DBreeze.Storage,Backup,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\Backup.cs,WriteBackupElement,The following statement contains a magic number: lock (lock_ibp_fs)              {                  this.GetFileStream();                    uint size = 0;                  byte[] toSave = null;                    switch (type)                  {                      case 0:                      case 1:                            //8(fileNumber)+1(type)+8(position)+data.Length                          size = Convert.ToUInt32(8 + 1 + 8 + data.Length);                          toSave = size.To_4_bytes_array_BigEndian().ConcatMany(fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { type }'                              pos.To_8_bytes_array_BigEndian()'                              data);                                                 break;                      case 2:                            //Now we save new information into rollback                           size = Convert.ToUInt32(8 + 1 + 8 + data.Length);                          toSave = size.To_4_bytes_array_BigEndian().ConcatMany(fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { 2 }'                              ((long)0).To_8_bytes_array_BigEndian()'                              data);                          break;                      case 3: //recreate table file                                       case 5: //removing complete table                            //8(fileNumber)+1(type)                          size = 9;                          toSave = size.To_4_bytes_array_BigEndian()                              .ConcatMany(                              fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { type }                              );                          break;                                                               }                    wasWritten = true;                  fs.Write(toSave' 0' toSave.Length);              }
Magic Number,DBreeze.Storage,Backup,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\Backup.cs,WriteBackupElement,The following statement contains a magic number: lock (lock_ibp_fs)              {                  this.GetFileStream();                    uint size = 0;                  byte[] toSave = null;                    switch (type)                  {                      case 0:                      case 1:                            //8(fileNumber)+1(type)+8(position)+data.Length                          size = Convert.ToUInt32(8 + 1 + 8 + data.Length);                          toSave = size.To_4_bytes_array_BigEndian().ConcatMany(fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { type }'                              pos.To_8_bytes_array_BigEndian()'                              data);                                                 break;                      case 2:                            //Now we save new information into rollback                           size = Convert.ToUInt32(8 + 1 + 8 + data.Length);                          toSave = size.To_4_bytes_array_BigEndian().ConcatMany(fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { 2 }'                              ((long)0).To_8_bytes_array_BigEndian()'                              data);                          break;                      case 3: //recreate table file                                       case 5: //removing complete table                            //8(fileNumber)+1(type)                          size = 9;                          toSave = size.To_4_bytes_array_BigEndian()                              .ConcatMany(                              fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { type }                              );                          break;                                                               }                    wasWritten = true;                  fs.Write(toSave' 0' toSave.Length);              }
Magic Number,DBreeze.Storage,Backup,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\Backup.cs,WriteBackupElement,The following statement contains a magic number: lock (lock_ibp_fs)              {                  this.GetFileStream();                    uint size = 0;                  byte[] toSave = null;                    switch (type)                  {                      case 0:                      case 1:                            //8(fileNumber)+1(type)+8(position)+data.Length                          size = Convert.ToUInt32(8 + 1 + 8 + data.Length);                          toSave = size.To_4_bytes_array_BigEndian().ConcatMany(fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { type }'                              pos.To_8_bytes_array_BigEndian()'                              data);                                                 break;                      case 2:                            //Now we save new information into rollback                           size = Convert.ToUInt32(8 + 1 + 8 + data.Length);                          toSave = size.To_4_bytes_array_BigEndian().ConcatMany(fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { 2 }'                              ((long)0).To_8_bytes_array_BigEndian()'                              data);                          break;                      case 3: //recreate table file                                       case 5: //removing complete table                            //8(fileNumber)+1(type)                          size = 9;                          toSave = size.To_4_bytes_array_BigEndian()                              .ConcatMany(                              fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { type }                              );                          break;                                                               }                    wasWritten = true;                  fs.Write(toSave' 0' toSave.Length);              }
Magic Number,DBreeze.Storage,Backup,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\Backup.cs,WriteBackupElement,The following statement contains a magic number: lock (lock_ibp_fs)              {                  this.GetFileStream();                    uint size = 0;                  byte[] toSave = null;                    switch (type)                  {                      case 0:                      case 1:                            //8(fileNumber)+1(type)+8(position)+data.Length                          size = Convert.ToUInt32(8 + 1 + 8 + data.Length);                          toSave = size.To_4_bytes_array_BigEndian().ConcatMany(fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { type }'                              pos.To_8_bytes_array_BigEndian()'                              data);                                                 break;                      case 2:                            //Now we save new information into rollback                           size = Convert.ToUInt32(8 + 1 + 8 + data.Length);                          toSave = size.To_4_bytes_array_BigEndian().ConcatMany(fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { 2 }'                              ((long)0).To_8_bytes_array_BigEndian()'                              data);                          break;                      case 3: //recreate table file                                       case 5: //removing complete table                            //8(fileNumber)+1(type)                          size = 9;                          toSave = size.To_4_bytes_array_BigEndian()                              .ConcatMany(                              fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { type }                              );                          break;                                                               }                    wasWritten = true;                  fs.Write(toSave' 0' toSave.Length);              }
Magic Number,DBreeze.Storage,Backup,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\Backup.cs,WriteBackupElement,The following statement contains a magic number: lock (lock_ibp_fs)              {                  this.GetFileStream();                    uint size = 0;                  byte[] toSave = null;                    switch (type)                  {                      case 0:                      case 1:                            //8(fileNumber)+1(type)+8(position)+data.Length                          size = Convert.ToUInt32(8 + 1 + 8 + data.Length);                          toSave = size.To_4_bytes_array_BigEndian().ConcatMany(fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { type }'                              pos.To_8_bytes_array_BigEndian()'                              data);                                                 break;                      case 2:                            //Now we save new information into rollback                           size = Convert.ToUInt32(8 + 1 + 8 + data.Length);                          toSave = size.To_4_bytes_array_BigEndian().ConcatMany(fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { 2 }'                              ((long)0).To_8_bytes_array_BigEndian()'                              data);                          break;                      case 3: //recreate table file                                       case 5: //removing complete table                            //8(fileNumber)+1(type)                          size = 9;                          toSave = size.To_4_bytes_array_BigEndian()                              .ConcatMany(                              fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { type }                              );                          break;                                                               }                    wasWritten = true;                  fs.Write(toSave' 0' toSave.Length);              }
Magic Number,DBreeze.Storage,Backup,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\Backup.cs,WriteBackupElement,The following statement contains a magic number: lock (lock_ibp_fs)              {                  this.GetFileStream();                    uint size = 0;                  byte[] toSave = null;                    switch (type)                  {                      case 0:                      case 1:                            //8(fileNumber)+1(type)+8(position)+data.Length                          size = Convert.ToUInt32(8 + 1 + 8 + data.Length);                          toSave = size.To_4_bytes_array_BigEndian().ConcatMany(fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { type }'                              pos.To_8_bytes_array_BigEndian()'                              data);                                                 break;                      case 2:                            //Now we save new information into rollback                           size = Convert.ToUInt32(8 + 1 + 8 + data.Length);                          toSave = size.To_4_bytes_array_BigEndian().ConcatMany(fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { 2 }'                              ((long)0).To_8_bytes_array_BigEndian()'                              data);                          break;                      case 3: //recreate table file                                       case 5: //removing complete table                            //8(fileNumber)+1(type)                          size = 9;                          toSave = size.To_4_bytes_array_BigEndian()                              .ConcatMany(                              fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { type }                              );                          break;                                                               }                    wasWritten = true;                  fs.Write(toSave' 0' toSave.Length);              }
Magic Number,DBreeze.Storage,Backup,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\Backup.cs,WriteBackupElement,The following statement contains a magic number: lock (lock_ibp_fs)              {                  this.GetFileStream();                    uint size = 0;                  byte[] toSave = null;                    switch (type)                  {                      case 0:                      case 1:                            //8(fileNumber)+1(type)+8(position)+data.Length                          size = Convert.ToUInt32(8 + 1 + 8 + data.Length);                          toSave = size.To_4_bytes_array_BigEndian().ConcatMany(fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { type }'                              pos.To_8_bytes_array_BigEndian()'                              data);                                                 break;                      case 2:                            //Now we save new information into rollback                           size = Convert.ToUInt32(8 + 1 + 8 + data.Length);                          toSave = size.To_4_bytes_array_BigEndian().ConcatMany(fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { 2 }'                              ((long)0).To_8_bytes_array_BigEndian()'                              data);                          break;                      case 3: //recreate table file                                       case 5: //removing complete table                            //8(fileNumber)+1(type)                          size = 9;                          toSave = size.To_4_bytes_array_BigEndian()                              .ConcatMany(                              fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { type }                              );                          break;                                                               }                    wasWritten = true;                  fs.Write(toSave' 0' toSave.Length);              }
Magic Number,DBreeze.Storage,Backup,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\Backup.cs,WriteBackupElement,The following statement contains a magic number: lock (lock_ibp_fs)              {                  this.GetFileStream();                    uint size = 0;                  byte[] toSave = null;                    switch (type)                  {                      case 0:                      case 1:                            //8(fileNumber)+1(type)+8(position)+data.Length                          size = Convert.ToUInt32(8 + 1 + 8 + data.Length);                          toSave = size.To_4_bytes_array_BigEndian().ConcatMany(fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { type }'                              pos.To_8_bytes_array_BigEndian()'                              data);                                                 break;                      case 2:                            //Now we save new information into rollback                           size = Convert.ToUInt32(8 + 1 + 8 + data.Length);                          toSave = size.To_4_bytes_array_BigEndian().ConcatMany(fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { 2 }'                              ((long)0).To_8_bytes_array_BigEndian()'                              data);                          break;                      case 3: //recreate table file                                       case 5: //removing complete table                            //8(fileNumber)+1(type)                          size = 9;                          toSave = size.To_4_bytes_array_BigEndian()                              .ConcatMany(                              fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { type }                              );                          break;                                                               }                    wasWritten = true;                  fs.Write(toSave' 0' toSave.Length);              }
Magic Number,DBreeze.Storage,Backup,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\Backup.cs,WriteBackupElement,The following statement contains a magic number: lock (lock_ibp_fs)              {                  this.GetFileStream();                    uint size = 0;                  byte[] toSave = null;                    switch (type)                  {                      case 0:                      case 1:                            //8(fileNumber)+1(type)+8(position)+data.Length                          size = Convert.ToUInt32(8 + 1 + 8 + data.Length);                          toSave = size.To_4_bytes_array_BigEndian().ConcatMany(fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { type }'                              pos.To_8_bytes_array_BigEndian()'                              data);                                                 break;                      case 2:                            //Now we save new information into rollback                           size = Convert.ToUInt32(8 + 1 + 8 + data.Length);                          toSave = size.To_4_bytes_array_BigEndian().ConcatMany(fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { 2 }'                              ((long)0).To_8_bytes_array_BigEndian()'                              data);                          break;                      case 3: //recreate table file                                       case 5: //removing complete table                            //8(fileNumber)+1(type)                          size = 9;                          toSave = size.To_4_bytes_array_BigEndian()                              .ConcatMany(                              fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { type }                              );                          break;                                                               }                    wasWritten = true;                  fs.Write(toSave' 0' toSave.Length);              }
Magic Number,DBreeze.Storage,Backup,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\Backup.cs,GetFileStream,The following statement contains a magic number: DateTime dtBase = new DateTime(1980' 1' 1' 0' 0' 0' DateTimeKind.Utc);
Magic Number,DBreeze.Storage,BackupFileNamesParser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\Backup.cs,ParseFilename,The following statement contains a magic number: switch (fileName)                  {                      case "_DBreezeSchema":                          return UInt64.MaxValue - 1;                      case "_DBreezeTranJrnl":                          return UInt64.MaxValue - 2;                      case "_DBreezeTextIndexer":                          return UInt64.MaxValue - 3;                      case "_DBreezeResources":                          return UInt64.MaxValue - 4;                      default:                          return Convert.ToUInt64(fileName);                  }
Magic Number,DBreeze.Storage,BackupFileNamesParser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\Backup.cs,ParseFilename,The following statement contains a magic number: switch (fileName)                  {                      case "_DBreezeSchema":                          return UInt64.MaxValue - 1;                      case "_DBreezeTranJrnl":                          return UInt64.MaxValue - 2;                      case "_DBreezeTextIndexer":                          return UInt64.MaxValue - 3;                      case "_DBreezeResources":                          return UInt64.MaxValue - 4;                      default:                          return Convert.ToUInt64(fileName);                  }
Magic Number,DBreeze.Storage,BackupFileNamesParser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\Backup.cs,ParseFilename,The following statement contains a magic number: switch (fileName)                  {                      case "_DBreezeSchema":                          return UInt64.MaxValue - 1;                      case "_DBreezeTranJrnl":                          return UInt64.MaxValue - 2;                      case "_DBreezeTextIndexer":                          return UInt64.MaxValue - 3;                      case "_DBreezeResources":                          return UInt64.MaxValue - 4;                      default:                          return Convert.ToUInt64(fileName);                  }
Magic Number,DBreeze.Storage,BackupFileNamesParser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\Backup.cs,ParseFilenameBack,The following statement contains a magic number: switch (filenumber)                  {                      case (UInt64.MaxValue - 1):                          return "_DBreezeSchema";                      case (UInt64.MaxValue - 2):                          return "_DBreezeTranJrnl";                      case (UInt64.MaxValue - 3):                          return "_DBreezeTextIndexer";                      case (UInt64.MaxValue - 4):                          return "_DBreezeResources";                      default:                          return filenumber.ToString();                  }
Magic Number,DBreeze.Storage,BackupFileNamesParser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\Backup.cs,ParseFilenameBack,The following statement contains a magic number: switch (filenumber)                  {                      case (UInt64.MaxValue - 1):                          return "_DBreezeSchema";                      case (UInt64.MaxValue - 2):                          return "_DBreezeTranJrnl";                      case (UInt64.MaxValue - 3):                          return "_DBreezeTextIndexer";                      case (UInt64.MaxValue - 4):                          return "_DBreezeResources";                      default:                          return filenumber.ToString();                  }
Magic Number,DBreeze.Storage,BackupFileNamesParser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\Backup.cs,ParseFilenameBack,The following statement contains a magic number: switch (filenumber)                  {                      case (UInt64.MaxValue - 1):                          return "_DBreezeSchema";                      case (UInt64.MaxValue - 2):                          return "_DBreezeTranJrnl";                      case (UInt64.MaxValue - 3):                          return "_DBreezeTextIndexer";                      case (UInt64.MaxValue - 4):                          return "_DBreezeResources";                      default:                          return filenumber.ToString();                  }
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,StartRestoration,The following statement contains a magic number: try              {                  //holder of filenames and filestreams                  ds.Clear();                    DirectoryInfo diDB = new DirectoryInfo(DataBaseFolder);                  DirectoryInfo diBP = new DirectoryInfo(BackupFolder);                    if (!diDB.Exists)                      diDB.Create();                    if (!diBP.Exists)                      diBP.Create();                    long totalBackupFileLength = 0;                  long processed = 0;                    foreach (var file in diBP.GetFiles())                  {                      totalBackupFileLength += file.Length;                  }                    if (totalBackupFileLength == processed)                  {                      OnRestore(new BackupRestorationProcess()                      {                          ReadinessInProcent = 100'                          Finished = true                      });                      return;                  }                    int readinessInProcent = Convert.ToInt32((processed * 100) / totalBackupFileLength);                  int prevReadinessInProcent = 0;                    OnRestore(new BackupRestorationProcess()                  {                      ReadinessInProcent = readinessInProcent'                      Finished = false                  });                    byte[] readOut = new byte[100000];                  int cnt = 0;                  byte[] pack = null;                  uint packSize = 0;                    foreach (var file in diBP.GetFiles().Where(r => r.Name.StartsWith("dbreeze_ibp_")).OrderBy(r => r.Name))                  {                      using (var bfs = new FileStream(file.FullName' FileMode.Open' FileAccess.Read' FileShare.None))                      {                          while ((cnt = bfs.Read(readOut' 0' readOut.Length)) > 0)                          {                              processed += cnt;                              readinessInProcent = Convert.ToInt32((processed * 100) / totalBackupFileLength);                              pack = pack.Concat(readOut.Substring(0' cnt));                                while (true)                              {                                  if (pack == null || pack.Length < 4)                                      break;                                    packSize = pack.Substring(0' 4).To_UInt32_BigEndian();                                    if (pack.Length >= 4 + packSize)                                  {                                      this.DoPackage(pack.Substring(4' (int)packSize));                                      pack = pack.Substring(4 + (int)packSize);                                  }                                  else                                      break;                              }                                if (prevReadinessInProcent != readinessInProcent)                              {                                  prevReadinessInProcent = readinessInProcent;                                  OnRestore(new BackupRestorationProcess()                                  {                                      ReadinessInProcent = readinessInProcent'                                      Finished = false                                  });                              }                          }                            if (prevReadinessInProcent != readinessInProcent)                          {                              prevReadinessInProcent = readinessInProcent;                              OnRestore(new BackupRestorationProcess()                              {                                  ReadinessInProcent = readinessInProcent'                                  Finished = false                              });                          }                            bfs.Dispose();                      }                  }                    this.CloseHandels();                    OnRestore(new BackupRestorationProcess()                  {                      ReadinessInProcent = 100'                      Finished = true                  });                }              catch (Exception ex)              {                  throw ex;              }
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,StartRestoration,The following statement contains a magic number: try              {                  //holder of filenames and filestreams                  ds.Clear();                    DirectoryInfo diDB = new DirectoryInfo(DataBaseFolder);                  DirectoryInfo diBP = new DirectoryInfo(BackupFolder);                    if (!diDB.Exists)                      diDB.Create();                    if (!diBP.Exists)                      diBP.Create();                    long totalBackupFileLength = 0;                  long processed = 0;                    foreach (var file in diBP.GetFiles())                  {                      totalBackupFileLength += file.Length;                  }                    if (totalBackupFileLength == processed)                  {                      OnRestore(new BackupRestorationProcess()                      {                          ReadinessInProcent = 100'                          Finished = true                      });                      return;                  }                    int readinessInProcent = Convert.ToInt32((processed * 100) / totalBackupFileLength);                  int prevReadinessInProcent = 0;                    OnRestore(new BackupRestorationProcess()                  {                      ReadinessInProcent = readinessInProcent'                      Finished = false                  });                    byte[] readOut = new byte[100000];                  int cnt = 0;                  byte[] pack = null;                  uint packSize = 0;                    foreach (var file in diBP.GetFiles().Where(r => r.Name.StartsWith("dbreeze_ibp_")).OrderBy(r => r.Name))                  {                      using (var bfs = new FileStream(file.FullName' FileMode.Open' FileAccess.Read' FileShare.None))                      {                          while ((cnt = bfs.Read(readOut' 0' readOut.Length)) > 0)                          {                              processed += cnt;                              readinessInProcent = Convert.ToInt32((processed * 100) / totalBackupFileLength);                              pack = pack.Concat(readOut.Substring(0' cnt));                                while (true)                              {                                  if (pack == null || pack.Length < 4)                                      break;                                    packSize = pack.Substring(0' 4).To_UInt32_BigEndian();                                    if (pack.Length >= 4 + packSize)                                  {                                      this.DoPackage(pack.Substring(4' (int)packSize));                                      pack = pack.Substring(4 + (int)packSize);                                  }                                  else                                      break;                              }                                if (prevReadinessInProcent != readinessInProcent)                              {                                  prevReadinessInProcent = readinessInProcent;                                  OnRestore(new BackupRestorationProcess()                                  {                                      ReadinessInProcent = readinessInProcent'                                      Finished = false                                  });                              }                          }                            if (prevReadinessInProcent != readinessInProcent)                          {                              prevReadinessInProcent = readinessInProcent;                              OnRestore(new BackupRestorationProcess()                              {                                  ReadinessInProcent = readinessInProcent'                                  Finished = false                              });                          }                            bfs.Dispose();                      }                  }                    this.CloseHandels();                    OnRestore(new BackupRestorationProcess()                  {                      ReadinessInProcent = 100'                      Finished = true                  });                }              catch (Exception ex)              {                  throw ex;              }
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,StartRestoration,The following statement contains a magic number: try              {                  //holder of filenames and filestreams                  ds.Clear();                    DirectoryInfo diDB = new DirectoryInfo(DataBaseFolder);                  DirectoryInfo diBP = new DirectoryInfo(BackupFolder);                    if (!diDB.Exists)                      diDB.Create();                    if (!diBP.Exists)                      diBP.Create();                    long totalBackupFileLength = 0;                  long processed = 0;                    foreach (var file in diBP.GetFiles())                  {                      totalBackupFileLength += file.Length;                  }                    if (totalBackupFileLength == processed)                  {                      OnRestore(new BackupRestorationProcess()                      {                          ReadinessInProcent = 100'                          Finished = true                      });                      return;                  }                    int readinessInProcent = Convert.ToInt32((processed * 100) / totalBackupFileLength);                  int prevReadinessInProcent = 0;                    OnRestore(new BackupRestorationProcess()                  {                      ReadinessInProcent = readinessInProcent'                      Finished = false                  });                    byte[] readOut = new byte[100000];                  int cnt = 0;                  byte[] pack = null;                  uint packSize = 0;                    foreach (var file in diBP.GetFiles().Where(r => r.Name.StartsWith("dbreeze_ibp_")).OrderBy(r => r.Name))                  {                      using (var bfs = new FileStream(file.FullName' FileMode.Open' FileAccess.Read' FileShare.None))                      {                          while ((cnt = bfs.Read(readOut' 0' readOut.Length)) > 0)                          {                              processed += cnt;                              readinessInProcent = Convert.ToInt32((processed * 100) / totalBackupFileLength);                              pack = pack.Concat(readOut.Substring(0' cnt));                                while (true)                              {                                  if (pack == null || pack.Length < 4)                                      break;                                    packSize = pack.Substring(0' 4).To_UInt32_BigEndian();                                    if (pack.Length >= 4 + packSize)                                  {                                      this.DoPackage(pack.Substring(4' (int)packSize));                                      pack = pack.Substring(4 + (int)packSize);                                  }                                  else                                      break;                              }                                if (prevReadinessInProcent != readinessInProcent)                              {                                  prevReadinessInProcent = readinessInProcent;                                  OnRestore(new BackupRestorationProcess()                                  {                                      ReadinessInProcent = readinessInProcent'                                      Finished = false                                  });                              }                          }                            if (prevReadinessInProcent != readinessInProcent)                          {                              prevReadinessInProcent = readinessInProcent;                              OnRestore(new BackupRestorationProcess()                              {                                  ReadinessInProcent = readinessInProcent'                                  Finished = false                              });                          }                            bfs.Dispose();                      }                  }                    this.CloseHandels();                    OnRestore(new BackupRestorationProcess()                  {                      ReadinessInProcent = 100'                      Finished = true                  });                }              catch (Exception ex)              {                  throw ex;              }
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,StartRestoration,The following statement contains a magic number: try              {                  //holder of filenames and filestreams                  ds.Clear();                    DirectoryInfo diDB = new DirectoryInfo(DataBaseFolder);                  DirectoryInfo diBP = new DirectoryInfo(BackupFolder);                    if (!diDB.Exists)                      diDB.Create();                    if (!diBP.Exists)                      diBP.Create();                    long totalBackupFileLength = 0;                  long processed = 0;                    foreach (var file in diBP.GetFiles())                  {                      totalBackupFileLength += file.Length;                  }                    if (totalBackupFileLength == processed)                  {                      OnRestore(new BackupRestorationProcess()                      {                          ReadinessInProcent = 100'                          Finished = true                      });                      return;                  }                    int readinessInProcent = Convert.ToInt32((processed * 100) / totalBackupFileLength);                  int prevReadinessInProcent = 0;                    OnRestore(new BackupRestorationProcess()                  {                      ReadinessInProcent = readinessInProcent'                      Finished = false                  });                    byte[] readOut = new byte[100000];                  int cnt = 0;                  byte[] pack = null;                  uint packSize = 0;                    foreach (var file in diBP.GetFiles().Where(r => r.Name.StartsWith("dbreeze_ibp_")).OrderBy(r => r.Name))                  {                      using (var bfs = new FileStream(file.FullName' FileMode.Open' FileAccess.Read' FileShare.None))                      {                          while ((cnt = bfs.Read(readOut' 0' readOut.Length)) > 0)                          {                              processed += cnt;                              readinessInProcent = Convert.ToInt32((processed * 100) / totalBackupFileLength);                              pack = pack.Concat(readOut.Substring(0' cnt));                                while (true)                              {                                  if (pack == null || pack.Length < 4)                                      break;                                    packSize = pack.Substring(0' 4).To_UInt32_BigEndian();                                    if (pack.Length >= 4 + packSize)                                  {                                      this.DoPackage(pack.Substring(4' (int)packSize));                                      pack = pack.Substring(4 + (int)packSize);                                  }                                  else                                      break;                              }                                if (prevReadinessInProcent != readinessInProcent)                              {                                  prevReadinessInProcent = readinessInProcent;                                  OnRestore(new BackupRestorationProcess()                                  {                                      ReadinessInProcent = readinessInProcent'                                      Finished = false                                  });                              }                          }                            if (prevReadinessInProcent != readinessInProcent)                          {                              prevReadinessInProcent = readinessInProcent;                              OnRestore(new BackupRestorationProcess()                              {                                  ReadinessInProcent = readinessInProcent'                                  Finished = false                              });                          }                            bfs.Dispose();                      }                  }                    this.CloseHandels();                    OnRestore(new BackupRestorationProcess()                  {                      ReadinessInProcent = 100'                      Finished = true                  });                }              catch (Exception ex)              {                  throw ex;              }
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,StartRestoration,The following statement contains a magic number: try              {                  //holder of filenames and filestreams                  ds.Clear();                    DirectoryInfo diDB = new DirectoryInfo(DataBaseFolder);                  DirectoryInfo diBP = new DirectoryInfo(BackupFolder);                    if (!diDB.Exists)                      diDB.Create();                    if (!diBP.Exists)                      diBP.Create();                    long totalBackupFileLength = 0;                  long processed = 0;                    foreach (var file in diBP.GetFiles())                  {                      totalBackupFileLength += file.Length;                  }                    if (totalBackupFileLength == processed)                  {                      OnRestore(new BackupRestorationProcess()                      {                          ReadinessInProcent = 100'                          Finished = true                      });                      return;                  }                    int readinessInProcent = Convert.ToInt32((processed * 100) / totalBackupFileLength);                  int prevReadinessInProcent = 0;                    OnRestore(new BackupRestorationProcess()                  {                      ReadinessInProcent = readinessInProcent'                      Finished = false                  });                    byte[] readOut = new byte[100000];                  int cnt = 0;                  byte[] pack = null;                  uint packSize = 0;                    foreach (var file in diBP.GetFiles().Where(r => r.Name.StartsWith("dbreeze_ibp_")).OrderBy(r => r.Name))                  {                      using (var bfs = new FileStream(file.FullName' FileMode.Open' FileAccess.Read' FileShare.None))                      {                          while ((cnt = bfs.Read(readOut' 0' readOut.Length)) > 0)                          {                              processed += cnt;                              readinessInProcent = Convert.ToInt32((processed * 100) / totalBackupFileLength);                              pack = pack.Concat(readOut.Substring(0' cnt));                                while (true)                              {                                  if (pack == null || pack.Length < 4)                                      break;                                    packSize = pack.Substring(0' 4).To_UInt32_BigEndian();                                    if (pack.Length >= 4 + packSize)                                  {                                      this.DoPackage(pack.Substring(4' (int)packSize));                                      pack = pack.Substring(4 + (int)packSize);                                  }                                  else                                      break;                              }                                if (prevReadinessInProcent != readinessInProcent)                              {                                  prevReadinessInProcent = readinessInProcent;                                  OnRestore(new BackupRestorationProcess()                                  {                                      ReadinessInProcent = readinessInProcent'                                      Finished = false                                  });                              }                          }                            if (prevReadinessInProcent != readinessInProcent)                          {                              prevReadinessInProcent = readinessInProcent;                              OnRestore(new BackupRestorationProcess()                              {                                  ReadinessInProcent = readinessInProcent'                                  Finished = false                              });                          }                            bfs.Dispose();                      }                  }                    this.CloseHandels();                    OnRestore(new BackupRestorationProcess()                  {                      ReadinessInProcent = 100'                      Finished = true                  });                }              catch (Exception ex)              {                  throw ex;              }
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,StartRestoration,The following statement contains a magic number: try              {                  //holder of filenames and filestreams                  ds.Clear();                    DirectoryInfo diDB = new DirectoryInfo(DataBaseFolder);                  DirectoryInfo diBP = new DirectoryInfo(BackupFolder);                    if (!diDB.Exists)                      diDB.Create();                    if (!diBP.Exists)                      diBP.Create();                    long totalBackupFileLength = 0;                  long processed = 0;                    foreach (var file in diBP.GetFiles())                  {                      totalBackupFileLength += file.Length;                  }                    if (totalBackupFileLength == processed)                  {                      OnRestore(new BackupRestorationProcess()                      {                          ReadinessInProcent = 100'                          Finished = true                      });                      return;                  }                    int readinessInProcent = Convert.ToInt32((processed * 100) / totalBackupFileLength);                  int prevReadinessInProcent = 0;                    OnRestore(new BackupRestorationProcess()                  {                      ReadinessInProcent = readinessInProcent'                      Finished = false                  });                    byte[] readOut = new byte[100000];                  int cnt = 0;                  byte[] pack = null;                  uint packSize = 0;                    foreach (var file in diBP.GetFiles().Where(r => r.Name.StartsWith("dbreeze_ibp_")).OrderBy(r => r.Name))                  {                      using (var bfs = new FileStream(file.FullName' FileMode.Open' FileAccess.Read' FileShare.None))                      {                          while ((cnt = bfs.Read(readOut' 0' readOut.Length)) > 0)                          {                              processed += cnt;                              readinessInProcent = Convert.ToInt32((processed * 100) / totalBackupFileLength);                              pack = pack.Concat(readOut.Substring(0' cnt));                                while (true)                              {                                  if (pack == null || pack.Length < 4)                                      break;                                    packSize = pack.Substring(0' 4).To_UInt32_BigEndian();                                    if (pack.Length >= 4 + packSize)                                  {                                      this.DoPackage(pack.Substring(4' (int)packSize));                                      pack = pack.Substring(4 + (int)packSize);                                  }                                  else                                      break;                              }                                if (prevReadinessInProcent != readinessInProcent)                              {                                  prevReadinessInProcent = readinessInProcent;                                  OnRestore(new BackupRestorationProcess()                                  {                                      ReadinessInProcent = readinessInProcent'                                      Finished = false                                  });                              }                          }                            if (prevReadinessInProcent != readinessInProcent)                          {                              prevReadinessInProcent = readinessInProcent;                              OnRestore(new BackupRestorationProcess()                              {                                  ReadinessInProcent = readinessInProcent'                                  Finished = false                              });                          }                            bfs.Dispose();                      }                  }                    this.CloseHandels();                    OnRestore(new BackupRestorationProcess()                  {                      ReadinessInProcent = 100'                      Finished = true                  });                }              catch (Exception ex)              {                  throw ex;              }
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,StartRestoration,The following statement contains a magic number: try              {                  //holder of filenames and filestreams                  ds.Clear();                    DirectoryInfo diDB = new DirectoryInfo(DataBaseFolder);                  DirectoryInfo diBP = new DirectoryInfo(BackupFolder);                    if (!diDB.Exists)                      diDB.Create();                    if (!diBP.Exists)                      diBP.Create();                    long totalBackupFileLength = 0;                  long processed = 0;                    foreach (var file in diBP.GetFiles())                  {                      totalBackupFileLength += file.Length;                  }                    if (totalBackupFileLength == processed)                  {                      OnRestore(new BackupRestorationProcess()                      {                          ReadinessInProcent = 100'                          Finished = true                      });                      return;                  }                    int readinessInProcent = Convert.ToInt32((processed * 100) / totalBackupFileLength);                  int prevReadinessInProcent = 0;                    OnRestore(new BackupRestorationProcess()                  {                      ReadinessInProcent = readinessInProcent'                      Finished = false                  });                    byte[] readOut = new byte[100000];                  int cnt = 0;                  byte[] pack = null;                  uint packSize = 0;                    foreach (var file in diBP.GetFiles().Where(r => r.Name.StartsWith("dbreeze_ibp_")).OrderBy(r => r.Name))                  {                      using (var bfs = new FileStream(file.FullName' FileMode.Open' FileAccess.Read' FileShare.None))                      {                          while ((cnt = bfs.Read(readOut' 0' readOut.Length)) > 0)                          {                              processed += cnt;                              readinessInProcent = Convert.ToInt32((processed * 100) / totalBackupFileLength);                              pack = pack.Concat(readOut.Substring(0' cnt));                                while (true)                              {                                  if (pack == null || pack.Length < 4)                                      break;                                    packSize = pack.Substring(0' 4).To_UInt32_BigEndian();                                    if (pack.Length >= 4 + packSize)                                  {                                      this.DoPackage(pack.Substring(4' (int)packSize));                                      pack = pack.Substring(4 + (int)packSize);                                  }                                  else                                      break;                              }                                if (prevReadinessInProcent != readinessInProcent)                              {                                  prevReadinessInProcent = readinessInProcent;                                  OnRestore(new BackupRestorationProcess()                                  {                                      ReadinessInProcent = readinessInProcent'                                      Finished = false                                  });                              }                          }                            if (prevReadinessInProcent != readinessInProcent)                          {                              prevReadinessInProcent = readinessInProcent;                              OnRestore(new BackupRestorationProcess()                              {                                  ReadinessInProcent = readinessInProcent'                                  Finished = false                              });                          }                            bfs.Dispose();                      }                  }                    this.CloseHandels();                    OnRestore(new BackupRestorationProcess()                  {                      ReadinessInProcent = 100'                      Finished = true                  });                }              catch (Exception ex)              {                  throw ex;              }
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,StartRestoration,The following statement contains a magic number: try              {                  //holder of filenames and filestreams                  ds.Clear();                    DirectoryInfo diDB = new DirectoryInfo(DataBaseFolder);                  DirectoryInfo diBP = new DirectoryInfo(BackupFolder);                    if (!diDB.Exists)                      diDB.Create();                    if (!diBP.Exists)                      diBP.Create();                    long totalBackupFileLength = 0;                  long processed = 0;                    foreach (var file in diBP.GetFiles())                  {                      totalBackupFileLength += file.Length;                  }                    if (totalBackupFileLength == processed)                  {                      OnRestore(new BackupRestorationProcess()                      {                          ReadinessInProcent = 100'                          Finished = true                      });                      return;                  }                    int readinessInProcent = Convert.ToInt32((processed * 100) / totalBackupFileLength);                  int prevReadinessInProcent = 0;                    OnRestore(new BackupRestorationProcess()                  {                      ReadinessInProcent = readinessInProcent'                      Finished = false                  });                    byte[] readOut = new byte[100000];                  int cnt = 0;                  byte[] pack = null;                  uint packSize = 0;                    foreach (var file in diBP.GetFiles().Where(r => r.Name.StartsWith("dbreeze_ibp_")).OrderBy(r => r.Name))                  {                      using (var bfs = new FileStream(file.FullName' FileMode.Open' FileAccess.Read' FileShare.None))                      {                          while ((cnt = bfs.Read(readOut' 0' readOut.Length)) > 0)                          {                              processed += cnt;                              readinessInProcent = Convert.ToInt32((processed * 100) / totalBackupFileLength);                              pack = pack.Concat(readOut.Substring(0' cnt));                                while (true)                              {                                  if (pack == null || pack.Length < 4)                                      break;                                    packSize = pack.Substring(0' 4).To_UInt32_BigEndian();                                    if (pack.Length >= 4 + packSize)                                  {                                      this.DoPackage(pack.Substring(4' (int)packSize));                                      pack = pack.Substring(4 + (int)packSize);                                  }                                  else                                      break;                              }                                if (prevReadinessInProcent != readinessInProcent)                              {                                  prevReadinessInProcent = readinessInProcent;                                  OnRestore(new BackupRestorationProcess()                                  {                                      ReadinessInProcent = readinessInProcent'                                      Finished = false                                  });                              }                          }                            if (prevReadinessInProcent != readinessInProcent)                          {                              prevReadinessInProcent = readinessInProcent;                              OnRestore(new BackupRestorationProcess()                              {                                  ReadinessInProcent = readinessInProcent'                                  Finished = false                              });                          }                            bfs.Dispose();                      }                  }                    this.CloseHandels();                    OnRestore(new BackupRestorationProcess()                  {                      ReadinessInProcent = 100'                      Finished = true                  });                }              catch (Exception ex)              {                  throw ex;              }
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,StartRestoration,The following statement contains a magic number: try              {                  //holder of filenames and filestreams                  ds.Clear();                    DirectoryInfo diDB = new DirectoryInfo(DataBaseFolder);                  DirectoryInfo diBP = new DirectoryInfo(BackupFolder);                    if (!diDB.Exists)                      diDB.Create();                    if (!diBP.Exists)                      diBP.Create();                    long totalBackupFileLength = 0;                  long processed = 0;                    foreach (var file in diBP.GetFiles())                  {                      totalBackupFileLength += file.Length;                  }                    if (totalBackupFileLength == processed)                  {                      OnRestore(new BackupRestorationProcess()                      {                          ReadinessInProcent = 100'                          Finished = true                      });                      return;                  }                    int readinessInProcent = Convert.ToInt32((processed * 100) / totalBackupFileLength);                  int prevReadinessInProcent = 0;                    OnRestore(new BackupRestorationProcess()                  {                      ReadinessInProcent = readinessInProcent'                      Finished = false                  });                    byte[] readOut = new byte[100000];                  int cnt = 0;                  byte[] pack = null;                  uint packSize = 0;                    foreach (var file in diBP.GetFiles().Where(r => r.Name.StartsWith("dbreeze_ibp_")).OrderBy(r => r.Name))                  {                      using (var bfs = new FileStream(file.FullName' FileMode.Open' FileAccess.Read' FileShare.None))                      {                          while ((cnt = bfs.Read(readOut' 0' readOut.Length)) > 0)                          {                              processed += cnt;                              readinessInProcent = Convert.ToInt32((processed * 100) / totalBackupFileLength);                              pack = pack.Concat(readOut.Substring(0' cnt));                                while (true)                              {                                  if (pack == null || pack.Length < 4)                                      break;                                    packSize = pack.Substring(0' 4).To_UInt32_BigEndian();                                    if (pack.Length >= 4 + packSize)                                  {                                      this.DoPackage(pack.Substring(4' (int)packSize));                                      pack = pack.Substring(4 + (int)packSize);                                  }                                  else                                      break;                              }                                if (prevReadinessInProcent != readinessInProcent)                              {                                  prevReadinessInProcent = readinessInProcent;                                  OnRestore(new BackupRestorationProcess()                                  {                                      ReadinessInProcent = readinessInProcent'                                      Finished = false                                  });                              }                          }                            if (prevReadinessInProcent != readinessInProcent)                          {                              prevReadinessInProcent = readinessInProcent;                              OnRestore(new BackupRestorationProcess()                              {                                  ReadinessInProcent = readinessInProcent'                                  Finished = false                              });                          }                            bfs.Dispose();                      }                  }                    this.CloseHandels();                    OnRestore(new BackupRestorationProcess()                  {                      ReadinessInProcent = 100'                      Finished = true                  });                }              catch (Exception ex)              {                  throw ex;              }
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,StartRestoration,The following statement contains a magic number: try              {                  //holder of filenames and filestreams                  ds.Clear();                    DirectoryInfo diDB = new DirectoryInfo(DataBaseFolder);                  DirectoryInfo diBP = new DirectoryInfo(BackupFolder);                    if (!diDB.Exists)                      diDB.Create();                    if (!diBP.Exists)                      diBP.Create();                    long totalBackupFileLength = 0;                  long processed = 0;                    foreach (var file in diBP.GetFiles())                  {                      totalBackupFileLength += file.Length;                  }                    if (totalBackupFileLength == processed)                  {                      OnRestore(new BackupRestorationProcess()                      {                          ReadinessInProcent = 100'                          Finished = true                      });                      return;                  }                    int readinessInProcent = Convert.ToInt32((processed * 100) / totalBackupFileLength);                  int prevReadinessInProcent = 0;                    OnRestore(new BackupRestorationProcess()                  {                      ReadinessInProcent = readinessInProcent'                      Finished = false                  });                    byte[] readOut = new byte[100000];                  int cnt = 0;                  byte[] pack = null;                  uint packSize = 0;                    foreach (var file in diBP.GetFiles().Where(r => r.Name.StartsWith("dbreeze_ibp_")).OrderBy(r => r.Name))                  {                      using (var bfs = new FileStream(file.FullName' FileMode.Open' FileAccess.Read' FileShare.None))                      {                          while ((cnt = bfs.Read(readOut' 0' readOut.Length)) > 0)                          {                              processed += cnt;                              readinessInProcent = Convert.ToInt32((processed * 100) / totalBackupFileLength);                              pack = pack.Concat(readOut.Substring(0' cnt));                                while (true)                              {                                  if (pack == null || pack.Length < 4)                                      break;                                    packSize = pack.Substring(0' 4).To_UInt32_BigEndian();                                    if (pack.Length >= 4 + packSize)                                  {                                      this.DoPackage(pack.Substring(4' (int)packSize));                                      pack = pack.Substring(4 + (int)packSize);                                  }                                  else                                      break;                              }                                if (prevReadinessInProcent != readinessInProcent)                              {                                  prevReadinessInProcent = readinessInProcent;                                  OnRestore(new BackupRestorationProcess()                                  {                                      ReadinessInProcent = readinessInProcent'                                      Finished = false                                  });                              }                          }                            if (prevReadinessInProcent != readinessInProcent)                          {                              prevReadinessInProcent = readinessInProcent;                              OnRestore(new BackupRestorationProcess()                              {                                  ReadinessInProcent = readinessInProcent'                                  Finished = false                              });                          }                            bfs.Dispose();                      }                  }                    this.CloseHandels();                    OnRestore(new BackupRestorationProcess()                  {                      ReadinessInProcent = 100'                      Finished = true                  });                }              catch (Exception ex)              {                  throw ex;              }
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,DoPackage,The following statement contains a magic number: ulong fileNumber = pack.Substring(0' 8).To_UInt64_BigEndian();
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,DoPackage,The following statement contains a magic number: byte type = pack.Substring(8' 1)[0];
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,DoPackage,The following statement contains a magic number: switch (type)              {                  case 0:                        //Write into table file                      lfs = this.GetFileStream(filename);                        //if (lfs == null)                      //{                      //    Console.WriteLine("Backup lfs = null");                      //    return;                      //}                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 1:                      //write into rollback file                      lfs = this.GetFileStream(filename + ".rol");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 2:                      //write into rollbackhelper                      lfs = this.GetFileStream(filename + ".rhp");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 3:                        //3 - recreate table file (only table file)                        contains = ds.ContainsKey(filename);                      if (contains)                      {                                                  ds[filename].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename);                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename' null);                        ds[filename] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                    case 4:                        //4 - recreate rollback file (only rollback file)                        contains = ds.ContainsKey(filename + ".rol");                      if (contains)                      {                                                  ds[filename + ".rol"].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename + ".rol");                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename + ".rol"' null);                        ds[filename + ".rol"] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                  case 5:                        //5 - removing complete table                        if (ds.ContainsKey(filename))                      {                                                  ds[filename].Dispose();                      }                        ds.Remove(filename);                        if (ds.ContainsKey(filename + ".rol"))                      {                                                  ds[filename + ".rol"].Dispose();                      }                        ds.Remove(filename + ".rol");                        if (ds.ContainsKey(filename + ".rhp"))                      {                                               ds[filename + ".rhp"].Dispose();                      }                        ds.Remove(filename + ".rhp");                        break;                }
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,DoPackage,The following statement contains a magic number: switch (type)              {                  case 0:                        //Write into table file                      lfs = this.GetFileStream(filename);                        //if (lfs == null)                      //{                      //    Console.WriteLine("Backup lfs = null");                      //    return;                      //}                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 1:                      //write into rollback file                      lfs = this.GetFileStream(filename + ".rol");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 2:                      //write into rollbackhelper                      lfs = this.GetFileStream(filename + ".rhp");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 3:                        //3 - recreate table file (only table file)                        contains = ds.ContainsKey(filename);                      if (contains)                      {                                                  ds[filename].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename);                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename' null);                        ds[filename] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                    case 4:                        //4 - recreate rollback file (only rollback file)                        contains = ds.ContainsKey(filename + ".rol");                      if (contains)                      {                                                  ds[filename + ".rol"].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename + ".rol");                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename + ".rol"' null);                        ds[filename + ".rol"] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                  case 5:                        //5 - removing complete table                        if (ds.ContainsKey(filename))                      {                                                  ds[filename].Dispose();                      }                        ds.Remove(filename);                        if (ds.ContainsKey(filename + ".rol"))                      {                                                  ds[filename + ".rol"].Dispose();                      }                        ds.Remove(filename + ".rol");                        if (ds.ContainsKey(filename + ".rhp"))                      {                                               ds[filename + ".rhp"].Dispose();                      }                        ds.Remove(filename + ".rhp");                        break;                }
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,DoPackage,The following statement contains a magic number: switch (type)              {                  case 0:                        //Write into table file                      lfs = this.GetFileStream(filename);                        //if (lfs == null)                      //{                      //    Console.WriteLine("Backup lfs = null");                      //    return;                      //}                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 1:                      //write into rollback file                      lfs = this.GetFileStream(filename + ".rol");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 2:                      //write into rollbackhelper                      lfs = this.GetFileStream(filename + ".rhp");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 3:                        //3 - recreate table file (only table file)                        contains = ds.ContainsKey(filename);                      if (contains)                      {                                                  ds[filename].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename);                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename' null);                        ds[filename] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                    case 4:                        //4 - recreate rollback file (only rollback file)                        contains = ds.ContainsKey(filename + ".rol");                      if (contains)                      {                                                  ds[filename + ".rol"].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename + ".rol");                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename + ".rol"' null);                        ds[filename + ".rol"] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                  case 5:                        //5 - removing complete table                        if (ds.ContainsKey(filename))                      {                                                  ds[filename].Dispose();                      }                        ds.Remove(filename);                        if (ds.ContainsKey(filename + ".rol"))                      {                                                  ds[filename + ".rol"].Dispose();                      }                        ds.Remove(filename + ".rol");                        if (ds.ContainsKey(filename + ".rhp"))                      {                                               ds[filename + ".rhp"].Dispose();                      }                        ds.Remove(filename + ".rhp");                        break;                }
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,DoPackage,The following statement contains a magic number: switch (type)              {                  case 0:                        //Write into table file                      lfs = this.GetFileStream(filename);                        //if (lfs == null)                      //{                      //    Console.WriteLine("Backup lfs = null");                      //    return;                      //}                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 1:                      //write into rollback file                      lfs = this.GetFileStream(filename + ".rol");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 2:                      //write into rollbackhelper                      lfs = this.GetFileStream(filename + ".rhp");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 3:                        //3 - recreate table file (only table file)                        contains = ds.ContainsKey(filename);                      if (contains)                      {                                                  ds[filename].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename);                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename' null);                        ds[filename] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                    case 4:                        //4 - recreate rollback file (only rollback file)                        contains = ds.ContainsKey(filename + ".rol");                      if (contains)                      {                                                  ds[filename + ".rol"].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename + ".rol");                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename + ".rol"' null);                        ds[filename + ".rol"] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                  case 5:                        //5 - removing complete table                        if (ds.ContainsKey(filename))                      {                                                  ds[filename].Dispose();                      }                        ds.Remove(filename);                        if (ds.ContainsKey(filename + ".rol"))                      {                                                  ds[filename + ".rol"].Dispose();                      }                        ds.Remove(filename + ".rol");                        if (ds.ContainsKey(filename + ".rhp"))                      {                                               ds[filename + ".rhp"].Dispose();                      }                        ds.Remove(filename + ".rhp");                        break;                }
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,DoPackage,The following statement contains a magic number: switch (type)              {                  case 0:                        //Write into table file                      lfs = this.GetFileStream(filename);                        //if (lfs == null)                      //{                      //    Console.WriteLine("Backup lfs = null");                      //    return;                      //}                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 1:                      //write into rollback file                      lfs = this.GetFileStream(filename + ".rol");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 2:                      //write into rollbackhelper                      lfs = this.GetFileStream(filename + ".rhp");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 3:                        //3 - recreate table file (only table file)                        contains = ds.ContainsKey(filename);                      if (contains)                      {                                                  ds[filename].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename);                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename' null);                        ds[filename] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                    case 4:                        //4 - recreate rollback file (only rollback file)                        contains = ds.ContainsKey(filename + ".rol");                      if (contains)                      {                                                  ds[filename + ".rol"].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename + ".rol");                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename + ".rol"' null);                        ds[filename + ".rol"] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                  case 5:                        //5 - removing complete table                        if (ds.ContainsKey(filename))                      {                                                  ds[filename].Dispose();                      }                        ds.Remove(filename);                        if (ds.ContainsKey(filename + ".rol"))                      {                                                  ds[filename + ".rol"].Dispose();                      }                        ds.Remove(filename + ".rol");                        if (ds.ContainsKey(filename + ".rhp"))                      {                                               ds[filename + ".rhp"].Dispose();                      }                        ds.Remove(filename + ".rhp");                        break;                }
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,DoPackage,The following statement contains a magic number: switch (type)              {                  case 0:                        //Write into table file                      lfs = this.GetFileStream(filename);                        //if (lfs == null)                      //{                      //    Console.WriteLine("Backup lfs = null");                      //    return;                      //}                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 1:                      //write into rollback file                      lfs = this.GetFileStream(filename + ".rol");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 2:                      //write into rollbackhelper                      lfs = this.GetFileStream(filename + ".rhp");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 3:                        //3 - recreate table file (only table file)                        contains = ds.ContainsKey(filename);                      if (contains)                      {                                                  ds[filename].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename);                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename' null);                        ds[filename] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                    case 4:                        //4 - recreate rollback file (only rollback file)                        contains = ds.ContainsKey(filename + ".rol");                      if (contains)                      {                                                  ds[filename + ".rol"].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename + ".rol");                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename + ".rol"' null);                        ds[filename + ".rol"] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                  case 5:                        //5 - removing complete table                        if (ds.ContainsKey(filename))                      {                                                  ds[filename].Dispose();                      }                        ds.Remove(filename);                        if (ds.ContainsKey(filename + ".rol"))                      {                                                  ds[filename + ".rol"].Dispose();                      }                        ds.Remove(filename + ".rol");                        if (ds.ContainsKey(filename + ".rhp"))                      {                                               ds[filename + ".rhp"].Dispose();                      }                        ds.Remove(filename + ".rhp");                        break;                }
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,DoPackage,The following statement contains a magic number: switch (type)              {                  case 0:                        //Write into table file                      lfs = this.GetFileStream(filename);                        //if (lfs == null)                      //{                      //    Console.WriteLine("Backup lfs = null");                      //    return;                      //}                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 1:                      //write into rollback file                      lfs = this.GetFileStream(filename + ".rol");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 2:                      //write into rollbackhelper                      lfs = this.GetFileStream(filename + ".rhp");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 3:                        //3 - recreate table file (only table file)                        contains = ds.ContainsKey(filename);                      if (contains)                      {                                                  ds[filename].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename);                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename' null);                        ds[filename] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                    case 4:                        //4 - recreate rollback file (only rollback file)                        contains = ds.ContainsKey(filename + ".rol");                      if (contains)                      {                                                  ds[filename + ".rol"].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename + ".rol");                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename + ".rol"' null);                        ds[filename + ".rol"] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                  case 5:                        //5 - removing complete table                        if (ds.ContainsKey(filename))                      {                                                  ds[filename].Dispose();                      }                        ds.Remove(filename);                        if (ds.ContainsKey(filename + ".rol"))                      {                                                  ds[filename + ".rol"].Dispose();                      }                        ds.Remove(filename + ".rol");                        if (ds.ContainsKey(filename + ".rhp"))                      {                                               ds[filename + ".rhp"].Dispose();                      }                        ds.Remove(filename + ".rhp");                        break;                }
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,DoPackage,The following statement contains a magic number: switch (type)              {                  case 0:                        //Write into table file                      lfs = this.GetFileStream(filename);                        //if (lfs == null)                      //{                      //    Console.WriteLine("Backup lfs = null");                      //    return;                      //}                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 1:                      //write into rollback file                      lfs = this.GetFileStream(filename + ".rol");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 2:                      //write into rollbackhelper                      lfs = this.GetFileStream(filename + ".rhp");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 3:                        //3 - recreate table file (only table file)                        contains = ds.ContainsKey(filename);                      if (contains)                      {                                                  ds[filename].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename);                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename' null);                        ds[filename] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                    case 4:                        //4 - recreate rollback file (only rollback file)                        contains = ds.ContainsKey(filename + ".rol");                      if (contains)                      {                                                  ds[filename + ".rol"].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename + ".rol");                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename + ".rol"' null);                        ds[filename + ".rol"] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                  case 5:                        //5 - removing complete table                        if (ds.ContainsKey(filename))                      {                                                  ds[filename].Dispose();                      }                        ds.Remove(filename);                        if (ds.ContainsKey(filename + ".rol"))                      {                                                  ds[filename + ".rol"].Dispose();                      }                        ds.Remove(filename + ".rol");                        if (ds.ContainsKey(filename + ".rhp"))                      {                                               ds[filename + ".rhp"].Dispose();                      }                        ds.Remove(filename + ".rhp");                        break;                }
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,DoPackage,The following statement contains a magic number: switch (type)              {                  case 0:                        //Write into table file                      lfs = this.GetFileStream(filename);                        //if (lfs == null)                      //{                      //    Console.WriteLine("Backup lfs = null");                      //    return;                      //}                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 1:                      //write into rollback file                      lfs = this.GetFileStream(filename + ".rol");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 2:                      //write into rollbackhelper                      lfs = this.GetFileStream(filename + ".rhp");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 3:                        //3 - recreate table file (only table file)                        contains = ds.ContainsKey(filename);                      if (contains)                      {                                                  ds[filename].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename);                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename' null);                        ds[filename] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                    case 4:                        //4 - recreate rollback file (only rollback file)                        contains = ds.ContainsKey(filename + ".rol");                      if (contains)                      {                                                  ds[filename + ".rol"].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename + ".rol");                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename + ".rol"' null);                        ds[filename + ".rol"] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                  case 5:                        //5 - removing complete table                        if (ds.ContainsKey(filename))                      {                                                  ds[filename].Dispose();                      }                        ds.Remove(filename);                        if (ds.ContainsKey(filename + ".rol"))                      {                                                  ds[filename + ".rol"].Dispose();                      }                        ds.Remove(filename + ".rol");                        if (ds.ContainsKey(filename + ".rhp"))                      {                                               ds[filename + ".rhp"].Dispose();                      }                        ds.Remove(filename + ".rhp");                        break;                }
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,DoPackage,The following statement contains a magic number: switch (type)              {                  case 0:                        //Write into table file                      lfs = this.GetFileStream(filename);                        //if (lfs == null)                      //{                      //    Console.WriteLine("Backup lfs = null");                      //    return;                      //}                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 1:                      //write into rollback file                      lfs = this.GetFileStream(filename + ".rol");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 2:                      //write into rollbackhelper                      lfs = this.GetFileStream(filename + ".rhp");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 3:                        //3 - recreate table file (only table file)                        contains = ds.ContainsKey(filename);                      if (contains)                      {                                                  ds[filename].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename);                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename' null);                        ds[filename] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                    case 4:                        //4 - recreate rollback file (only rollback file)                        contains = ds.ContainsKey(filename + ".rol");                      if (contains)                      {                                                  ds[filename + ".rol"].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename + ".rol");                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename + ".rol"' null);                        ds[filename + ".rol"] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                  case 5:                        //5 - removing complete table                        if (ds.ContainsKey(filename))                      {                                                  ds[filename].Dispose();                      }                        ds.Remove(filename);                        if (ds.ContainsKey(filename + ".rol"))                      {                                                  ds[filename + ".rol"].Dispose();                      }                        ds.Remove(filename + ".rol");                        if (ds.ContainsKey(filename + ".rhp"))                      {                                               ds[filename + ".rhp"].Dispose();                      }                        ds.Remove(filename + ".rhp");                        break;                }
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,DoPackage,The following statement contains a magic number: switch (type)              {                  case 0:                        //Write into table file                      lfs = this.GetFileStream(filename);                        //if (lfs == null)                      //{                      //    Console.WriteLine("Backup lfs = null");                      //    return;                      //}                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 1:                      //write into rollback file                      lfs = this.GetFileStream(filename + ".rol");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 2:                      //write into rollbackhelper                      lfs = this.GetFileStream(filename + ".rhp");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 3:                        //3 - recreate table file (only table file)                        contains = ds.ContainsKey(filename);                      if (contains)                      {                                                  ds[filename].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename);                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename' null);                        ds[filename] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                    case 4:                        //4 - recreate rollback file (only rollback file)                        contains = ds.ContainsKey(filename + ".rol");                      if (contains)                      {                                                  ds[filename + ".rol"].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename + ".rol");                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename + ".rol"' null);                        ds[filename + ".rol"] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                  case 5:                        //5 - removing complete table                        if (ds.ContainsKey(filename))                      {                                                  ds[filename].Dispose();                      }                        ds.Remove(filename);                        if (ds.ContainsKey(filename + ".rol"))                      {                                                  ds[filename + ".rol"].Dispose();                      }                        ds.Remove(filename + ".rol");                        if (ds.ContainsKey(filename + ".rhp"))                      {                                               ds[filename + ".rhp"].Dispose();                      }                        ds.Remove(filename + ".rhp");                        break;                }
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,DoPackage,The following statement contains a magic number: switch (type)              {                  case 0:                        //Write into table file                      lfs = this.GetFileStream(filename);                        //if (lfs == null)                      //{                      //    Console.WriteLine("Backup lfs = null");                      //    return;                      //}                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 1:                      //write into rollback file                      lfs = this.GetFileStream(filename + ".rol");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 2:                      //write into rollbackhelper                      lfs = this.GetFileStream(filename + ".rhp");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 3:                        //3 - recreate table file (only table file)                        contains = ds.ContainsKey(filename);                      if (contains)                      {                                                  ds[filename].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename);                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename' null);                        ds[filename] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                    case 4:                        //4 - recreate rollback file (only rollback file)                        contains = ds.ContainsKey(filename + ".rol");                      if (contains)                      {                                                  ds[filename + ".rol"].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename + ".rol");                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename + ".rol"' null);                        ds[filename + ".rol"] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                  case 5:                        //5 - removing complete table                        if (ds.ContainsKey(filename))                      {                                                  ds[filename].Dispose();                      }                        ds.Remove(filename);                        if (ds.ContainsKey(filename + ".rol"))                      {                                                  ds[filename + ".rol"].Dispose();                      }                        ds.Remove(filename + ".rol");                        if (ds.ContainsKey(filename + ".rhp"))                      {                                               ds[filename + ".rhp"].Dispose();                      }                        ds.Remove(filename + ".rhp");                        break;                }
Magic Number,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,DoPackage,The following statement contains a magic number: switch (type)              {                  case 0:                        //Write into table file                      lfs = this.GetFileStream(filename);                        //if (lfs == null)                      //{                      //    Console.WriteLine("Backup lfs = null");                      //    return;                      //}                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 1:                      //write into rollback file                      lfs = this.GetFileStream(filename + ".rol");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 2:                      //write into rollbackhelper                      lfs = this.GetFileStream(filename + ".rhp");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 3:                        //3 - recreate table file (only table file)                        contains = ds.ContainsKey(filename);                      if (contains)                      {                                                  ds[filename].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename);                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename' null);                        ds[filename] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                    case 4:                        //4 - recreate rollback file (only rollback file)                        contains = ds.ContainsKey(filename + ".rol");                      if (contains)                      {                                                  ds[filename + ".rol"].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename + ".rol");                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename + ".rol"' null);                        ds[filename + ".rol"] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                  case 5:                        //5 - removing complete table                        if (ds.ContainsKey(filename))                      {                                                  ds[filename].Dispose();                      }                        ds.Remove(filename);                        if (ds.ContainsKey(filename + ".rol"))                      {                                                  ds[filename + ".rol"].Dispose();                      }                        ds.Remove(filename + ".rol");                        if (ds.ContainsKey(filename + ".rhp"))                      {                                               ds[filename + ".rhp"].Dispose();                      }                        ds.Remove(filename + ".rhp");                        break;                }
Magic Number,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,InitRollback,The following statement contains a magic number: byte[] btWork = new byte[8];
Magic Number,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,InitRollback,The following statement contains a magic number: _fsRollbackHelper.Read(btWork' 0' 8);
Magic Number,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,InitRollback,The following statement contains a magic number: _fsRollbackHelper.Write(eofRollback.To_8_bytes_array_BigEndian()' 0' 8);
Magic Number,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,RestoreInitRollback,The following statement contains a magic number: byte[] rba = new byte[100 * 1024];
Magic Number,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,RestoreInitRollback,The following statement contains a magic number: byte[] rba = new byte[100 * 1024];
Magic Number,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,DoProtocol1,The following statement contains a magic number: if (protocolData.Length < (1 + DefaultPointerLen + 4))                  return null;
Magic Number,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,DoProtocol1,The following statement contains a magic number: int len = (int)(protocolData.Substring(1 + DefaultPointerLen' 4).To_UInt32_BigEndian());
Magic Number,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,DoProtocol1,The following statement contains a magic number: if (protocolData.Length >= len + 1 + DefaultPointerLen + 4)              {                  data = protocolData.Substring(1 + DefaultPointerLen + 4' len);                  left = protocolData.Substring(len + 1 + DefaultPointerLen + 4' protocolData.Length);                      byte[] offset = protocolData.Substring(1' DefaultPointerLen);                    //Writing data back                  //Console.WriteLine("Of: {0}; DL: {1}"' offset.ToBytesString("")' data.Length.To_4_bytes_array_BigEndian().ToBytesString(""));                    this._fsData.Position = (long)offset.DynamicLength_To_UInt64_BigEndian();                  this._fsData.Write(data' 0' data.Length);              }              else                  return null;
Magic Number,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,DoProtocol1,The following statement contains a magic number: if (protocolData.Length >= len + 1 + DefaultPointerLen + 4)              {                  data = protocolData.Substring(1 + DefaultPointerLen + 4' len);                  left = protocolData.Substring(len + 1 + DefaultPointerLen + 4' protocolData.Length);                      byte[] offset = protocolData.Substring(1' DefaultPointerLen);                    //Writing data back                  //Console.WriteLine("Of: {0}; DL: {1}"' offset.ToBytesString("")' data.Length.To_4_bytes_array_BigEndian().ToBytesString(""));                    this._fsData.Position = (long)offset.DynamicLength_To_UInt64_BigEndian();                  this._fsData.Write(data' 0' data.Length);              }              else                  return null;
Magic Number,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,DoProtocol1,The following statement contains a magic number: if (protocolData.Length >= len + 1 + DefaultPointerLen + 4)              {                  data = protocolData.Substring(1 + DefaultPointerLen + 4' len);                  left = protocolData.Substring(len + 1 + DefaultPointerLen + 4' protocolData.Length);                      byte[] offset = protocolData.Substring(1' DefaultPointerLen);                    //Writing data back                  //Console.WriteLine("Of: {0}; DL: {1}"' offset.ToBytesString("")' data.Length.To_4_bytes_array_BigEndian().ToBytesString(""));                    this._fsData.Position = (long)offset.DynamicLength_To_UInt64_BigEndian();                  this._fsData.Write(data' 0' data.Length);              }              else                  return null;
Magic Number,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,Table_WriteToTheEnd,The following statement contains a magic number: lock (lock_fs)              {                  //case when incoming data bigger then buffer' we clean buffer and write data directly to the disk                    if (data.Length > _seqBufCapacity)                  {                      FlushSequentialBuffer();                      _fsData.Position = position = _fsData.Length;                      _fsData.Write(data' 0' data.Length);                        return ((ulong)position).To_8_bytes_array_BigEndian().Substring(8 - DefaultPointerLen' DefaultPointerLen);                  }                                    //Time to clean buffer                  if (_seqBuf.EOF + data.Length > _seqBufCapacity)                  {                      FlushSequentialBuffer();                  }                    //Writing into buffer                    position = _fsData.Length + _seqBuf.EOF;                    _seqBuf.Write_ToTheEnd(data);                                    //eofData (ptr to the end of file before current commit) will be increased only after flush                }
Magic Number,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,Table_WriteToTheEnd,The following statement contains a magic number: return ((ulong)position).To_8_bytes_array_BigEndian().Substring(8 - DefaultPointerLen' DefaultPointerLen);
Magic Number,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,FlushRandomBuffer,The following statement contains a magic number: foreach (var de in _randBuf.OrderBy(r => r.Key))                             {                  offset = ((ulong)de.Key).To_8_bytes_array_BigEndian().Substring(8 - DefaultPointerLen' DefaultPointerLen);                    if (_rollbackCache.ContainsKey(de.Key))                      continue;                    //Reading from dataFile values which must be rolled back                  btRoll = new byte[de.Value.Length];                    _fsData.Position = de.Key;                  _fsData.Read(btRoll' 0' btRoll.Length);                  //Console.WriteLine("2;{0};{1}"' de.Key' ((btRoll == null) ? -1 : btRoll.Length));                    //Forming protocol for rollback                  btRoll = new byte[] { 1 }                             .ConcatMany(                             offset'                             ((uint)btRoll.Length).To_4_bytes_array_BigEndian()'                             btRoll                             );                    //Writing rollback                  _fsRollback.Position = eofRollback;                  _fsRollback.Write(btRoll' 0' btRoll.Length);                    if (_backupIsActive)                  {                      this._configuration.Backup.WriteBackupElement(ulFileName' 1' eofRollback' btRoll);                  }                    _rollbackCache.Add(de.Key' new r { o = eofRollback + 1 + offset.Length + 4' l = de.Value.Length });                             //increasing eof rollback file                  eofRollback += btRoll.Length;                    flushRollback = true;              }
Magic Number,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,FlushRandomBuffer,The following statement contains a magic number: foreach (var de in _randBuf.OrderBy(r => r.Key))                             {                  offset = ((ulong)de.Key).To_8_bytes_array_BigEndian().Substring(8 - DefaultPointerLen' DefaultPointerLen);                    if (_rollbackCache.ContainsKey(de.Key))                      continue;                    //Reading from dataFile values which must be rolled back                  btRoll = new byte[de.Value.Length];                    _fsData.Position = de.Key;                  _fsData.Read(btRoll' 0' btRoll.Length);                  //Console.WriteLine("2;{0};{1}"' de.Key' ((btRoll == null) ? -1 : btRoll.Length));                    //Forming protocol for rollback                  btRoll = new byte[] { 1 }                             .ConcatMany(                             offset'                             ((uint)btRoll.Length).To_4_bytes_array_BigEndian()'                             btRoll                             );                    //Writing rollback                  _fsRollback.Position = eofRollback;                  _fsRollback.Write(btRoll' 0' btRoll.Length);                    if (_backupIsActive)                  {                      this._configuration.Backup.WriteBackupElement(ulFileName' 1' eofRollback' btRoll);                  }                    _rollbackCache.Add(de.Key' new r { o = eofRollback + 1 + offset.Length + 4' l = de.Value.Length });                             //increasing eof rollback file                  eofRollback += btRoll.Length;                    flushRollback = true;              }
Magic Number,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,FlushRandomBuffer,The following statement contains a magic number: if (flushRollback)              {                    //Flushing rollback                  NET_Flush(_fsRollback);                    //Writing into helper                  _fsRollbackHelper.Position = 0;                  _fsRollbackHelper.Write(eofRollback.To_8_bytes_array_BigEndian()' 0' 8);                    //Flushing rollback helper                  NET_Flush(_fsRollbackHelper);                      if (_backupIsActive)                  {                      this._configuration.Backup.WriteBackupElement(ulFileName' 2' 0' eofRollback.To_8_bytes_array_BigEndian());                      this._configuration.Backup.Flush();                  }              }
Magic Number,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,FlushRandomBuffer,The following statement contains a magic number: if (flushRollback)              {                    //Flushing rollback                  NET_Flush(_fsRollback);                    //Writing into helper                  _fsRollbackHelper.Position = 0;                  _fsRollbackHelper.Write(eofRollback.To_8_bytes_array_BigEndian()' 0' 8);                    //Flushing rollback helper                  NET_Flush(_fsRollbackHelper);                      if (_backupIsActive)                  {                      this._configuration.Backup.WriteBackupElement(ulFileName' 2' 0' eofRollback.To_8_bytes_array_BigEndian());                      this._configuration.Backup.Flush();                  }              }
Magic Number,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,Commit,The following statement contains a magic number: lock (lock_fs)              {                  FlushSequentialBuffer();                  FlushRandomBuffer();                    NET_Flush(_fsData);                    if (_backupIsActive)                  {                      this._configuration.Backup.Flush();                  }                    if (eofRollback != 0)                  {                      //Finalizing rollback helper                        eofRollback = 0;                      _fsRollbackHelper.Position = 0;                      _fsRollbackHelper.Write(eofRollback.To_8_bytes_array_BigEndian()' 0' 8);                        NET_Flush(_fsRollbackHelper);                        if (_backupIsActive)                      {                          this._configuration.Backup.WriteBackupElement(ulFileName' 2' 0' eofRollback.To_8_bytes_array_BigEndian());                          this._configuration.Backup.Flush();                      }                  }                    _rollbackCache.Clear();                    eofData = this._fsData.Length;                                               }
Magic Number,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,Commit,The following statement contains a magic number: lock (lock_fs)              {                  FlushSequentialBuffer();                  FlushRandomBuffer();                    NET_Flush(_fsData);                    if (_backupIsActive)                  {                      this._configuration.Backup.Flush();                  }                    if (eofRollback != 0)                  {                      //Finalizing rollback helper                        eofRollback = 0;                      _fsRollbackHelper.Position = 0;                      _fsRollbackHelper.Write(eofRollback.To_8_bytes_array_BigEndian()' 0' 8);                        NET_Flush(_fsRollbackHelper);                        if (_backupIsActive)                      {                          this._configuration.Backup.WriteBackupElement(ulFileName' 2' 0' eofRollback.To_8_bytes_array_BigEndian());                          this._configuration.Backup.Flush();                      }                  }                    _rollbackCache.Clear();                    eofData = this._fsData.Length;                                               }
Magic Number,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,TransactionalCommitIsFinished,The following statement contains a magic number: lock (lock_fs)              {                  if (eofRollback != 0)                  {                      //Finalizing rollback helper                        eofRollback = 0;                      _fsRollbackHelper.Position = 0;                      _fsRollbackHelper.Write(eofRollback.To_8_bytes_array_BigEndian()' 0' 8);                        NET_Flush(_fsRollbackHelper);                        if (_backupIsActive)                      {                          this._configuration.Backup.WriteBackupElement(ulFileName' 2' 0' eofRollback.To_8_bytes_array_BigEndian());                          this._configuration.Backup.Flush();                      }                  }                    _rollbackCache.Clear();                    eofData = this._fsData.Length;                    TransactionalCommitIsStarted = false;              }
Magic Number,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,TransactionalCommitIsFinished,The following statement contains a magic number: lock (lock_fs)              {                  if (eofRollback != 0)                  {                      //Finalizing rollback helper                        eofRollback = 0;                      _fsRollbackHelper.Position = 0;                      _fsRollbackHelper.Write(eofRollback.To_8_bytes_array_BigEndian()' 0' 8);                        NET_Flush(_fsRollbackHelper);                        if (_backupIsActive)                      {                          this._configuration.Backup.WriteBackupElement(ulFileName' 2' 0' eofRollback.To_8_bytes_array_BigEndian());                          this._configuration.Backup.Flush();                      }                  }                    _rollbackCache.Clear();                    eofData = this._fsData.Length;                    TransactionalCommitIsStarted = false;              }
Magic Number,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,Rollback,The following statement contains a magic number: try              {                  lock (lock_fs)                  {                      //Clearing random buffer                      if (_randBuf.Count() != 0)                      {                          usedBufferSize = 0;                          _randBuf.Clear();                      }                        //Restoring Rollback records                      byte[] btWork = null;                        if (_rollbackCache.Count() > 0)                      {                            foreach (var rb in _rollbackCache)                          {                              btWork = new byte[rb.Value.l];                              _fsRollback.Position = rb.Value.o;                              _fsRollback.Read(btWork' 0' btWork.Length);                                _fsData.Position = rb.Key;                              _fsData.Write(btWork' 0' btWork.Length);                                if (_backupIsActive)                              {                                  this._configuration.Backup.WriteBackupElement(ulFileName' 0' rb.Key' btWork);                              }                          }                            NET_Flush(_fsData);                             if (_backupIsActive)                          {                              this._configuration.Backup.Flush();                          }                            //Restoring rhp                          eofRollback = 0;                          _fsRollbackHelper.Position = 0;                          _fsRollbackHelper.Write(eofRollback.To_8_bytes_array_BigEndian()' 0' 8);                            NET_Flush(_fsRollbackHelper);                            if (_backupIsActive)                          {                              this._configuration.Backup.WriteBackupElement(ulFileName' 2' 0' eofRollback.To_8_bytes_array_BigEndian());                              this._configuration.Backup.Flush();                          }                            //Clearing rollbackCache                          _rollbackCache.Clear();                        }                        //we dont move eofData' space can be re-used up to next restart (may be root can have this info in next protocols)                      //eofData = this._fsData.Length;                  }              }              catch (Exception ex)              {                  IsOperable = false;                  throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.RESTORE_ROLLBACK_DATA_FAILED' this._fileName' ex);              }
Magic Number,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,Rollback,The following statement contains a magic number: try              {                  lock (lock_fs)                  {                      //Clearing random buffer                      if (_randBuf.Count() != 0)                      {                          usedBufferSize = 0;                          _randBuf.Clear();                      }                        //Restoring Rollback records                      byte[] btWork = null;                        if (_rollbackCache.Count() > 0)                      {                            foreach (var rb in _rollbackCache)                          {                              btWork = new byte[rb.Value.l];                              _fsRollback.Position = rb.Value.o;                              _fsRollback.Read(btWork' 0' btWork.Length);                                _fsData.Position = rb.Key;                              _fsData.Write(btWork' 0' btWork.Length);                                if (_backupIsActive)                              {                                  this._configuration.Backup.WriteBackupElement(ulFileName' 0' rb.Key' btWork);                              }                          }                            NET_Flush(_fsData);                             if (_backupIsActive)                          {                              this._configuration.Backup.Flush();                          }                            //Restoring rhp                          eofRollback = 0;                          _fsRollbackHelper.Position = 0;                          _fsRollbackHelper.Write(eofRollback.To_8_bytes_array_BigEndian()' 0' 8);                            NET_Flush(_fsRollbackHelper);                            if (_backupIsActive)                          {                              this._configuration.Backup.WriteBackupElement(ulFileName' 2' 0' eofRollback.To_8_bytes_array_BigEndian());                              this._configuration.Backup.Flush();                          }                            //Clearing rollbackCache                          _rollbackCache.Clear();                        }                        //we dont move eofData' space can be re-used up to next restart (may be root can have this info in next protocols)                      //eofData = this._fsData.Length;                  }              }              catch (Exception ex)              {                  IsOperable = false;                  throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.RESTORE_ROLLBACK_DATA_FAILED' this._fileName' ex);              }
Magic Number,DBreeze.Storage,MemoryStorage,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MemoryStorage.cs,MemoryStorage,The following statement contains a magic number: if (initialCapacity < 5)                  initialCapacity = 5;
Magic Number,DBreeze.Storage,MemoryStorage,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MemoryStorage.cs,MemoryStorage,The following statement contains a magic number: if (initialCapacity < 5)                  initialCapacity = 5;
Magic Number,DBreeze.Storage,MemoryStorage,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MemoryStorage.cs,MemoryStorage,The following statement contains a magic number: if(strategy == eMemoryExpandStartegy.FIXED_LENGTH_INCREASE)              {                  if (increaseOnBytes < 5)                      increaseOnBytes = 5;                    _increaseOnInBytes = increaseOnBytes;              }
Magic Number,DBreeze.Storage,MemoryStorage,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MemoryStorage.cs,MemoryStorage,The following statement contains a magic number: if(strategy == eMemoryExpandStartegy.FIXED_LENGTH_INCREASE)              {                  if (increaseOnBytes < 5)                      increaseOnBytes = 5;                    _increaseOnInBytes = increaseOnBytes;              }
Magic Number,DBreeze.Storage,MemoryStorage,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MemoryStorage.cs,Resize,The following statement contains a magic number: switch (_expandStrategy)              {                  case eMemoryExpandStartegy.MULTIPLY_CAPACITY_BY_2:                        if (_capacity * 2 < upTo)                      {                          x = (int)Math.Ceiling((double)upTo / ((double) 2 * _capacity));                      }                      _capacity = _capacity * 2 * x;                                                          break;                  case eMemoryExpandStartegy.FIXED_LENGTH_INCREASE:                        if (_capacity + _increaseOnInBytes < upTo)                      {                          x = (int)Math.Ceiling((double)(upTo - _capacity) / (double)_increaseOnInBytes);                      }                      _capacity = _capacity + (_increaseOnInBytes * x);                        break;              }
Magic Number,DBreeze.Storage,MemoryStorage,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MemoryStorage.cs,Resize,The following statement contains a magic number: switch (_expandStrategy)              {                  case eMemoryExpandStartegy.MULTIPLY_CAPACITY_BY_2:                        if (_capacity * 2 < upTo)                      {                          x = (int)Math.Ceiling((double)upTo / ((double) 2 * _capacity));                      }                      _capacity = _capacity * 2 * x;                                                          break;                  case eMemoryExpandStartegy.FIXED_LENGTH_INCREASE:                        if (_capacity + _increaseOnInBytes < upTo)                      {                          x = (int)Math.Ceiling((double)(upTo - _capacity) / (double)_increaseOnInBytes);                      }                      _capacity = _capacity + (_increaseOnInBytes * x);                        break;              }
Magic Number,DBreeze.Storage,MemoryStorage,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MemoryStorage.cs,Resize,The following statement contains a magic number: switch (_expandStrategy)              {                  case eMemoryExpandStartegy.MULTIPLY_CAPACITY_BY_2:                        if (_capacity * 2 < upTo)                      {                          x = (int)Math.Ceiling((double)upTo / ((double) 2 * _capacity));                      }                      _capacity = _capacity * 2 * x;                                                          break;                  case eMemoryExpandStartegy.FIXED_LENGTH_INCREASE:                        if (_capacity + _increaseOnInBytes < upTo)                      {                          x = (int)Math.Ceiling((double)(upTo - _capacity) / (double)_increaseOnInBytes);                      }                      _capacity = _capacity + (_increaseOnInBytes * x);                        break;              }
Magic Number,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,InitFiles,The following statement contains a magic number: try              {                  this._fsData = new MemoryStorage(1024 * 16' 1024 * 500' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                  this._fsRollback = new MemoryStorage(1024 * 16' 1024 * 128' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                  this._fsRollbackHelper = new MemoryStorage(8' 10' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                    //Writing root                  this._fsData.Write_ToTheEnd(new byte[64]);                    eofData = this._fsData.EOF;                    _storageFixTime = DateTime.UtcNow;              }              catch (Exception ex)              {                  IsOperable = false;                  throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DB_IS_NOT_OPERABLE' "MSR INIT FAILED: " + this._fileName' ex);              }
Magic Number,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,InitFiles,The following statement contains a magic number: try              {                  this._fsData = new MemoryStorage(1024 * 16' 1024 * 500' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                  this._fsRollback = new MemoryStorage(1024 * 16' 1024 * 128' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                  this._fsRollbackHelper = new MemoryStorage(8' 10' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                    //Writing root                  this._fsData.Write_ToTheEnd(new byte[64]);                    eofData = this._fsData.EOF;                    _storageFixTime = DateTime.UtcNow;              }              catch (Exception ex)              {                  IsOperable = false;                  throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DB_IS_NOT_OPERABLE' "MSR INIT FAILED: " + this._fileName' ex);              }
Magic Number,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,InitFiles,The following statement contains a magic number: try              {                  this._fsData = new MemoryStorage(1024 * 16' 1024 * 500' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                  this._fsRollback = new MemoryStorage(1024 * 16' 1024 * 128' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                  this._fsRollbackHelper = new MemoryStorage(8' 10' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                    //Writing root                  this._fsData.Write_ToTheEnd(new byte[64]);                    eofData = this._fsData.EOF;                    _storageFixTime = DateTime.UtcNow;              }              catch (Exception ex)              {                  IsOperable = false;                  throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DB_IS_NOT_OPERABLE' "MSR INIT FAILED: " + this._fileName' ex);              }
Magic Number,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,InitFiles,The following statement contains a magic number: try              {                  this._fsData = new MemoryStorage(1024 * 16' 1024 * 500' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                  this._fsRollback = new MemoryStorage(1024 * 16' 1024 * 128' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                  this._fsRollbackHelper = new MemoryStorage(8' 10' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                    //Writing root                  this._fsData.Write_ToTheEnd(new byte[64]);                    eofData = this._fsData.EOF;                    _storageFixTime = DateTime.UtcNow;              }              catch (Exception ex)              {                  IsOperable = false;                  throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DB_IS_NOT_OPERABLE' "MSR INIT FAILED: " + this._fileName' ex);              }
Magic Number,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,InitFiles,The following statement contains a magic number: try              {                  this._fsData = new MemoryStorage(1024 * 16' 1024 * 500' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                  this._fsRollback = new MemoryStorage(1024 * 16' 1024 * 128' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                  this._fsRollbackHelper = new MemoryStorage(8' 10' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                    //Writing root                  this._fsData.Write_ToTheEnd(new byte[64]);                    eofData = this._fsData.EOF;                    _storageFixTime = DateTime.UtcNow;              }              catch (Exception ex)              {                  IsOperable = false;                  throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DB_IS_NOT_OPERABLE' "MSR INIT FAILED: " + this._fileName' ex);              }
Magic Number,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,InitFiles,The following statement contains a magic number: try              {                  this._fsData = new MemoryStorage(1024 * 16' 1024 * 500' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                  this._fsRollback = new MemoryStorage(1024 * 16' 1024 * 128' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                  this._fsRollbackHelper = new MemoryStorage(8' 10' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                    //Writing root                  this._fsData.Write_ToTheEnd(new byte[64]);                    eofData = this._fsData.EOF;                    _storageFixTime = DateTime.UtcNow;              }              catch (Exception ex)              {                  IsOperable = false;                  throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DB_IS_NOT_OPERABLE' "MSR INIT FAILED: " + this._fileName' ex);              }
Magic Number,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,InitFiles,The following statement contains a magic number: try              {                  this._fsData = new MemoryStorage(1024 * 16' 1024 * 500' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                  this._fsRollback = new MemoryStorage(1024 * 16' 1024 * 128' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                  this._fsRollbackHelper = new MemoryStorage(8' 10' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                    //Writing root                  this._fsData.Write_ToTheEnd(new byte[64]);                    eofData = this._fsData.EOF;                    _storageFixTime = DateTime.UtcNow;              }              catch (Exception ex)              {                  IsOperable = false;                  throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DB_IS_NOT_OPERABLE' "MSR INIT FAILED: " + this._fileName' ex);              }
Magic Number,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,InitFiles,The following statement contains a magic number: try              {                  this._fsData = new MemoryStorage(1024 * 16' 1024 * 500' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                  this._fsRollback = new MemoryStorage(1024 * 16' 1024 * 128' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                  this._fsRollbackHelper = new MemoryStorage(8' 10' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                    //Writing root                  this._fsData.Write_ToTheEnd(new byte[64]);                    eofData = this._fsData.EOF;                    _storageFixTime = DateTime.UtcNow;              }              catch (Exception ex)              {                  IsOperable = false;                  throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DB_IS_NOT_OPERABLE' "MSR INIT FAILED: " + this._fileName' ex);              }
Magic Number,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,InitFiles,The following statement contains a magic number: try              {                  this._fsData = new MemoryStorage(1024 * 16' 1024 * 500' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                  this._fsRollback = new MemoryStorage(1024 * 16' 1024 * 128' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                  this._fsRollbackHelper = new MemoryStorage(8' 10' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                    //Writing root                  this._fsData.Write_ToTheEnd(new byte[64]);                    eofData = this._fsData.EOF;                    _storageFixTime = DateTime.UtcNow;              }              catch (Exception ex)              {                  IsOperable = false;                  throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DB_IS_NOT_OPERABLE' "MSR INIT FAILED: " + this._fileName' ex);              }
Magic Number,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,InitFiles,The following statement contains a magic number: try              {                  this._fsData = new MemoryStorage(1024 * 16' 1024 * 500' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                  this._fsRollback = new MemoryStorage(1024 * 16' 1024 * 128' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                  this._fsRollbackHelper = new MemoryStorage(8' 10' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                    //Writing root                  this._fsData.Write_ToTheEnd(new byte[64]);                    eofData = this._fsData.EOF;                    _storageFixTime = DateTime.UtcNow;              }              catch (Exception ex)              {                  IsOperable = false;                  throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DB_IS_NOT_OPERABLE' "MSR INIT FAILED: " + this._fileName' ex);              }
Magic Number,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,InitFiles,The following statement contains a magic number: try              {                  this._fsData = new MemoryStorage(1024 * 16' 1024 * 500' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                  this._fsRollback = new MemoryStorage(1024 * 16' 1024 * 128' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                  this._fsRollbackHelper = new MemoryStorage(8' 10' MemoryStorage.eMemoryExpandStartegy.FIXED_LENGTH_INCREASE);                    //Writing root                  this._fsData.Write_ToTheEnd(new byte[64]);                    eofData = this._fsData.EOF;                    _storageFixTime = DateTime.UtcNow;              }              catch (Exception ex)              {                  IsOperable = false;                  throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.DB_IS_NOT_OPERABLE' "MSR INIT FAILED: " + this._fileName' ex);              }
Magic Number,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,Table_WriteToTheEnd,The following statement contains a magic number: return ((ulong)position).To_8_bytes_array_BigEndian().Substring(8 - DefaultPointerLen' DefaultPointerLen);
Magic Number,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,FlushRandomBuffer,The following statement contains a magic number: foreach (var de in _randBuf.OrderBy(r => r.Key))      //sorting can mean nothing here' only takes extra time              {                  offset = ((ulong)de.Key).To_8_bytes_array_BigEndian().Substring(8 - DefaultPointerLen' DefaultPointerLen);                    if (_rollbackCache.ContainsKey(de.Key))                      continue;                    //Reading from dataFile values which must be rolled back                  btRoll = new byte[de.Value.Length];                    _fsData.Write_ByOffset((int)de.Key' ref btRoll);                    //Forming protocol for rollback                  btRoll = new byte[] { 1 }                             .ConcatMany(                             offset'                             ((uint)btRoll.Length).To_4_bytes_array_BigEndian()'                             btRoll                             );                    //Writing rollback                  _fsRollback.Write_ByOffset((int)eofRollback' ref btRoll);                    _rollbackCache.Add(de.Key' new r { o = eofRollback + 1 + offset.Length + 4' l = de.Value.Length });  //10 is size of protocol data                    //increasing eof rollback file                  eofRollback += btRoll.Length;                    flushRollback = true;              }
Magic Number,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,FlushRandomBuffer,The following statement contains a magic number: foreach (var de in _randBuf.OrderBy(r => r.Key))      //sorting can mean nothing here' only takes extra time              {                  offset = ((ulong)de.Key).To_8_bytes_array_BigEndian().Substring(8 - DefaultPointerLen' DefaultPointerLen);                    if (_rollbackCache.ContainsKey(de.Key))                      continue;                    //Reading from dataFile values which must be rolled back                  btRoll = new byte[de.Value.Length];                    _fsData.Write_ByOffset((int)de.Key' ref btRoll);                    //Forming protocol for rollback                  btRoll = new byte[] { 1 }                             .ConcatMany(                             offset'                             ((uint)btRoll.Length).To_4_bytes_array_BigEndian()'                             btRoll                             );                    //Writing rollback                  _fsRollback.Write_ByOffset((int)eofRollback' ref btRoll);                    _rollbackCache.Add(de.Key' new r { o = eofRollback + 1 + offset.Length + 4' l = de.Value.Length });  //10 is size of protocol data                    //increasing eof rollback file                  eofRollback += btRoll.Length;                    flushRollback = true;              }
Magic Number,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,InitRollback,The following statement contains a magic number: byte[] btWork = new byte[8];
Magic Number,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,InitRollback,The following statement contains a magic number: RIC.RollbackHelperFileRead(btWork' 0' 8);
Magic Number,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,InitRollback,The following statement contains a magic number: RIC.RollbackHelperFileWrite(eofRollback.To_8_bytes_array_BigEndian()' 0' 8' true);
Magic Number,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,RestoreInitRollback,The following statement contains a magic number: byte[] rba = new byte[100 * 1024];
Magic Number,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,RestoreInitRollback,The following statement contains a magic number: byte[] rba = new byte[100 * 1024];
Magic Number,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,DoProtocol1,The following statement contains a magic number: if (protocolData.Length < (1 + DefaultPointerLen + 4))                  return null;
Magic Number,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,DoProtocol1,The following statement contains a magic number: int len = (int)(protocolData.Substring(1 + DefaultPointerLen' 4).To_UInt32_BigEndian());
Magic Number,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,DoProtocol1,The following statement contains a magic number: if (protocolData.Length >= len + 1 + DefaultPointerLen + 4)              {                  data = protocolData.Substring(1 + DefaultPointerLen + 4' len);                  left = protocolData.Substring(len + 1 + DefaultPointerLen + 4' protocolData.Length);                      byte[] offset = protocolData.Substring(1' DefaultPointerLen);                    //Writing data back                  //Console.WriteLine("Of: {0}; DL: {1}"' offset.ToBytesString("")' data.Length.To_4_bytes_array_BigEndian().ToBytesString(""));                    RIC.DataFilePosition = (long)offset.DynamicLength_To_UInt64_BigEndian();                  RIC.DataFileWrite(data' 0' data.Length'false);                  //this._fsData.Position = (long)offset.DynamicLength_To_UInt64_BigEndian();                  //this._fsData.Write(data' 0' data.Length);              }              else                  return null;
Magic Number,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,DoProtocol1,The following statement contains a magic number: if (protocolData.Length >= len + 1 + DefaultPointerLen + 4)              {                  data = protocolData.Substring(1 + DefaultPointerLen + 4' len);                  left = protocolData.Substring(len + 1 + DefaultPointerLen + 4' protocolData.Length);                      byte[] offset = protocolData.Substring(1' DefaultPointerLen);                    //Writing data back                  //Console.WriteLine("Of: {0}; DL: {1}"' offset.ToBytesString("")' data.Length.To_4_bytes_array_BigEndian().ToBytesString(""));                    RIC.DataFilePosition = (long)offset.DynamicLength_To_UInt64_BigEndian();                  RIC.DataFileWrite(data' 0' data.Length'false);                  //this._fsData.Position = (long)offset.DynamicLength_To_UInt64_BigEndian();                  //this._fsData.Write(data' 0' data.Length);              }              else                  return null;
Magic Number,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,DoProtocol1,The following statement contains a magic number: if (protocolData.Length >= len + 1 + DefaultPointerLen + 4)              {                  data = protocolData.Substring(1 + DefaultPointerLen + 4' len);                  left = protocolData.Substring(len + 1 + DefaultPointerLen + 4' protocolData.Length);                      byte[] offset = protocolData.Substring(1' DefaultPointerLen);                    //Writing data back                  //Console.WriteLine("Of: {0}; DL: {1}"' offset.ToBytesString("")' data.Length.To_4_bytes_array_BigEndian().ToBytesString(""));                    RIC.DataFilePosition = (long)offset.DynamicLength_To_UInt64_BigEndian();                  RIC.DataFileWrite(data' 0' data.Length'false);                  //this._fsData.Position = (long)offset.DynamicLength_To_UInt64_BigEndian();                  //this._fsData.Write(data' 0' data.Length);              }              else                  return null;
Magic Number,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,Table_WriteToTheEnd,The following statement contains a magic number: lock (lock_fs)              {                  //case when incoming data bigger then buffer' we clean buffer and write data directly to the disk                    if (data.Length > _seqBufCapacity)                  {                      FlushSequentialBuffer();                        RIC.DataFilePosition = position = RIC.DataFileLength;                      RIC.DataFileWrite(data' 0' data.Length' false);                        //_fsData.Position = position = _fsData.Length;                      //_fsData.Write(data' 0' data.Length);                        return ((ulong)position).To_8_bytes_array_BigEndian().Substring(8 - DefaultPointerLen' DefaultPointerLen);                  }                                    //Time to clean buffer                  if (_seqBuf.EOF + data.Length > _seqBufCapacity)                  {                      FlushSequentialBuffer();                  }                    //Writing into buffer                    position = RIC.DataFileLength + _seqBuf.EOF;                  //position = _fsData.Length + _seqBuf.EOF;                    _seqBuf.Write_ToTheEnd(data);                                    //eofData (ptr to the end of file before current commit) will be increased only after flush                }
Magic Number,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,Table_WriteToTheEnd,The following statement contains a magic number: return ((ulong)position).To_8_bytes_array_BigEndian().Substring(8 - DefaultPointerLen' DefaultPointerLen);
Magic Number,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,FlushRandomBuffer,The following statement contains a magic number: foreach (var de in _randBuf.OrderBy(r => r.Key))                             {                  offset = ((ulong)de.Key).To_8_bytes_array_BigEndian().Substring(8 - DefaultPointerLen' DefaultPointerLen);                    if (_rollbackCache.ContainsKey(de.Key))                      continue;                    //Reading from dataFile values which must be rolled back                  btRoll = new byte[de.Value.Length];                    RIC.DataFilePosition = de.Key;                  RIC.DataFileRead(btRoll' 0' btRoll.Length);                  //Console.WriteLine("2;{0};{1}"' de.Key' ((btRoll == null) ? -1 : btRoll.Length));                  //_fsData.Position = de.Key;                  //_fsData.Read(btRoll' 0' btRoll.Length);                    //Forming protocol for rollback                  btRoll = new byte[] { 1 }                             .ConcatMany(                             offset'                             ((uint)btRoll.Length).To_4_bytes_array_BigEndian()'                             btRoll                             );                    //Writing rollback                  RIC.RollbackFilePosition = eofRollback;                  RIC.RollbackFileWrite(btRoll' 0' btRoll.Length'false);                  //_fsRollback.Position = eofRollback;                  //_fsRollback.Write(btRoll' 0' btRoll.Length);                    if (_backupIsActive)                  {                      this._configuration.Backup.WriteBackupElement(ulFileName' 1' eofRollback' btRoll);                  }                    _rollbackCache.Add(de.Key' new r { o = eofRollback + 1 + offset.Length + 4' l = de.Value.Length });                             //increasing eof rollback file                  eofRollback += btRoll.Length;                    flushRollback = true;              }
Magic Number,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,FlushRandomBuffer,The following statement contains a magic number: foreach (var de in _randBuf.OrderBy(r => r.Key))                             {                  offset = ((ulong)de.Key).To_8_bytes_array_BigEndian().Substring(8 - DefaultPointerLen' DefaultPointerLen);                    if (_rollbackCache.ContainsKey(de.Key))                      continue;                    //Reading from dataFile values which must be rolled back                  btRoll = new byte[de.Value.Length];                    RIC.DataFilePosition = de.Key;                  RIC.DataFileRead(btRoll' 0' btRoll.Length);                  //Console.WriteLine("2;{0};{1}"' de.Key' ((btRoll == null) ? -1 : btRoll.Length));                  //_fsData.Position = de.Key;                  //_fsData.Read(btRoll' 0' btRoll.Length);                    //Forming protocol for rollback                  btRoll = new byte[] { 1 }                             .ConcatMany(                             offset'                             ((uint)btRoll.Length).To_4_bytes_array_BigEndian()'                             btRoll                             );                    //Writing rollback                  RIC.RollbackFilePosition = eofRollback;                  RIC.RollbackFileWrite(btRoll' 0' btRoll.Length'false);                  //_fsRollback.Position = eofRollback;                  //_fsRollback.Write(btRoll' 0' btRoll.Length);                    if (_backupIsActive)                  {                      this._configuration.Backup.WriteBackupElement(ulFileName' 1' eofRollback' btRoll);                  }                    _rollbackCache.Add(de.Key' new r { o = eofRollback + 1 + offset.Length + 4' l = de.Value.Length });                             //increasing eof rollback file                  eofRollback += btRoll.Length;                    flushRollback = true;              }
Magic Number,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,FlushRandomBuffer,The following statement contains a magic number: if (flushRollback)              {                    //Flushing rollback                  RIC.RollbackFileFlush();                  //NET_Flush(_fsRollback);                    //Writing into helper                  RIC.RollbackHelperFilePosition = 0;                  RIC.RollbackHelperFileWrite(eofRollback.To_8_bytes_array_BigEndian()' 0' 8' true);                  //_fsRollbackHelper.Position = 0;                  //_fsRollbackHelper.Write(eofRollback.To_8_bytes_array_BigEndian()' 0' 8);                  ////Flushing rollback helper                  //NET_Flush(_fsRollbackHelper);                      if (_backupIsActive)                  {                      this._configuration.Backup.WriteBackupElement(ulFileName' 2' 0' eofRollback.To_8_bytes_array_BigEndian());                      this._configuration.Backup.Flush();                  }              }
Magic Number,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,FlushRandomBuffer,The following statement contains a magic number: if (flushRollback)              {                    //Flushing rollback                  RIC.RollbackFileFlush();                  //NET_Flush(_fsRollback);                    //Writing into helper                  RIC.RollbackHelperFilePosition = 0;                  RIC.RollbackHelperFileWrite(eofRollback.To_8_bytes_array_BigEndian()' 0' 8' true);                  //_fsRollbackHelper.Position = 0;                  //_fsRollbackHelper.Write(eofRollback.To_8_bytes_array_BigEndian()' 0' 8);                  ////Flushing rollback helper                  //NET_Flush(_fsRollbackHelper);                      if (_backupIsActive)                  {                      this._configuration.Backup.WriteBackupElement(ulFileName' 2' 0' eofRollback.To_8_bytes_array_BigEndian());                      this._configuration.Backup.Flush();                  }              }
Magic Number,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,Commit,The following statement contains a magic number: lock (lock_fs)              {                  FlushSequentialBuffer();                  FlushRandomBuffer();                    RIC.DataFileFlush();                  //NET_Flush(_fsData);                    if (_backupIsActive)                  {                      this._configuration.Backup.Flush();                  }                    if (eofRollback != 0)                  {                      //Finalizing rollback helper                        eofRollback = 0;                      RIC.RollbackHelperFilePosition = 0;                      RIC.RollbackHelperFileWrite(eofRollback.To_8_bytes_array_BigEndian()' 0' 8' true);                      //_fsRollbackHelper.Position = 0;                      //_fsRollbackHelper.Write(eofRollback.To_8_bytes_array_BigEndian()' 0' 8);                      //NET_Flush(_fsRollbackHelper);                        if (_backupIsActive)                      {                          this._configuration.Backup.WriteBackupElement(ulFileName' 2' 0' eofRollback.To_8_bytes_array_BigEndian());                          this._configuration.Backup.Flush();                      }                  }                    _rollbackCache.Clear();                    //eofData = this._fsData.Length;                  eofData = RIC.DataFileLength;                                               }
Magic Number,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,Commit,The following statement contains a magic number: lock (lock_fs)              {                  FlushSequentialBuffer();                  FlushRandomBuffer();                    RIC.DataFileFlush();                  //NET_Flush(_fsData);                    if (_backupIsActive)                  {                      this._configuration.Backup.Flush();                  }                    if (eofRollback != 0)                  {                      //Finalizing rollback helper                        eofRollback = 0;                      RIC.RollbackHelperFilePosition = 0;                      RIC.RollbackHelperFileWrite(eofRollback.To_8_bytes_array_BigEndian()' 0' 8' true);                      //_fsRollbackHelper.Position = 0;                      //_fsRollbackHelper.Write(eofRollback.To_8_bytes_array_BigEndian()' 0' 8);                      //NET_Flush(_fsRollbackHelper);                        if (_backupIsActive)                      {                          this._configuration.Backup.WriteBackupElement(ulFileName' 2' 0' eofRollback.To_8_bytes_array_BigEndian());                          this._configuration.Backup.Flush();                      }                  }                    _rollbackCache.Clear();                    //eofData = this._fsData.Length;                  eofData = RIC.DataFileLength;                                               }
Magic Number,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,TransactionalCommitIsFinished,The following statement contains a magic number: lock (lock_fs)              {                  if (eofRollback != 0)                  {                      //Finalizing rollback helper                        eofRollback = 0;                        RIC.RollbackHelperFilePosition = 0;                      RIC.RollbackHelperFileWrite(eofRollback.To_8_bytes_array_BigEndian()' 0' 8' true);                        //_fsRollbackHelper.Position = 0;                      //_fsRollbackHelper.Write(eofRollback.To_8_bytes_array_BigEndian()' 0' 8);                      //NET_Flush(_fsRollbackHelper);                            if (_backupIsActive)                      {                          this._configuration.Backup.WriteBackupElement(ulFileName' 2' 0' eofRollback.To_8_bytes_array_BigEndian());                          this._configuration.Backup.Flush();                      }                  }                    _rollbackCache.Clear();                    //eofData = this._fsData.Length;                  eofData = RIC.DataFileLength;                    TransactionalCommitIsStarted = false;              }
Magic Number,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,TransactionalCommitIsFinished,The following statement contains a magic number: lock (lock_fs)              {                  if (eofRollback != 0)                  {                      //Finalizing rollback helper                        eofRollback = 0;                        RIC.RollbackHelperFilePosition = 0;                      RIC.RollbackHelperFileWrite(eofRollback.To_8_bytes_array_BigEndian()' 0' 8' true);                        //_fsRollbackHelper.Position = 0;                      //_fsRollbackHelper.Write(eofRollback.To_8_bytes_array_BigEndian()' 0' 8);                      //NET_Flush(_fsRollbackHelper);                            if (_backupIsActive)                      {                          this._configuration.Backup.WriteBackupElement(ulFileName' 2' 0' eofRollback.To_8_bytes_array_BigEndian());                          this._configuration.Backup.Flush();                      }                  }                    _rollbackCache.Clear();                    //eofData = this._fsData.Length;                  eofData = RIC.DataFileLength;                    TransactionalCommitIsStarted = false;              }
Magic Number,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,Rollback,The following statement contains a magic number: try              {                  lock (lock_fs)                  {                      //Clearing random buffer                      if (_randBuf.Count() != 0)                      {                          usedBufferSize = 0;                          _randBuf.Clear();                      }                        //Restoring Rollback records                      byte[] btWork = null;                        if (_rollbackCache.Count() > 0)                      {                            foreach (var rb in _rollbackCache)                          {                              btWork = new byte[rb.Value.l];                                RIC.RollbackFilePosition = rb.Value.o;                              RIC.RollbackFileRead(btWork' 0' btWork.Length);                              //_fsRollback.Position = rb.Value.o;                              //_fsRollback.Read(btWork' 0' btWork.Length);                                RIC.DataFilePosition = rb.Key;                              RIC.DataFileWrite(btWork' 0' btWork.Length'false);                              //_fsData.Position = rb.Key;                              //_fsData.Write(btWork' 0' btWork.Length);                                if (_backupIsActive)                              {                                  this._configuration.Backup.WriteBackupElement(ulFileName' 0' rb.Key' btWork);                              }                          }                            RIC.DataFileFlush();                         // NET_Flush(_fsData);                             if (_backupIsActive)                          {                              this._configuration.Backup.Flush();                          }                            //Restoring rhp                          eofRollback = 0;                            RIC.RollbackHelperFilePosition = 0;                          RIC.RollbackHelperFileWrite(eofRollback.To_8_bytes_array_BigEndian()' 0' 8' true);                          //_fsRollbackHelper.Position = 0;                          //_fsRollbackHelper.Write(eofRollback.To_8_bytes_array_BigEndian()' 0' 8);                          //NET_Flush(_fsRollbackHelper);                            if (_backupIsActive)                          {                              this._configuration.Backup.WriteBackupElement(ulFileName' 2' 0' eofRollback.To_8_bytes_array_BigEndian());                              this._configuration.Backup.Flush();                          }                            //Clearing rollbackCache                          _rollbackCache.Clear();                        }                        //we dont move eofData' space can be re-used up to next restart (may be root can have this info in next protocols)                      //eofData = this._fsData.Length;                  }              }              catch (Exception ex)              {                  IsOperable = false;                  throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.RESTORE_ROLLBACK_DATA_FAILED' this._fileName' ex);              }
Magic Number,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,Rollback,The following statement contains a magic number: try              {                  lock (lock_fs)                  {                      //Clearing random buffer                      if (_randBuf.Count() != 0)                      {                          usedBufferSize = 0;                          _randBuf.Clear();                      }                        //Restoring Rollback records                      byte[] btWork = null;                        if (_rollbackCache.Count() > 0)                      {                            foreach (var rb in _rollbackCache)                          {                              btWork = new byte[rb.Value.l];                                RIC.RollbackFilePosition = rb.Value.o;                              RIC.RollbackFileRead(btWork' 0' btWork.Length);                              //_fsRollback.Position = rb.Value.o;                              //_fsRollback.Read(btWork' 0' btWork.Length);                                RIC.DataFilePosition = rb.Key;                              RIC.DataFileWrite(btWork' 0' btWork.Length'false);                              //_fsData.Position = rb.Key;                              //_fsData.Write(btWork' 0' btWork.Length);                                if (_backupIsActive)                              {                                  this._configuration.Backup.WriteBackupElement(ulFileName' 0' rb.Key' btWork);                              }                          }                            RIC.DataFileFlush();                         // NET_Flush(_fsData);                             if (_backupIsActive)                          {                              this._configuration.Backup.Flush();                          }                            //Restoring rhp                          eofRollback = 0;                            RIC.RollbackHelperFilePosition = 0;                          RIC.RollbackHelperFileWrite(eofRollback.To_8_bytes_array_BigEndian()' 0' 8' true);                          //_fsRollbackHelper.Position = 0;                          //_fsRollbackHelper.Write(eofRollback.To_8_bytes_array_BigEndian()' 0' 8);                          //NET_Flush(_fsRollbackHelper);                            if (_backupIsActive)                          {                              this._configuration.Backup.WriteBackupElement(ulFileName' 2' 0' eofRollback.To_8_bytes_array_BigEndian());                              this._configuration.Backup.Flush();                          }                            //Clearing rollbackCache                          _rollbackCache.Clear();                        }                        //we dont move eofData' space can be re-used up to next restart (may be root can have this info in next protocols)                      //eofData = this._fsData.Length;                  }              }              catch (Exception ex)              {                  IsOperable = false;                  throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.RESTORE_ROLLBACK_DATA_FAILED' this._fileName' ex);              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,OpenRemoteTable,The following statement contains a magic number: if (ret[0] == 1)    //For protocol version 1              {                  //First 8 bytes = RemoteTableId                  RemoteTableId = BitConverter.ToUInt64(ret' 1);                  //We need all remote table files lengthes                  _DataFileLength = BitConverter.ToInt64(ret' 9);                  _RollbackFileLength = BitConverter.ToInt64(ret' 17);                  _RollbackHelperFileLength = BitConverter.ToInt64(ret' 25);              }              else if (ret[0] == 255)                  throw new Exception("DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.OpenRemoteTable: remote exception");
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,OpenRemoteTable,The following statement contains a magic number: if (ret[0] == 1)    //For protocol version 1              {                  //First 8 bytes = RemoteTableId                  RemoteTableId = BitConverter.ToUInt64(ret' 1);                  //We need all remote table files lengthes                  _DataFileLength = BitConverter.ToInt64(ret' 9);                  _RollbackFileLength = BitConverter.ToInt64(ret' 17);                  _RollbackHelperFileLength = BitConverter.ToInt64(ret' 25);              }              else if (ret[0] == 255)                  throw new Exception("DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.OpenRemoteTable: remote exception");
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,OpenRemoteTable,The following statement contains a magic number: if (ret[0] == 1)    //For protocol version 1              {                  //First 8 bytes = RemoteTableId                  RemoteTableId = BitConverter.ToUInt64(ret' 1);                  //We need all remote table files lengthes                  _DataFileLength = BitConverter.ToInt64(ret' 9);                  _RollbackFileLength = BitConverter.ToInt64(ret' 17);                  _RollbackHelperFileLength = BitConverter.ToInt64(ret' 25);              }              else if (ret[0] == 255)                  throw new Exception("DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.OpenRemoteTable: remote exception");
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,OpenRemoteTable,The following statement contains a magic number: if (ret[0] == 1)    //For protocol version 1              {                  //First 8 bytes = RemoteTableId                  RemoteTableId = BitConverter.ToUInt64(ret' 1);                  //We need all remote table files lengthes                  _DataFileLength = BitConverter.ToInt64(ret' 9);                  _RollbackFileLength = BitConverter.ToInt64(ret' 17);                  _RollbackHelperFileLength = BitConverter.ToInt64(ret' 25);              }              else if (ret[0] == 255)                  throw new Exception("DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.OpenRemoteTable: remote exception");
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,CloseRemoteTable,The following statement contains a magic number: byte[] protocol = new byte[] { ProtocolVersion' 2 }                                .ConcatMany(BitConverter.GetBytes(RemoteTableId));
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,CloseRemoteTable,The following statement contains a magic number: if (ret[0] == 255)                  throw new Exception("DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.CloseRemoteTable: remote exception");
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,DeleteRemoteTable,The following statement contains a magic number: byte[] protocol = new byte[] { ProtocolVersion' 3 }                                .ConcatMany(BitConverter.GetBytes(RemoteTableId));
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,DeleteRemoteTable,The following statement contains a magic number: if (ret[0] == 255)                  throw new Exception("DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.DeleteRemoteTable: remote exception");
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,DataFileWrite,The following statement contains a magic number: byte[] protocol = new byte[] { ProtocolVersion' 4 }                                .ConcatMany(                                BitConverter.GetBytes(RemoteTableId)'                                BitConverter.GetBytes(this._DataFilePosition)'                                (withFlush) ? new byte[] {1} : new byte[] {0}'                                array.Substring(offset'count)                                );
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,DataFileWrite,The following statement contains a magic number: if (ret[0] == 1)    //For protocol version 1              {                                  _DataFileLength = BitConverter.ToInt64(ret' 1);                           }              else if (ret[0] == 255)                  throw new Exception("DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.DataFileWrite: remote exception");
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,RollbackFileWrite,The following statement contains a magic number: byte[] protocol = new byte[] { ProtocolVersion' 5 }                               .ConcatMany(                               BitConverter.GetBytes(RemoteTableId)'                               BitConverter.GetBytes(this._RollbackFilePosition)'                               (withFlush) ? new byte[] { 1 } : new byte[] { 0 }'                               array.Substring(offset' count)                               );
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,RollbackFileWrite,The following statement contains a magic number: if (ret[0] == 1)    //For protocol version 1              {                  _RollbackFileLength = BitConverter.ToInt64(ret' 1);              }              else if (ret[0] == 255)                  throw new Exception("DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.RollbackFileWrite: remote exception");
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,RollbackHelperFileWrite,The following statement contains a magic number: byte[] protocol = new byte[] { ProtocolVersion' 6 }                               .ConcatMany(                               BitConverter.GetBytes(RemoteTableId)'                               BitConverter.GetBytes(this._RollbackHelperFilePosition)'                               (withFlush) ? new byte[] { 1 } : new byte[] { 0 }'                               array.Substring(offset' count)                               );
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,RollbackHelperFileWrite,The following statement contains a magic number: if (ret[0] == 1)    //For protocol version 1              {                  _RollbackHelperFileLength = BitConverter.ToInt64(ret' 1);              }              else if (ret[0] == 255)                  throw new Exception("DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.RollbackHelperFileWrite: remote exception");
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,DataFileRead,The following statement contains a magic number: byte[] protocol = new byte[] { ProtocolVersion' 7 }                                .ConcatMany(                                BitConverter.GetBytes(RemoteTableId)'                                BitConverter.GetBytes(this._DataFilePosition)'                                                             BitConverter.GetBytes(count-offset)                                );
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,DataFileRead,The following statement contains a magic number: if (ret[0] == 1)    //For protocol version 1              {                  if (ret.Length == 1)                  {                      (new byte[0]).CopyTo(array' 0);                  }                  else                      ret.Substring(1).CopyTo(array' 0);  //not to loose ref object              }              //else if (ret[0] == 254)              //{              //    //Trying to reconnect              //    OpenRemoteTable(this.tableName);              //    DataFileRead(array' offset' count);              //}              else if (ret[0] == 255)                  throw new Exception("DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.DataFileRead: remote exception");
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,RollbackFileRead,The following statement contains a magic number: byte[] protocol = new byte[] { ProtocolVersion' 8 }                                .ConcatMany(                                BitConverter.GetBytes(RemoteTableId)'                                BitConverter.GetBytes(this._RollbackFilePosition)'                                BitConverter.GetBytes(count - offset)                                );
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,RollbackFileRead,The following statement contains a magic number: if (ret[0] == 1)    //For protocol version 1              {                  if (ret.Length == 1)                  {                      (new byte[0]).CopyTo(array' 0);                  }                  else                      ret.Substring(1).CopyTo(array' 0);  //not to loose ref object                              }              else if (ret[0] == 255)                  throw new Exception("DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.RollbackFileRead: remote exception");
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,RollbackHelperFileRead,The following statement contains a magic number: byte[] protocol = new byte[] { ProtocolVersion' 9 }                                .ConcatMany(                                BitConverter.GetBytes(RemoteTableId)'                                BitConverter.GetBytes(this._RollbackHelperFilePosition)'                                BitConverter.GetBytes(count - offset)                                );
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,RollbackHelperFileRead,The following statement contains a magic number: if (ret[0] == 1)    //For protocol version 1              {                  if (ret.Length == 1)                  {                      (new byte[0]).CopyTo(array' 0);                  }                  else                      ret.Substring(1).CopyTo(array' 0);  //not to loose ref object              }              else if (ret[0] == 255)                  throw new Exception("DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.RollbackHelperFileRead: remote exception");
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,DataFileFlush,The following statement contains a magic number: byte[] protocol = new byte[] { ProtocolVersion' 10 }                               .ConcatMany(                               BitConverter.GetBytes(RemoteTableId)                               );
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,DataFileFlush,The following statement contains a magic number: if (ret[0] == 255)                  throw new Exception("DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.DataFileFlush: remote exception");
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,RollbackFileFlush,The following statement contains a magic number: byte[] protocol = new byte[] { ProtocolVersion' 11 }                               .ConcatMany(                               BitConverter.GetBytes(RemoteTableId)                               );
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,RollbackFileFlush,The following statement contains a magic number: if (ret[0] == 255)                  throw new Exception("DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.RollbackFileFlush: remote exception");
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,RollbackFileRecreate,The following statement contains a magic number: byte[] protocol = new byte[] { ProtocolVersion' 12 }                               .ConcatMany(                               BitConverter.GetBytes(RemoteTableId)                               );
Magic Number,DBreeze.Storage.RemoteInstance,RemoteInstanceCommander,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteInstanceCommander.cs,RollbackFileRecreate,The following statement contains a magic number: if (ret[0] == 255)                  throw new Exception("DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.RollbackFileRecreate: remote exception");
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following statement contains a magic number: try              {                  ulong callTableId = 0;                  RemoteTable rt = null;                  byte[] ret = null;                    if (protocol[0] == 1)   //Protocol 1                  {                        if (protocol[1] != 1)                      {                          callTableId = BitConverter.ToUInt64(protocol' 2);                            _sync.EnterReadLock();                          try                          {                              if (!_t.TryGetValue(callTableId' out rt))                              {                                  //throw new Exception("table can't be find by id");                                  return new byte[] { 255 };  //Protocol 255 means error of operation and must raise an exception                              }                          }                          finally                          {                              _sync.ExitReadLock();                          }                      }                        switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }                  }              }              catch// (Exception ex)              {                  return new byte[] { 255 };                  //throw ex;       //Connector must be disconnected and error must be logged              }
Magic Number,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,ObjectInsert,The following statement contains a magic number: if (!toInsert.NewEntity)              {                  ITrieRootNode readRoot = null;                  LTrie table = null;                    if (toInsert.ptrToExisingEntity == null)                  {                                         table = GetReadTableFromBuffer(tableName' out readRoot' true);                                             if (table != null)                      {                                                  var row = table.GetKey(ref primary.IndexFull' readRoot' false);                          if (row.Exists)                              ptr = row.Value.Substring(0' 16);                      }                  }                  else                  {                      ptr = toInsert.ptrToExisingEntity;                      val = toInsert.ExisingEntity;                  }                    newptr = ptr == null;                    if (!newptr)                  {                      //Getting existing value                      if (toInsert.ptrToExisingEntity == null)                      {                          val = this.SelectDataBlock(tableName' ptr);                          val = table.SelectDataBlock(ref val' !(readRoot == null));                      }                                          Biser.Decode_DICT_PROTO_UINT_BYTEARRAY(val' d);                        if(toInsert.IncludeOldEntityIntoResult)                          res.OldEntity = DataTypesConvertor.ConvertBack<TObject>(d[0]);                      res.OldEntityWasFound = true;                                            d[0] = DataTypesConvertor.ConvertValue<TObject>(toInsert.Entity);                                            if (speedUpdate)                      {                          //We must in any case delete all indexes and then insert new                          foreach (var idx in d.Skip(1))                          {                              if (nidx.ContainsKey((byte)idx.Key))                              {                                  if (nidx[(byte)idx.Key] == null)                                      this.RandomKeySorter.Remove<byte[]>(tableName' idx.Value);                                  else if (!nidx[(byte)idx.Key]._ByteArrayEquals(idx.Value))                                      this.RandomKeySorter.Remove<byte[]>(tableName' idx.Value);                              }                              else                                  this.RandomKeySorter.Remove<byte[]>(tableName' idx.Value);                          }                            foreach (var idx in nidx)                          {                              if (idx.Value == null)                                  d.Remove(idx.Key);                              else                                  d[idx.Key] = idx.Value;                          }                            ptr = null;                          newptr = true;                      }                      else                      {                          //In first element we got value itself                          //In other - stored indexes                          foreach (var idx in nidx)                          {                              if (d.ContainsKey(idx.Key))                              {                                  if (idx.Value == null)                                  {                                      this.RandomKeySorter.Remove<byte[]>(tableName' d[idx.Key]);                                      d.Remove(idx.Key);                                      continue;                                  }else if (!idx.Value._ByteArrayEquals(d[idx.Key]))                                  {                                      this.RandomKeySorter.Remove<byte[]>(tableName' d[idx.Key]);                                      d[idx.Key] = idx.Value;                                      newIdx.Add(idx.Value);                                  }                              }                              else                              {                                  if (idx.Value == null)                                      continue;                                  //new index must be added                                  d[idx.Key] = idx.Value;                                  newIdx.Add(idx.Value);                              }                          }                            //Checking may be we don't need to update anything                                                 encodedVal = d.Encode_DICT_PROTO_UINT_BYTEARRAY();                          if (newIdx.Count == 0 && val._ByteArrayEquals(encodedVal))                          {                              res.EntityWasInserted = false;                              return res;                          }                      }                    }                  else                  {                      d[0] = DataTypesConvertor.ConvertValue<TObject>(toInsert.Entity);                      foreach (var idx in nidx)                      {                          if (idx.Value == null)                              continue;                          d[idx.Key] = idx.Value;                      }                  }                             }              else              {                  d[0] = DataTypesConvertor.ConvertValue<TObject>(toInsert.Entity);                  foreach (var idx in nidx)                  {                      if (idx.Value == null)                          continue;                      d[idx.Key] = idx.Value;                  }              }
Magic Number,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,ObjectRemove,The following statement contains a magic number: if (table != null)              {                                  var row = table.GetKey(ref index' readRoot'false);                  if (row.Exists)                      ptr = row.Value.Substring(0' 16);              }
Magic Number,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,Insert,The following statement contains a magic number: if (refToInsertedValue != null)                  refToInsertedValue = refToInsertedValue.EnlargeByteArray_BigEndian(8);
Magic Number,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,InsertPart,The following statement contains a magic number: if (refToInsertedValue != null)                  refToInsertedValue = refToInsertedValue.EnlargeByteArray_BigEndian(8);
Magic Number,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,TextRemoveAll,The following statement contains a magic number: tsh.InsertDocumentText(this' tableName' documentId' String.Empty'String.Empty' deferredIndexing'3' TextSearchHandler.eInsertMode.Insert);
Magic Number,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Decode_DICT_PROTO_STRING_BYTEARRAYHASHSET,The following statement contains a magic number: byte[] sizer = new byte[4];
Magic Number,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Decode_DICT_PROTO_STRING_BYTEARRAYHASHSET,The following statement contains a magic number: Action ClearSizer = () =>              {                  sizer[0] = 0;                  sizer[1] = 0;                  sizer[2] = 0;                  sizer[3] = 0;                    size = 0;              };
Magic Number,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Decode_DICT_PROTO_STRING_BYTEARRAYHASHSET,The following statement contains a magic number: Action ClearSizer = () =>              {                  sizer[0] = 0;                  sizer[1] = 0;                  sizer[2] = 0;                  sizer[3] = 0;                    size = 0;              };
Magic Number,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Decode_DICT_PROTO_STRING_BYTEARRAYHASHSET,The following statement contains a magic number: while (i < encB.Length)              {                  el = encB[i];                    switch (mode)                  {                      case 0:                            if ((el & 0x80) > 0)                          {                              sizer[size] = el;                              size++;                          }                          else                          {                              hc = 0;                              mode = 1;                              sizer[size] = el;                              size++;                              keyLength = ToUInt32(sizer);                              key = System.Text.Encoding.UTF8.GetString(encB.Substring(i + 1' (int)keyLength));                              i += (int)keyLength + 1;                              ClearSizer();                              continue;                          }                            break;                      case 1:                          //HashSet Count                          if ((el & 0x80) > 0)                          {                              sizer[size] = el;                              size++;                          }                          else                          {                              mode = 2;                              sizer[size] = el;                              size++;                              valCnt = ToUInt32(sizer);                              ClearSizer();                                if (valCnt == 0)                              {                                  retD.Add(key' new List<byte[]>());                                  mode = 0;                              }                          }                          break;                      case 2:                          if ((el & 0x80) > 0)                          {                              sizer[size] = el;                              size++;                          }                          else                          {                              sizer[size] = el;                              size++;                              if (hc == 0)                                  mhs = new List<byte[]>();                              lenBa = ToUInt32(sizer);                              mhs.Add(encB.Substring(i + 1' (int)lenBa));                              i += (int)lenBa + 1;                              hc++;                              ClearSizer();                                if (valCnt == hc)                              {                                  mode = 0;                                  retD.Add(key' mhs);                              }                              continue;                            }                          break;                  }                  i++;              }
Magic Number,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Decode_DICT_PROTO_STRING_BYTEARRAYHASHSET,The following statement contains a magic number: while (i < encB.Length)              {                  el = encB[i];                    switch (mode)                  {                      case 0:                            if ((el & 0x80) > 0)                          {                              sizer[size] = el;                              size++;                          }                          else                          {                              hc = 0;                              mode = 1;                              sizer[size] = el;                              size++;                              keyLength = ToUInt32(sizer);                              key = System.Text.Encoding.UTF8.GetString(encB.Substring(i + 1' (int)keyLength));                              i += (int)keyLength + 1;                              ClearSizer();                              continue;                          }                            break;                      case 1:                          //HashSet Count                          if ((el & 0x80) > 0)                          {                              sizer[size] = el;                              size++;                          }                          else                          {                              mode = 2;                              sizer[size] = el;                              size++;                              valCnt = ToUInt32(sizer);                              ClearSizer();                                if (valCnt == 0)                              {                                  retD.Add(key' new List<byte[]>());                                  mode = 0;                              }                          }                          break;                      case 2:                          if ((el & 0x80) > 0)                          {                              sizer[size] = el;                              size++;                          }                          else                          {                              sizer[size] = el;                              size++;                              if (hc == 0)                                  mhs = new List<byte[]>();                              lenBa = ToUInt32(sizer);                              mhs.Add(encB.Substring(i + 1' (int)lenBa));                              i += (int)lenBa + 1;                              hc++;                              ClearSizer();                                if (valCnt == hc)                              {                                  mode = 0;                                  retD.Add(key' mhs);                              }                              continue;                            }                          break;                  }                  i++;              }
Magic Number,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Decode_DICT_PROTO_STRING_UINTHASHSET,The following statement contains a magic number: byte[] sizer = new byte[4];
Magic Number,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Decode_DICT_PROTO_STRING_UINTHASHSET,The following statement contains a magic number: Action ClearSizer = () =>              {                  sizer[0] = 0;                  sizer[1] = 0;                  sizer[2] = 0;                  sizer[3] = 0;                    size = 0;              };
Magic Number,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Decode_DICT_PROTO_STRING_UINTHASHSET,The following statement contains a magic number: Action ClearSizer = () =>              {                  sizer[0] = 0;                  sizer[1] = 0;                  sizer[2] = 0;                  sizer[3] = 0;                    size = 0;              };
Magic Number,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Decode_DICT_PROTO_STRING_UINTHASHSET,The following statement contains a magic number: while (i < encB.Length)              {                  el = encB[i];                    switch (mode)                  {                      case 0:                            if ((el & 0x80) > 0)                          {                              sizer[size] = el;                              size++;                          }                          else                          {                              hc = 0;                              mode = 1;                              sizer[size] = el;                              size++;                              keyLength = ToUInt32(sizer);                              key = System.Text.Encoding.UTF8.GetString(encB.Substring(i + 1' (int)keyLength));                              i += (int)keyLength + 1;                              ClearSizer();                              continue;                          }                            break;                      case 1:                          //HashSet Count                          if ((el & 0x80) > 0)                          {                              sizer[size] = el;                              size++;                          }                          else                          {                              mode = 2;                              sizer[size] = el;                              size++;                              valCnt = ToUInt32(sizer);                              ClearSizer();                                if (valCnt == 0)                              {                                  retD.Add(key' new HashSet<uint>());                                  mode = 0;                              }                          }                          break;                      case 2:                          if ((el & 0x80) > 0)                          {                              sizer[size] = el;                              size++;                          }                          else                          {                              sizer[size] = el;                              size++;                              if (hc == 0)                                  mhs = new HashSet<uint>();                              mhs.Add(ToUInt32(sizer));                              hc++;                              ClearSizer();                                if (valCnt == hc)                              {                                  mode = 0;                                  retD.Add(key' mhs);                              }                          }                          break;                  }                  i++;              }
Magic Number,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Decode_DICT_PROTO_STRING_UINTHASHSET,The following statement contains a magic number: while (i < encB.Length)              {                  el = encB[i];                    switch (mode)                  {                      case 0:                            if ((el & 0x80) > 0)                          {                              sizer[size] = el;                              size++;                          }                          else                          {                              hc = 0;                              mode = 1;                              sizer[size] = el;                              size++;                              keyLength = ToUInt32(sizer);                              key = System.Text.Encoding.UTF8.GetString(encB.Substring(i + 1' (int)keyLength));                              i += (int)keyLength + 1;                              ClearSizer();                              continue;                          }                            break;                      case 1:                          //HashSet Count                          if ((el & 0x80) > 0)                          {                              sizer[size] = el;                              size++;                          }                          else                          {                              mode = 2;                              sizer[size] = el;                              size++;                              valCnt = ToUInt32(sizer);                              ClearSizer();                                if (valCnt == 0)                              {                                  retD.Add(key' new HashSet<uint>());                                  mode = 0;                              }                          }                          break;                      case 2:                          if ((el & 0x80) > 0)                          {                              sizer[size] = el;                              size++;                          }                          else                          {                              sizer[size] = el;                              size++;                              if (hc == 0)                                  mhs = new HashSet<uint>();                              mhs.Add(ToUInt32(sizer));                              hc++;                              ClearSizer();                                if (valCnt == hc)                              {                                  mode = 0;                                  retD.Add(key' mhs);                              }                          }                          break;                  }                  i++;              }
Magic Number,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Decode_DICT_PROTO_UINT_BYTEARRAY,The following statement contains a magic number: byte[] sizer = new byte[4];
Magic Number,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Decode_DICT_PROTO_UINT_BYTEARRAY,The following statement contains a magic number: Action ClearSizer = () =>              {                  sizer[0] = 0;                  sizer[1] = 0;                  sizer[2] = 0;                  sizer[3] = 0;                    size = 0;              };
Magic Number,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Decode_DICT_PROTO_UINT_BYTEARRAY,The following statement contains a magic number: Action ClearSizer = () =>              {                  sizer[0] = 0;                  sizer[1] = 0;                  sizer[2] = 0;                  sizer[3] = 0;                    size = 0;              };
Magic Number,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Decode_DICT_PROTO_UINT_BYTEARRAY,The following statement contains a magic number: foreach (byte el in encB)              {                  switch (mode)                  {                      case 0:                          //Key' Size of BT //                          if ((el & 0x80) > 0)                          {                              sizer[size] = el;                              size++;                          }                          else                          {                              mode = 1;                              sizer[size] = el;                              size++;                              key = ToUInt32(sizer);                              ClearSizer();                          }                            break;                      case 1:                          //Value Size                          if ((el & 0x80) > 0)                          {                              sizer[size] = el;                              size++;                          }                          else                          {                              mode = 2;                              sizer[size] = el;                              size++;                              valLen = ToUInt32(sizer);                              ClearSizer();                                if (valLen == 0)                              {                                  retD.Add(key' null);                                  mode = 0;                                  break;                              }                                val = new byte[valLen];                              valCnt = 0;                          }                          break;                      case 2:                          val[valCnt] = el;                          valCnt++;                          if (valCnt == valLen)                          {                              retD.Add(key' val);                              mode = 0;                              break;                          }                          break;                  }              }
Magic Number,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Decode_DICT_PROTO_UINT_BYTEARRAY,The following statement contains a magic number: foreach (byte el in encB)              {                  switch (mode)                  {                      case 0:                          //Key' Size of BT //                          if ((el & 0x80) > 0)                          {                              sizer[size] = el;                              size++;                          }                          else                          {                              mode = 1;                              sizer[size] = el;                              size++;                              key = ToUInt32(sizer);                              ClearSizer();                          }                            break;                      case 1:                          //Value Size                          if ((el & 0x80) > 0)                          {                              sizer[size] = el;                              size++;                          }                          else                          {                              mode = 2;                              sizer[size] = el;                              size++;                              valLen = ToUInt32(sizer);                              ClearSizer();                                if (valLen == 0)                              {                                  retD.Add(key' null);                                  mode = 0;                                  break;                              }                                val = new byte[valLen];                              valCnt = 0;                          }                          break;                      case 2:                          val[valCnt] = el;                          valCnt++;                          if (valCnt == valLen)                          {                              retD.Add(key' val);                              mode = 0;                              break;                          }                          break;                  }              }
Magic Number,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,GetVarintBytes,The following statement contains a magic number: var buffer = new byte[10];
Magic Number,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,GetVarintBytes,The following statement contains a magic number: do              {                  var byteVal = value & 0x7f;                  value >>= 7;                    if (value != 0)                  {                      byteVal |= 0x80;                  }                    buffer[pos++] = (byte)byteVal;                } while (value != 0);
Magic Number,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,ToUInt32,The following statement contains a magic number: return (uint)ToTarget(bytes' 32);
Magic Number,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,ToTarget,The following statement contains a magic number: foreach (ulong byteValue in bytes)              {                  ulong tmp = byteValue & 0x7f;                  result |= tmp << shift;                    if (shift > sizeBites)                  {                      throw new ArgumentOutOfRangeException("bytes"' "Byte array is too large.");                  }                    if ((byteValue & 0x80) != 0x80)                  {                      return result;                  }                    shift += 7;              }
Magic Number,DBreeze.Utils,Filter<T>,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BloomFilter.cs,bestK,The following statement contains a magic number: return (int)Math.Round(Math.Log(2.0) * bestM(capacity' errorRate) / capacity);
Magic Number,DBreeze.Utils,Filter<T>,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BloomFilter.cs,bestM,The following statement contains a magic number: return (int)Math.Ceiling(capacity * Math.Log(errorRate' (1.0 / Math.Pow(2' Math.Log(2.0)))));
Magic Number,DBreeze.Utils,Filter<T>,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BloomFilter.cs,bestM,The following statement contains a magic number: return (int)Math.Ceiling(capacity * Math.Log(errorRate' (1.0 / Math.Pow(2' Math.Log(2.0)))));
Magic Number,DBreeze.Utils,Filter<T>,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BloomFilter.cs,bestErrorRate,The following statement contains a magic number: if (c != 0)                      return c;                  else                      return (float)Math.Pow(0.6185' int.MaxValue / capacity);
Magic Number,DBreeze.Utils,Filter<T>,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BloomFilter.cs,hashInt32,The following statement contains a magic number: unchecked                  {                      x = ~x + (x << 15); // x = (x << 15) - x- 1' as (~x) + y is equivalent to y - x - 1 in two's complement representation                      x = x ^ (x >> 12);                      x = x + (x << 2);                      x = x ^ (x >> 4);                      x = x * 2057; // x = (x + (x << 3)) + (x<< 11);                      x = x ^ (x >> 16);                      return (int)x;                  }
Magic Number,DBreeze.Utils,Filter<T>,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BloomFilter.cs,hashInt32,The following statement contains a magic number: unchecked                  {                      x = ~x + (x << 15); // x = (x << 15) - x- 1' as (~x) + y is equivalent to y - x - 1 in two's complement representation                      x = x ^ (x >> 12);                      x = x + (x << 2);                      x = x ^ (x >> 4);                      x = x * 2057; // x = (x + (x << 3)) + (x<< 11);                      x = x ^ (x >> 16);                      return (int)x;                  }
Magic Number,DBreeze.Utils,Filter<T>,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BloomFilter.cs,hashInt32,The following statement contains a magic number: unchecked                  {                      x = ~x + (x << 15); // x = (x << 15) - x- 1' as (~x) + y is equivalent to y - x - 1 in two's complement representation                      x = x ^ (x >> 12);                      x = x + (x << 2);                      x = x ^ (x >> 4);                      x = x * 2057; // x = (x + (x << 3)) + (x<< 11);                      x = x ^ (x >> 16);                      return (int)x;                  }
Magic Number,DBreeze.Utils,Filter<T>,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BloomFilter.cs,hashInt32,The following statement contains a magic number: unchecked                  {                      x = ~x + (x << 15); // x = (x << 15) - x- 1' as (~x) + y is equivalent to y - x - 1 in two's complement representation                      x = x ^ (x >> 12);                      x = x + (x << 2);                      x = x ^ (x >> 4);                      x = x * 2057; // x = (x + (x << 3)) + (x<< 11);                      x = x ^ (x >> 16);                      return (int)x;                  }
Magic Number,DBreeze.Utils,Filter<T>,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BloomFilter.cs,hashInt32,The following statement contains a magic number: unchecked                  {                      x = ~x + (x << 15); // x = (x << 15) - x- 1' as (~x) + y is equivalent to y - x - 1 in two's complement representation                      x = x ^ (x >> 12);                      x = x + (x << 2);                      x = x ^ (x >> 4);                      x = x * 2057; // x = (x + (x << 3)) + (x<< 11);                      x = x ^ (x >> 16);                      return (int)x;                  }
Magic Number,DBreeze.Utils,Filter<T>,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BloomFilter.cs,hashInt32,The following statement contains a magic number: unchecked                  {                      x = ~x + (x << 15); // x = (x << 15) - x- 1' as (~x) + y is equivalent to y - x - 1 in two's complement representation                      x = x ^ (x >> 12);                      x = x + (x << 2);                      x = x ^ (x >> 4);                      x = x * 2057; // x = (x + (x << 3)) + (x<< 11);                      x = x ^ (x >> 16);                      return (int)x;                  }
Magic Number,DBreeze.Utils,Filter<T>,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BloomFilter.cs,hashString,The following statement contains a magic number: for (int i = 0; i < s.Length; i++)                  {                      hash += s[i];                      hash += (hash << 10);                      hash ^= (hash >> 6);                  }
Magic Number,DBreeze.Utils,Filter<T>,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BloomFilter.cs,hashString,The following statement contains a magic number: for (int i = 0; i < s.Length; i++)                  {                      hash += s[i];                      hash += (hash << 10);                      hash ^= (hash >> 6);                  }
Magic Number,DBreeze.Utils,Filter<T>,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BloomFilter.cs,hashString,The following statement contains a magic number: hash += (hash << 3);
Magic Number,DBreeze.Utils,Filter<T>,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BloomFilter.cs,hashString,The following statement contains a magic number: hash ^= (hash >> 11);
Magic Number,DBreeze.Utils,Filter<T>,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BloomFilter.cs,hashString,The following statement contains a magic number: hash += (hash << 15);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToIndex,The following statement contains a magic number: if (indexNumber < 1 || indexNumber > 255)                  throw new Exception("DBreezeIndex: 1-255 is an allowed index region!");
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Byte_NULL,The following statement contains a magic number: if (value == null || value.Length != 2 || value[0] == 0)                  return null;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_DateTime_NULL,The following statement contains a magic number: if (value == null || value.Length != 9 || value[0] == 0)                  return null;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_DateTime_NULL,The following statement contains a magic number: return new DateTime((long)(new byte[] { value[1]' value[2]' value[3]' value[4]' value[5]' value[6]' value[7]' value[8] }.To_UInt64_BigEndian()));
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_DateTime_NULL,The following statement contains a magic number: return new DateTime((long)(new byte[] { value[1]' value[2]' value[3]' value[4]' value[5]' value[6]' value[7]' value[8] }.To_UInt64_BigEndian()));
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_DateTime_NULL,The following statement contains a magic number: return new DateTime((long)(new byte[] { value[1]' value[2]' value[3]' value[4]' value[5]' value[6]' value[7]' value[8] }.To_UInt64_BigEndian()));
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_DateTime_NULL,The following statement contains a magic number: return new DateTime((long)(new byte[] { value[1]' value[2]' value[3]' value[4]' value[5]' value[6]' value[7]' value[8] }.To_UInt64_BigEndian()));
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_DateTime_NULL,The following statement contains a magic number: return new DateTime((long)(new byte[] { value[1]' value[2]' value[3]' value[4]' value[5]' value[6]' value[7]' value[8] }.To_UInt64_BigEndian()));
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_DateTime_NULL,The following statement contains a magic number: return new DateTime((long)(new byte[] { value[1]' value[2]' value[3]' value[4]' value[5]' value[6]' value[7]' value[8] }.To_UInt64_BigEndian()));
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_DateTime_NULL,The following statement contains a magic number: return new DateTime((long)(new byte[] { value[1]' value[2]' value[3]' value[4]' value[5]' value[6]' value[7]' value[8] }.To_UInt64_BigEndian()));
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Bool_NULL,The following statement contains a magic number: if (value == null || value.Length != 1 || value[0] == 2)                  return null;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Char_NULL,The following statement contains a magic number: if (value == null || value.Length != 3 || value[0] == 0)                  return null;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Char_NULL,The following statement contains a magic number: return (System.Text.Encoding.Unicode.GetChars(new byte[] {value[1]'value[2]})[0]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_SByte_NULL,The following statement contains a magic number: if (value == null || value.Length != 2 || value[0] == 0)                  return null;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int16_BigEndian_NULL,The following statement contains a magic number: if (value == null || value.Length != 3 || value[0] == 0)                  return null;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int16_LittleEndian_NULL,The following statement contains a magic number: if (value == null || value.Length != 3 || value[0] == 0)                  return null;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt16_BigEndian,The following statement contains a magic number: return (ushort)(value[0] << 8 | value[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt16_LittleEndian,The following statement contains a magic number: return (ushort)(value[1] << 8 | value[0]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt16_BigEndian_NULL,The following statement contains a magic number: if (value == null || value.Length != 3 || value[0] == 0)                  return null;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt16_BigEndian_NULL,The following statement contains a magic number: return (ushort)(value[1] << 8 | value[2]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt16_BigEndian_NULL,The following statement contains a magic number: return (ushort)(value[1] << 8 | value[2]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt16_LittleEndian_NULL,The following statement contains a magic number: if (value == null || value.Length != 3 || value[0] == 0)                  return null;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt16_LittleEndian_NULL,The following statement contains a magic number: return (ushort)(value[2] << 8 | value[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt16_LittleEndian_NULL,The following statement contains a magic number: return (ushort)(value[2] << 8 | value[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int32_BigEndian_NULL,The following statement contains a magic number: if (value == null || value.Length != 5 || value[0] == 0)                  return null;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int32_BigEndian_NULL,The following statement contains a magic number: return (int?)((new byte[] { value[1]' value[2]' value[3]' value[4] }).To_UInt32_BigEndian() + int.MinValue);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int32_BigEndian_NULL,The following statement contains a magic number: return (int?)((new byte[] { value[1]' value[2]' value[3]' value[4] }).To_UInt32_BigEndian() + int.MinValue);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int32_BigEndian_NULL,The following statement contains a magic number: return (int?)((new byte[] { value[1]' value[2]' value[3]' value[4] }).To_UInt32_BigEndian() + int.MinValue);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int32_LittleEndian_NULL,The following statement contains a magic number: if (value == null || value.Length != 5 || value[0] == 0)                  return null;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int32_LittleEndian_NULL,The following statement contains a magic number: return (int?)((new byte[] {value[1]'value[2]'value[3]'value[4]}).To_UInt32_LittleEndian() + int.MinValue);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int32_LittleEndian_NULL,The following statement contains a magic number: return (int?)((new byte[] {value[1]'value[2]'value[3]'value[4]}).To_UInt32_LittleEndian() + int.MinValue);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int32_LittleEndian_NULL,The following statement contains a magic number: return (int?)((new byte[] {value[1]'value[2]'value[3]'value[4]}).To_UInt32_LittleEndian() + int.MinValue);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt32_BigEndian,The following statement contains a magic number: return (uint)(value[0] << 24 | value[1] << 16 | value[2] << 8 | value[3]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt32_BigEndian,The following statement contains a magic number: return (uint)(value[0] << 24 | value[1] << 16 | value[2] << 8 | value[3]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt32_BigEndian,The following statement contains a magic number: return (uint)(value[0] << 24 | value[1] << 16 | value[2] << 8 | value[3]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt32_BigEndian,The following statement contains a magic number: return (uint)(value[0] << 24 | value[1] << 16 | value[2] << 8 | value[3]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt32_BigEndian,The following statement contains a magic number: return (uint)(value[0] << 24 | value[1] << 16 | value[2] << 8 | value[3]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt32_LittleEndian,The following statement contains a magic number: return (uint)(value[3] << 24 | value[2] << 16 | value[1] << 8 | value[0]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt32_LittleEndian,The following statement contains a magic number: return (uint)(value[3] << 24 | value[2] << 16 | value[1] << 8 | value[0]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt32_LittleEndian,The following statement contains a magic number: return (uint)(value[3] << 24 | value[2] << 16 | value[1] << 8 | value[0]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt32_LittleEndian,The following statement contains a magic number: return (uint)(value[3] << 24 | value[2] << 16 | value[1] << 8 | value[0]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt32_LittleEndian,The following statement contains a magic number: return (uint)(value[3] << 24 | value[2] << 16 | value[1] << 8 | value[0]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt32_BigEndian_NULL,The following statement contains a magic number: if (value == null || value.Length != 5 || value[0] == 0)                  return null;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt32_BigEndian_NULL,The following statement contains a magic number: return (uint)(value[1] << 24 | value[2] << 16 | value[3] << 8 | value[4]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt32_BigEndian_NULL,The following statement contains a magic number: return (uint)(value[1] << 24 | value[2] << 16 | value[3] << 8 | value[4]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt32_BigEndian_NULL,The following statement contains a magic number: return (uint)(value[1] << 24 | value[2] << 16 | value[3] << 8 | value[4]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt32_BigEndian_NULL,The following statement contains a magic number: return (uint)(value[1] << 24 | value[2] << 16 | value[3] << 8 | value[4]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt32_BigEndian_NULL,The following statement contains a magic number: return (uint)(value[1] << 24 | value[2] << 16 | value[3] << 8 | value[4]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt32_BigEndian_NULL,The following statement contains a magic number: return (uint)(value[1] << 24 | value[2] << 16 | value[3] << 8 | value[4]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt32_LittleEndian_NULL,The following statement contains a magic number: if (value == null || value.Length != 5 || value[0] == 0)                  return null;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt32_LittleEndian_NULL,The following statement contains a magic number: return (uint)(value[4] << 24 | value[3] << 16 | value[2] << 8 | value[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt32_LittleEndian_NULL,The following statement contains a magic number: return (uint)(value[4] << 24 | value[3] << 16 | value[2] << 8 | value[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt32_LittleEndian_NULL,The following statement contains a magic number: return (uint)(value[4] << 24 | value[3] << 16 | value[2] << 8 | value[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt32_LittleEndian_NULL,The following statement contains a magic number: return (uint)(value[4] << 24 | value[3] << 16 | value[2] << 8 | value[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt32_LittleEndian_NULL,The following statement contains a magic number: return (uint)(value[4] << 24 | value[3] << 16 | value[2] << 8 | value[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt32_LittleEndian_NULL,The following statement contains a magic number: return (uint)(value[4] << 24 | value[3] << 16 | value[2] << 8 | value[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int64_BigEndian_NULL,The following statement contains a magic number: if (value == null || value.Length != 9 || value[0] == 0)                  return null;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int64_BigEndian_NULL,The following statement contains a magic number: return (long?)((new byte[] { value[1]' value[2]' value[3]' value[4]' value[5]' value[6]' value[7]' value[8] }).To_UInt64_BigEndian() - (ulong)Math.Abs(long.MinValue + 1) - 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int64_BigEndian_NULL,The following statement contains a magic number: return (long?)((new byte[] { value[1]' value[2]' value[3]' value[4]' value[5]' value[6]' value[7]' value[8] }).To_UInt64_BigEndian() - (ulong)Math.Abs(long.MinValue + 1) - 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int64_BigEndian_NULL,The following statement contains a magic number: return (long?)((new byte[] { value[1]' value[2]' value[3]' value[4]' value[5]' value[6]' value[7]' value[8] }).To_UInt64_BigEndian() - (ulong)Math.Abs(long.MinValue + 1) - 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int64_BigEndian_NULL,The following statement contains a magic number: return (long?)((new byte[] { value[1]' value[2]' value[3]' value[4]' value[5]' value[6]' value[7]' value[8] }).To_UInt64_BigEndian() - (ulong)Math.Abs(long.MinValue + 1) - 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int64_BigEndian_NULL,The following statement contains a magic number: return (long?)((new byte[] { value[1]' value[2]' value[3]' value[4]' value[5]' value[6]' value[7]' value[8] }).To_UInt64_BigEndian() - (ulong)Math.Abs(long.MinValue + 1) - 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int64_BigEndian_NULL,The following statement contains a magic number: return (long?)((new byte[] { value[1]' value[2]' value[3]' value[4]' value[5]' value[6]' value[7]' value[8] }).To_UInt64_BigEndian() - (ulong)Math.Abs(long.MinValue + 1) - 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int64_BigEndian_NULL,The following statement contains a magic number: return (long?)((new byte[] { value[1]' value[2]' value[3]' value[4]' value[5]' value[6]' value[7]' value[8] }).To_UInt64_BigEndian() - (ulong)Math.Abs(long.MinValue + 1) - 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int64_LittleEndian_NULL,The following statement contains a magic number: if (value == null || value.Length != 9 || value[0] == 0)                  return null;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int64_LittleEndian_NULL,The following statement contains a magic number: return (long?)((new byte[] { value[1]' value[2]' value[3]' value[4]' value[5]' value[6]' value[7]' value[8]}).To_UInt64_LittleEndian() - (ulong)Math.Abs(long.MinValue + 1) - 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int64_LittleEndian_NULL,The following statement contains a magic number: return (long?)((new byte[] { value[1]' value[2]' value[3]' value[4]' value[5]' value[6]' value[7]' value[8]}).To_UInt64_LittleEndian() - (ulong)Math.Abs(long.MinValue + 1) - 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int64_LittleEndian_NULL,The following statement contains a magic number: return (long?)((new byte[] { value[1]' value[2]' value[3]' value[4]' value[5]' value[6]' value[7]' value[8]}).To_UInt64_LittleEndian() - (ulong)Math.Abs(long.MinValue + 1) - 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int64_LittleEndian_NULL,The following statement contains a magic number: return (long?)((new byte[] { value[1]' value[2]' value[3]' value[4]' value[5]' value[6]' value[7]' value[8]}).To_UInt64_LittleEndian() - (ulong)Math.Abs(long.MinValue + 1) - 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int64_LittleEndian_NULL,The following statement contains a magic number: return (long?)((new byte[] { value[1]' value[2]' value[3]' value[4]' value[5]' value[6]' value[7]' value[8]}).To_UInt64_LittleEndian() - (ulong)Math.Abs(long.MinValue + 1) - 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int64_LittleEndian_NULL,The following statement contains a magic number: return (long?)((new byte[] { value[1]' value[2]' value[3]' value[4]' value[5]' value[6]' value[7]' value[8]}).To_UInt64_LittleEndian() - (ulong)Math.Abs(long.MinValue + 1) - 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Int64_LittleEndian_NULL,The following statement contains a magic number: return (long?)((new byte[] { value[1]' value[2]' value[3]' value[4]' value[5]' value[6]' value[7]' value[8]}).To_UInt64_LittleEndian() - (ulong)Math.Abs(long.MinValue + 1) - 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,DynamicLength_To_UInt64_BigEndian,The following statement contains a magic number: for (int i = 0; i < vl; i++)              {                  res += (ulong)value[i] << ((vl - 1 - i) * 8);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian,The following statement contains a magic number: return (ulong)(((ulong)value[0] << 56) + ((ulong)value[1] << 48) + ((ulong)value[2] << 40) + ((ulong)value[3] << 32) + ((ulong)value[4] << 24) + ((ulong)value[5] << 16) + ((ulong)value[6] << 8) + (ulong)value[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian,The following statement contains a magic number: return (ulong)(((ulong)value[0] << 56) + ((ulong)value[1] << 48) + ((ulong)value[2] << 40) + ((ulong)value[3] << 32) + ((ulong)value[4] << 24) + ((ulong)value[5] << 16) + ((ulong)value[6] << 8) + (ulong)value[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian,The following statement contains a magic number: return (ulong)(((ulong)value[0] << 56) + ((ulong)value[1] << 48) + ((ulong)value[2] << 40) + ((ulong)value[3] << 32) + ((ulong)value[4] << 24) + ((ulong)value[5] << 16) + ((ulong)value[6] << 8) + (ulong)value[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian,The following statement contains a magic number: return (ulong)(((ulong)value[0] << 56) + ((ulong)value[1] << 48) + ((ulong)value[2] << 40) + ((ulong)value[3] << 32) + ((ulong)value[4] << 24) + ((ulong)value[5] << 16) + ((ulong)value[6] << 8) + (ulong)value[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian,The following statement contains a magic number: return (ulong)(((ulong)value[0] << 56) + ((ulong)value[1] << 48) + ((ulong)value[2] << 40) + ((ulong)value[3] << 32) + ((ulong)value[4] << 24) + ((ulong)value[5] << 16) + ((ulong)value[6] << 8) + (ulong)value[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian,The following statement contains a magic number: return (ulong)(((ulong)value[0] << 56) + ((ulong)value[1] << 48) + ((ulong)value[2] << 40) + ((ulong)value[3] << 32) + ((ulong)value[4] << 24) + ((ulong)value[5] << 16) + ((ulong)value[6] << 8) + (ulong)value[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian,The following statement contains a magic number: return (ulong)(((ulong)value[0] << 56) + ((ulong)value[1] << 48) + ((ulong)value[2] << 40) + ((ulong)value[3] << 32) + ((ulong)value[4] << 24) + ((ulong)value[5] << 16) + ((ulong)value[6] << 8) + (ulong)value[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian,The following statement contains a magic number: return (ulong)(((ulong)value[0] << 56) + ((ulong)value[1] << 48) + ((ulong)value[2] << 40) + ((ulong)value[3] << 32) + ((ulong)value[4] << 24) + ((ulong)value[5] << 16) + ((ulong)value[6] << 8) + (ulong)value[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian,The following statement contains a magic number: return (ulong)(((ulong)value[0] << 56) + ((ulong)value[1] << 48) + ((ulong)value[2] << 40) + ((ulong)value[3] << 32) + ((ulong)value[4] << 24) + ((ulong)value[5] << 16) + ((ulong)value[6] << 8) + (ulong)value[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian,The following statement contains a magic number: return (ulong)(((ulong)value[0] << 56) + ((ulong)value[1] << 48) + ((ulong)value[2] << 40) + ((ulong)value[3] << 32) + ((ulong)value[4] << 24) + ((ulong)value[5] << 16) + ((ulong)value[6] << 8) + (ulong)value[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian,The following statement contains a magic number: return (ulong)(((ulong)value[0] << 56) + ((ulong)value[1] << 48) + ((ulong)value[2] << 40) + ((ulong)value[3] << 32) + ((ulong)value[4] << 24) + ((ulong)value[5] << 16) + ((ulong)value[6] << 8) + (ulong)value[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian,The following statement contains a magic number: return (ulong)(((ulong)value[0] << 56) + ((ulong)value[1] << 48) + ((ulong)value[2] << 40) + ((ulong)value[3] << 32) + ((ulong)value[4] << 24) + ((ulong)value[5] << 16) + ((ulong)value[6] << 8) + (ulong)value[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian,The following statement contains a magic number: return (ulong)(((ulong)value[0] << 56) + ((ulong)value[1] << 48) + ((ulong)value[2] << 40) + ((ulong)value[3] << 32) + ((ulong)value[4] << 24) + ((ulong)value[5] << 16) + ((ulong)value[6] << 8) + (ulong)value[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian,The following statement contains a magic number: return (ulong)(((ulong)value[7] << 56) + ((ulong)value[6] << 48) + ((ulong)value[5] << 40) + ((ulong)value[4] << 32) + ((ulong)value[3] << 24) + ((ulong)value[2] << 16) + ((ulong)value[1] << 8) + (ulong)value[0]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian,The following statement contains a magic number: return (ulong)(((ulong)value[7] << 56) + ((ulong)value[6] << 48) + ((ulong)value[5] << 40) + ((ulong)value[4] << 32) + ((ulong)value[3] << 24) + ((ulong)value[2] << 16) + ((ulong)value[1] << 8) + (ulong)value[0]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian,The following statement contains a magic number: return (ulong)(((ulong)value[7] << 56) + ((ulong)value[6] << 48) + ((ulong)value[5] << 40) + ((ulong)value[4] << 32) + ((ulong)value[3] << 24) + ((ulong)value[2] << 16) + ((ulong)value[1] << 8) + (ulong)value[0]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian,The following statement contains a magic number: return (ulong)(((ulong)value[7] << 56) + ((ulong)value[6] << 48) + ((ulong)value[5] << 40) + ((ulong)value[4] << 32) + ((ulong)value[3] << 24) + ((ulong)value[2] << 16) + ((ulong)value[1] << 8) + (ulong)value[0]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian,The following statement contains a magic number: return (ulong)(((ulong)value[7] << 56) + ((ulong)value[6] << 48) + ((ulong)value[5] << 40) + ((ulong)value[4] << 32) + ((ulong)value[3] << 24) + ((ulong)value[2] << 16) + ((ulong)value[1] << 8) + (ulong)value[0]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian,The following statement contains a magic number: return (ulong)(((ulong)value[7] << 56) + ((ulong)value[6] << 48) + ((ulong)value[5] << 40) + ((ulong)value[4] << 32) + ((ulong)value[3] << 24) + ((ulong)value[2] << 16) + ((ulong)value[1] << 8) + (ulong)value[0]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian,The following statement contains a magic number: return (ulong)(((ulong)value[7] << 56) + ((ulong)value[6] << 48) + ((ulong)value[5] << 40) + ((ulong)value[4] << 32) + ((ulong)value[3] << 24) + ((ulong)value[2] << 16) + ((ulong)value[1] << 8) + (ulong)value[0]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian,The following statement contains a magic number: return (ulong)(((ulong)value[7] << 56) + ((ulong)value[6] << 48) + ((ulong)value[5] << 40) + ((ulong)value[4] << 32) + ((ulong)value[3] << 24) + ((ulong)value[2] << 16) + ((ulong)value[1] << 8) + (ulong)value[0]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian,The following statement contains a magic number: return (ulong)(((ulong)value[7] << 56) + ((ulong)value[6] << 48) + ((ulong)value[5] << 40) + ((ulong)value[4] << 32) + ((ulong)value[3] << 24) + ((ulong)value[2] << 16) + ((ulong)value[1] << 8) + (ulong)value[0]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian,The following statement contains a magic number: return (ulong)(((ulong)value[7] << 56) + ((ulong)value[6] << 48) + ((ulong)value[5] << 40) + ((ulong)value[4] << 32) + ((ulong)value[3] << 24) + ((ulong)value[2] << 16) + ((ulong)value[1] << 8) + (ulong)value[0]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian,The following statement contains a magic number: return (ulong)(((ulong)value[7] << 56) + ((ulong)value[6] << 48) + ((ulong)value[5] << 40) + ((ulong)value[4] << 32) + ((ulong)value[3] << 24) + ((ulong)value[2] << 16) + ((ulong)value[1] << 8) + (ulong)value[0]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian,The following statement contains a magic number: return (ulong)(((ulong)value[7] << 56) + ((ulong)value[6] << 48) + ((ulong)value[5] << 40) + ((ulong)value[4] << 32) + ((ulong)value[3] << 24) + ((ulong)value[2] << 16) + ((ulong)value[1] << 8) + (ulong)value[0]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian,The following statement contains a magic number: return (ulong)(((ulong)value[7] << 56) + ((ulong)value[6] << 48) + ((ulong)value[5] << 40) + ((ulong)value[4] << 32) + ((ulong)value[3] << 24) + ((ulong)value[2] << 16) + ((ulong)value[1] << 8) + (ulong)value[0]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian_NULL,The following statement contains a magic number: if (value == null || value.Length != 9 || value[0] == 0)                  return null;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[1] << 56) + ((ulong)value[2] << 48) + ((ulong)value[3] << 40) + ((ulong)value[4] << 32) + ((ulong)value[5] << 24) + ((ulong)value[6] << 16) + ((ulong)value[7] << 8) + (ulong)value[8]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[1] << 56) + ((ulong)value[2] << 48) + ((ulong)value[3] << 40) + ((ulong)value[4] << 32) + ((ulong)value[5] << 24) + ((ulong)value[6] << 16) + ((ulong)value[7] << 8) + (ulong)value[8]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[1] << 56) + ((ulong)value[2] << 48) + ((ulong)value[3] << 40) + ((ulong)value[4] << 32) + ((ulong)value[5] << 24) + ((ulong)value[6] << 16) + ((ulong)value[7] << 8) + (ulong)value[8]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[1] << 56) + ((ulong)value[2] << 48) + ((ulong)value[3] << 40) + ((ulong)value[4] << 32) + ((ulong)value[5] << 24) + ((ulong)value[6] << 16) + ((ulong)value[7] << 8) + (ulong)value[8]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[1] << 56) + ((ulong)value[2] << 48) + ((ulong)value[3] << 40) + ((ulong)value[4] << 32) + ((ulong)value[5] << 24) + ((ulong)value[6] << 16) + ((ulong)value[7] << 8) + (ulong)value[8]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[1] << 56) + ((ulong)value[2] << 48) + ((ulong)value[3] << 40) + ((ulong)value[4] << 32) + ((ulong)value[5] << 24) + ((ulong)value[6] << 16) + ((ulong)value[7] << 8) + (ulong)value[8]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[1] << 56) + ((ulong)value[2] << 48) + ((ulong)value[3] << 40) + ((ulong)value[4] << 32) + ((ulong)value[5] << 24) + ((ulong)value[6] << 16) + ((ulong)value[7] << 8) + (ulong)value[8]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[1] << 56) + ((ulong)value[2] << 48) + ((ulong)value[3] << 40) + ((ulong)value[4] << 32) + ((ulong)value[5] << 24) + ((ulong)value[6] << 16) + ((ulong)value[7] << 8) + (ulong)value[8]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[1] << 56) + ((ulong)value[2] << 48) + ((ulong)value[3] << 40) + ((ulong)value[4] << 32) + ((ulong)value[5] << 24) + ((ulong)value[6] << 16) + ((ulong)value[7] << 8) + (ulong)value[8]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[1] << 56) + ((ulong)value[2] << 48) + ((ulong)value[3] << 40) + ((ulong)value[4] << 32) + ((ulong)value[5] << 24) + ((ulong)value[6] << 16) + ((ulong)value[7] << 8) + (ulong)value[8]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[1] << 56) + ((ulong)value[2] << 48) + ((ulong)value[3] << 40) + ((ulong)value[4] << 32) + ((ulong)value[5] << 24) + ((ulong)value[6] << 16) + ((ulong)value[7] << 8) + (ulong)value[8]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[1] << 56) + ((ulong)value[2] << 48) + ((ulong)value[3] << 40) + ((ulong)value[4] << 32) + ((ulong)value[5] << 24) + ((ulong)value[6] << 16) + ((ulong)value[7] << 8) + (ulong)value[8]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[1] << 56) + ((ulong)value[2] << 48) + ((ulong)value[3] << 40) + ((ulong)value[4] << 32) + ((ulong)value[5] << 24) + ((ulong)value[6] << 16) + ((ulong)value[7] << 8) + (ulong)value[8]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_BigEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[1] << 56) + ((ulong)value[2] << 48) + ((ulong)value[3] << 40) + ((ulong)value[4] << 32) + ((ulong)value[5] << 24) + ((ulong)value[6] << 16) + ((ulong)value[7] << 8) + (ulong)value[8]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian_NULL,The following statement contains a magic number: if (value == null || value.Length != 9 || value[0] == 0)                  return null;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[8] << 56) + ((ulong)value[7] << 48) + ((ulong)value[6] << 40) + ((ulong)value[5] << 32) + ((ulong)value[4] << 24) + ((ulong)value[3] << 16) + ((ulong)value[2] << 8) + (ulong)value[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[8] << 56) + ((ulong)value[7] << 48) + ((ulong)value[6] << 40) + ((ulong)value[5] << 32) + ((ulong)value[4] << 24) + ((ulong)value[3] << 16) + ((ulong)value[2] << 8) + (ulong)value[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[8] << 56) + ((ulong)value[7] << 48) + ((ulong)value[6] << 40) + ((ulong)value[5] << 32) + ((ulong)value[4] << 24) + ((ulong)value[3] << 16) + ((ulong)value[2] << 8) + (ulong)value[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[8] << 56) + ((ulong)value[7] << 48) + ((ulong)value[6] << 40) + ((ulong)value[5] << 32) + ((ulong)value[4] << 24) + ((ulong)value[3] << 16) + ((ulong)value[2] << 8) + (ulong)value[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[8] << 56) + ((ulong)value[7] << 48) + ((ulong)value[6] << 40) + ((ulong)value[5] << 32) + ((ulong)value[4] << 24) + ((ulong)value[3] << 16) + ((ulong)value[2] << 8) + (ulong)value[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[8] << 56) + ((ulong)value[7] << 48) + ((ulong)value[6] << 40) + ((ulong)value[5] << 32) + ((ulong)value[4] << 24) + ((ulong)value[3] << 16) + ((ulong)value[2] << 8) + (ulong)value[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[8] << 56) + ((ulong)value[7] << 48) + ((ulong)value[6] << 40) + ((ulong)value[5] << 32) + ((ulong)value[4] << 24) + ((ulong)value[3] << 16) + ((ulong)value[2] << 8) + (ulong)value[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[8] << 56) + ((ulong)value[7] << 48) + ((ulong)value[6] << 40) + ((ulong)value[5] << 32) + ((ulong)value[4] << 24) + ((ulong)value[3] << 16) + ((ulong)value[2] << 8) + (ulong)value[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[8] << 56) + ((ulong)value[7] << 48) + ((ulong)value[6] << 40) + ((ulong)value[5] << 32) + ((ulong)value[4] << 24) + ((ulong)value[3] << 16) + ((ulong)value[2] << 8) + (ulong)value[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[8] << 56) + ((ulong)value[7] << 48) + ((ulong)value[6] << 40) + ((ulong)value[5] << 32) + ((ulong)value[4] << 24) + ((ulong)value[3] << 16) + ((ulong)value[2] << 8) + (ulong)value[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[8] << 56) + ((ulong)value[7] << 48) + ((ulong)value[6] << 40) + ((ulong)value[5] << 32) + ((ulong)value[4] << 24) + ((ulong)value[3] << 16) + ((ulong)value[2] << 8) + (ulong)value[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[8] << 56) + ((ulong)value[7] << 48) + ((ulong)value[6] << 40) + ((ulong)value[5] << 32) + ((ulong)value[4] << 24) + ((ulong)value[3] << 16) + ((ulong)value[2] << 8) + (ulong)value[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[8] << 56) + ((ulong)value[7] << 48) + ((ulong)value[6] << 40) + ((ulong)value[5] << 32) + ((ulong)value[4] << 24) + ((ulong)value[3] << 16) + ((ulong)value[2] << 8) + (ulong)value[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_UInt64_LittleEndian_NULL,The following statement contains a magic number: return (ulong)(((ulong)value[8] << 56) + ((ulong)value[7] << 48) + ((ulong)value[6] << 40) + ((ulong)value[5] << 32) + ((ulong)value[4] << 24) + ((ulong)value[3] << 16) + ((ulong)value[2] << 8) + (ulong)value[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: bool blIsPositive = ((input[0] & 128) > 0);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[9] << 24 | input[10] << 16 | input[11] << 8 | input[12])'                      (int)(input[5] << 24 | input[6] << 16 | input[7] << 8 | input[8])'                      (int)(input[1] << 24 | input[2] << 16 | input[3] << 8 | input[4])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[9]) << 24 | (input[10]) << 16 | (input[11]) << 8 | (input[12])))'                      (int)(~((input[5]) << 24 | (input[6]) << 16 | (input[7]) << 8 | (input[8])))'                      (int)(~((input[1]) << 24 | (input[2]) << 16 | (input[3]) << 8 | (input[4])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: byte lastDigit = (byte)(input[13] >> 3);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: byte lastDigit = (byte)(input[13] >> 3);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: byte numOfDigits = (byte)(input[14] & 0x1F);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: byte scale = (byte)(((input[13] & 0x03) << 3) + (input[14] >> 5));
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: byte scale = (byte)(((input[13] & 0x03) << 3) + (input[14] >> 5));
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: byte scale = (byte)(((input[13] & 0x03) << 3) + (input[14] >> 5));
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: byte scale = (byte)(((input[13] & 0x03) << 3) + (input[14] >> 5));
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (numOfDigits < 28)              {                  decimalValuePart = Math.Floor(decimalValuePart / (decimal)Math.Pow(10' 28 - numOfDigits));              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (numOfDigits < 28)              {                  decimalValuePart = Math.Floor(decimalValuePart / (decimal)Math.Pow(10' 28 - numOfDigits));              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (numOfDigits < 28)              {                  decimalValuePart = Math.Floor(decimalValuePart / (decimal)Math.Pow(10' 28 - numOfDigits));              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (numOfDigits == 29)              {                  decimalValuePart = (decimalValuePart * 10) + lastDigit;              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: if (numOfDigits == 29)              {                  decimalValuePart = (decimalValuePart * 10) + lastDigit;              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: return new decimal(new int[4]               {                  decArray[0]'                  decArray[1]'                  decArray[2]'                  (int)((blIsPositive ? 0 : (1 << 31)) + (scale << 16))              });
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: return new decimal(new int[4]               {                  decArray[0]'                  decArray[1]'                  decArray[2]'                  (int)((blIsPositive ? 0 : (1 << 31)) + (scale << 16))              });
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: return new decimal(new int[4]               {                  decArray[0]'                  decArray[1]'                  decArray[2]'                  (int)((blIsPositive ? 0 : (1 << 31)) + (scale << 16))              });
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian,The following statement contains a magic number: return new decimal(new int[4]               {                  decArray[0]'                  decArray[1]'                  decArray[2]'                  (int)((blIsPositive ? 0 : (1 << 31)) + (scale << 16))              });
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (input == null || input.Length != 16 || input[0] == 0)                  return null;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: bool blIsPositive = ((input[1] & 128) > 0);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (blIsPositive)              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(input[10] << 24 | input[11] << 16 | input[12] << 8 | input[13])'                      (int)(input[6] << 24 | input[7] << 16 | input[8] << 8 | input[9])'                      (int)(input[2] << 24 | input[3] << 16 | input[4] << 8 | input[5])'                      (int)0                  });              }              else              {                  decimalValuePart = new decimal(new int[4]                   {                       (int)(~((input[10]) << 24 | (input[11]) << 16 | (input[12]) << 8 | (input[13])))'                      (int)(~((input[6]) << 24 | (input[7]) << 16 | (input[8]) << 8 | (input[9])))'                      (int)(~((input[2]) << 24 | (input[3]) << 16 | (input[4]) << 8 | (input[5])))'                      (int)0                  });              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: byte lastDigit = (byte)(input[14] >> 3);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: byte lastDigit = (byte)(input[14] >> 3);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: byte numOfDigits = (byte)(input[15] & 0x1F);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: byte scale = (byte)(((input[14] & 0x03) << 3) + (input[15] >> 5));
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: byte scale = (byte)(((input[14] & 0x03) << 3) + (input[15] >> 5));
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: byte scale = (byte)(((input[14] & 0x03) << 3) + (input[15] >> 5));
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: byte scale = (byte)(((input[14] & 0x03) << 3) + (input[15] >> 5));
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (numOfDigits < 28)              {                  decimalValuePart = Math.Floor(decimalValuePart / (decimal)Math.Pow(10' 28 - numOfDigits));              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (numOfDigits < 28)              {                  decimalValuePart = Math.Floor(decimalValuePart / (decimal)Math.Pow(10' 28 - numOfDigits));              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (numOfDigits < 28)              {                  decimalValuePart = Math.Floor(decimalValuePart / (decimal)Math.Pow(10' 28 - numOfDigits));              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (numOfDigits == 29)              {                  decimalValuePart = (decimalValuePart * 10) + lastDigit;              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: if (numOfDigits == 29)              {                  decimalValuePart = (decimalValuePart * 10) + lastDigit;              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: return new decimal(new int[4]               {                  decArray[0]'                  decArray[1]'                  decArray[2]'                  (int)((blIsPositive ? 0 : (1 << 31)) + (scale << 16))              });
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: return new decimal(new int[4]               {                  decArray[0]'                  decArray[1]'                  decArray[2]'                  (int)((blIsPositive ? 0 : (1 << 31)) + (scale << 16))              });
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: return new decimal(new int[4]               {                  decArray[0]'                  decArray[1]'                  decArray[2]'                  (int)((blIsPositive ? 0 : (1 << 31)) + (scale << 16))              });
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Decimal_BigEndian_NULL,The following statement contains a magic number: return new decimal(new int[4]               {                  decArray[0]'                  decArray[1]'                  decArray[2]'                  (int)((blIsPositive ? 0 : (1 << 31)) + (scale << 16))              });
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian,The following statement contains a magic number: bool blIsPositive = ((input[0] & 128) > 0);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian,The following statement contains a magic number: int exp = ((input[0] & 127) << 8) | (input[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian,The following statement contains a magic number: int exp = ((input[0] & 127) << 8) | (input[1]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian,The following statement contains a magic number: byte[] numberArray = new byte[8] { 0' 0' 0' 0' 0' 0' 0' 0 };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian,The following statement contains a magic number: System.Buffer.BlockCopy(input' 2' numberArray' 1' 7);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian,The following statement contains a magic number: System.Buffer.BlockCopy(input' 2' numberArray' 1' 7);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian_NULL,The following statement contains a magic number: if (input == null || input.Length != 10 || input[0] == 0)                  return null;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian_NULL,The following statement contains a magic number: bool blIsPositive = ((input[1] & 128) > 0);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian_NULL,The following statement contains a magic number: int exp = ((input[1] & 127) << 8) | (input[2]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian_NULL,The following statement contains a magic number: int exp = ((input[1] & 127) << 8) | (input[2]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian_NULL,The following statement contains a magic number: int exp = ((input[1] & 127) << 8) | (input[2]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian_NULL,The following statement contains a magic number: byte[] numberArray = new byte[8] { 0' 0' 0' 0' 0' 0' 0' 0 };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian_NULL,The following statement contains a magic number: System.Buffer.BlockCopy(input' 3' numberArray' 1' 7);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian_NULL,The following statement contains a magic number: System.Buffer.BlockCopy(input' 3' numberArray' 1' 7);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian_NULL,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian_NULL,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian_NULL,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian_NULL,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian_NULL,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian_NULL,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian_NULL,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian_NULL,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian_NULL,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian_NULL,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian_NULL,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian_NULL,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Double_BigEndian_NULL,The following statement contains a magic number: ulong doubleNumber = (ulong)(((ulong)numberArray[0] << 56) + ((ulong)numberArray[1] << 48) + ((ulong)numberArray[2] << 40) + ((ulong)numberArray[3] << 32) + ((ulong)numberArray[4] << 24) + ((ulong)numberArray[5] << 16) + ((ulong)numberArray[6] << 8) + (ulong)numberArray[7]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Float_BigEndian,The following statement contains a magic number: bool blIsPositive = ((input[0] & 128) > 0);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Float_BigEndian,The following statement contains a magic number: int exp = input[0] & 127;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Float_BigEndian,The following statement contains a magic number: uint floatNumber = (uint)(input[0] << 24 | input[1] << 16 | input[2] << 8 | input[3]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Float_BigEndian,The following statement contains a magic number: uint floatNumber = (uint)(input[0] << 24 | input[1] << 16 | input[2] << 8 | input[3]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Float_BigEndian,The following statement contains a magic number: uint floatNumber = (uint)(input[0] << 24 | input[1] << 16 | input[2] << 8 | input[3]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Float_BigEndian,The following statement contains a magic number: uint floatNumber = (uint)(input[0] << 24 | input[1] << 16 | input[2] << 8 | input[3]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Float_BigEndian,The following statement contains a magic number: uint floatNumber = (uint)(input[0] << 24 | input[1] << 16 | input[2] << 8 | input[3]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Float_BigEndian_NULL,The following statement contains a magic number: if (input == null || input.Length != 5 || input[0] == 0)                  return null;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Float_BigEndian_NULL,The following statement contains a magic number: input = new byte[] { input[1]' input[2]' input[3]' input[4] };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Float_BigEndian_NULL,The following statement contains a magic number: input = new byte[] { input[1]' input[2]' input[3]' input[4] };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Float_BigEndian_NULL,The following statement contains a magic number: input = new byte[] { input[1]' input[2]' input[3]' input[4] };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Float_BigEndian_NULL,The following statement contains a magic number: bool blIsPositive = ((input[0] & 128) > 0);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Float_BigEndian_NULL,The following statement contains a magic number: int exp = input[0] & 127;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Float_BigEndian_NULL,The following statement contains a magic number: uint floatNumber = (uint)(input[0] << 24 | input[1] << 16 | input[2] << 8 | input[3]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Float_BigEndian_NULL,The following statement contains a magic number: uint floatNumber = (uint)(input[0] << 24 | input[1] << 16 | input[2] << 8 | input[3]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Float_BigEndian_NULL,The following statement contains a magic number: uint floatNumber = (uint)(input[0] << 24 | input[1] << 16 | input[2] << 8 | input[3]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Float_BigEndian_NULL,The following statement contains a magic number: uint floatNumber = (uint)(input[0] << 24 | input[1] << 16 | input[2] << 8 | input[3]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_Float_BigEndian_NULL,The following statement contains a magic number: uint floatNumber = (uint)(input[0] << 24 | input[1] << 16 | input[2] << 8 | input[3]);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_1_byte_array,The following statement contains a magic number: if (value == null)                  return new byte[] { 2 };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_2_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   (byte) (val1 >> 8)'                   (byte)  val1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_2_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                   (byte)  val1'                  (byte) (val1 >> 8)                              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_3_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   1'                  (byte) (val1 >> 8)'                   (byte)  val1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_3_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                   1'                  (byte)  val1'                  (byte) (val1 >> 8)                              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_2_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   (byte) (value >> 8)'                   (byte) value              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_2_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                   (byte) value'                  (byte) (value >> 8)                              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_3_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   1'                  (byte) (value >> 8)'                   (byte) value              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_3_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                   1'                  (byte) value'                  (byte) (value >> 8)                              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   (byte)(val1 >> 24)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 8)'                   (byte) val1               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   (byte)(val1 >> 24)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 8)'                   (byte) val1               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   (byte)(val1 >> 24)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 8)'                   (byte) val1               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                    (byte) val1 '                  (byte)(val1 >> 8)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 24)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                    (byte) val1 '                  (byte)(val1 >> 8)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 24)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                    (byte) val1 '                  (byte)(val1 >> 8)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 24)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   1'                  (byte)(val1 >> 24)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 8)'                   (byte) val1               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   1'                  (byte)(val1 >> 24)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 8)'                   (byte) val1               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   1'                  (byte)(val1 >> 24)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 8)'                   (byte) val1               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                    1'                  (byte) val1 '                  (byte)(val1 >> 8)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 24)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                    1'                  (byte) val1 '                  (byte)(val1 >> 8)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 24)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                    1'                  (byte) val1 '                  (byte)(val1 >> 8)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 24)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   (byte)(value >> 24)'                   (byte)(value >> 16)'                   (byte)(value >> 8)'                   (byte) value               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   (byte)(value >> 24)'                   (byte)(value >> 16)'                   (byte)(value >> 8)'                   (byte) value               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   (byte)(value >> 24)'                   (byte)(value >> 16)'                   (byte)(value >> 8)'                   (byte) value               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                    (byte) value '                  (byte)(value >> 8)'                   (byte)(value >> 16)'                   (byte)(value >> 24)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                    (byte) value '                  (byte)(value >> 8)'                   (byte)(value >> 16)'                   (byte)(value >> 24)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                    (byte) value '                  (byte)(value >> 8)'                   (byte)(value >> 16)'                   (byte)(value >> 24)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   1'                  (byte)(value >> 24)'                   (byte)(value >> 16)'                   (byte)(value >> 8)'                   (byte) value               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   1'                  (byte)(value >> 24)'                   (byte)(value >> 16)'                   (byte)(value >> 8)'                   (byte) value               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   1'                  (byte)(value >> 24)'                   (byte)(value >> 16)'                   (byte)(value >> 8)'                   (byte) value               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                    1'                  (byte) value '                  (byte)(value >> 8)'                   (byte)(value >> 16)'                   (byte)(value >> 24)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                    1'                  (byte) value '                  (byte)(value >> 8)'                   (byte)(value >> 16)'                   (byte)(value >> 24)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                    1'                  (byte) value '                  (byte)(value >> 8)'                   (byte)(value >> 16)'                   (byte)(value >> 24)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   (byte)(val1 >> 56)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 8)'                   (byte) val1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   (byte)(val1 >> 56)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 8)'                   (byte) val1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   (byte)(val1 >> 56)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 8)'                   (byte) val1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   (byte)(val1 >> 56)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 8)'                   (byte) val1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   (byte)(val1 >> 56)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 8)'                   (byte) val1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   (byte)(val1 >> 56)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 8)'                   (byte) val1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   (byte)(val1 >> 56)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 8)'                   (byte) val1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                                   (byte) val1'                  (byte)(val1 >> 8)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                                   (byte) val1'                  (byte)(val1 >> 8)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                                   (byte) val1'                  (byte)(val1 >> 8)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                                   (byte) val1'                  (byte)(val1 >> 8)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                                   (byte) val1'                  (byte)(val1 >> 8)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                                   (byte) val1'                  (byte)(val1 >> 8)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                                   (byte) val1'                  (byte)(val1 >> 8)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   1'                  (byte)(val1 >> 56)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 8)'                   (byte) val1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   1'                  (byte)(val1 >> 56)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 8)'                   (byte) val1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   1'                  (byte)(val1 >> 56)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 8)'                   (byte) val1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   1'                  (byte)(val1 >> 56)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 8)'                   (byte) val1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   1'                  (byte)(val1 >> 56)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 8)'                   (byte) val1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   1'                  (byte)(val1 >> 56)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 8)'                   (byte) val1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   1'                  (byte)(val1 >> 56)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 8)'                   (byte) val1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                          1'                  (byte) val1'                  (byte)(val1 >> 8)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                          1'                  (byte) val1'                  (byte)(val1 >> 8)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                          1'                  (byte) val1'                  (byte)(val1 >> 8)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                          1'                  (byte) val1'                  (byte)(val1 >> 8)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                          1'                  (byte) val1'                  (byte)(val1 >> 8)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                          1'                  (byte) val1'                  (byte)(val1 >> 8)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                          1'                  (byte) val1'                  (byte)(val1 >> 8)'                   (byte)(val1 >> 16)'                   (byte)(val1 >> 24)'                   (byte)(val1 >> 32)'                   (byte)(val1 >> 40)'                   (byte)(val1 >> 48)'                   (byte)(val1 >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   (byte)(value >> 56)'                   (byte)(value >> 48)'                   (byte)(value >> 40)'                   (byte)(value >> 32)'                   (byte)(value >> 24)'                   (byte)(value >> 16)'                   (byte)(value >> 8)'                   (byte) value              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   (byte)(value >> 56)'                   (byte)(value >> 48)'                   (byte)(value >> 40)'                   (byte)(value >> 32)'                   (byte)(value >> 24)'                   (byte)(value >> 16)'                   (byte)(value >> 8)'                   (byte) value              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   (byte)(value >> 56)'                   (byte)(value >> 48)'                   (byte)(value >> 40)'                   (byte)(value >> 32)'                   (byte)(value >> 24)'                   (byte)(value >> 16)'                   (byte)(value >> 8)'                   (byte) value              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   (byte)(value >> 56)'                   (byte)(value >> 48)'                   (byte)(value >> 40)'                   (byte)(value >> 32)'                   (byte)(value >> 24)'                   (byte)(value >> 16)'                   (byte)(value >> 8)'                   (byte) value              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   (byte)(value >> 56)'                   (byte)(value >> 48)'                   (byte)(value >> 40)'                   (byte)(value >> 32)'                   (byte)(value >> 24)'                   (byte)(value >> 16)'                   (byte)(value >> 8)'                   (byte) value              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   (byte)(value >> 56)'                   (byte)(value >> 48)'                   (byte)(value >> 40)'                   (byte)(value >> 32)'                   (byte)(value >> 24)'                   (byte)(value >> 16)'                   (byte)(value >> 8)'                   (byte) value              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   (byte)(value >> 56)'                   (byte)(value >> 48)'                   (byte)(value >> 40)'                   (byte)(value >> 32)'                   (byte)(value >> 24)'                   (byte)(value >> 16)'                   (byte)(value >> 8)'                   (byte) value              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                                   (byte) value'                  (byte)(value >> 8)'                   (byte)(value >> 16)'                   (byte)(value >> 24)'                   (byte)(value >> 32)'                   (byte)(value >> 40)'                   (byte)(value >> 48)'                   (byte)(value >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                                   (byte) value'                  (byte)(value >> 8)'                   (byte)(value >> 16)'                   (byte)(value >> 24)'                   (byte)(value >> 32)'                   (byte)(value >> 40)'                   (byte)(value >> 48)'                   (byte)(value >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                                   (byte) value'                  (byte)(value >> 8)'                   (byte)(value >> 16)'                   (byte)(value >> 24)'                   (byte)(value >> 32)'                   (byte)(value >> 40)'                   (byte)(value >> 48)'                   (byte)(value >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                                   (byte) value'                  (byte)(value >> 8)'                   (byte)(value >> 16)'                   (byte)(value >> 24)'                   (byte)(value >> 32)'                   (byte)(value >> 40)'                   (byte)(value >> 48)'                   (byte)(value >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                                   (byte) value'                  (byte)(value >> 8)'                   (byte)(value >> 16)'                   (byte)(value >> 24)'                   (byte)(value >> 32)'                   (byte)(value >> 40)'                   (byte)(value >> 48)'                   (byte)(value >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                                   (byte) value'                  (byte)(value >> 8)'                   (byte)(value >> 16)'                   (byte)(value >> 24)'                   (byte)(value >> 32)'                   (byte)(value >> 40)'                   (byte)(value >> 48)'                   (byte)(value >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_8_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                                   (byte) value'                  (byte)(value >> 8)'                   (byte)(value >> 16)'                   (byte)(value >> 24)'                   (byte)(value >> 32)'                   (byte)(value >> 40)'                   (byte)(value >> 48)'                   (byte)(value >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   1'                  (byte)(value >> 56)'                   (byte)(value >> 48)'                   (byte)(value >> 40)'                   (byte)(value >> 32)'                   (byte)(value >> 24)'                   (byte)(value >> 16)'                   (byte)(value >> 8)'                   (byte) value              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   1'                  (byte)(value >> 56)'                   (byte)(value >> 48)'                   (byte)(value >> 40)'                   (byte)(value >> 32)'                   (byte)(value >> 24)'                   (byte)(value >> 16)'                   (byte)(value >> 8)'                   (byte) value              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   1'                  (byte)(value >> 56)'                   (byte)(value >> 48)'                   (byte)(value >> 40)'                   (byte)(value >> 32)'                   (byte)(value >> 24)'                   (byte)(value >> 16)'                   (byte)(value >> 8)'                   (byte) value              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   1'                  (byte)(value >> 56)'                   (byte)(value >> 48)'                   (byte)(value >> 40)'                   (byte)(value >> 32)'                   (byte)(value >> 24)'                   (byte)(value >> 16)'                   (byte)(value >> 8)'                   (byte) value              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   1'                  (byte)(value >> 56)'                   (byte)(value >> 48)'                   (byte)(value >> 40)'                   (byte)(value >> 32)'                   (byte)(value >> 24)'                   (byte)(value >> 16)'                   (byte)(value >> 8)'                   (byte) value              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   1'                  (byte)(value >> 56)'                   (byte)(value >> 48)'                   (byte)(value >> 40)'                   (byte)(value >> 32)'                   (byte)(value >> 24)'                   (byte)(value >> 16)'                   (byte)(value >> 8)'                   (byte) value              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: return new byte[]               {                   1'                  (byte)(value >> 56)'                   (byte)(value >> 48)'                   (byte)(value >> 40)'                   (byte)(value >> 32)'                   (byte)(value >> 24)'                   (byte)(value >> 16)'                   (byte)(value >> 8)'                   (byte) value              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                                  1'                  (byte) value'                  (byte)(value >> 8)'                   (byte)(value >> 16)'                   (byte)(value >> 24)'                   (byte)(value >> 32)'                   (byte)(value >> 40)'                   (byte)(value >> 48)'                   (byte)(value >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                                  1'                  (byte) value'                  (byte)(value >> 8)'                   (byte)(value >> 16)'                   (byte)(value >> 24)'                   (byte)(value >> 32)'                   (byte)(value >> 40)'                   (byte)(value >> 48)'                   (byte)(value >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                                  1'                  (byte) value'                  (byte)(value >> 8)'                   (byte)(value >> 16)'                   (byte)(value >> 24)'                   (byte)(value >> 32)'                   (byte)(value >> 40)'                   (byte)(value >> 48)'                   (byte)(value >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                                  1'                  (byte) value'                  (byte)(value >> 8)'                   (byte)(value >> 16)'                   (byte)(value >> 24)'                   (byte)(value >> 32)'                   (byte)(value >> 40)'                   (byte)(value >> 48)'                   (byte)(value >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                                  1'                  (byte) value'                  (byte)(value >> 8)'                   (byte)(value >> 16)'                   (byte)(value >> 24)'                   (byte)(value >> 32)'                   (byte)(value >> 40)'                   (byte)(value >> 48)'                   (byte)(value >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                                  1'                  (byte) value'                  (byte)(value >> 8)'                   (byte)(value >> 16)'                   (byte)(value >> 24)'                   (byte)(value >> 32)'                   (byte)(value >> 40)'                   (byte)(value >> 48)'                   (byte)(value >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_LittleEndian,The following statement contains a magic number: return new byte[]               {                                  1'                  (byte) value'                  (byte)(value >> 8)'                   (byte)(value >> 16)'                   (byte)(value >> 24)'                   (byte)(value >> 32)'                   (byte)(value >> 40)'                   (byte)(value >> 48)'                   (byte)(value >> 56)'               };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: bool blIsPositive = ((decArray[3] & 0x80000000) == 0);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: byte scale = (byte)(decArray[3] >> 16);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: byte scale = (byte)(decArray[3] >> 16);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: decimal decimalValuePart = new decimal(new int[4] { decArray[0]' decArray[1]' decArray[2]' 0 });
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: decimal decimalValuePart = new decimal(new int[4] { decArray[0]' decArray[1]' decArray[2]' 0 });
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: byte exp = (byte)(30 + numOfDigits - 1 - scale);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (numOfDigits == 29)              {                  lastDigit = (byte)(decimalValuePart % 10);                  decimalValuePart = Math.Floor(decimalValuePart / 10);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (numOfDigits == 29)              {                  lastDigit = (byte)(decimalValuePart % 10);                  decimalValuePart = Math.Floor(decimalValuePart / 10);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (numOfDigits == 29)              {                  lastDigit = (byte)(decimalValuePart % 10);                  decimalValuePart = Math.Floor(decimalValuePart / 10);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (numOfDigits < 28) decimalValuePart *= (decimal)Math.Pow(10' 28 - numOfDigits);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (numOfDigits < 28) decimalValuePart *= (decimal)Math.Pow(10' 28 - numOfDigits);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (numOfDigits < 28) decimalValuePart *= (decimal)Math.Pow(10' 28 - numOfDigits);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_15_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[BCNT_DECIMAL]                   {                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: bool blIsPositive = ((decArray[3] & 0x80000000) == 0);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: byte scale = (byte)(decArray[3] >> 16);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: byte scale = (byte)(decArray[3] >> 16);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: decimal decimalValuePart = new decimal(new int[4] { decArray[0]' decArray[1]' decArray[2]' 0 });
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: decimal decimalValuePart = new decimal(new int[4] { decArray[0]' decArray[1]' decArray[2]' 0 });
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: byte exp = (byte)(30 + numOfDigits - 1 - scale);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (numOfDigits == 29)              {                  lastDigit = (byte)(decimalValuePart % 10);                  decimalValuePart = Math.Floor(decimalValuePart / 10);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (numOfDigits == 29)              {                  lastDigit = (byte)(decimalValuePart % 10);                  decimalValuePart = Math.Floor(decimalValuePart / 10);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (numOfDigits == 29)              {                  lastDigit = (byte)(decimalValuePart % 10);                  decimalValuePart = Math.Floor(decimalValuePart / 10);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (numOfDigits < 28) decimalValuePart *= (decimal)Math.Pow(10' 28 - numOfDigits);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (numOfDigits < 28) decimalValuePart *= (decimal)Math.Pow(10' 28 - numOfDigits);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (numOfDigits < 28) decimalValuePart *= (decimal)Math.Pow(10' 28 - numOfDigits);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_16_bytes_array_BigEndian,The following statement contains a magic number: if (blIsPositive)              {                  resultArray = new byte[16]                   {                      1'                      (byte)(128 + (blIsExpPositive ? 64 : 0) + (exp & 0x3F))'                      (byte)(decArray[2] >> 24)' (byte)(decArray[2] >> 16)' (byte)(decArray[2] >> 8)' (byte)decArray[2]'                      (byte)(decArray[1] >> 24)' (byte)(decArray[1] >> 16)' (byte)(decArray[1] >> 8)' (byte)decArray[1]'                      (byte)(decArray[0] >> 24)' (byte)(decArray[0] >> 16)' (byte)(decArray[0] >> 8)' (byte)decArray[0]'                      (byte)((lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }              else              {                  resultArray = new byte[16]                   {                      1'                      (byte)((blIsExpPositive ? 0 : 64) + (exp & 0x3F))'                      (byte)(~decArray[2] >> 24)' (byte)(~decArray[2] >> 16)' (byte)(~decArray[2] >> 8)' (byte)~decArray[2]'                      (byte)(~decArray[1] >> 24)' (byte)(~decArray[1] >> 16)' (byte)(~decArray[1] >> 8)' (byte)~decArray[1]'                      (byte)(~decArray[0] >> 24)' (byte)(~decArray[0] >> 16)' (byte)(~decArray[0] >> 8)' (byte)~decArray[0]'                      (byte)((~lastDigit << 3) + (byte)(scale >> 3))'                      (byte)((scale << 5) + numOfDigits)                  };              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: Int16[] ushortPowerList = new Int16[5] {                  1'                  10'                  100'                  1000'                  10000              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: Int16[] ushortPowerList = new Int16[5] {                  1'                  10'                  100'                  1000'                  10000              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: Int16[] ushortPowerList = new Int16[5] {                  1'                  10'                  100'                  1000'                  10000              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: Int16[] ushortPowerList = new Int16[5] {                  1'                  10'                  100'                  1000'                  10000              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: Int16[] ushortPowerList = new Int16[5] {                  1'                  10'                  100'                  1000'                  10000              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: byte[] resultArray = new byte[] {                  (byte)(servicePart >> 8)'                  (byte)servicePart'                  (byte)(doubleNumber >> 48)'                   (byte)(doubleNumber >> 40)'                   (byte)(doubleNumber >> 32)'                   (byte)(doubleNumber >> 24)'                   (byte)(doubleNumber >> 16)'                   (byte)(doubleNumber >> 8)'                   (byte)doubleNumber              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: byte[] resultArray = new byte[] {                  (byte)(servicePart >> 8)'                  (byte)servicePart'                  (byte)(doubleNumber >> 48)'                   (byte)(doubleNumber >> 40)'                   (byte)(doubleNumber >> 32)'                   (byte)(doubleNumber >> 24)'                   (byte)(doubleNumber >> 16)'                   (byte)(doubleNumber >> 8)'                   (byte)doubleNumber              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: byte[] resultArray = new byte[] {                  (byte)(servicePart >> 8)'                  (byte)servicePart'                  (byte)(doubleNumber >> 48)'                   (byte)(doubleNumber >> 40)'                   (byte)(doubleNumber >> 32)'                   (byte)(doubleNumber >> 24)'                   (byte)(doubleNumber >> 16)'                   (byte)(doubleNumber >> 8)'                   (byte)doubleNumber              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: byte[] resultArray = new byte[] {                  (byte)(servicePart >> 8)'                  (byte)servicePart'                  (byte)(doubleNumber >> 48)'                   (byte)(doubleNumber >> 40)'                   (byte)(doubleNumber >> 32)'                   (byte)(doubleNumber >> 24)'                   (byte)(doubleNumber >> 16)'                   (byte)(doubleNumber >> 8)'                   (byte)doubleNumber              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: byte[] resultArray = new byte[] {                  (byte)(servicePart >> 8)'                  (byte)servicePart'                  (byte)(doubleNumber >> 48)'                   (byte)(doubleNumber >> 40)'                   (byte)(doubleNumber >> 32)'                   (byte)(doubleNumber >> 24)'                   (byte)(doubleNumber >> 16)'                   (byte)(doubleNumber >> 8)'                   (byte)doubleNumber              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: byte[] resultArray = new byte[] {                  (byte)(servicePart >> 8)'                  (byte)servicePart'                  (byte)(doubleNumber >> 48)'                   (byte)(doubleNumber >> 40)'                   (byte)(doubleNumber >> 32)'                   (byte)(doubleNumber >> 24)'                   (byte)(doubleNumber >> 16)'                   (byte)(doubleNumber >> 8)'                   (byte)doubleNumber              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_9_bytes_array_BigEndian,The following statement contains a magic number: byte[] resultArray = new byte[] {                  (byte)(servicePart >> 8)'                  (byte)servicePart'                  (byte)(doubleNumber >> 48)'                   (byte)(doubleNumber >> 40)'                   (byte)(doubleNumber >> 32)'                   (byte)(doubleNumber >> 24)'                   (byte)(doubleNumber >> 16)'                   (byte)(doubleNumber >> 8)'                   (byte)doubleNumber              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: ulong[] ulongPowerListReverse = new ulong[16] {                  1000000000000000'                  100000000000000'                  10000000000000'                  1000000000000'                  100000000000'                  10000000000'                  1000000000'                  100000000'                  10000000'                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: Int16[] ushortPowerList = new Int16[5] {                  1'                  10'                  100'                  1000'                  10000              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: Int16[] ushortPowerList = new Int16[5] {                  1'                  10'                  100'                  1000'                  10000              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: Int16[] ushortPowerList = new Int16[5] {                  1'                  10'                  100'                  1000'                  10000              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: Int16[] ushortPowerList = new Int16[5] {                  1'                  10'                  100'                  1000'                  10000              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: Int16[] ushortPowerList = new Int16[5] {                  1'                  10'                  100'                  1000'                  10000              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: byte[] resultArray = new byte[] {                  1'                  (byte)(servicePart >> 8)'                  (byte)servicePart'                  (byte)(doubleNumber >> 48)'                   (byte)(doubleNumber >> 40)'                   (byte)(doubleNumber >> 32)'                   (byte)(doubleNumber >> 24)'                   (byte)(doubleNumber >> 16)'                   (byte)(doubleNumber >> 8)'                   (byte)doubleNumber              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: byte[] resultArray = new byte[] {                  1'                  (byte)(servicePart >> 8)'                  (byte)servicePart'                  (byte)(doubleNumber >> 48)'                   (byte)(doubleNumber >> 40)'                   (byte)(doubleNumber >> 32)'                   (byte)(doubleNumber >> 24)'                   (byte)(doubleNumber >> 16)'                   (byte)(doubleNumber >> 8)'                   (byte)doubleNumber              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: byte[] resultArray = new byte[] {                  1'                  (byte)(servicePart >> 8)'                  (byte)servicePart'                  (byte)(doubleNumber >> 48)'                   (byte)(doubleNumber >> 40)'                   (byte)(doubleNumber >> 32)'                   (byte)(doubleNumber >> 24)'                   (byte)(doubleNumber >> 16)'                   (byte)(doubleNumber >> 8)'                   (byte)doubleNumber              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: byte[] resultArray = new byte[] {                  1'                  (byte)(servicePart >> 8)'                  (byte)servicePart'                  (byte)(doubleNumber >> 48)'                   (byte)(doubleNumber >> 40)'                   (byte)(doubleNumber >> 32)'                   (byte)(doubleNumber >> 24)'                   (byte)(doubleNumber >> 16)'                   (byte)(doubleNumber >> 8)'                   (byte)doubleNumber              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: byte[] resultArray = new byte[] {                  1'                  (byte)(servicePart >> 8)'                  (byte)servicePart'                  (byte)(doubleNumber >> 48)'                   (byte)(doubleNumber >> 40)'                   (byte)(doubleNumber >> 32)'                   (byte)(doubleNumber >> 24)'                   (byte)(doubleNumber >> 16)'                   (byte)(doubleNumber >> 8)'                   (byte)doubleNumber              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: byte[] resultArray = new byte[] {                  1'                  (byte)(servicePart >> 8)'                  (byte)servicePart'                  (byte)(doubleNumber >> 48)'                   (byte)(doubleNumber >> 40)'                   (byte)(doubleNumber >> 32)'                   (byte)(doubleNumber >> 24)'                   (byte)(doubleNumber >> 16)'                   (byte)(doubleNumber >> 8)'                   (byte)doubleNumber              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_10_bytes_array_BigEndian,The following statement contains a magic number: byte[] resultArray = new byte[] {                  1'                  (byte)(servicePart >> 8)'                  (byte)servicePart'                  (byte)(doubleNumber >> 48)'                   (byte)(doubleNumber >> 40)'                   (byte)(doubleNumber >> 32)'                   (byte)(doubleNumber >> 24)'                   (byte)(doubleNumber >> 16)'                   (byte)(doubleNumber >> 8)'                   (byte)doubleNumber              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_BigEndian,The following statement contains a magic number: uint[] uintPowerListReverse = new uint[7] {                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_BigEndian,The following statement contains a magic number: uint[] uintPowerListReverse = new uint[7] {                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_BigEndian,The following statement contains a magic number: uint[] uintPowerListReverse = new uint[7] {                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_BigEndian,The following statement contains a magic number: uint[] uintPowerListReverse = new uint[7] {                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_BigEndian,The following statement contains a magic number: uint[] uintPowerListReverse = new uint[7] {                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_BigEndian,The following statement contains a magic number: uint[] uintPowerListReverse = new uint[7] {                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_BigEndian,The following statement contains a magic number: uint[] uintPowerListReverse = new uint[7] {                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_BigEndian,The following statement contains a magic number: Int16[] ushortPowerList = new Int16[5] {                  1'                  10'                  100'                  1000'                  10000              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_BigEndian,The following statement contains a magic number: Int16[] ushortPowerList = new Int16[5] {                  1'                  10'                  100'                  1000'                  10000              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_BigEndian,The following statement contains a magic number: Int16[] ushortPowerList = new Int16[5] {                  1'                  10'                  100'                  1000'                  10000              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_BigEndian,The following statement contains a magic number: Int16[] ushortPowerList = new Int16[5] {                  1'                  10'                  100'                  1000'                  10000              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_BigEndian,The following statement contains a magic number: Int16[] ushortPowerList = new Int16[5] {                  1'                  10'                  100'                  1000'                  10000              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_BigEndian,The following statement contains a magic number: resultArray = new byte[] {                  (byte)servicePart'                  (byte)(floatNumber >> 16)'                   (byte)(floatNumber >> 8)'                   (byte)floatNumber              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_4_bytes_array_BigEndian,The following statement contains a magic number: resultArray = new byte[] {                  (byte)servicePart'                  (byte)(floatNumber >> 16)'                   (byte)(floatNumber >> 8)'                   (byte)floatNumber              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_BigEndian,The following statement contains a magic number: uint[] uintPowerListReverse = new uint[7] {                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_BigEndian,The following statement contains a magic number: uint[] uintPowerListReverse = new uint[7] {                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_BigEndian,The following statement contains a magic number: uint[] uintPowerListReverse = new uint[7] {                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_BigEndian,The following statement contains a magic number: uint[] uintPowerListReverse = new uint[7] {                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_BigEndian,The following statement contains a magic number: uint[] uintPowerListReverse = new uint[7] {                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_BigEndian,The following statement contains a magic number: uint[] uintPowerListReverse = new uint[7] {                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_BigEndian,The following statement contains a magic number: uint[] uintPowerListReverse = new uint[7] {                  1000000'                  100000'                  10000'                  1000'                  100'                  10'                  1              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_BigEndian,The following statement contains a magic number: Int16[] ushortPowerList = new Int16[5] {                  1'                  10'                  100'                  1000'                  10000              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_BigEndian,The following statement contains a magic number: Int16[] ushortPowerList = new Int16[5] {                  1'                  10'                  100'                  1000'                  10000              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_BigEndian,The following statement contains a magic number: Int16[] ushortPowerList = new Int16[5] {                  1'                  10'                  100'                  1000'                  10000              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_BigEndian,The following statement contains a magic number: Int16[] ushortPowerList = new Int16[5] {                  1'                  10'                  100'                  1000'                  10000              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_BigEndian,The following statement contains a magic number: Int16[] ushortPowerList = new Int16[5] {                  1'                  10'                  100'                  1000'                  10000              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_BigEndian,The following statement contains a magic number: resultArray = new byte[] {                  1'                  (byte)servicePart'                  (byte)(floatNumber >> 16)'                   (byte)(floatNumber >> 8)'                   (byte)floatNumber              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_5_bytes_array_BigEndian,The following statement contains a magic number: resultArray = new byte[] {                  1'                  (byte)servicePart'                  (byte)(floatNumber >> 16)'                   (byte)(floatNumber >> 8)'                   (byte)floatNumber              };
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,TruncateUTF8,The following statement contains a magic number: if (bt[maxSizeInBytes - 1] < 128)                  return bt.Substring(0' maxSizeInBytes);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,TruncateUTF8,The following statement contains a magic number: for (int i = maxSizeInBytes - 1; i >= 0; i--)              {                  toRemove++;                    if ((bt[i] & 64) == 64)                  {                      //Calculating quantity of higher bits                      int qb = 2;                      int b = 0x20;                        for (int j = 1; j < 5; j++)                      {                          if ((bt[i] & b) == b)                          {                              qb++;                              b >>= 1;                          }                          else                              break;                      }                          if (toRemove == qb)                          toRemove = 0;                        break;                  }              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,TruncateUTF8,The following statement contains a magic number: for (int i = maxSizeInBytes - 1; i >= 0; i--)              {                  toRemove++;                    if ((bt[i] & 64) == 64)                  {                      //Calculating quantity of higher bits                      int qb = 2;                      int b = 0x20;                        for (int j = 1; j < 5; j++)                      {                          if ((bt[i] & b) == b)                          {                              qb++;                              b >>= 1;                          }                          else                              break;                      }                          if (toRemove == qb)                          toRemove = 0;                        break;                  }              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,TruncateUTF8,The following statement contains a magic number: for (int i = maxSizeInBytes - 1; i >= 0; i--)              {                  toRemove++;                    if ((bt[i] & 64) == 64)                  {                      //Calculating quantity of higher bits                      int qb = 2;                      int b = 0x20;                        for (int j = 1; j < 5; j++)                      {                          if ((bt[i] & b) == b)                          {                              qb++;                              b >>= 1;                          }                          else                              break;                      }                          if (toRemove == qb)                          toRemove = 0;                        break;                  }              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,TruncateUTF8,The following statement contains a magic number: for (int i = maxSizeInBytes - 1; i >= 0; i--)              {                  toRemove++;                    if ((bt[i] & 64) == 64)                  {                      //Calculating quantity of higher bits                      int qb = 2;                      int b = 0x20;                        for (int j = 1; j < 5; j++)                      {                          if ((bt[i] & b) == b)                          {                              qb++;                              b >>= 1;                          }                          else                              break;                      }                          if (toRemove == qb)                          toRemove = 0;                        break;                  }              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_FixedSizeColumn,The following statement contains a magic number: if (fixedSize < 4)              {                  if (isASCII && fixedSize < 1)                  {                      throw new Exception("Fixed Size must be minimum 1");                  }                  else                      throw new Exception("Fixed Size must be minimum 4 for UTF-8 text");                               }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_FixedSizeColumn,The following statement contains a magic number: if (value == null)                  return UInt16.MaxValue.To_2_bytes_array_BigEndian().EnlargeByteArray_LittleEndian(fixedSize + 2);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,To_FixedSizeColumn,The following statement contains a magic number: return ((ushort)text.Length).To_2_bytes_array_BigEndian().Concat(text).EnlargeByteArray_LittleEndian(fixedSize + 2);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,From_FixedSizeColumn,The following statement contains a magic number: if (value == null || value.Length < 2)                  return null;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,From_FixedSizeColumn,The following statement contains a magic number: if (isASCII)                  return System.Text.Encoding.ASCII.GetString(value.Substring(2' (int)size));              else                  return System.Text.Encoding.UTF8.GetString(value.Substring(2' (int)size));
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,From_FixedSizeColumn,The following statement contains a magic number: if (isASCII)                  return System.Text.Encoding.ASCII.GetString(value.Substring(2' (int)size));              else                  return System.Text.Encoding.UTF8.GetString(value.Substring(2' (int)size));
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToByteArrayFromHex,The following statement contains a magic number: byte[] tr = new byte[str.Length / 2];
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToByteArrayFromHex,The following statement contains a magic number: for (int i = 0; i < str.Length; i += 2)              {                  d = str[i] - 48;                  d = d > 9 ? d - 7 : d;                  tr[j] = (byte)(d * 16);                  d = str[i + 1] - 48;                  d = d > 9 ? d - 7 : d;                  tr[j] += (byte)d;                  j++;              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToByteArrayFromHex,The following statement contains a magic number: for (int i = 0; i < str.Length; i += 2)              {                  d = str[i] - 48;                  d = d > 9 ? d - 7 : d;                  tr[j] = (byte)(d * 16);                  d = str[i + 1] - 48;                  d = d > 9 ? d - 7 : d;                  tr[j] += (byte)d;                  j++;              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToByteArrayFromHex,The following statement contains a magic number: for (int i = 0; i < str.Length; i += 2)              {                  d = str[i] - 48;                  d = d > 9 ? d - 7 : d;                  tr[j] = (byte)(d * 16);                  d = str[i + 1] - 48;                  d = d > 9 ? d - 7 : d;                  tr[j] += (byte)d;                  j++;              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToByteArrayFromHex,The following statement contains a magic number: for (int i = 0; i < str.Length; i += 2)              {                  d = str[i] - 48;                  d = d > 9 ? d - 7 : d;                  tr[j] = (byte)(d * 16);                  d = str[i + 1] - 48;                  d = d > 9 ? d - 7 : d;                  tr[j] += (byte)d;                  j++;              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToByteArrayFromHex,The following statement contains a magic number: for (int i = 0; i < str.Length; i += 2)              {                  d = str[i] - 48;                  d = d > 9 ? d - 7 : d;                  tr[j] = (byte)(d * 16);                  d = str[i + 1] - 48;                  d = d > 9 ? d - 7 : d;                  tr[j] += (byte)d;                  j++;              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToByteArrayFromHex,The following statement contains a magic number: for (int i = 0; i < str.Length; i += 2)              {                  d = str[i] - 48;                  d = d > 9 ? d - 7 : d;                  tr[j] = (byte)(d * 16);                  d = str[i + 1] - 48;                  d = d > 9 ? d - 7 : d;                  tr[j] += (byte)d;                  j++;              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToByteArrayFromHex,The following statement contains a magic number: for (int i = 0; i < str.Length; i += 2)              {                  d = str[i] - 48;                  d = d > 9 ? d - 7 : d;                  tr[j] = (byte)(d * 16);                  d = str[i + 1] - 48;                  d = d > 9 ? d - 7 : d;                  tr[j] += (byte)d;                  j++;              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToByteArrayFromHex,The following statement contains a magic number: for (int i = 0; i < str.Length; i += 2)              {                  d = str[i] - 48;                  d = d > 9 ? d - 7 : d;                  tr[j] = (byte)(d * 16);                  d = str[i + 1] - 48;                  d = d > 9 ? d - 7 : d;                  tr[j] += (byte)d;                  j++;              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToBytesString,The following statement contains a magic number: char[] digits = new char[dBytes.Length * 2];
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToBytesString,The following statement contains a magic number: for (int i = 0; i < dBytes.Length; i++)              {                  d2 = dBytes[i] % 16;                  d1 = dBytes[i] / 16;                                 digits[2 * i] = _hexDigits[d1];                  digits[2 * i + 1] = _hexDigits[d2];              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToBytesString,The following statement contains a magic number: for (int i = 0; i < dBytes.Length; i++)              {                  d2 = dBytes[i] % 16;                  d1 = dBytes[i] / 16;                                 digits[2 * i] = _hexDigits[d1];                  digits[2 * i + 1] = _hexDigits[d2];              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToBytesString,The following statement contains a magic number: for (int i = 0; i < dBytes.Length; i++)              {                  d2 = dBytes[i] % 16;                  d1 = dBytes[i] / 16;                                 digits[2 * i] = _hexDigits[d1];                  digits[2 * i + 1] = _hexDigits[d2];              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToBytesString,The following statement contains a magic number: for (int i = 0; i < dBytes.Length; i++)              {                  d2 = dBytes[i] % 16;                  d1 = dBytes[i] / 16;                                 digits[2 * i] = _hexDigits[d1];                  digits[2 * i + 1] = _hexDigits[d2];              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToBitArray,The following statement contains a magic number: byte[] ret = new byte[8];
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToBitArray,The following statement contains a magic number: ret[0] = (byte)((bt >> 7) & 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToBitArray,The following statement contains a magic number: ret[1] = (byte)((bt >> 6) & 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToBitArray,The following statement contains a magic number: ret[2] = (byte)((bt >> 5) & 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToBitArray,The following statement contains a magic number: ret[2] = (byte)((bt >> 5) & 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToBitArray,The following statement contains a magic number: ret[3] = (byte)((bt >> 4) & 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToBitArray,The following statement contains a magic number: ret[3] = (byte)((bt >> 4) & 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToBitArray,The following statement contains a magic number: ret[4] = (byte)((bt >> 3) & 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToBitArray,The following statement contains a magic number: ret[4] = (byte)((bt >> 3) & 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToBitArray,The following statement contains a magic number: ret[5] = (byte)((bt >> 2) & 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToBitArray,The following statement contains a magic number: ret[5] = (byte)((bt >> 2) & 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToBitArray,The following statement contains a magic number: ret[6] = (byte)((bt >> 1) & 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ToBitArray,The following statement contains a magic number: ret[7] = (byte)(bt & 1);
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,BytesAction_GoOneBitUp_NoArrayGrow_BigEndian,The following statement contains a magic number: for (int i = bt.Length - 1; i >= 0; i--)              {                  /* OPTIMIZATION CHECK LATER                  if (bt[0] == 255)                  {                      if (toAdd)                      {                          if (i == 0)                          {                              return null;                          }                          else                          {                              ret[i] = 0;                              toAdd = true;                          }                      }                      else                      {                          ret[i] = bt[i];                      }                  }                  else                  {                      if (toAdd)                      {                          toAdd = false;                          ret[i] = (byte)(bt[i] + 1);                      }                      else                          ret[i] = bt[i];                  }                   */                      if (i == 0 && toAdd && bt[0] == 255)                      return null;                    if (toAdd && bt[i] == 255)                  {                      ret[i] = 0;                      toAdd = true;                  }                  else if (toAdd && bt[i] < 255)                  {                      toAdd = false;                      ret[i] = (byte)(bt[i] + 1);                  }                  else                      ret[i] = bt[i];                }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,BytesAction_GoOneBitUp_NoArrayGrow_BigEndian,The following statement contains a magic number: for (int i = bt.Length - 1; i >= 0; i--)              {                  /* OPTIMIZATION CHECK LATER                  if (bt[0] == 255)                  {                      if (toAdd)                      {                          if (i == 0)                          {                              return null;                          }                          else                          {                              ret[i] = 0;                              toAdd = true;                          }                      }                      else                      {                          ret[i] = bt[i];                      }                  }                  else                  {                      if (toAdd)                      {                          toAdd = false;                          ret[i] = (byte)(bt[i] + 1);                      }                      else                          ret[i] = bt[i];                  }                   */                      if (i == 0 && toAdd && bt[0] == 255)                      return null;                    if (toAdd && bt[i] == 255)                  {                      ret[i] = 0;                      toAdd = true;                  }                  else if (toAdd && bt[i] < 255)                  {                      toAdd = false;                      ret[i] = (byte)(bt[i] + 1);                  }                  else                      ret[i] = bt[i];                }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,BytesAction_GoOneBitUp_NoArrayGrow_BigEndian,The following statement contains a magic number: for (int i = bt.Length - 1; i >= 0; i--)              {                  /* OPTIMIZATION CHECK LATER                  if (bt[0] == 255)                  {                      if (toAdd)                      {                          if (i == 0)                          {                              return null;                          }                          else                          {                              ret[i] = 0;                              toAdd = true;                          }                      }                      else                      {                          ret[i] = bt[i];                      }                  }                  else                  {                      if (toAdd)                      {                          toAdd = false;                          ret[i] = (byte)(bt[i] + 1);                      }                      else                          ret[i] = bt[i];                  }                   */                      if (i == 0 && toAdd && bt[0] == 255)                      return null;                    if (toAdd && bt[i] == 255)                  {                      ret[i] = 0;                      toAdd = true;                  }                  else if (toAdd && bt[i] < 255)                  {                      toAdd = false;                      ret[i] = (byte)(bt[i] + 1);                  }                  else                      ret[i] = bt[i];                }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,BytesAction_GoOneBitUp_ArrayGrows_BigEndian,The following statement contains a magic number: for (int i = bt.Length - 1; i >= 0; i--)              {                  /* OPTIMIZATION CHECK LATER                   * BETTER START if(toAdd) etc' look on bitDown                   *                   if (bt[0] == 255)                  {                      if (toAdd)                      {                          if (i == 0)                          {                              ret[0] = 0;                              return new byte[] { 1 }.Concat(ret);                          }                          else                          {                              ret[i] = 0;                              toAdd = true;                          }                      }                      else                      {                          ret[i] = bt[i];                      }                  }                  else                  {                      if (toAdd)                      {                          toAdd = false;                          ret[i] = (byte)(bt[i] + 1);                      }                      else                          ret[i] = bt[i];                  }                   */                      if (i == 0 && toAdd && bt[0] == 255)                  {                      ret[0] = 0;                      return new byte[] { 1 }.Concat(ret);                  }                      if (toAdd && bt[i] == 255)                  {                      ret[i] = 0;                      toAdd = true;                  }                  else if (toAdd && bt[i] < 255)                  {                      toAdd = false;                      ret[i] = (byte)(bt[i] + 1);                  }                  else                      ret[i] = bt[i];                }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,BytesAction_GoOneBitUp_ArrayGrows_BigEndian,The following statement contains a magic number: for (int i = bt.Length - 1; i >= 0; i--)              {                  /* OPTIMIZATION CHECK LATER                   * BETTER START if(toAdd) etc' look on bitDown                   *                   if (bt[0] == 255)                  {                      if (toAdd)                      {                          if (i == 0)                          {                              ret[0] = 0;                              return new byte[] { 1 }.Concat(ret);                          }                          else                          {                              ret[i] = 0;                              toAdd = true;                          }                      }                      else                      {                          ret[i] = bt[i];                      }                  }                  else                  {                      if (toAdd)                      {                          toAdd = false;                          ret[i] = (byte)(bt[i] + 1);                      }                      else                          ret[i] = bt[i];                  }                   */                      if (i == 0 && toAdd && bt[0] == 255)                  {                      ret[0] = 0;                      return new byte[] { 1 }.Concat(ret);                  }                      if (toAdd && bt[i] == 255)                  {                      ret[i] = 0;                      toAdd = true;                  }                  else if (toAdd && bt[i] < 255)                  {                      toAdd = false;                      ret[i] = (byte)(bt[i] + 1);                  }                  else                      ret[i] = bt[i];                }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,BytesAction_GoOneBitUp_ArrayGrows_BigEndian,The following statement contains a magic number: for (int i = bt.Length - 1; i >= 0; i--)              {                  /* OPTIMIZATION CHECK LATER                   * BETTER START if(toAdd) etc' look on bitDown                   *                   if (bt[0] == 255)                  {                      if (toAdd)                      {                          if (i == 0)                          {                              ret[0] = 0;                              return new byte[] { 1 }.Concat(ret);                          }                          else                          {                              ret[i] = 0;                              toAdd = true;                          }                      }                      else                      {                          ret[i] = bt[i];                      }                  }                  else                  {                      if (toAdd)                      {                          toAdd = false;                          ret[i] = (byte)(bt[i] + 1);                      }                      else                          ret[i] = bt[i];                  }                   */                      if (i == 0 && toAdd && bt[0] == 255)                  {                      ret[0] = 0;                      return new byte[] { 1 }.Concat(ret);                  }                      if (toAdd && bt[i] == 255)                  {                      ret[i] = 0;                      toAdd = true;                  }                  else if (toAdd && bt[i] < 255)                  {                      toAdd = false;                      ret[i] = (byte)(bt[i] + 1);                  }                  else                      ret[i] = bt[i];                }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,BytesAction_GoOneBitDown_NoArrayGrow_BigEndian,The following statement contains a magic number: for (int i = bt.Length - 1; i >= 0; i--)              {                  if (toExtract)                  {                      if (i == 0 && bt[i] == 0)                          return null;                        if (bt[i] == 0)                      {                          ret[i] = 255;                      }                      else                      {                          toExtract = false;                          ret[i] = (byte)(bt[i] - 1);                      }                  }                  else                  {                      ret[i] = bt[i];                  }                }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,BytesAction_GoUpNextByteStart_NoArrayGrow_BigEndian,The following statement contains a magic number: if (bt == null || bt.Length < 2)                  return null;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,BytesAction_GoUpNextByteStart_NoArrayGrow_BigEndian,The following statement contains a magic number: for (int i = bt.Length - 1; i >= 0; i--)              {                  if (i == 0 && toAdd && bt[0] == 255)                      return null;                    if (i >= index)                  {                      ret[i] = 0;                  }                  else                  {                      if (toAdd && bt[i] == 255)                      {                          ret[i] = 0;                          toAdd = true;                      }                      else if (toAdd && bt[i] < 255)                      {                          toAdd = false;                          ret[i] = (byte)(bt[i] + 1);                      }                      else                          ret[i] = bt[i];                  }                }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,BytesAction_GoUpNextByteStart_NoArrayGrow_BigEndian,The following statement contains a magic number: for (int i = bt.Length - 1; i >= 0; i--)              {                  if (i == 0 && toAdd && bt[0] == 255)                      return null;                    if (i >= index)                  {                      ret[i] = 0;                  }                  else                  {                      if (toAdd && bt[i] == 255)                      {                          ret[i] = 0;                          toAdd = true;                      }                      else if (toAdd && bt[i] < 255)                      {                          toAdd = false;                          ret[i] = (byte)(bt[i] + 1);                      }                      else                          ret[i] = bt[i];                  }                }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,BytesAction_GoUpNextByteStart_NoArrayGrow_BigEndian,The following statement contains a magic number: for (int i = bt.Length - 1; i >= 0; i--)              {                  if (i == 0 && toAdd && bt[0] == 255)                      return null;                    if (i >= index)                  {                      ret[i] = 0;                  }                  else                  {                      if (toAdd && bt[i] == 255)                      {                          ret[i] = 0;                          toAdd = true;                      }                      else if (toAdd && bt[i] < 255)                      {                          toAdd = false;                          ret[i] = (byte)(bt[i] + 1);                      }                      else                          ret[i] = bt[i];                  }                }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,BytesAction_GoDownNextByteStart_NoArrayGrow_BigEndian,The following statement contains a magic number: if (bt == null || bt.Length < 2)                  return null;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,BytesAction_GoDownNextByteStart_NoArrayGrow_BigEndian,The following statement contains a magic number: for (int i = bt.Length - 1; i >= 0; i--)              {                  if (i == 0 && toExtract && bt[0] == 0)                      return null;                    if (i >= index)                  {                      ret[i] = 255;                  }                  else                  {                      if (toExtract && bt[i] == 0)                      {                          ret[i] = 255;                          toExtract = true;                      }                      else if (toExtract && bt[i] > 0)                      {                          toExtract = false;                          ret[i] = (byte)(bt[i] - 1);                      }                      else                          ret[i] = bt[i];                  }                }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,BytesAction_GoDownNextByteStart_NoArrayGrow_BigEndian,The following statement contains a magic number: for (int i = bt.Length - 1; i >= 0; i--)              {                  if (i == 0 && toExtract && bt[0] == 0)                      return null;                    if (i >= index)                  {                      ret[i] = 255;                  }                  else                  {                      if (toExtract && bt[i] == 0)                      {                          ret[i] = 255;                          toExtract = true;                      }                      else if (toExtract && bt[i] > 0)                      {                          toExtract = false;                          ret[i] = (byte)(bt[i] - 1);                      }                      else                          ret[i] = bt[i];                  }                }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfDynamicDataPointerIsEmpty,The following statement contains a magic number: if (initPtr == null || initPtr.Length != 16)   //8 bytes pointer + 4 bytes DataBlockSize + 4 bytes Length                  return true;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfDynamicDataPointerIsEmpty,The following statement contains a magic number: return (initPtr[0] | initPtr[1] | initPtr[2] | initPtr[3] | initPtr[4] | initPtr[5] | initPtr[6] | initPtr[7]) == 0;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfDynamicDataPointerIsEmpty,The following statement contains a magic number: return (initPtr[0] | initPtr[1] | initPtr[2] | initPtr[3] | initPtr[4] | initPtr[5] | initPtr[6] | initPtr[7]) == 0;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfDynamicDataPointerIsEmpty,The following statement contains a magic number: return (initPtr[0] | initPtr[1] | initPtr[2] | initPtr[3] | initPtr[4] | initPtr[5] | initPtr[6] | initPtr[7]) == 0;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfDynamicDataPointerIsEmpty,The following statement contains a magic number: return (initPtr[0] | initPtr[1] | initPtr[2] | initPtr[3] | initPtr[4] | initPtr[5] | initPtr[6] | initPtr[7]) == 0;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfDynamicDataPointerIsEmpty,The following statement contains a magic number: return (initPtr[0] | initPtr[1] | initPtr[2] | initPtr[3] | initPtr[4] | initPtr[5] | initPtr[6] | initPtr[7]) == 0;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfDynamicDataPointerIsEmpty,The following statement contains a magic number: return (initPtr[0] | initPtr[1] | initPtr[2] | initPtr[3] | initPtr[4] | initPtr[5] | initPtr[6] | initPtr[7]) == 0;
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_IfPointerIsEmpty,The following statement contains a magic number: switch (DefaultPointerLen)              {                  case 5:     //Gives ability to allocate file up to 1 terrabyte (1.099.511.627.775)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4]) == 0;                  case 8:     //UINT64.Max                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6] | ptr[7]) == 0;                  case 4:     //4GB                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3]) == 0;                  case 3:     //17MB                      return (ptr[0] | ptr[1] | ptr[2]) == 0;                  case 6:     //281 Terrabytes (281.474.976.710.655)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5]) == 0;                  case 7:      //72 Petabytes (72.057.594.037.927.935)                      return (ptr[0] | ptr[1] | ptr[2] | ptr[3] | ptr[4] | ptr[5] | ptr[6]) == 0;                  case 2:      //65 KB                      return (ptr[0] | ptr[1]) == 0;                  default:                      return ptr._ByteArrayEquals(new byte[DefaultPointerLen]);              }
Magic Number,DBreeze.Utils,BytesProcessing,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,_ByteArrayEquals_EqualityBrokenIndex,The following statement contains a magic number: return -2;
Magic Number,DBreeze.Utils,Crc16,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ComputeChecksum,The following statement contains a magic number: for (int i = 0; i < bytes.Length; ++i)                  {                      byte index = (byte)(crc ^ bytes[i]);                      crc = (ushort)((crc >> 8) ^ Crc16.table[index]);                  }
Magic Number,DBreeze.Utils,Crc16,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,ComputeChecksumBytes,The following statement contains a magic number: return new byte[] { (byte)(crc >> 8)' (byte)(crc & 0x00ff) };
Magic Number,DBreeze.Utils,Crc16,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\BytesProcessing.cs,InitializeMe,The following statement contains a magic number: for (ushort i = 0; i < table.Length; ++i)                  {                      value = 0;                      temp = i;                      for (byte j = 0; j < 8; ++j)                      {                          if (((value ^ temp) & 0x0001) != 0)                          {                              value = (ushort)((value >> 1) ^ polynomial);                          }                          else                          {                              value >>= 1;                          }                          temp >>= 1;                      }                      Crc16.table[i] = value;                  }
Magic Number,DBreeze.Utils,Compression,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Compression.cs,GZip_Decompress,The following statement contains a magic number: int length = 100000;
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MixedMurMurHash3_128,The following statement contains a magic number: return ((((ulong)MurmurHash3(data' 42)) << 32) | ((ulong)MurmurHash3(data' 37))).To_8_bytes_array_BigEndian()                  .Concat(                  ((((ulong)MurmurHash3(data' 26)) << 32) | ((ulong)MurmurHash3(data' 7))).To_8_bytes_array_BigEndian()                  );
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MixedMurMurHash3_128,The following statement contains a magic number: return ((((ulong)MurmurHash3(data' 42)) << 32) | ((ulong)MurmurHash3(data' 37))).To_8_bytes_array_BigEndian()                  .Concat(                  ((((ulong)MurmurHash3(data' 26)) << 32) | ((ulong)MurmurHash3(data' 7))).To_8_bytes_array_BigEndian()                  );
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MixedMurMurHash3_128,The following statement contains a magic number: return ((((ulong)MurmurHash3(data' 42)) << 32) | ((ulong)MurmurHash3(data' 37))).To_8_bytes_array_BigEndian()                  .Concat(                  ((((ulong)MurmurHash3(data' 26)) << 32) | ((ulong)MurmurHash3(data' 7))).To_8_bytes_array_BigEndian()                  );
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MixedMurMurHash3_128,The following statement contains a magic number: return ((((ulong)MurmurHash3(data' 42)) << 32) | ((ulong)MurmurHash3(data' 37))).To_8_bytes_array_BigEndian()                  .Concat(                  ((((ulong)MurmurHash3(data' 26)) << 32) | ((ulong)MurmurHash3(data' 7))).To_8_bytes_array_BigEndian()                  );
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MixedMurMurHash3_128,The following statement contains a magic number: return ((((ulong)MurmurHash3(data' 42)) << 32) | ((ulong)MurmurHash3(data' 37))).To_8_bytes_array_BigEndian()                  .Concat(                  ((((ulong)MurmurHash3(data' 26)) << 32) | ((ulong)MurmurHash3(data' 7))).To_8_bytes_array_BigEndian()                  );
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MixedMurMurHash3_128,The following statement contains a magic number: return ((((ulong)MurmurHash3(data' 42)) << 32) | ((ulong)MurmurHash3(data' 37))).To_8_bytes_array_BigEndian()                  .Concat(                  ((((ulong)MurmurHash3(data' 26)) << 32) | ((ulong)MurmurHash3(data' 7))).To_8_bytes_array_BigEndian()                  );
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MixedMurMurHash3_64,The following statement contains a magic number: return (((ulong)MurmurHash3(data' 42)) << 32) | ((ulong)MurmurHash3(data' 37));
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MixedMurMurHash3_64,The following statement contains a magic number: return (((ulong)MurmurHash3(data' 42)) << 32) | ((ulong)MurmurHash3(data' 37));
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MixedMurMurHash3_64,The following statement contains a magic number: return (((ulong)MurmurHash3(data' 42)) << 32) | ((ulong)MurmurHash3(data' 37));
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MurmurHash3,The following statement contains a magic number: while (curLength >= 4)              {                  /* Get four bytes from the input into an UInt32 */                  k1 = (uint)(data[currentIndex++]                    | data[currentIndex++] << 8                    | data[currentIndex++] << 16                    | data[currentIndex++] << 24);                    /* bitmagic hash */                  k1 *= c1;                  k1 = rotl32(k1' 15);                  k1 *= c2;                    h1 ^= k1;                  h1 = rotl32(h1' 13);                  h1 = h1 * 5 + 0xe6546b64;                  curLength -= 4;              }
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MurmurHash3,The following statement contains a magic number: while (curLength >= 4)              {                  /* Get four bytes from the input into an UInt32 */                  k1 = (uint)(data[currentIndex++]                    | data[currentIndex++] << 8                    | data[currentIndex++] << 16                    | data[currentIndex++] << 24);                    /* bitmagic hash */                  k1 *= c1;                  k1 = rotl32(k1' 15);                  k1 *= c2;                    h1 ^= k1;                  h1 = rotl32(h1' 13);                  h1 = h1 * 5 + 0xe6546b64;                  curLength -= 4;              }
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MurmurHash3,The following statement contains a magic number: while (curLength >= 4)              {                  /* Get four bytes from the input into an UInt32 */                  k1 = (uint)(data[currentIndex++]                    | data[currentIndex++] << 8                    | data[currentIndex++] << 16                    | data[currentIndex++] << 24);                    /* bitmagic hash */                  k1 *= c1;                  k1 = rotl32(k1' 15);                  k1 *= c2;                    h1 ^= k1;                  h1 = rotl32(h1' 13);                  h1 = h1 * 5 + 0xe6546b64;                  curLength -= 4;              }
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MurmurHash3,The following statement contains a magic number: while (curLength >= 4)              {                  /* Get four bytes from the input into an UInt32 */                  k1 = (uint)(data[currentIndex++]                    | data[currentIndex++] << 8                    | data[currentIndex++] << 16                    | data[currentIndex++] << 24);                    /* bitmagic hash */                  k1 *= c1;                  k1 = rotl32(k1' 15);                  k1 *= c2;                    h1 ^= k1;                  h1 = rotl32(h1' 13);                  h1 = h1 * 5 + 0xe6546b64;                  curLength -= 4;              }
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MurmurHash3,The following statement contains a magic number: while (curLength >= 4)              {                  /* Get four bytes from the input into an UInt32 */                  k1 = (uint)(data[currentIndex++]                    | data[currentIndex++] << 8                    | data[currentIndex++] << 16                    | data[currentIndex++] << 24);                    /* bitmagic hash */                  k1 *= c1;                  k1 = rotl32(k1' 15);                  k1 *= c2;                    h1 ^= k1;                  h1 = rotl32(h1' 13);                  h1 = h1 * 5 + 0xe6546b64;                  curLength -= 4;              }
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MurmurHash3,The following statement contains a magic number: while (curLength >= 4)              {                  /* Get four bytes from the input into an UInt32 */                  k1 = (uint)(data[currentIndex++]                    | data[currentIndex++] << 8                    | data[currentIndex++] << 16                    | data[currentIndex++] << 24);                    /* bitmagic hash */                  k1 *= c1;                  k1 = rotl32(k1' 15);                  k1 *= c2;                    h1 ^= k1;                  h1 = rotl32(h1' 13);                  h1 = h1 * 5 + 0xe6546b64;                  curLength -= 4;              }
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MurmurHash3,The following statement contains a magic number: while (curLength >= 4)              {                  /* Get four bytes from the input into an UInt32 */                  k1 = (uint)(data[currentIndex++]                    | data[currentIndex++] << 8                    | data[currentIndex++] << 16                    | data[currentIndex++] << 24);                    /* bitmagic hash */                  k1 *= c1;                  k1 = rotl32(k1' 15);                  k1 *= c2;                    h1 ^= k1;                  h1 = rotl32(h1' 13);                  h1 = h1 * 5 + 0xe6546b64;                  curLength -= 4;              }
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MurmurHash3,The following statement contains a magic number: while (curLength >= 4)              {                  /* Get four bytes from the input into an UInt32 */                  k1 = (uint)(data[currentIndex++]                    | data[currentIndex++] << 8                    | data[currentIndex++] << 16                    | data[currentIndex++] << 24);                    /* bitmagic hash */                  k1 *= c1;                  k1 = rotl32(k1' 15);                  k1 *= c2;                    h1 ^= k1;                  h1 = rotl32(h1' 13);                  h1 = h1 * 5 + 0xe6546b64;                  curLength -= 4;              }
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MurmurHash3,The following statement contains a magic number: switch (curLength)              {                  case 3:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8                        | data[currentIndex++] << 16);                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 2:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8);                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 1:                      k1 = data[currentIndex++];                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;              }
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MurmurHash3,The following statement contains a magic number: switch (curLength)              {                  case 3:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8                        | data[currentIndex++] << 16);                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 2:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8);                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 1:                      k1 = data[currentIndex++];                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;              }
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MurmurHash3,The following statement contains a magic number: switch (curLength)              {                  case 3:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8                        | data[currentIndex++] << 16);                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 2:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8);                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 1:                      k1 = data[currentIndex++];                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;              }
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MurmurHash3,The following statement contains a magic number: switch (curLength)              {                  case 3:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8                        | data[currentIndex++] << 16);                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 2:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8);                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 1:                      k1 = data[currentIndex++];                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;              }
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MurmurHash3,The following statement contains a magic number: switch (curLength)              {                  case 3:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8                        | data[currentIndex++] << 16);                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 2:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8);                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 1:                      k1 = data[currentIndex++];                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;              }
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MurmurHash3,The following statement contains a magic number: switch (curLength)              {                  case 3:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8                        | data[currentIndex++] << 16);                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 2:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8);                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 1:                      k1 = data[currentIndex++];                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;              }
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MurmurHash3,The following statement contains a magic number: switch (curLength)              {                  case 3:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8                        | data[currentIndex++] << 16);                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 2:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8);                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 1:                      k1 = data[currentIndex++];                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;              }
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MurmurHash3,The following statement contains a magic number: switch (curLength)              {                  case 3:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8                        | data[currentIndex++] << 16);                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 2:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8);                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 1:                      k1 = data[currentIndex++];                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;              }
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,rotl32,The following statement contains a magic number: return (x << r) | (x >> (32 - r));
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,fmix,The following statement contains a magic number: h ^= h >> 16;
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,fmix,The following statement contains a magic number: h ^= h >> 13;
Magic Number,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,fmix,The following statement contains a magic number: h ^= h >> 16;
Magic Number,DBreeze.LianaTrie.Iterations,Backward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Backward.cs,ItBwdStartFrom,The following statement contains a magic number: if (keyIsFound)              {                  startFrom = 255; //will check starting from KidsValue and then 0-255              }              else              {                  //Kid is still not found                  if (generationMapLine.Length > initialKey.Length)                  {                      startFrom = 256;            //must be 256                          }                  else                  {                      startFrom = initialKey[generationMapLine.Length - 1];                  }              }
Magic Number,DBreeze.LianaTrie.Iterations,Backward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Backward.cs,ItBwdStartFrom,The following statement contains a magic number: if (keyIsFound)              {                  startFrom = 255; //will check starting from KidsValue and then 0-255              }              else              {                  //Kid is still not found                  if (generationMapLine.Length > initialKey.Length)                  {                      startFrom = 256;            //must be 256                          }                  else                  {                      startFrom = initialKey[generationMapLine.Length - 1];                  }              }
Magic Number,DBreeze.LianaTrie.Iterations,Backward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Backward.cs,ItBwdStartFrom,The following statement contains a magic number: foreach (var kd in gn.KidsInNode.GetKidsBackward(startFrom))              {                  if (kd.ValueKid || !kd.LinkToNode)                  {                      //Value Kid                              if (ReturnKeyValuePair)                      {                          this._root.Tree.Cache.ReadKeyValue(useCache' kd.Ptr' out valueStartPtr' out valueLength' out key' out xValue);                                             }                      else                      {                          key = this._root.Tree.Cache.ReadKey(useCache' kd.Ptr);                      }                        if (keyIsFound)                      {                          //We return this one key                            row = new LTrieRow(this._root);                            if (ReturnKeyValuePair)                          {                              row.ValueStartPointer = valueStartPtr;                              row.ValueFullLength = valueLength;                              row.Value = xValue;                              row.ValueIsReadOut = true;                          }                                                    row.Key = key;                          row.LinkToValue = kd.Ptr;                          yield return row;                      }                      else                      {                                                 //Checking if key equals to the found element' bigger or smaller                            //Key is still not found                             if ((includeStartKey) ? key.IfStringArraySmallerOrEqualThen(initialKey) : key.IfStringArraySmallerThen(initialKey))                          //if (key.IfStringArraySmallerThen(initialKey))                          //if (IfFirstKeyIsSmallerThenCompareKey(key' initialKey))                          {                              keyIsFound = true;                                                            //We return this one key                                                               row = new LTrieRow(this._root);                                if (ReturnKeyValuePair)                              {                                  row.ValueStartPointer = valueStartPtr;                                  row.ValueFullLength = valueLength;                                  row.Value = xValue;                                  row.ValueIsReadOut = true;                              }                                row.Key = key;                              row.LinkToValue = kd.Ptr;                              yield return row;                          }                      }                  }                  else                  {                      if (!keyIsFound && startFrom != 256 && startFrom > kd.Val)                          keyIsFound = true;                        //It's a Link To Node' gettign new generation Node                      LTrieGenerationNode gn1 = new LTrieGenerationNode(this._root);                      gn1.Pointer = kd.Ptr;                      gn1.Value = (byte)kd.Val;                      gml = generationMapLine.Concat(gn1.Value);                      gn1.ReadSelf(useCache' gml);                      //generationMapLine = generationMapLine.Concat(gn1.Value);                      //gn1.ReadSelf(useCache' generationMapLine);                        //foreach (var xr in ItBwdStartFrom(gn1' generationMapLine' useCache))                      foreach (var xr in ItBwdStartFrom(gn1' gml' useCache))                      {                          yield return xr;                      }                  }              }
Magic Number,DBreeze.LianaTrie.Iterations,Backward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Backward.cs,ItBwdFromTo,The following statement contains a magic number: if (keyIsFound)              {                  startFrom = 255; //will check starting from KidsValue and then 0-255              }              else              {                  //Kid is still not found                  if (generationMapLine.Length > initialKey.Length)                  {                      startFrom = 256;                  }                  else                  {                      startFrom = initialKey[generationMapLine.Length - 1];                  }              }
Magic Number,DBreeze.LianaTrie.Iterations,Backward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Backward.cs,ItBwdFromTo,The following statement contains a magic number: if (keyIsFound)              {                  startFrom = 255; //will check starting from KidsValue and then 0-255              }              else              {                  //Kid is still not found                  if (generationMapLine.Length > initialKey.Length)                  {                      startFrom = 256;                  }                  else                  {                      startFrom = initialKey[generationMapLine.Length - 1];                  }              }
Magic Number,DBreeze.LianaTrie.Iterations,Backward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Backward.cs,ItBwdFromTo,The following statement contains a magic number: foreach (var kd in gn.KidsInNode.GetKidsBackward(startFrom))              {                      if (kd.ValueKid || !kd.LinkToNode)                  {                      //Value Kid                            if (ReturnKeyValuePair)                      {                          this._root.Tree.Cache.ReadKeyValue(useCache' kd.Ptr' out valueStartPtr' out valueLength' out key' out xValue);                      }                      else                      {                          key = this._root.Tree.Cache.ReadKey(useCache' kd.Ptr);                      }                        if (keyIsFound)                      {                          //We return this one key                            if ((includeStopKey) ? key.IfStringArrayBiggerOrEqualThen(endKey) : key.IfStringArrayBiggerThen(endKey))                          {                              row = new LTrieRow(this._root);                                if (ReturnKeyValuePair)                              {                                  row.ValueStartPointer = valueStartPtr;                                  row.ValueFullLength = valueLength;                                  row.Value = xValue;                                  row.ValueIsReadOut = true;                              }                              row.Key = key;                              row.LinkToValue = kd.Ptr;                              yield return row;                          }                          else                          {                              yield return null;                              break;                          }                      }                      else                      {                          //Checking if key equals to the found element' bigger or smaller                            //Key is still not found                             if ((includeStartKey) ? key.IfStringArraySmallerOrEqualThen(initialKey) : key.IfStringArraySmallerThen(initialKey))                          {                              keyIsFound = true;                                if ((includeStopKey) ? key.IfStringArrayBiggerOrEqualThen(endKey) : key.IfStringArrayBiggerThen(endKey))                              {                                  //We return this one key                                                          row = new LTrieRow(this._root);                                  if (ReturnKeyValuePair)                                  {                                      row.ValueStartPointer = valueStartPtr;                                      row.ValueFullLength = valueLength;                                      row.Value = xValue;                                      row.ValueIsReadOut = true;                                  }                                  row.Key = key;                                  row.LinkToValue = kd.Ptr;                                  yield return row;                              }                              else                              {                                  yield return null;                                  break;                              }                          }                      }                  }                  else                  {                      if (!keyIsFound && startFrom != 256 && startFrom > kd.Val)                          keyIsFound = true;                        //It's a Link To Node' gettign new generation Node                      LTrieGenerationNode gn1 = new LTrieGenerationNode(this._root);                      gn1.Pointer = kd.Ptr;                      gn1.Value = (byte)kd.Val;                      gml = generationMapLine.Concat(gn1.Value);                      gn1.ReadSelf(useCache' gml);                      //generationMapLine = generationMapLine.Concat(gn1.Value);                      //gn1.ReadSelf(useCache' generationMapLine);                        //foreach (var xr in ItBwdFromTo(gn1' generationMapLine' useCache))                      foreach (var xr in ItBwdFromTo(gn1' gml' useCache))                      {                          if (xr == null)                          {                              yield return null;                              break;                          }                          yield return xr;                      }                  }              }
Magic Number,DBreeze.LianaTrie.Iterations,Backward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Backward.cs,ItBwdSkipFrom,The following statement contains a magic number: if (keyIsFound)              {                  startFrom = 255; //will check starting from KidsValue and then 0-255              }              else              {                  //Kid is still not found                  if (generationMapLine.Length > initialKey.Length)                  {                      startFrom = 256;                  }                  else                  {                      startFrom = initialKey[generationMapLine.Length - 1];                  }              }
Magic Number,DBreeze.LianaTrie.Iterations,Backward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Backward.cs,ItBwdSkipFrom,The following statement contains a magic number: if (keyIsFound)              {                  startFrom = 255; //will check starting from KidsValue and then 0-255              }              else              {                  //Kid is still not found                  if (generationMapLine.Length > initialKey.Length)                  {                      startFrom = 256;                  }                  else                  {                      startFrom = initialKey[generationMapLine.Length - 1];                  }              }
Magic Number,DBreeze.LianaTrie.Iterations,Forward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Forward.cs,ItFrwStartFrom,The following statement contains a magic number: if (keyIsFound)              {                  startFrom = 256; //will check starting from KidsValue and then 0-255              }              else              {                  //Kid is still not found                  if (generationMapLine.Length > initialKey.Length)                  {                      startFrom = 256;                  }                  else                  {                      startFrom = initialKey[generationMapLine.Length - 1];                  }              }
Magic Number,DBreeze.LianaTrie.Iterations,Forward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Forward.cs,ItFrwStartFrom,The following statement contains a magic number: if (keyIsFound)              {                  startFrom = 256; //will check starting from KidsValue and then 0-255              }              else              {                  //Kid is still not found                  if (generationMapLine.Length > initialKey.Length)                  {                      startFrom = 256;                  }                  else                  {                      startFrom = initialKey[generationMapLine.Length - 1];                  }              }
Magic Number,DBreeze.LianaTrie.Iterations,Forward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Forward.cs,ItFrwStartFrom,The following statement contains a magic number: foreach (var kd in gn.KidsInNode.GetKidsForward(startFrom))              {                  if (kd.ValueKid || !kd.LinkToNode)                  {                      //Value Kid                                                    if (keyIsFound)                      {                          //We return this one key                          if (ReturnKeyValuePair)                          {                              this._root.Tree.Cache.ReadKeyValue(useCache' kd.Ptr' out valueStartPtr' out valueLength' out key' out xValue);                          }                          else                          {                              key = this._root.Tree.Cache.ReadKey(useCache' kd.Ptr);                          }                            row = new LTrieRow(this._root);                          if (ReturnKeyValuePair)                          {                              row.ValueStartPointer = valueStartPtr;                              row.ValueFullLength = valueLength;                              row.Value = xValue;                              row.ValueIsReadOut = true;                          }                          row.Key = key;                          row.LinkToValue = kd.Ptr;                          yield return row;                      }                      else                      {                          key = this._root.Tree.Cache.ReadKey(useCache' kd.Ptr);                          //Checking if key equals to the found element' bigger or smaller                            //Key is still not found                             if ((includeStartKey) ? key.IfStringArrayBiggerOrEqualThen(initialKey) : key.IfStringArrayBiggerThen(initialKey))                          //if (key.IfStringArrayBiggerThen(initialKey))                          //if (IfFirstKeyIsBiggerThenCompareKey(key' initialKey))                          {                              keyIsFound = true;                                //We return this one key                                                      row = new LTrieRow(this._root);                              row.Key = key;                              row.LinkToValue = kd.Ptr;                              yield return row;                          }                                                }                  }                  else                  {                      if (!keyIsFound && startFrom != 256 && startFrom < kd.Val)                          keyIsFound = true;                        //It's a Link To Node' gettign new generation Node                      LTrieGenerationNode gn1 = new LTrieGenerationNode(this._root);                      gn1.Pointer = kd.Ptr;                      gn1.Value = (byte)kd.Val;                      gml = generationMapLine.Concat(gn1.Value);                      gn1.ReadSelf(useCache' gml);                      //generationMapLine = generationMapLine.Concat(gn1.Value);                      //gn1.ReadSelf(useCache' generationMapLine);                        //foreach (var xr in ItFrwStartFrom(gn1' generationMapLine' useCache))                      foreach (var xr in ItFrwStartFrom(gn1' gml' useCache))                      {                          yield return xr;                      }                  }              }
Magic Number,DBreeze.LianaTrie.Iterations,Forward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Forward.cs,ItFrwFromTo,The following statement contains a magic number: if (keyIsFound)              {                  startFrom = 256; //will check starting from KidsValue and then 0-255              }              else              {                  //Kid is still not found                  if (generationMapLine.Length > initialKey.Length)                  {                      startFrom = 256;                  }                  else                  {                      startFrom = initialKey[generationMapLine.Length - 1];                  }              }
Magic Number,DBreeze.LianaTrie.Iterations,Forward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Forward.cs,ItFrwFromTo,The following statement contains a magic number: if (keyIsFound)              {                  startFrom = 256; //will check starting from KidsValue and then 0-255              }              else              {                  //Kid is still not found                  if (generationMapLine.Length > initialKey.Length)                  {                      startFrom = 256;                  }                  else                  {                      startFrom = initialKey[generationMapLine.Length - 1];                  }              }
Magic Number,DBreeze.LianaTrie.Iterations,Forward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Forward.cs,ItFrwFromTo,The following statement contains a magic number: foreach (var kd in gn.KidsInNode.GetKidsForward(startFrom))              {                  if (kd.ValueKid || !kd.LinkToNode)                  {                      //Value Kid                            if (ReturnKeyValuePair)                      {                          this._root.Tree.Cache.ReadKeyValue(useCache' kd.Ptr' out valueStartPtr' out valueLength' out key' out xValue);                      }                      else                      {                          key = this._root.Tree.Cache.ReadKey(useCache' kd.Ptr);                      }                        if (keyIsFound)                      {                          //We return this one key                          if ((includeStopKey) ? key.IfStringArraySmallerOrEqualThen(endKey) : key.IfStringArraySmallerThen(endKey))                          {                              row = new LTrieRow(this._root);                              if (ReturnKeyValuePair)                              {                                  row.ValueStartPointer = valueStartPtr;                                  row.ValueFullLength = valueLength;                                  row.Value = xValue;                                  row.ValueIsReadOut = true;                              }                              row.Key = key;                              row.LinkToValue = kd.Ptr;                              yield return row;                          }                          else                          {                              yield return null;                              break;                          }                      }                      else                      {                          //Checking if key equals to the found element' bigger or smaller                            //Key is still not found                             if ((includeStartKey) ? key.IfStringArrayBiggerOrEqualThen(initialKey) : key.IfStringArrayBiggerThen(initialKey))                          //if (key.IfStringArrayBiggerThen(initialKey))                          //if (IfFirstKeyIsBiggerThenCompareKey(key' initialKey))                          {                              keyIsFound = true;                                if ((includeStopKey) ? key.IfStringArraySmallerOrEqualThen(endKey) : key.IfStringArraySmallerThen(endKey))                              {                                  //We return this one key                                                          row = new LTrieRow(this._root);                                  if (ReturnKeyValuePair)                                  {                                      row.ValueStartPointer = valueStartPtr;                                      row.ValueFullLength = valueLength;                                      row.Value = xValue;                                      row.ValueIsReadOut = true;                                  }                                  row.Key = key;                                  row.LinkToValue = kd.Ptr;                                  yield return row;                              }                              else                              {                                  yield return null;                                  break;                              }                          }                          //else                          //    break;                      }                  }                  else                  {                      if (!keyIsFound && startFrom != 256 && startFrom < kd.Val)                          keyIsFound = true;                          //It's a Link To Node' gettign new generation Node                      LTrieGenerationNode gn1 = new LTrieGenerationNode(this._root);                      gn1.Pointer = kd.Ptr;                      gn1.Value = (byte)kd.Val;                      gml = generationMapLine.Concat(gn1.Value);                      gn1.ReadSelf(useCache' gml);                      //generationMapLine = generationMapLine.Concat(gn1.Value);                      //gn1.ReadSelf(useCache' generationMapLine);                        //foreach (var xr in ItFrwFromTo(gn1' generationMapLine' useCache))                      foreach (var xr in ItFrwFromTo(gn1' gml' useCache))                      {                          if (xr == null)                          {                              yield return null;                              break;                          }                          yield return xr;                      }                  }              }
Magic Number,DBreeze.LianaTrie.Iterations,Forward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Forward.cs,ItFrwSkipFrom,The following statement contains a magic number: if (keyIsFound)              {                  startFrom = 256; //will check starting from KidsValue and then 0-255              }              else              {                  //Kid is still not found                  if (generationMapLine.Length > initialKey.Length)                  {                      startFrom = 256;                  }                  else                  {                      startFrom = initialKey[generationMapLine.Length - 1];                  }              }
Magic Number,DBreeze.LianaTrie.Iterations,Forward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Forward.cs,ItFrwSkipFrom,The following statement contains a magic number: if (keyIsFound)              {                  startFrom = 256; //will check starting from KidsValue and then 0-255              }              else              {                  //Kid is still not found                  if (generationMapLine.Length > initialKey.Length)                  {                      startFrom = 256;                  }                  else                  {                      startFrom = initialKey[generationMapLine.Length - 1];                  }              }
Magic Number,DBreeze.TextSearch,SBlock,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\SBlock.cs,CreateBlock,The following statement contains a magic number: if (block._tsm == null)              {                  //Creating real block                  block._tsm = this._tsm;                  block.BlockId = this._tsm.cntBlockId++;                  this._tsm.WordsPrepare(block._fullMatchWords.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries).Where(r => r.Length > 2)' true' ref block.ParsedWords);                  this._tsm.WordsPrepare(block._containsWords.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries).Where(r => r.Length > 2)' false' ref block.ParsedWords);                  this._tsm.toComputeWordsOrigin = true;                  this._tsm.Blocks[block.BlockId] = block;              }
Magic Number,DBreeze.TextSearch,SBlock,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\SBlock.cs,CreateBlock,The following statement contains a magic number: if (block._tsm == null)              {                  //Creating real block                  block._tsm = this._tsm;                  block.BlockId = this._tsm.cntBlockId++;                  this._tsm.WordsPrepare(block._fullMatchWords.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries).Where(r => r.Length > 2)' true' ref block.ParsedWords);                  this._tsm.WordsPrepare(block._containsWords.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries).Where(r => r.Length > 2)' false' ref block.ParsedWords);                  this._tsm.toComputeWordsOrigin = true;                  this._tsm.Blocks[block.BlockId] = block;              }
Magic Number,DBreeze.TextSearch,TextDeferredIndexer,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextDeferredIndexer.cs,TextDeferredIndexer,The following statement contains a magic number: if (LTrie.Storage.Length > 100000)  //Recreating file if its size more then 100KB and it is empty              {                  if (LTrie.Count(true) == 0)                  {                      LTrie.Storage.RecreateFiles();                      LTrie.Dispose();                        Storage = new StorageLayer(Path.Combine(engine.MainFolder' TableFileName)' LTrieSettings' engine.Configuration);                      LTrie = new LTrie(Storage);                      LTrie.TableName = "DBreeze.TextIndexer";                  }              }
Magic Number,DBreeze.TextSearch,TextDeferredIndexer,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextDeferredIndexer.cs,Indexer,The following statement contains a magic number: int maximalIterations = 10;
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,GetDocumentsSearchables,The following statement contains a magic number: its = new ITS()              {                  e2i = tran.SelectTable<byte>(tableName' 1' 0)'                  srch = tran.SelectTable<byte>(tableName' 3' 0)'              };
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,InsertDocumentText,The following statement contains a magic number: if (!itbls.TryGetValue(tableName' out its))              {                  its = new ITS()                  {                      e2i = tran.InsertTable<byte>(tableName' 1' 0)'                      i2e = tran.InsertTable<byte>(tableName' 2' 0)'                      srch = tran.InsertTable<byte>(tableName' 3' 0)'                  };                    its.e2i.ValuesLazyLoadingIsOn = false;                  its.i2e.ValuesLazyLoadingIsOn = false;                  its.srch.ValuesLazyLoadingIsOn = false;                    itbls.Add(tableName' its);              }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,InsertDocumentText,The following statement contains a magic number: if (!itbls.TryGetValue(tableName' out its))              {                  its = new ITS()                  {                      e2i = tran.InsertTable<byte>(tableName' 1' 0)'                      i2e = tran.InsertTable<byte>(tableName' 2' 0)'                      srch = tran.InsertTable<byte>(tableName' 3' 0)'                  };                    its.e2i.ValuesLazyLoadingIsOn = false;                  its.i2e.ValuesLazyLoadingIsOn = false;                  its.srch.ValuesLazyLoadingIsOn = false;                    itbls.Add(tableName' its);              }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The following statement contains a magic number: foreach (var tbl in xitbls)              {                  its = tbl.Value;                  if (its.srch == null)   //Can be instantiated in insert procedure' depending how we use indexer                  {                      its.srch = itran.InsertTable<byte>(tbl.Key' 3' 0);                      its.srch.ValuesLazyLoadingIsOn = false;                  }                  //Are instantiated only hear                  its.blocks = itran.InsertTable<byte>(tbl.Key' 10' 0);                  its.words = itran.InsertTable<byte>(tbl.Key' 20' 0);                  its.currentBlock = itran.Select<int' uint>(tbl.Key' 11).Value;                  its.numberInBlock = itran.Select<int' uint>(tbl.Key' 12).Value;                                    its.blocks.ValuesLazyLoadingIsOn = false;                  its.words.ValuesLazyLoadingIsOn = false;                    if (its.currentBlock == 0)                  {                      its.numberInBlock = 0;                      its.currentBlock = 1;                  }                    //Getting latest indexing time for that table                  var litRow = itran.Select<byte' byte[]>(tbl.Key' 4);                  byte[] lastIndexed = DateTime.MinValue.Ticks.To_8_bytes_array_BigEndian();                  if (litRow.Exists)                      lastIndexed = litRow.Value;                    kA = lastIndexed.Concat(int.MinValue.To_4_bytes_array_BigEndian());                  kZ = DateTime.MaxValue.Ticks.To_8_bytes_array_BigEndian().Concat(int.MaxValue.To_4_bytes_array_BigEndian());                    //Key is word' Value.Item1 is documents list from which this word must be removed' Value.Item2 is documents List where word must be added                  Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>> ds = new Dictionary<string' Tuple<HashSet<int>' HashSet<int>' WordInDocs>>();                  Tuple<HashSet<int>' HashSet<int>' WordInDocs> tpl = null;                    //Dictionary<string' byte[]> tmpWrds = new Dictionary<string' byte[]>(StringComparison.Ordinal);                  var tmpWrds = new SortedDictionary<string' byte[]>(StringComparer.Ordinal);                    Action<string> createNew = (word) =>                  {                      if (!tmpWrds.ContainsKey(word))                      {                          rWord = its.words.Select<string' byte[]>(word' true);                          wd = new WordInDocs();                            if (rWord.Exists)                          {                              wd.BlockId = rWord.Value.Substring(0' 4).To_UInt32_BigEndian();                              wd.NumberInBlock = rWord.Value.Substring(4' 4).To_UInt32_BigEndian();                          }                          else                          {                              its.numberInBlock++;                                if (its.numberInBlock > itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.QuantityOfWordsInBlock)  //Quantity of words (WAHs) in block                              {                                  its.currentBlock++;                                  its.numberInBlock = 1;                              }                                wd.BlockId = its.currentBlock;                              wd.NumberInBlock = its.numberInBlock;                              //Inserting new definition                                    // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                              if (tmpWrds.Count < 100000)                                  tmpWrds[word] = wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian());                              else                              {                                  // its.words.Insert<string' byte[]>(word' wd.BlockId.To_4_bytes_array_BigEndian().Concat(wd.NumberInBlock.To_4_bytes_array_BigEndian()));                                    foreach (var tmpwrd in tmpWrds)                                  {                                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                                    }                                  tmpWrds.Clear();                              }                            }                          tpl = new Tuple<HashSet<int>' HashSet<int>' WordInDocs>(new HashSet<int>()' new HashSet<int>()' wd);                          ds[word] = tpl;                      }                  };                    //List<byte[]> docs2Change = new List<byte[]>();                  Dictionary<byte[]'byte[]> docs2Change = new Dictionary<byte[]'byte[]>();                  Tuple<HashSet<string>' HashSet<string>> diff;                                                      //foreach (var docId in its.ChangedDocIds)                  foreach (var docId in its.ChangedDocIds.OrderBy(r=>r))                  {                        //diff will return list of words to be removed and list of words to be added                                         oldSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })).Value;                      newSrch = its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })).Value;                        diff = WordsDiff(                                  oldSrch' //Current searchables                                   newSrch //new                                  );                        //diff = WordsDiff(                      //            its.srch.Select<byte[]' byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 })' true).Value' //Current searchables                       //            newSrch //new                      //            );                        //Copying new searchables to current searchables                      docs2Change.Add(docId.To_4_bytes_array_BigEndian()' newSrch);                      //its.srch.ChangeKey<byte[]>(docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 1 })' docId.To_4_bytes_array_BigEndian().Concat(new byte[] { 0 }));                          //To be removed                      foreach (var word in diff.Item1)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item1.Add(docId);                      }                        //To be added                      foreach (var word in diff.Item2)                      {                          if (!ds.TryGetValue(word' out tpl))                              createNew(word);                            tpl.Item2.Add(docId);                      }                  }//eo foreach new searchables' end of document itteration                                       foreach (var d2c in docs2Change.OrderBy(r=>r.Key.ToBytesString()))                  {                      its.srch.RemoveKey<byte[]>(d2c.Key.Concat(new byte[] { 1 }));                                         its.srch.Insert<byte[]'byte[]>(d2c.Key.Concat(new byte[] { 0 })' d2c.Value);                      // its.srch.ChangeKey<byte[]>(d2c.Concat(new byte[] { 1 })' d2c.Concat(new byte[] { 0 }));                  }                    //foreach (var eeel in its.srch.SelectForward<byte[]' byte[]>(false).Take(50))                  //    Console.WriteLine(eeel.Key.ToBytesString());                    foreach (var tmpwrd in tmpWrds)                  {                      its.words.Insert<string' byte[]>(tmpwrd.Key' tmpwrd.Value);                    }                  tmpWrds.Clear();                      #region "S1"                  //Inserting WAH blocks                  //Going through the list of collected words order by blockID' fill blocks and save them                                    block.Clear();                  iterBlockId = 0;                    foreach (var wd1 in ds.OrderBy(r => r.Value.Item3.BlockId))                  {                      //reading block if it's not loaded                      if (wd1.Value.Item3.BlockId != iterBlockId)                      {                          if (iterBlockId > 0)                          {                              //We must save current datablock                              if (block.Count() > 0)                              {                                    btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                                    if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserv                                  {                                      tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else if ((btBlock.Length + 4) > iterBlockLen)                                  {                                      //Doubling reserve                                      tmp = new byte[btBlock.Length * 2];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                  else                                  {                                      //Filling existing space                                      tmp = new byte[btBlock.Length + 4];                                      tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                                      tmp.CopyInside(4' btBlock);                                  }                                    //Saving into DB                                                                     its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                              }                                block.Clear();                          }                            val = its.blocks.Select<uint' byte[]>(wd1.Value.Item3.BlockId).Value;                          iterBlockId = wd1.Value.Item3.BlockId;                          iterBlockLen = val == null ? 0 : val.Length;                            if (val != null)                          {                              blockSize = val.Substring(0' 4).To_Int32_BigEndian();                              if (blockSize > 0)                              {                                  btBlock = val.Substring(4' blockSize);                                  block.Clear();                                  btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                              }                              else                                  block.Clear();                          }                          else                              block.Clear();                      }                        //Getting from Block                       if (block.TryGetValue((uint)wd1.Value.Item3.NumberInBlock' out btWah))                      {                          wah = new WABI(btWah);                      }                      else                          wah = new WABI(null);                        //Adding documents                      foreach (var dId in wd1.Value.Item2)                          wah.Add(dId' true);                        //Removing documents                      foreach (var dId in wd1.Value.Item1)                          wah.Add(dId' false);                        block[wd1.Value.Item3.NumberInBlock] = wah.GetCompressedByteArray();                    }//eo foreach wds                      //Saving last element                  //saving current block                  if (block.Count() > 0)                  {                      //!!!!!!!!!!! Remake it for smoothing storage                       btBlock = block.Encode_DICT_PROTO_UINT_BYTEARRAY(Compression.eCompressionMethod.Gzip);                        if ((btBlock.Length + 4) < itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes)    //Minimal reserve                      {                          tmp = new byte[itran._transactionUnit.TransactionsCoordinator._engine.Configuration.TextSearchConfig.MinimalBlockReservInBytes];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else if ((btBlock.Length + 4) > iterBlockLen)                      {                          //Doubling reserve                          tmp = new byte[btBlock.Length * 2];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                      else                      {                          //Filling existing space                          tmp = new byte[btBlock.Length + 4];                          tmp.CopyInside(0' btBlock.Length.To_4_bytes_array_BigEndian());                          tmp.CopyInside(4' btBlock);                      }                        //Saving into DB                                its.blocks.Insert<uint' byte[]>(iterBlockId' tmp);                  }                    block.Clear();                  #endregion                    itran.Insert<int' uint>(tbl.Key' 11' its.currentBlock);                  itran.Insert<int' uint>(tbl.Key' 12' its.numberInBlock);                    //Setting last indexing time                  itran.Insert<byte' byte[]>(tbl.Key' 4' btUdtStart);                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,GetWordsDefinitionFromText,The following statement contains a magic number: try              {                  if (String.IsNullOrEmpty(containsWords) && String.IsNullOrEmpty(fullMatchWords))                      return wordsCounter;                    if (containsMinimalLength < 3)                      containsMinimalLength = 3;                    StringBuilder sb = new StringBuilder();                  string word = "";                  WordDefinition wordDefinition = null;                                    //Non splittable words                  foreach (var nswrd in fullMatchWords.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries).Where(r => r.Length >= containsMinimalLength))                  {                                        word = nswrd.ToLower();                      wordDefinition = new WordDefinition() { CountInDocu = 1 };                      wordsCounter[word] = wordDefinition;                  }                    if (String.IsNullOrEmpty(containsWords))                      return wordsCounter;                    Action processWord = () =>                  {                      //We take all words' so we can later find even by email address jj@gmx.net ... we will need jj and gmx.net                      if (sb.Length > 0 && sb.Length >= containsMinimalLength)                      {                          word = sb.ToString().ToLower();                            List<string> wrds = new List<string>();                          wrds.Add(word);                          int i = 1;                            while (word.Length - i >= containsMinimalLength)                          {                              wrds.Add(word.Substring(i));                              i++;                          }                            // System.Diagnostics.Debug.WriteLine("--------------");                          foreach (var w in wrds)                          {                              //System.Diagnostics.Debug.WriteLine(w);                              if (wordsCounter.TryGetValue(w' out wordDefinition))                              {                                  wordDefinition.CountInDocu++;                              }                              else                              {                                  wordDefinition = new WordDefinition() { CountInDocu = 1 };                                  wordsCounter[w] = wordDefinition;                              }                          }                        }                        if (sb.Length > 0)                          sb.Remove(0' sb.Length);                      //sb.Clear();                  };                    int wordLen = 0;                  int maximalWordLengthBeforeSplit = maxWordSize; //Default is 50                    foreach (var c in containsWords)                  {                      //No words reviews (must be checked in outer systems)                      if (c != ' ')                      {                          sb.Append(c);                          wordLen++;                                                    if (wordLen >= maximalWordLengthBeforeSplit)                          {                              //Processing ready word                              processWord();                              wordLen = 0;                          }                      }                      else                      {                          //Processing ready word                          processWord();                          wordLen = 0;                      }                                     }                    //Processing last word                  processWord();                    //if (wordsCounter.Count() > 0)                  //    return wordsCounter;              }              catch              {                }
Magic Number,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,GetWordsDefinitionFromText,The following statement contains a magic number: try              {                  if (String.IsNullOrEmpty(containsWords) && String.IsNullOrEmpty(fullMatchWords))                      return wordsCounter;                    if (containsMinimalLength < 3)                      containsMinimalLength = 3;                    StringBuilder sb = new StringBuilder();                  string word = "";                  WordDefinition wordDefinition = null;                                    //Non splittable words                  foreach (var nswrd in fullMatchWords.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries).Where(r => r.Length >= containsMinimalLength))                  {                                        word = nswrd.ToLower();                      wordDefinition = new WordDefinition() { CountInDocu = 1 };                      wordsCounter[word] = wordDefinition;                  }                    if (String.IsNullOrEmpty(containsWords))                      return wordsCounter;                    Action processWord = () =>                  {                      //We take all words' so we can later find even by email address jj@gmx.net ... we will need jj and gmx.net                      if (sb.Length > 0 && sb.Length >= containsMinimalLength)                      {                          word = sb.ToString().ToLower();                            List<string> wrds = new List<string>();                          wrds.Add(word);                          int i = 1;                            while (word.Length - i >= containsMinimalLength)                          {                              wrds.Add(word.Substring(i));                              i++;                          }                            // System.Diagnostics.Debug.WriteLine("--------------");                          foreach (var w in wrds)                          {                              //System.Diagnostics.Debug.WriteLine(w);                              if (wordsCounter.TryGetValue(w' out wordDefinition))                              {                                  wordDefinition.CountInDocu++;                              }                              else                              {                                  wordDefinition = new WordDefinition() { CountInDocu = 1 };                                  wordsCounter[w] = wordDefinition;                              }                          }                        }                        if (sb.Length > 0)                          sb.Remove(0' sb.Length);                      //sb.Clear();                  };                    int wordLen = 0;                  int maximalWordLengthBeforeSplit = maxWordSize; //Default is 50                    foreach (var c in containsWords)                  {                      //No words reviews (must be checked in outer systems)                      if (c != ' ')                      {                          sb.Append(c);                          wordLen++;                                                    if (wordLen >= maximalWordLengthBeforeSplit)                          {                              //Processing ready word                              processWord();                              wordLen = 0;                          }                      }                      else                      {                          //Processing ready word                          processWord();                          wordLen = 0;                      }                                     }                    //Processing last word                  processWord();                    //if (wordsCounter.Count() > 0)                  //    return wordsCounter;              }              catch              {                }
Magic Number,DBreeze.TextSearch,TextSearchStorageOptions,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchOptions.cs,TextSearchStorageOptions,The following statement contains a magic number: SearchWordContainsLogicMinimalLength = 3;
Magic Number,DBreeze.TextSearch,TextSearchRequest,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchOptions.cs,TextSearchRequest,The following statement contains a magic number: Quantity = 100;
Magic Number,DBreeze.TextSearch,TextSearchRequest,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchOptions.cs,TextSearchRequest,The following statement contains a magic number: NoisyQuantity = 1000;
Magic Number,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,ComputeWordsOrigin,The following statement contains a magic number: if (this.tbWords == null)              {                  if (this._tran == null || String.IsNullOrEmpty(this._tableName))                      throw new Exception("DBreeze.TextSearch.TextSearchTable.ComputeWordsOrigin: transaction is not initialzed");                    this.tbWords = this._tran.SelectTable<byte>(this._tableName' 20' 0);                  this.tbWords.ValuesLazyLoadingIsOn = false;              }
Magic Number,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,ComputeWordsOrigin,The following statement contains a magic number: if (this.tbBlocks == null)              {                  this.tbBlocks = this._tran.SelectTable<byte>(this._tableName' 10' 0);                  this.tbBlocks.ValuesLazyLoadingIsOn = false;              }
Magic Number,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,ComputeWordsOrigin,The following statement contains a magic number: if (this.i2e == null)              {                  i2e = this._tran.SelectTable<byte>(this._tableName' 2' 0);                  i2e.ValuesLazyLoadingIsOn = false;              }
Magic Number,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,ComputeWordsOrigin,The following statement contains a magic number: foreach (var wrd in this.PureWords.Where(r => !r.Value.Processed).OrderBy(r => r.Key))              {                    if (wrd.Value.FullMatch)                  {                      if (this.RealWords.ContainsKey(wrd.Key))                          continue;                      var row2 = this.tbWords.Select<string' byte[]>(wrd.Key);                      if (row2.Exists)                      {                          wid = new TextSearchHandler.WordInDocs()                          {                              BlockId = row2.Value.Substring(0' 4).To_UInt32_BigEndian()'                              NumberInBlock = row2.Value.Substring(4' 4).To_UInt32_BigEndian()                          };                            this.RealWords[wrd.Key] = wid;                      }                  }                  else                  {                      //Contains                      containsFound = 0;                      startsWithEchoes = new HashSet<string>();                      foreach (var row1 in this.tbWords.SelectForwardStartsWith<string' byte[]>(wrd.Key).Take(this.NoisyQuantity))                      {                          containsFound++;                            if (wrd.Key != row1.Key)                              startsWithEchoes.Add(row1.Key);                            if (this.RealWords.ContainsKey(row1.Key))                              continue;                            wid = new TextSearchHandler.WordInDocs()                          {                              BlockId = row1.Value.Substring(0' 4).To_UInt32_BigEndian()'                              NumberInBlock = row1.Value.Substring(4' 4).To_UInt32_BigEndian()                          };                            this.RealWords.Add(row1.Key' wid);                      }                        if (startsWithEchoes.Count > 0)                          wrd.Value.StartsWith = startsWithEchoes;                        if (containsFound == this.NoisyQuantity)                          this.SearchCriteriaIsNoisy = true;                  }                    wrd.Value.Processed = true;              }
Magic Number,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,ComputeWordsOrigin,The following statement contains a magic number: foreach (var wrd in this.PureWords.Where(r => !r.Value.Processed).OrderBy(r => r.Key))              {                    if (wrd.Value.FullMatch)                  {                      if (this.RealWords.ContainsKey(wrd.Key))                          continue;                      var row2 = this.tbWords.Select<string' byte[]>(wrd.Key);                      if (row2.Exists)                      {                          wid = new TextSearchHandler.WordInDocs()                          {                              BlockId = row2.Value.Substring(0' 4).To_UInt32_BigEndian()'                              NumberInBlock = row2.Value.Substring(4' 4).To_UInt32_BigEndian()                          };                            this.RealWords[wrd.Key] = wid;                      }                  }                  else                  {                      //Contains                      containsFound = 0;                      startsWithEchoes = new HashSet<string>();                      foreach (var row1 in this.tbWords.SelectForwardStartsWith<string' byte[]>(wrd.Key).Take(this.NoisyQuantity))                      {                          containsFound++;                            if (wrd.Key != row1.Key)                              startsWithEchoes.Add(row1.Key);                            if (this.RealWords.ContainsKey(row1.Key))                              continue;                            wid = new TextSearchHandler.WordInDocs()                          {                              BlockId = row1.Value.Substring(0' 4).To_UInt32_BigEndian()'                              NumberInBlock = row1.Value.Substring(4' 4).To_UInt32_BigEndian()                          };                            this.RealWords.Add(row1.Key' wid);                      }                        if (startsWithEchoes.Count > 0)                          wrd.Value.StartsWith = startsWithEchoes;                        if (containsFound == this.NoisyQuantity)                          this.SearchCriteriaIsNoisy = true;                  }                    wrd.Value.Processed = true;              }
Magic Number,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,ComputeWordsOrigin,The following statement contains a magic number: foreach (var wrd in this.PureWords.Where(r => !r.Value.Processed).OrderBy(r => r.Key))              {                    if (wrd.Value.FullMatch)                  {                      if (this.RealWords.ContainsKey(wrd.Key))                          continue;                      var row2 = this.tbWords.Select<string' byte[]>(wrd.Key);                      if (row2.Exists)                      {                          wid = new TextSearchHandler.WordInDocs()                          {                              BlockId = row2.Value.Substring(0' 4).To_UInt32_BigEndian()'                              NumberInBlock = row2.Value.Substring(4' 4).To_UInt32_BigEndian()                          };                            this.RealWords[wrd.Key] = wid;                      }                  }                  else                  {                      //Contains                      containsFound = 0;                      startsWithEchoes = new HashSet<string>();                      foreach (var row1 in this.tbWords.SelectForwardStartsWith<string' byte[]>(wrd.Key).Take(this.NoisyQuantity))                      {                          containsFound++;                            if (wrd.Key != row1.Key)                              startsWithEchoes.Add(row1.Key);                            if (this.RealWords.ContainsKey(row1.Key))                              continue;                            wid = new TextSearchHandler.WordInDocs()                          {                              BlockId = row1.Value.Substring(0' 4).To_UInt32_BigEndian()'                              NumberInBlock = row1.Value.Substring(4' 4).To_UInt32_BigEndian()                          };                            this.RealWords.Add(row1.Key' wid);                      }                        if (startsWithEchoes.Count > 0)                          wrd.Value.StartsWith = startsWithEchoes;                        if (containsFound == this.NoisyQuantity)                          this.SearchCriteriaIsNoisy = true;                  }                    wrd.Value.Processed = true;              }
Magic Number,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,ComputeWordsOrigin,The following statement contains a magic number: foreach (var wrd in this.PureWords.Where(r => !r.Value.Processed).OrderBy(r => r.Key))              {                    if (wrd.Value.FullMatch)                  {                      if (this.RealWords.ContainsKey(wrd.Key))                          continue;                      var row2 = this.tbWords.Select<string' byte[]>(wrd.Key);                      if (row2.Exists)                      {                          wid = new TextSearchHandler.WordInDocs()                          {                              BlockId = row2.Value.Substring(0' 4).To_UInt32_BigEndian()'                              NumberInBlock = row2.Value.Substring(4' 4).To_UInt32_BigEndian()                          };                            this.RealWords[wrd.Key] = wid;                      }                  }                  else                  {                      //Contains                      containsFound = 0;                      startsWithEchoes = new HashSet<string>();                      foreach (var row1 in this.tbWords.SelectForwardStartsWith<string' byte[]>(wrd.Key).Take(this.NoisyQuantity))                      {                          containsFound++;                            if (wrd.Key != row1.Key)                              startsWithEchoes.Add(row1.Key);                            if (this.RealWords.ContainsKey(row1.Key))                              continue;                            wid = new TextSearchHandler.WordInDocs()                          {                              BlockId = row1.Value.Substring(0' 4).To_UInt32_BigEndian()'                              NumberInBlock = row1.Value.Substring(4' 4).To_UInt32_BigEndian()                          };                            this.RealWords.Add(row1.Key' wid);                      }                        if (startsWithEchoes.Count > 0)                          wrd.Value.StartsWith = startsWithEchoes;                        if (containsFound == this.NoisyQuantity)                          this.SearchCriteriaIsNoisy = true;                  }                    wrd.Value.Processed = true;              }
Magic Number,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,ComputeWordsOrigin,The following statement contains a magic number: foreach (var wrd in this.PureWords.Where(r => !r.Value.Processed).OrderBy(r => r.Key))              {                    if (wrd.Value.FullMatch)                  {                      if (this.RealWords.ContainsKey(wrd.Key))                          continue;                      var row2 = this.tbWords.Select<string' byte[]>(wrd.Key);                      if (row2.Exists)                      {                          wid = new TextSearchHandler.WordInDocs()                          {                              BlockId = row2.Value.Substring(0' 4).To_UInt32_BigEndian()'                              NumberInBlock = row2.Value.Substring(4' 4).To_UInt32_BigEndian()                          };                            this.RealWords[wrd.Key] = wid;                      }                  }                  else                  {                      //Contains                      containsFound = 0;                      startsWithEchoes = new HashSet<string>();                      foreach (var row1 in this.tbWords.SelectForwardStartsWith<string' byte[]>(wrd.Key).Take(this.NoisyQuantity))                      {                          containsFound++;                            if (wrd.Key != row1.Key)                              startsWithEchoes.Add(row1.Key);                            if (this.RealWords.ContainsKey(row1.Key))                              continue;                            wid = new TextSearchHandler.WordInDocs()                          {                              BlockId = row1.Value.Substring(0' 4).To_UInt32_BigEndian()'                              NumberInBlock = row1.Value.Substring(4' 4).To_UInt32_BigEndian()                          };                            this.RealWords.Add(row1.Key' wid);                      }                        if (startsWithEchoes.Count > 0)                          wrd.Value.StartsWith = startsWithEchoes;                        if (containsFound == this.NoisyQuantity)                          this.SearchCriteriaIsNoisy = true;                  }                    wrd.Value.Processed = true;              }
Magic Number,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,ComputeWordsOrigin,The following statement contains a magic number: foreach (var wrd in this.PureWords.Where(r => !r.Value.Processed).OrderBy(r => r.Key))              {                    if (wrd.Value.FullMatch)                  {                      if (this.RealWords.ContainsKey(wrd.Key))                          continue;                      var row2 = this.tbWords.Select<string' byte[]>(wrd.Key);                      if (row2.Exists)                      {                          wid = new TextSearchHandler.WordInDocs()                          {                              BlockId = row2.Value.Substring(0' 4).To_UInt32_BigEndian()'                              NumberInBlock = row2.Value.Substring(4' 4).To_UInt32_BigEndian()                          };                            this.RealWords[wrd.Key] = wid;                      }                  }                  else                  {                      //Contains                      containsFound = 0;                      startsWithEchoes = new HashSet<string>();                      foreach (var row1 in this.tbWords.SelectForwardStartsWith<string' byte[]>(wrd.Key).Take(this.NoisyQuantity))                      {                          containsFound++;                            if (wrd.Key != row1.Key)                              startsWithEchoes.Add(row1.Key);                            if (this.RealWords.ContainsKey(row1.Key))                              continue;                            wid = new TextSearchHandler.WordInDocs()                          {                              BlockId = row1.Value.Substring(0' 4).To_UInt32_BigEndian()'                              NumberInBlock = row1.Value.Substring(4' 4).To_UInt32_BigEndian()                          };                            this.RealWords.Add(row1.Key' wid);                      }                        if (startsWithEchoes.Count > 0)                          wrd.Value.StartsWith = startsWithEchoes;                        if (containsFound == this.NoisyQuantity)                          this.SearchCriteriaIsNoisy = true;                  }                    wrd.Value.Processed = true;              }
Magic Number,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,ComputeWordsOrigin,The following statement contains a magic number: foreach (var wrd in this.RealWords.Where(r => !r.Value.Processed).OrderBy(r => r.Value.BlockId))              {                  if (currentBlockId != wrd.Value.BlockId)                  {                      currentBlockId = wrd.Value.BlockId;                      block = new Dictionary<uint' byte[]>();                      btBlock = this.tbBlocks.Select<uint' byte[]>(wrd.Value.BlockId).Value;                      btBlock = btBlock.Substring(4' btBlock.Substring(0' 4).To_Int32_BigEndian());                      btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                  }                    wrd.Value.wahArray = new WABI(block[wrd.Value.NumberInBlock]).GetUncompressedByteArray();                                  wrd.Value.Processed = true;              }
Magic Number,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,ComputeWordsOrigin,The following statement contains a magic number: foreach (var wrd in this.RealWords.Where(r => !r.Value.Processed).OrderBy(r => r.Value.BlockId))              {                  if (currentBlockId != wrd.Value.BlockId)                  {                      currentBlockId = wrd.Value.BlockId;                      block = new Dictionary<uint' byte[]>();                      btBlock = this.tbBlocks.Select<uint' byte[]>(wrd.Value.BlockId).Value;                      btBlock = btBlock.Substring(4' btBlock.Substring(0' 4).To_Int32_BigEndian());                      btBlock.Decode_DICT_PROTO_UINT_BYTEARRAY(block' Compression.eCompressionMethod.Gzip);                  }                    wrd.Value.wahArray = new WABI(block[wrd.Value.NumberInBlock]).GetUncompressedByteArray();                                  wrd.Value.Processed = true;              }
Magic Number,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,BlockAnd,The following statement contains a magic number: this.WordsPrepare(fullMatchWords.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries).Where(r => r.Length > 2)' true' ref sb.ParsedWords);
Magic Number,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,BlockAnd,The following statement contains a magic number: this.WordsPrepare(containsWords.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries).Where(r => r.Length > 2)' false' ref sb.ParsedWords);
Magic Number,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,BlockOr,The following statement contains a magic number: this.WordsPrepare(fullMatchWords.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries).Where(r => r.Length > 2)' true' ref sb.ParsedWords);
Magic Number,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,BlockOr,The following statement contains a magic number: this.WordsPrepare(containsWords.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries).Where(r => r.Length > 2)' false' ref sb.ParsedWords);
Magic Number,DBreeze.TextSearch,TextSearchTable,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchTable.cs,WordsPrepare,The following statement contains a magic number: foreach (var wrd in searchKeywords)              {                     word = wrd.ToLower();                  if (word.Trim().Length < 2 || word.Contains(" "))                      continue;                    //this.PureWords.Add(word' new TextSearchTable.PureWordDef() { FullMatch = fullMatch' Processed = false });                  ////Adding also words to blocks                  //wordsList.Add(word' fullMatch);                    if (!this.PureWords.ContainsKey(word))                  {                      this.PureWords.Add(word' new TextSearchTable.PureWordDef() { FullMatch = fullMatch' Processed = false });                  }                  else                  {                      //In case if word already in the list and is fullMatch' but supplied in not fullmatch we change to contains                      if (!fullMatch && this.PureWords[word].FullMatch)                      {                          this.PureWords[word].FullMatch = fullMatch;                          this.PureWords[word].Processed = false;                      }                  }                    //Adding also words to blocks                  if (!wordsList.ContainsKey(word))                      wordsList.Add(word' fullMatch);                  else                  {                      //In case if word already in the list and is fullMatch' but supplied in not fullmatch we change to contains                      if (!fullMatch && wordsList[word])                          wordsList[word] = fullMatch;                  }              }
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,WABI,The following statement contains a magic number: bt = array.Substring(2' array.Length);
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,Add,The following statement contains a magic number: int byteNumber = Convert.ToInt32(index / 8);
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,Add,The following statement contains a magic number: int rest = index % 8;
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,Contains,The following statement contains a magic number: int byteNumber = Convert.ToInt32(index / 8);
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,Contains,The following statement contains a magic number: int rest = index % 8;
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_AND_logic,The following statement contains a magic number: if (indexesToCheck != null && indexesToCheck.Count > 0)              {                  int MinLenght = indexesToCheck.Min(r => r == null ? 0 : r.Length);                  if (MinLenght != 0)                  {                      byte res = 0;                      uint docId = Convert.ToUInt32(MinLenght * 8) - 1;                      byte mask = 0;                        for (int i = MinLenght - 1; i >= 0; i--)                      {                          res = 255;                          foreach (var wah in indexesToCheck)                          {                              res &= wah[i];                          }                            for (int j = 7; j >= 0; j--)                          {                              mask = (byte)(1 << j);                                if ((res & mask) != 0)                                  yield return (uint)docId;                                docId--;                          }                      }                  }              }
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_AND_logic,The following statement contains a magic number: if (indexesToCheck != null && indexesToCheck.Count > 0)              {                  int MinLenght = indexesToCheck.Min(r => r == null ? 0 : r.Length);                  if (MinLenght != 0)                  {                      byte res = 0;                      uint docId = Convert.ToUInt32(MinLenght * 8) - 1;                      byte mask = 0;                        for (int i = MinLenght - 1; i >= 0; i--)                      {                          res = 255;                          foreach (var wah in indexesToCheck)                          {                              res &= wah[i];                          }                            for (int j = 7; j >= 0; j--)                          {                              mask = (byte)(1 << j);                                if ((res & mask) != 0)                                  yield return (uint)docId;                                docId--;                          }                      }                  }              }
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_AND_logic,The following statement contains a magic number: if (indexesToCheck != null && indexesToCheck.Count > 0)              {                  int MinLenght = indexesToCheck.Min(r => r == null ? 0 : r.Length);                  if (MinLenght != 0)                  {                      byte res = 0;                      uint docId = Convert.ToUInt32(MinLenght * 8) - 1;                      byte mask = 0;                        for (int i = MinLenght - 1; i >= 0; i--)                      {                          res = 255;                          foreach (var wah in indexesToCheck)                          {                              res &= wah[i];                          }                            for (int j = 7; j >= 0; j--)                          {                              mask = (byte)(1 << j);                                if ((res & mask) != 0)                                  yield return (uint)docId;                                docId--;                          }                      }                  }              }
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_AND_logic,The following statement contains a magic number: if (indexesToCheck != null && indexesToCheck.Count > 0)              {                  int MinLenght = indexesToCheck.Min(r => r == null ? 0 : r.Length);                    if (MinLenght != 0)                  {                      byte res = 0;                      uint docId = 0;                      byte mask = 0;                        int start = 0;                      int stop = 0;                        if (descending)                      {                                                start = MinLenght - 1;                          stop = 0;                            if (docStart > 0)                          {                              start = docStart / 8;                              if (start > MinLenght - 1)                                  start = MinLenght - 1;                          }                            if (docStop > 0)                              stop = docStop / 8;                            if(stop <= start && start <= MinLenght - 1 && stop <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 1;                              for (int i = start; i >= stop; i--)                              {                                                                  res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId > docStart)                                          {                                              docId--;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else if(i == stop && docStop > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId < docStop)                                              break;                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else                                  {                                       for (int j = 7; j >= 0; j--)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                }                          }                      }                      else                      {//ASCENDING                          start = 0;                          stop = MinLenght - 1;                            if (docStart > 0)                              start = docStart / 8;                            if (docStop > 0)                          {                              stop = docStop / 8;                              if (MinLenght - 1 < stop)                                  stop = MinLenght - 1;                          }                            if (start <= stop && stop <= MinLenght - 1 && start <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 8;                              for (int i = start; i <= stop; i++)                              {                                                                      res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          if (docId < docStart)                                          {                                              docId++;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                                  else if (i == stop && docStop > 0)                                  {                                      for (byte j = 0; j <= 7; j++)                                      {                                          if (docId > docStop)                                              break;                                            mask = (byte)(1 << j);                                                                                   if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                                                       }                                  else                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                              }                          }                      }                        }              }
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_AND_logic,The following statement contains a magic number: if (indexesToCheck != null && indexesToCheck.Count > 0)              {                  int MinLenght = indexesToCheck.Min(r => r == null ? 0 : r.Length);                    if (MinLenght != 0)                  {                      byte res = 0;                      uint docId = 0;                      byte mask = 0;                        int start = 0;                      int stop = 0;                        if (descending)                      {                                                start = MinLenght - 1;                          stop = 0;                            if (docStart > 0)                          {                              start = docStart / 8;                              if (start > MinLenght - 1)                                  start = MinLenght - 1;                          }                            if (docStop > 0)                              stop = docStop / 8;                            if(stop <= start && start <= MinLenght - 1 && stop <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 1;                              for (int i = start; i >= stop; i--)                              {                                                                  res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId > docStart)                                          {                                              docId--;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else if(i == stop && docStop > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId < docStop)                                              break;                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else                                  {                                       for (int j = 7; j >= 0; j--)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                }                          }                      }                      else                      {//ASCENDING                          start = 0;                          stop = MinLenght - 1;                            if (docStart > 0)                              start = docStart / 8;                            if (docStop > 0)                          {                              stop = docStop / 8;                              if (MinLenght - 1 < stop)                                  stop = MinLenght - 1;                          }                            if (start <= stop && stop <= MinLenght - 1 && start <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 8;                              for (int i = start; i <= stop; i++)                              {                                                                      res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          if (docId < docStart)                                          {                                              docId++;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                                  else if (i == stop && docStop > 0)                                  {                                      for (byte j = 0; j <= 7; j++)                                      {                                          if (docId > docStop)                                              break;                                            mask = (byte)(1 << j);                                                                                   if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                                                       }                                  else                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                              }                          }                      }                        }              }
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_AND_logic,The following statement contains a magic number: if (indexesToCheck != null && indexesToCheck.Count > 0)              {                  int MinLenght = indexesToCheck.Min(r => r == null ? 0 : r.Length);                    if (MinLenght != 0)                  {                      byte res = 0;                      uint docId = 0;                      byte mask = 0;                        int start = 0;                      int stop = 0;                        if (descending)                      {                                                start = MinLenght - 1;                          stop = 0;                            if (docStart > 0)                          {                              start = docStart / 8;                              if (start > MinLenght - 1)                                  start = MinLenght - 1;                          }                            if (docStop > 0)                              stop = docStop / 8;                            if(stop <= start && start <= MinLenght - 1 && stop <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 1;                              for (int i = start; i >= stop; i--)                              {                                                                  res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId > docStart)                                          {                                              docId--;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else if(i == stop && docStop > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId < docStop)                                              break;                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else                                  {                                       for (int j = 7; j >= 0; j--)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                }                          }                      }                      else                      {//ASCENDING                          start = 0;                          stop = MinLenght - 1;                            if (docStart > 0)                              start = docStart / 8;                            if (docStop > 0)                          {                              stop = docStop / 8;                              if (MinLenght - 1 < stop)                                  stop = MinLenght - 1;                          }                            if (start <= stop && stop <= MinLenght - 1 && start <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 8;                              for (int i = start; i <= stop; i++)                              {                                                                      res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          if (docId < docStart)                                          {                                              docId++;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                                  else if (i == stop && docStop > 0)                                  {                                      for (byte j = 0; j <= 7; j++)                                      {                                          if (docId > docStop)                                              break;                                            mask = (byte)(1 << j);                                                                                   if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                                                       }                                  else                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                              }                          }                      }                        }              }
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_AND_logic,The following statement contains a magic number: if (indexesToCheck != null && indexesToCheck.Count > 0)              {                  int MinLenght = indexesToCheck.Min(r => r == null ? 0 : r.Length);                    if (MinLenght != 0)                  {                      byte res = 0;                      uint docId = 0;                      byte mask = 0;                        int start = 0;                      int stop = 0;                        if (descending)                      {                                                start = MinLenght - 1;                          stop = 0;                            if (docStart > 0)                          {                              start = docStart / 8;                              if (start > MinLenght - 1)                                  start = MinLenght - 1;                          }                            if (docStop > 0)                              stop = docStop / 8;                            if(stop <= start && start <= MinLenght - 1 && stop <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 1;                              for (int i = start; i >= stop; i--)                              {                                                                  res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId > docStart)                                          {                                              docId--;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else if(i == stop && docStop > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId < docStop)                                              break;                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else                                  {                                       for (int j = 7; j >= 0; j--)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                }                          }                      }                      else                      {//ASCENDING                          start = 0;                          stop = MinLenght - 1;                            if (docStart > 0)                              start = docStart / 8;                            if (docStop > 0)                          {                              stop = docStop / 8;                              if (MinLenght - 1 < stop)                                  stop = MinLenght - 1;                          }                            if (start <= stop && stop <= MinLenght - 1 && start <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 8;                              for (int i = start; i <= stop; i++)                              {                                                                      res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          if (docId < docStart)                                          {                                              docId++;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                                  else if (i == stop && docStop > 0)                                  {                                      for (byte j = 0; j <= 7; j++)                                      {                                          if (docId > docStop)                                              break;                                            mask = (byte)(1 << j);                                                                                   if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                                                       }                                  else                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                              }                          }                      }                        }              }
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_AND_logic,The following statement contains a magic number: if (indexesToCheck != null && indexesToCheck.Count > 0)              {                  int MinLenght = indexesToCheck.Min(r => r == null ? 0 : r.Length);                    if (MinLenght != 0)                  {                      byte res = 0;                      uint docId = 0;                      byte mask = 0;                        int start = 0;                      int stop = 0;                        if (descending)                      {                                                start = MinLenght - 1;                          stop = 0;                            if (docStart > 0)                          {                              start = docStart / 8;                              if (start > MinLenght - 1)                                  start = MinLenght - 1;                          }                            if (docStop > 0)                              stop = docStop / 8;                            if(stop <= start && start <= MinLenght - 1 && stop <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 1;                              for (int i = start; i >= stop; i--)                              {                                                                  res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId > docStart)                                          {                                              docId--;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else if(i == stop && docStop > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId < docStop)                                              break;                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else                                  {                                       for (int j = 7; j >= 0; j--)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                }                          }                      }                      else                      {//ASCENDING                          start = 0;                          stop = MinLenght - 1;                            if (docStart > 0)                              start = docStart / 8;                            if (docStop > 0)                          {                              stop = docStop / 8;                              if (MinLenght - 1 < stop)                                  stop = MinLenght - 1;                          }                            if (start <= stop && stop <= MinLenght - 1 && start <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 8;                              for (int i = start; i <= stop; i++)                              {                                                                      res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          if (docId < docStart)                                          {                                              docId++;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                                  else if (i == stop && docStop > 0)                                  {                                      for (byte j = 0; j <= 7; j++)                                      {                                          if (docId > docStop)                                              break;                                            mask = (byte)(1 << j);                                                                                   if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                                                       }                                  else                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                              }                          }                      }                        }              }
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_AND_logic,The following statement contains a magic number: if (indexesToCheck != null && indexesToCheck.Count > 0)              {                  int MinLenght = indexesToCheck.Min(r => r == null ? 0 : r.Length);                    if (MinLenght != 0)                  {                      byte res = 0;                      uint docId = 0;                      byte mask = 0;                        int start = 0;                      int stop = 0;                        if (descending)                      {                                                start = MinLenght - 1;                          stop = 0;                            if (docStart > 0)                          {                              start = docStart / 8;                              if (start > MinLenght - 1)                                  start = MinLenght - 1;                          }                            if (docStop > 0)                              stop = docStop / 8;                            if(stop <= start && start <= MinLenght - 1 && stop <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 1;                              for (int i = start; i >= stop; i--)                              {                                                                  res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId > docStart)                                          {                                              docId--;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else if(i == stop && docStop > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId < docStop)                                              break;                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else                                  {                                       for (int j = 7; j >= 0; j--)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                }                          }                      }                      else                      {//ASCENDING                          start = 0;                          stop = MinLenght - 1;                            if (docStart > 0)                              start = docStart / 8;                            if (docStop > 0)                          {                              stop = docStop / 8;                              if (MinLenght - 1 < stop)                                  stop = MinLenght - 1;                          }                            if (start <= stop && stop <= MinLenght - 1 && start <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 8;                              for (int i = start; i <= stop; i++)                              {                                                                      res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          if (docId < docStart)                                          {                                              docId++;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                                  else if (i == stop && docStop > 0)                                  {                                      for (byte j = 0; j <= 7; j++)                                      {                                          if (docId > docStop)                                              break;                                            mask = (byte)(1 << j);                                                                                   if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                                                       }                                  else                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                              }                          }                      }                        }              }
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_AND_logic,The following statement contains a magic number: if (indexesToCheck != null && indexesToCheck.Count > 0)              {                  int MinLenght = indexesToCheck.Min(r => r == null ? 0 : r.Length);                    if (MinLenght != 0)                  {                      byte res = 0;                      uint docId = 0;                      byte mask = 0;                        int start = 0;                      int stop = 0;                        if (descending)                      {                                                start = MinLenght - 1;                          stop = 0;                            if (docStart > 0)                          {                              start = docStart / 8;                              if (start > MinLenght - 1)                                  start = MinLenght - 1;                          }                            if (docStop > 0)                              stop = docStop / 8;                            if(stop <= start && start <= MinLenght - 1 && stop <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 1;                              for (int i = start; i >= stop; i--)                              {                                                                  res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId > docStart)                                          {                                              docId--;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else if(i == stop && docStop > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId < docStop)                                              break;                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else                                  {                                       for (int j = 7; j >= 0; j--)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                }                          }                      }                      else                      {//ASCENDING                          start = 0;                          stop = MinLenght - 1;                            if (docStart > 0)                              start = docStart / 8;                            if (docStop > 0)                          {                              stop = docStop / 8;                              if (MinLenght - 1 < stop)                                  stop = MinLenght - 1;                          }                            if (start <= stop && stop <= MinLenght - 1 && start <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 8;                              for (int i = start; i <= stop; i++)                              {                                                                      res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          if (docId < docStart)                                          {                                              docId++;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                                  else if (i == stop && docStop > 0)                                  {                                      for (byte j = 0; j <= 7; j++)                                      {                                          if (docId > docStop)                                              break;                                            mask = (byte)(1 << j);                                                                                   if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                                                       }                                  else                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                              }                          }                      }                        }              }
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_AND_logic,The following statement contains a magic number: if (indexesToCheck != null && indexesToCheck.Count > 0)              {                  int MinLenght = indexesToCheck.Min(r => r == null ? 0 : r.Length);                    if (MinLenght != 0)                  {                      byte res = 0;                      uint docId = 0;                      byte mask = 0;                        int start = 0;                      int stop = 0;                        if (descending)                      {                                                start = MinLenght - 1;                          stop = 0;                            if (docStart > 0)                          {                              start = docStart / 8;                              if (start > MinLenght - 1)                                  start = MinLenght - 1;                          }                            if (docStop > 0)                              stop = docStop / 8;                            if(stop <= start && start <= MinLenght - 1 && stop <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 1;                              for (int i = start; i >= stop; i--)                              {                                                                  res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId > docStart)                                          {                                              docId--;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else if(i == stop && docStop > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId < docStop)                                              break;                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else                                  {                                       for (int j = 7; j >= 0; j--)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                }                          }                      }                      else                      {//ASCENDING                          start = 0;                          stop = MinLenght - 1;                            if (docStart > 0)                              start = docStart / 8;                            if (docStop > 0)                          {                              stop = docStop / 8;                              if (MinLenght - 1 < stop)                                  stop = MinLenght - 1;                          }                            if (start <= stop && stop <= MinLenght - 1 && start <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 8;                              for (int i = start; i <= stop; i++)                              {                                                                      res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          if (docId < docStart)                                          {                                              docId++;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                                  else if (i == stop && docStop > 0)                                  {                                      for (byte j = 0; j <= 7; j++)                                      {                                          if (docId > docStop)                                              break;                                            mask = (byte)(1 << j);                                                                                   if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                                                       }                                  else                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                              }                          }                      }                        }              }
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_AND_logic,The following statement contains a magic number: if (indexesToCheck != null && indexesToCheck.Count > 0)              {                  int MinLenght = indexesToCheck.Min(r => r == null ? 0 : r.Length);                    if (MinLenght != 0)                  {                      byte res = 0;                      uint docId = 0;                      byte mask = 0;                        int start = 0;                      int stop = 0;                        if (descending)                      {                                                start = MinLenght - 1;                          stop = 0;                            if (docStart > 0)                          {                              start = docStart / 8;                              if (start > MinLenght - 1)                                  start = MinLenght - 1;                          }                            if (docStop > 0)                              stop = docStop / 8;                            if(stop <= start && start <= MinLenght - 1 && stop <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 1;                              for (int i = start; i >= stop; i--)                              {                                                                  res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId > docStart)                                          {                                              docId--;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else if(i == stop && docStop > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId < docStop)                                              break;                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else                                  {                                       for (int j = 7; j >= 0; j--)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                }                          }                      }                      else                      {//ASCENDING                          start = 0;                          stop = MinLenght - 1;                            if (docStart > 0)                              start = docStart / 8;                            if (docStop > 0)                          {                              stop = docStop / 8;                              if (MinLenght - 1 < stop)                                  stop = MinLenght - 1;                          }                            if (start <= stop && stop <= MinLenght - 1 && start <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 8;                              for (int i = start; i <= stop; i++)                              {                                                                      res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          if (docId < docStart)                                          {                                              docId++;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                                  else if (i == stop && docStop > 0)                                  {                                      for (byte j = 0; j <= 7; j++)                                      {                                          if (docId > docStop)                                              break;                                            mask = (byte)(1 << j);                                                                                   if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                                                       }                                  else                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                              }                          }                      }                        }              }
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_AND_logic,The following statement contains a magic number: if (indexesToCheck != null && indexesToCheck.Count > 0)              {                  int MinLenght = indexesToCheck.Min(r => r == null ? 0 : r.Length);                    if (MinLenght != 0)                  {                      byte res = 0;                      uint docId = 0;                      byte mask = 0;                        int start = 0;                      int stop = 0;                        if (descending)                      {                                                start = MinLenght - 1;                          stop = 0;                            if (docStart > 0)                          {                              start = docStart / 8;                              if (start > MinLenght - 1)                                  start = MinLenght - 1;                          }                            if (docStop > 0)                              stop = docStop / 8;                            if(stop <= start && start <= MinLenght - 1 && stop <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 1;                              for (int i = start; i >= stop; i--)                              {                                                                  res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId > docStart)                                          {                                              docId--;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else if(i == stop && docStop > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId < docStop)                                              break;                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else                                  {                                       for (int j = 7; j >= 0; j--)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                }                          }                      }                      else                      {//ASCENDING                          start = 0;                          stop = MinLenght - 1;                            if (docStart > 0)                              start = docStart / 8;                            if (docStop > 0)                          {                              stop = docStop / 8;                              if (MinLenght - 1 < stop)                                  stop = MinLenght - 1;                          }                            if (start <= stop && stop <= MinLenght - 1 && start <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 8;                              for (int i = start; i <= stop; i++)                              {                                                                      res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          if (docId < docStart)                                          {                                              docId++;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                                  else if (i == stop && docStop > 0)                                  {                                      for (byte j = 0; j <= 7; j++)                                      {                                          if (docId > docStop)                                              break;                                            mask = (byte)(1 << j);                                                                                   if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                                                       }                                  else                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                              }                          }                      }                        }              }
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_AND_logic,The following statement contains a magic number: if (indexesToCheck != null && indexesToCheck.Count > 0)              {                  int MinLenght = indexesToCheck.Min(r => r == null ? 0 : r.Length);                    if (MinLenght != 0)                  {                      byte res = 0;                      uint docId = 0;                      byte mask = 0;                        int start = 0;                      int stop = 0;                        if (descending)                      {                                                start = MinLenght - 1;                          stop = 0;                            if (docStart > 0)                          {                              start = docStart / 8;                              if (start > MinLenght - 1)                                  start = MinLenght - 1;                          }                            if (docStop > 0)                              stop = docStop / 8;                            if(stop <= start && start <= MinLenght - 1 && stop <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 1;                              for (int i = start; i >= stop; i--)                              {                                                                  res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId > docStart)                                          {                                              docId--;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else if(i == stop && docStop > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId < docStop)                                              break;                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else                                  {                                       for (int j = 7; j >= 0; j--)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                }                          }                      }                      else                      {//ASCENDING                          start = 0;                          stop = MinLenght - 1;                            if (docStart > 0)                              start = docStart / 8;                            if (docStop > 0)                          {                              stop = docStop / 8;                              if (MinLenght - 1 < stop)                                  stop = MinLenght - 1;                          }                            if (start <= stop && stop <= MinLenght - 1 && start <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 8;                              for (int i = start; i <= stop; i++)                              {                                                                      res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          if (docId < docStart)                                          {                                              docId++;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                                  else if (i == stop && docStop > 0)                                  {                                      for (byte j = 0; j <= 7; j++)                                      {                                          if (docId > docStop)                                              break;                                            mask = (byte)(1 << j);                                                                                   if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                                                       }                                  else                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                              }                          }                      }                        }              }
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_AND_logic,The following statement contains a magic number: if (indexesToCheck != null && indexesToCheck.Count > 0)              {                  int MinLenght = indexesToCheck.Min(r => r == null ? 0 : r.Length);                    if (MinLenght != 0)                  {                      byte res = 0;                      uint docId = 0;                      byte mask = 0;                        int start = 0;                      int stop = 0;                        if (descending)                      {                                                start = MinLenght - 1;                          stop = 0;                            if (docStart > 0)                          {                              start = docStart / 8;                              if (start > MinLenght - 1)                                  start = MinLenght - 1;                          }                            if (docStop > 0)                              stop = docStop / 8;                            if(stop <= start && start <= MinLenght - 1 && stop <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 1;                              for (int i = start; i >= stop; i--)                              {                                                                  res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId > docStart)                                          {                                              docId--;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else if(i == stop && docStop > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId < docStop)                                              break;                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else                                  {                                       for (int j = 7; j >= 0; j--)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                }                          }                      }                      else                      {//ASCENDING                          start = 0;                          stop = MinLenght - 1;                            if (docStart > 0)                              start = docStart / 8;                            if (docStop > 0)                          {                              stop = docStop / 8;                              if (MinLenght - 1 < stop)                                  stop = MinLenght - 1;                          }                            if (start <= stop && stop <= MinLenght - 1 && start <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 8;                              for (int i = start; i <= stop; i++)                              {                                                                      res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          if (docId < docStart)                                          {                                              docId++;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                                  else if (i == stop && docStop > 0)                                  {                                      for (byte j = 0; j <= 7; j++)                                      {                                          if (docId > docStop)                                              break;                                            mask = (byte)(1 << j);                                                                                   if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                                                       }                                  else                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                              }                          }                      }                        }              }
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_AND_logic,The following statement contains a magic number: if (indexesToCheck != null && indexesToCheck.Count > 0)              {                  int MinLenght = indexesToCheck.Min(r => r == null ? 0 : r.Length);                    if (MinLenght != 0)                  {                      byte res = 0;                      uint docId = 0;                      byte mask = 0;                        int start = 0;                      int stop = 0;                        if (descending)                      {                                                start = MinLenght - 1;                          stop = 0;                            if (docStart > 0)                          {                              start = docStart / 8;                              if (start > MinLenght - 1)                                  start = MinLenght - 1;                          }                            if (docStop > 0)                              stop = docStop / 8;                            if(stop <= start && start <= MinLenght - 1 && stop <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 1;                              for (int i = start; i >= stop; i--)                              {                                                                  res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId > docStart)                                          {                                              docId--;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else if(i == stop && docStop > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId < docStop)                                              break;                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else                                  {                                       for (int j = 7; j >= 0; j--)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                }                          }                      }                      else                      {//ASCENDING                          start = 0;                          stop = MinLenght - 1;                            if (docStart > 0)                              start = docStart / 8;                            if (docStop > 0)                          {                              stop = docStop / 8;                              if (MinLenght - 1 < stop)                                  stop = MinLenght - 1;                          }                            if (start <= stop && stop <= MinLenght - 1 && start <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 8;                              for (int i = start; i <= stop; i++)                              {                                                                      res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          if (docId < docStart)                                          {                                              docId++;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                                  else if (i == stop && docStop > 0)                                  {                                      for (byte j = 0; j <= 7; j++)                                      {                                          if (docId > docStop)                                              break;                                            mask = (byte)(1 << j);                                                                                   if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                                                       }                                  else                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                              }                          }                      }                        }              }
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_AND_logic,The following statement contains a magic number: if (indexesToCheck != null && indexesToCheck.Count > 0)              {                  int MinLenght = indexesToCheck.Min(r => r == null ? 0 : r.Length);                    if (MinLenght != 0)                  {                      byte res = 0;                      uint docId = 0;                      byte mask = 0;                        int start = 0;                      int stop = 0;                        if (descending)                      {                                                start = MinLenght - 1;                          stop = 0;                            if (docStart > 0)                          {                              start = docStart / 8;                              if (start > MinLenght - 1)                                  start = MinLenght - 1;                          }                            if (docStop > 0)                              stop = docStop / 8;                            if(stop <= start && start <= MinLenght - 1 && stop <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 1;                              for (int i = start; i >= stop; i--)                              {                                                                  res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId > docStart)                                          {                                              docId--;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else if(i == stop && docStop > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId < docStop)                                              break;                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else                                  {                                       for (int j = 7; j >= 0; j--)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                }                          }                      }                      else                      {//ASCENDING                          start = 0;                          stop = MinLenght - 1;                            if (docStart > 0)                              start = docStart / 8;                            if (docStop > 0)                          {                              stop = docStop / 8;                              if (MinLenght - 1 < stop)                                  stop = MinLenght - 1;                          }                            if (start <= stop && stop <= MinLenght - 1 && start <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 8;                              for (int i = start; i <= stop; i++)                              {                                                                      res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          if (docId < docStart)                                          {                                              docId++;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                                  else if (i == stop && docStop > 0)                                  {                                      for (byte j = 0; j <= 7; j++)                                      {                                          if (docId > docStop)                                              break;                                            mask = (byte)(1 << j);                                                                                   if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                                                       }                                  else                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                              }                          }                      }                        }              }
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_AND_logic,The following statement contains a magic number: if (indexesToCheck != null && indexesToCheck.Count > 0)              {                  int MinLenght = indexesToCheck.Min(r => r == null ? 0 : r.Length);                    if (MinLenght != 0)                  {                      byte res = 0;                      uint docId = 0;                      byte mask = 0;                        int start = 0;                      int stop = 0;                        if (descending)                      {                                                start = MinLenght - 1;                          stop = 0;                            if (docStart > 0)                          {                              start = docStart / 8;                              if (start > MinLenght - 1)                                  start = MinLenght - 1;                          }                            if (docStop > 0)                              stop = docStop / 8;                            if(stop <= start && start <= MinLenght - 1 && stop <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 1;                              for (int i = start; i >= stop; i--)                              {                                                                  res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId > docStart)                                          {                                              docId--;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else if(i == stop && docStop > 0)                                  {                                      for (int j = 7; j >= 0; j--)                                      {                                          if (docId < docStop)                                              break;                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                  else                                  {                                       for (int j = 7; j >= 0; j--)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId--;                                      }                                  }                                }                          }                      }                      else                      {//ASCENDING                          start = 0;                          stop = MinLenght - 1;                            if (docStart > 0)                              start = docStart / 8;                            if (docStop > 0)                          {                              stop = docStop / 8;                              if (MinLenght - 1 < stop)                                  stop = MinLenght - 1;                          }                            if (start <= stop && stop <= MinLenght - 1 && start <= MinLenght - 1)                          {                              docId = Convert.ToUInt32((start + 1) * 8) - 8;                              for (int i = start; i <= stop; i++)                              {                                                                      res = 255;                                  foreach (var wah in indexesToCheck)                                  {                                      res &= wah[i];                                  }                                    if (i == start && docStart > 0)                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          if (docId < docStart)                                          {                                              docId++;                                              continue;                                          }                                            mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                                  else if (i == stop && docStop > 0)                                  {                                      for (byte j = 0; j <= 7; j++)                                      {                                          if (docId > docStop)                                              break;                                            mask = (byte)(1 << j);                                                                                   if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                                                       }                                  else                                  {                                      for (int j = 0; j <= 7; j++)                                      {                                          mask = (byte)(1 << j);                                            if ((res & mask) != 0)                                              yield return (uint)docId;                                            docId++;                                      }                                  }                              }                          }                      }                        }              }
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_OR_logic,The following statement contains a magic number: uint docId = Convert.ToUInt32(MaxLenght * 8) - 1;
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_OR_logic,The following statement contains a magic number: int[] el = new int[8];
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_OR_logic,The following statement contains a magic number: for (int i = MaxLenght - 1; i >= 0; i--)              {                  foreach (var wah in indexesToCheck)                  {                      if (i > (wah.Length - 1))                          continue;                        //for (int j = 0; j < 8; j++)                      for (int j = 7; j >= 0; j--)                      {                          mask = (byte)(1 << j);                          if ((wah[i] & mask) != 0)                              el[j] += 1;                      }                  }                    //Here we analyze el array                  //for (int j = 0; j < 8; j++)                  for (int j = 7; j >= 0; j--)                  {                      //el[j] contains quantity of occurance                      if (el[j] > 0)                      {                          if (!d.TryGetValue(el[j]' out docLst))                              docLst = new List<uint>();                            added++;                          yield return docId;                          //docLst.Add(docId);                            d[el[j]] = docLst;                      }                        el[j] = 0;                      docId--;                  }                    if (added > maximalReturnQuantity)                      break;              }
Magic Number,DBreeze.TextSearch,WABI,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\WABI.cs,TextSearch_OR_logic,The following statement contains a magic number: for (int i = MaxLenght - 1; i >= 0; i--)              {                  foreach (var wah in indexesToCheck)                  {                      if (i > (wah.Length - 1))                          continue;                        //for (int j = 0; j < 8; j++)                      for (int j = 7; j >= 0; j--)                      {                          mask = (byte)(1 << j);                          if ((wah[i] & mask) != 0)                              el[j] += 1;                      }                  }                    //Here we analyze el array                  //for (int j = 0; j < 8; j++)                  for (int j = 7; j >= 0; j--)                  {                      //el[j] contains quantity of occurance                      if (el[j] > 0)                      {                          if (!d.TryGetValue(el[j]' out docLst))                              docLst = new List<uint>();                            added++;                          yield return docId;                          //docLst.Add(docId);                            d[el[j]] = docLst;                      }                        el[j] = 0;                      docId--;                  }                    if (added > maximalReturnQuantity)                      break;              }
Duplicate Code,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,SetupKidWithValue,The method contains a code clone-set at the following line numbers (starting from the method definition): ((21' 40)' (120' 139))
Duplicate Code,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The method contains a code clone-set at the following line numbers (starting from the method definition): ((112' 131)' (160' 179))
Duplicate Code,DBreeze.Storage,FSR,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\FSR.cs,Table_Read,The method contains a code clone-set at the following line numbers (starting from the method definition): ((79' 105)' (202' 228))
Duplicate Code,DBreeze.Storage,MSR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MSR.cs,Table_Read,The method contains a code clone-set at the following line numbers (starting from the method definition): ((53' 78)' (173' 198))
Duplicate Code,DBreeze.Storage,RISR,C:\repos\hhblaze_DBreeze\DBreeze\Storage\RISR.cs,Table_Read,The method contains a code clone-set at the following line numbers (starting from the method definition): ((91' 117)' (220' 246))
Duplicate Code,DBreeze.LianaTrie.Iterations,Backward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Backward.cs,ItBwdStartsWith,The method contains a code clone-set at the following line numbers (starting from the method definition): ((44' 63)' (93' 112))
Duplicate Code,DBreeze.LianaTrie.Iterations,Forward,C:\repos\hhblaze_DBreeze\DBreeze\LianaTrie\Iterations\Forward.cs,ItFrwStartsWith,The method contains a code clone-set at the following line numbers (starting from the method definition): ((24' 62)' (73' 111))
Duplicate Code,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,DoIndexing,The method contains a code clone-set at the following line numbers (starting from the method definition): ((201' 225)' (277' 301))
Missing Default,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,SetupValueRowFromNode,The following switch statement is missing a default case: switch (protocolVersion)              {                  case 1:                      //First protocol type                      /*                      Protocol:                          1byte - protocol version (starting from 1)                          16bytes link to content (or 0)                          1byte - lenght of NodeName                                          Nbytes - Name                                                                         */                        val = new byte[] { protocolVersion }.ConcatMany                          (                              (node.ContentRef != null) ? node.ContentRef : new byte[] { 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0' 0 }'                              new byte[] { (byte)name.Length }'                              name                          );                      break;              }
Missing Default,DBreeze.DataStructures,DataAsTree,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\DataStructures\DataAsTree.cs,SetupNodeFromRow,The following switch statement is missing a default case: switch (val[0])              {                  case 1: //First protocol type                          /*                          Protocol:                              1byte - protocol version (starting from 1)                              16bytes link to content (or 0)                              1byte - lenght of NodeName                                              Nbytes - Name                                                                             */                        if ((val[1] | val[2] | val[3] | val[4] | val[5] | val[6] | val[7] | val[8]) != 0)                      {                          //We got content                          node.ContentRef = val.Substring(1' 16);                      }                      node.NodeName = System.Text.Encoding.UTF8.GetString(val.Substring(18' val[17]));                      break;              }
Missing Default,DBreeze.Exceptions,DBreezeException,C:\repos\hhblaze_DBreeze\DBreeze\Exceptions\DBreezeException.cs,GenerateException,The following switch statement is missing a default case: switch (exceptionType)              {                  //General                  case eDBreezeExceptions.GENERAL_EXCEPTION_DB_NOT_OPERABLE:                      return new DBreezeException(String.Format("Database is not operable' please find out the problem and restart the engine! {0}"'message)' innerException);                                        //Enging                  case eDBreezeExceptions.DB_IS_NOT_OPERABLE:                      return new DBreezeException(String.Format("Database is not operable' please find out the problem and restart the engine! {0}"' message)' innerException);                  case eDBreezeExceptions.CREATE_DB_FOLDER_FAILED:                      return new DBreezeException("Creation of the database folder failed!"' innerException);                  // return new DBreezeException(String.Format("{0}creation of the database folder failed: {1}"' ExceptionHeader' originalException.ToString()));                    //Schema                  case eDBreezeExceptions.SCHEME_GET_TABLE_WRITE_FAILED:                      return new DBreezeException(String.Format("Getting table \"{0}\" from the schema failed!"' message)' innerException);                  case eDBreezeExceptions.SCHEME_FILE_PROTOCOL_IS_UNKNOWN:                      return new DBreezeException(String.Format("Scheme file protocol is unknown from the schema failed!")' innerException);                  case eDBreezeExceptions.SCHEME_TABLE_DELETE_FAILED:                      return new DBreezeException(String.Format("User table \"{0}\" delete failed!"'message)' innerException);                  case eDBreezeExceptions.SCHEME_TABLE_RENAME_FAILED:                      return new DBreezeException(String.Format("User table \"{0}\" rename failed!"' message)' innerException);                      //SchemaInternal.UserTable name patterns                  case eDBreezeExceptions.TABLE_NAMES_TABLENAMECANTBEEMPTY:                      return new DBreezeException(String.Format("Table name can't be empty!")' innerException);                  case eDBreezeExceptions.TABLE_NAMES_TABLENAMECANT_CONTAINRESERVEDSYMBOLS:                      return new DBreezeException(String.Format("Table name can not contain reserved symbols like * # @ \\ ^ $ ~ ´")' innerException);                  case eDBreezeExceptions.TABLE_PATTERN_CANTBEEMPTY:                      return new DBreezeException(String.Format("Table pattern can't be empty!")' innerException);                  case eDBreezeExceptions.TABLE_PATTERN_SYMBOLS_AFTER_SHARP:                      return new DBreezeException(String.Format("After # must follow / and any other symbol!")' innerException);                                            //LTrie                  //case eDBreezeExceptions.TABLE_IS_NOT_OPEARABLE:                  //    return new DBreezeException(String.Format("Table \"{0}\" is not operable!"' message)' innerException);                  case eDBreezeExceptions.COMMIT_FAILED:                      return new DBreezeException(String.Format("Table \"{0}\" commit failed!"' message)' innerException);     //ADD TABLE NAME!!!                  case eDBreezeExceptions.TRANSACTIONAL_COMMIT_FAILED:                      return new DBreezeException(String.Format("Transaction commit failed on table \"{0}\"!"'message)' innerException);                  case eDBreezeExceptions.RESTORE_ROLLBACK_DATA_FAILED:                      return new DBreezeException(String.Format("Restore rollback file \"{0}\" failed!"' message)' innerException);                  case eDBreezeExceptions.ROLLBACK_NOT_OPERABLE:                                            //WTF ?????????????????                      //return new DBreezeException(String.Format("{0}rollback of the file \"{1}\" is not operatable: {2}"' ExceptionHeader' description' originalException.ToString()));                      return new DBreezeException(String.Format("Rollback of the file \"{0}\" is not operable!"' message)' innerException);                  case eDBreezeExceptions.ROLLBACK_FAILED:                                                                       return new DBreezeException(String.Format("Rollback of the table \"{0}\" failed!"' message)' innerException);                  case eDBreezeExceptions.TRANSACTIONAL_ROLLBACK_FAILED:                                                                       return new DBreezeException(String.Format("Transaction rollback failed on the table \"{0}\"!"' message)' innerException);                  case eDBreezeExceptions.RECREATE_TABLE_FAILED:                      return new DBreezeException(String.Format("Table \"{0}\" re-creation failed!"' message)' innerException);                  case eDBreezeExceptions.PREPARE_ROLLBACK_FILE_FAILED:                      return new DBreezeException(String.Format("Rollback file \"{0}\" preparation failed!"' message)' innerException);                  case eDBreezeExceptions.KEY_IS_TOO_LONG:                                   return new DBreezeException(String.Format("Key is too long' maximal key size is: {0}!"' UInt16.MaxValue.ToString())' innerException);                  case eDBreezeExceptions.TABLE_WAS_CHANGED_LINKS_ARE_NOT_ACTUAL:                      {                          //It can happen when we have read LTrieRow with link to value' then table was re-created or restored from other table'                          //and then we want to get value from an "old" link                          return new DBreezeException(String.Format("Table was changed (Table Recrete' Table RestoreTableFromTheOtherTable)' links are not actual' repeat reading operation!")' innerException);                      }                    //Transaction Journal                  case eDBreezeExceptions.CLEAN_ROLLBACK_FILES_FOR_FINISHED_TRANSACTIONS_FAILED:                      return new DBreezeException(String.Format("Transaction journal couldn't clean rollback files of the finished transactions!")' innerException);                      //Transactions Coordinator                  case eDBreezeExceptions.TRANSACTION_DOESNT_EXIST:                      return new DBreezeException(String.Format("Transaction doesn't exist anymore!")' innerException);                  case eDBreezeExceptions.TRANSACTION_CANBEUSED_FROM_ONE_THREAD:                      return new DBreezeException(String.Format("One transaction can be used from one thread only!")' innerException);                  case eDBreezeExceptions.TRANSACTION_IN_DEADLOCK:                      return new DBreezeException(String.Format("Transaction is in a deadlock state and will be terminated. To avoid such case use Transaction.SynchronizeTables!")' innerException);                  case eDBreezeExceptions.TRANSACTION_TABLE_WRITE_REGISTRATION_FAILED:                      return new DBreezeException(String.Format("Transaction registration table for Write failed!")' innerException);                  case eDBreezeExceptions.TRANSACTION_GETTING_TRANSACTION_FAILED:                      return new DBreezeException(String.Format("getting transaction failed!")' innerException);                      //Transaction                  case eDBreezeExceptions.TRANSACTION_TABLES_RESERVATION_FAILED:                      return new DBreezeException(String.Format("Reservation tables for modification or synchronized read failed! Use SynchronizeTables before any modification!")' innerException);                  case eDBreezeExceptions.TRANSACTION_TABLES_RESERVATION_CANBEDONE_ONCE:                      return new DBreezeException(String.Format("Reservation tables for modification or synchronized read failed! Only one synchronization call permitted per transaction!")' innerException);                  case eDBreezeExceptions.TRANSACTION_TABLES_RESERVATION_LIST_MUSTBEFILLED:                      return new DBreezeException(String.Format("Reservation tables for modification or synchronized read failed! Synchronization list must be filled!")' innerException);                                          //DataTypes                  case eDBreezeExceptions.UNSUPPORTED_DATATYPE:                      return new DBreezeException(String.Format("Unsupported data type \"{0}\"!"' message)' innerException);                  case eDBreezeExceptions.UNSUPPORTED_DATATYPE_VALUE:                      return new DBreezeException(String.Format("Unsupported data type value \"{0}\"!"' message)' innerException);                                      case eDBreezeExceptions.KEY_CANT_BE_NULL:                      return new DBreezeException(String.Format("Key can't be NULL!")' innerException);                  case eDBreezeExceptions.PARTIAL_VALUE_CANT_BE_NULL:                      return new DBreezeException(String.Format("Partial value can't be NULL!")' innerException);                      //XML serializer                  case eDBreezeExceptions.XML_SERIALIZATION_ERROR:                      return new DBreezeException(String.Format("XML serialization error!")' innerException);                  case eDBreezeExceptions.XML_DESERIALIZATION_ERROR:                      return new DBreezeException(String.Format("XML deserialization error!")' innerException);                      //MICROSOFT JSON serializer                  case eDBreezeExceptions.MJSON_SERIALIZATION_ERROR:                      return new DBreezeException(String.Format("Microsoft JSON serialization error!")' innerException);                  case eDBreezeExceptions.MJSON_DESERIALIZATION_ERROR:                      return new DBreezeException(String.Format("Microsoft JSON deserialization error!")' innerException);                    //Custom serializer                  case eDBreezeExceptions.CUSTOM_SERIALIZATION_ERROR:                      return new DBreezeException(String.Format("Custom serialization error!")' innerException);                  case eDBreezeExceptions.CUSTOM_DESERIALIZATION_ERROR:                      return new DBreezeException(String.Format("Custom deserialization error!")' innerException);                    //DBINTABLE                  case eDBreezeExceptions.DBINTABLE_CHANGEDATA_FROMSELECTVIEW:                      return new DBreezeException(String.Format("Changing data after SelectTable is not permitted' use InsertTable instead!")' innerException);                    //Dynamic data blocks                  case eDBreezeExceptions.DYNAMIC_DATA_BLOCK_VALUE_IS_BIG:                      return new DBreezeException(String.Format("Value is too big' more then Int32.MaxValue!")' innerException);                    //Backup                  case eDBreezeExceptions.BACKUP_FOLDER_CREATE_FAILED:                      return new DBreezeException(String.Format("Backup folder creation has failed")' innerException);                    case eDBreezeExceptions.DBREEZE_RESOURCES_CONCERNING:                      return new DBreezeException(String.Format("DBreeze.DbreezeResources err: \"{0}\"!"' message)' innerException);              }
Missing Default,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValuePartially,The following switch statement is missing a default case: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                                         break;                  case 1:                      btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      totalReservedSize = (int)btTotalReservedSize.To_UInt32_BigEndian();                      break;              }
Missing Default,DBreeze.LianaTrie,LTrieGenerationNode,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieGenerationNode.cs,TryOverWriteValue,The following switch statement is missing a default case: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                                         break;                  case 1:                      btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      totalReservedSize = (int)btTotalReservedSize.To_UInt32_BigEndian();                                          break;              }
Missing Default,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKeyValue,The following switch statement is missing a default case: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          initRead = keySize + valueSize + 7;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                        key = data.Substring(7' keySize);                        if (valueSize > 0)                      {                          valueStartPtr = lPtr + 7 + keySize;                                                  val = data.Substring(7 + keySize' valueSize);                      }                        break;                  case 1:                      //With Reserved space                        if ((keySize + valueSize + 11) > initRead)                      {                          initRead = keySize + valueSize + 11;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                          key = data.Substring(11' keySize);                        if (valueSize > 0)                      {                          valueStartPtr = lPtr + 11 + keySize;                                                                        val = data.Substring(11 + keySize' valueSize);                      }                      break;              }
Missing Default,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadKey,The following switch statement is missing a default case: switch (protocol)              {                  case 0:                      //First insert - no reservation identifiers for the space                        //Expanding read if necessary                      if (keySize > (initRead - 7))   //>= ?                      {                          initRead = keySize + 7;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                                              }                        key = data.Substring(7' keySize);                        break;                  case 1:                      //Expanding read if necessary                      if (keySize > (initRead - 11))  //>= ?                      {                          initRead = keySize + 11;                          data = Trie.Storage.Table_Read(useCache' pointer' initRead);                      }                        key = data.Substring(11' keySize);                        break;              }
Missing Default,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValue,The following switch statement is missing a default case: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          lPtr += 7 + keySize;                          valueStartPtr = lPtr;                          val = Trie.Storage.Table_Read(useCache' lPtr' valueSize);                      }                      else                      {                          valueStartPtr = lPtr + 7 + keySize;                          val = data.Substring(7 + keySize' valueSize);                      }                        break;                  case 1:                      //btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      //totalReservedSize = btTotalReservedSize.To_Int32_BigEndian();                      if ((keySize + valueSize + 11) > initRead)                      {                          lPtr += 11 + keySize;                          valueStartPtr = lPtr;                          val = Trie.Storage.Table_Read(useCache' lPtr' valueSize);                      }                      else                      {                          valueStartPtr = lPtr + 11 + keySize;                          val = data.Substring(11 + keySize' valueSize);                      }                      break;              }
Missing Default,DBreeze.LianaTrie,LTrieWriteCache,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\LianaTrie\LTrieWriteCache.cs,ReadValuePartially,The following switch statement is missing a default case: switch (protocol)              {                  case 0:                      //We don't have reservation identifiers' it happens after first insert into the new place                         if ((keySize + valueSize + 7) > initRead)                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //lPtr += 7 + keySize;                          //val = this.DBStorage.Read(lPtr' valueSize);                          valueStartPtr = lPtr + 7 + keySize;                          lPtr += 7 + keySize + (int)startIndex;                          val = Trie.Storage.Table_Read(useCache' lPtr' (int)length);                      }                      else                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //val = data.Substring(7 + keySize' valueSize);                            //in partial read                          valueStartPtr = lPtr + 7 + keySize;                          val = data.Substring(7 + keySize + (int)startIndex' (int)length);                      }                        break;                  case 1:                      //btTotalReservedSize = new byte[] { data[7]' data[8]' data[9]' data[10] };                      //totalReservedSize = btTotalReservedSize.To_Int32_BigEndian();                      if ((keySize + valueSize + 11) > initRead)                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //lPtr += 11 + keySize;                          //val = this.DBStorage.Read(lPtr' valueSize);                            //in partial read                          valueStartPtr = lPtr + 11 + keySize;                          lPtr += 11 + keySize + (int)startIndex;                          val = Trie.Storage.Table_Read(useCache' lPtr' (int)length);                      }                      else                      {                          //HERE READ ONLY PART OF THE VALUE                            //original in read                          //val = data.Substring(11 + keySize' valueSize);                            //in partial read                          valueStartPtr = lPtr + 11 + keySize;                          val = data.Substring(11 + keySize + (int)startIndex' (int)length);                      }                      break;              }
Missing Default,DBreeze.SchemeInternal,DbUserTables,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\SchemeInternal\Sheme.UserTable.cs,UserTableNameIsOk,The following switch statement is missing a default case: switch(tableName[i])                  {                      case '*':   //used as pattern mask                                          case '#':   //used as pattern mask                      case '$':   //used as pattern mask                      case '@':   //used for system tables                      case '\\':  //reserved by dbreeze                      case '^':   //reserved by dbreeze                                          case '~':   //reserved by dbreeze                      case '´':   //reserved by dbreeze                                              throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.TABLE_NAMES_TABLENAMECANT_CONTAINRESERVEDSYMBOLS);                   }
Missing Default,DBreeze.SchemeInternal,DbUserTables,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\SchemeInternal\Sheme.UserTable.cs,UserTablePatternIsOk,The following switch statement is missing a default case: switch (tableName[i])                  {                      case '*':                          //Substring till * and return                          return tableName.Substring(0' i+1);                      case '$':                          //Substring till $ and return                          return tableName.Substring(0' i + 1);                      case '#':                            if ((i + 2) > (tableName.Length - 1))                              throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.TABLE_PATTERN_SYMBOLS_AFTER_SHARP);                             if (tableName[i + 1] != '/')                              throw DBreezeException.Throw(DBreezeException.eDBreezeExceptions.TABLE_PATTERN_SYMBOLS_AFTER_SHARP);                                                   break;                  }
Missing Default,DBreeze.Storage,Backup,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\Backup.cs,WriteBackupElement,The following switch statement is missing a default case: switch (type)                  {                      case 0:                      case 1:                            //8(fileNumber)+1(type)+8(position)+data.Length                          size = Convert.ToUInt32(8 + 1 + 8 + data.Length);                          toSave = size.To_4_bytes_array_BigEndian().ConcatMany(fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { type }'                              pos.To_8_bytes_array_BigEndian()'                              data);                                                 break;                      case 2:                            //Now we save new information into rollback                           size = Convert.ToUInt32(8 + 1 + 8 + data.Length);                          toSave = size.To_4_bytes_array_BigEndian().ConcatMany(fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { 2 }'                              ((long)0).To_8_bytes_array_BigEndian()'                              data);                          break;                      case 3: //recreate table file                                       case 5: //removing complete table                            //8(fileNumber)+1(type)                          size = 9;                          toSave = size.To_4_bytes_array_BigEndian()                              .ConcatMany(                              fileNumber.To_8_bytes_array_BigEndian()'                              new byte[] { type }                              );                          break;                                                               }
Missing Default,DBreeze.Storage,BackupRestorer,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\Backup\BackupRestorer.cs,DoPackage,The following switch statement is missing a default case: switch (type)              {                  case 0:                        //Write into table file                      lfs = this.GetFileStream(filename);                        //if (lfs == null)                      //{                      //    Console.WriteLine("Backup lfs = null");                      //    return;                      //}                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 1:                      //write into rollback file                      lfs = this.GetFileStream(filename + ".rol");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 2:                      //write into rollbackhelper                      lfs = this.GetFileStream(filename + ".rhp");                        if (lfs == null)                      {                          System.Diagnostics.Debug.WriteLine("Backup lfs = null");                          return;                      }                        offset = pack.Substring(9' 8).To_Int64_BigEndian();                      data = pack.Substring(17);                      lfs.Position = offset;                      lfs.Write(data' 0' data.Length);                      lfs.Flush();                      break;                  case 3:                        //3 - recreate table file (only table file)                        contains = ds.ContainsKey(filename);                      if (contains)                      {                                                  ds[filename].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename);                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename' null);                        ds[filename] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                    case 4:                        //4 - recreate rollback file (only rollback file)                        contains = ds.ContainsKey(filename + ".rol");                      if (contains)                      {                                                  ds[filename + ".rol"].Dispose();                        }                        tfn = Path.Combine(this.DataBaseFolder' filename + ".rol");                      File.Delete(tfn);                        if (!contains)                          ds.Add(filename + ".rol"' null);                        ds[filename + ".rol"] = new FileStream(tfn' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.None);                        break;                  case 5:                        //5 - removing complete table                        if (ds.ContainsKey(filename))                      {                                                  ds[filename].Dispose();                      }                        ds.Remove(filename);                        if (ds.ContainsKey(filename + ".rol"))                      {                                                  ds[filename + ".rol"].Dispose();                      }                        ds.Remove(filename + ".rol");                        if (ds.ContainsKey(filename + ".rhp"))                      {                                               ds[filename + ".rhp"].Dispose();                      }                        ds.Remove(filename + ".rhp");                        break;                }
Missing Default,DBreeze.Storage,MemoryStorage,C:\repos\hhblaze_DBreeze\DBreeze\Storage\MemoryStorage.cs,Resize,The following switch statement is missing a default case: switch (_expandStrategy)              {                  case eMemoryExpandStartegy.MULTIPLY_CAPACITY_BY_2:                        if (_capacity * 2 < upTo)                      {                          x = (int)Math.Ceiling((double)upTo / ((double) 2 * _capacity));                      }                      _capacity = _capacity * 2 * x;                                                          break;                  case eMemoryExpandStartegy.FIXED_LENGTH_INCREASE:                        if (_capacity + _increaseOnInBytes < upTo)                      {                          x = (int)Math.Ceiling((double)(upTo - _capacity) / (double)_increaseOnInBytes);                      }                      _capacity = _capacity + (_increaseOnInBytes * x);                        break;              }
Missing Default,DBreeze.Storage,StorageLayer,C:\repos\hhblaze_DBreeze\DBreeze\Storage\StorageLayer.cs,StorageLayer,The following switch statement is missing a default case: switch (trieSettings.AlternativeTableStorageType)                  {                      case DBreezeConfiguration.eStorage.DISK:                            _tableStorage = (IStorage) new FSR(fileName' trieSettings' configuration);                            break;                      case DBreezeConfiguration.eStorage.MEMORY:                            _tableStorage = (IStorage)new MSR(fileName' trieSettings' configuration);                            break;                      case DBreezeConfiguration.eStorage.RemoteInstance:                            _tableStorage = (IStorage)new RISR(fileName' trieSettings' configuration);                            break;                  }
Missing Default,DBreeze.Storage,StorageLayer,C:\repos\hhblaze_DBreeze\DBreeze\Storage\StorageLayer.cs,StorageLayer,The following switch statement is missing a default case: switch (configuration.Storage)                  {                      case DBreezeConfiguration.eStorage.DISK:                            _tableStorage = (IStorage)new FSR(fileName' trieSettings' configuration);                            break;                      case DBreezeConfiguration.eStorage.MEMORY:                            _tableStorage = (IStorage)new MSR(fileName' trieSettings' configuration);                            break;                      case DBreezeConfiguration.eStorage.RemoteInstance:                            _tableStorage = (IStorage)new RISR(fileName' trieSettings' configuration);                            break;                  }
Missing Default,DBreeze.Storage.RemoteInstance,RemoteTablesHandler,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Storage\RemoteInstance\RemoteTablesHandler.cs,ParseProtocol,The following switch statement is missing a default case: switch (protocol[1])                      {                          case 1:                              #region "OpenRemoteTable"                              //Special parsing                              int tblLen = BitConverter.ToInt32(protocol' 2);                              string tblName = System.Text.Encoding.UTF8.GetString(protocol.Substring(6'tblLen));                              string _fileName = System.IO.Path.Combine(databasePreFolderPath' tblName);                                                         _sync.EnterUpgradeableReadLock();                              try                              {                                  if (!_tIds.TryGetValue(_fileName' out callTableId))                                  {                                      _sync.EnterWriteLock();                                      try                                      {                                          if (!_tIds.TryGetValue(_fileName' out callTableId))                                          {                                              tableId++;                                                //Creating directory' if necessary                                              if (directoryIsNotCreated)                                              {                                                  System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_fileName));                                                  directoryIsNotCreated = false;                                              }                                                rt = new RemoteTable(_fileName' tableId);                                              _t[tableId] = rt;                                              _tIds[_fileName] = tableId;                                          }                                      }                                      finally                                      {                                          _sync.ExitWriteLock();                                      }                                  }                                  else                                      _t.TryGetValue(callTableId' out rt);                              }                              finally                              {                                  _sync.ExitUpgradeableReadLock();                              }                                return rt.OpenRemoteTable();                              #endregion                          case 2:                              #region "CloseRemoteTable"                                return rt.CloseRemoteTable();                                #endregion                          case 3:                              #region "DeleteRemoteTable"                              ret = rt.DeleteRemoteTable();                                _sync.EnterWriteLock();                              try                              {                                  _tIds.Remove(rt._fileName);                                                                  _t.Remove(callTableId);                                                              }                              finally                              {                                  _sync.ExitWriteLock();                              }                                return ret;                              #endregion                          case 4:                              #region DataFileWrite                              return rt.DataFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                                                     case 5:                              #region "RollbackFileWrite"                              return rt.RollbackFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                          #endregion                          case 6:                              #region "RollbackHelperFileWrite"                              return rt.RollbackHelperFileWrite(BitConverter.ToInt64(protocol' 10)' (protocol[18] == 1)' protocol.Substring(19));                              #endregion                          case 7:                              #region "DataFileRead"                              return rt.DataFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                          #endregion                          case 8:                              #region "RollbackFileRead"                              return rt.RollbackFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 9:                              #region "RollbackHelperFileRead"                              return rt.RollbackHelperFileRead(BitConverter.ToInt64(protocol' 10)' BitConverter.ToInt32(protocol' 18));                              #endregion                          case 10:                              #region "DataFileFlush"                              return rt.DataFileFlush();                              #endregion                          case 11:                              #region "RollbackFileFlush"                              return rt.RollbackFileFlush();                              #endregion                          case 12:                              #region "RollbackFileRecreate"                              return rt.RollbackFileRecreate();                              #endregion                        }
Missing Default,DBreeze.Transactions,Transaction,C:\repos\hhblaze_DBreeze\DBreeze\Transactions\Transaction.cs,Transaction,The following switch statement is missing a default case: switch(transactionType)              {                  case 0:                      break;                  case 1:                      while (true)                      {                          if (_transactionUnit.TransactionsCoordinator.GetSchema.Engine._transactionTablesLocker.AddSession(lockType' tables))                              break;                        }                      break;              }
Missing Default,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Encode_DICT_PROTO_STRING_BYTEARRAYHASHSET,The following switch statement is missing a default case: switch (compression)              {                  case Compression.eCompressionMethod.Gzip:                      encB = encB.GZip_Compress();                      break;              }
Missing Default,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Decode_DICT_PROTO_STRING_BYTEARRAYHASHSET,The following switch statement is missing a default case: switch (compression)              {                  case Compression.eCompressionMethod.Gzip:                      encB = encB.GZip_Decompress();                      break;              }
Missing Default,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Decode_DICT_PROTO_STRING_BYTEARRAYHASHSET,The following switch statement is missing a default case: switch (mode)                  {                      case 0:                            if ((el & 0x80) > 0)                          {                              sizer[size] = el;                              size++;                          }                          else                          {                              hc = 0;                              mode = 1;                              sizer[size] = el;                              size++;                              keyLength = ToUInt32(sizer);                              key = System.Text.Encoding.UTF8.GetString(encB.Substring(i + 1' (int)keyLength));                              i += (int)keyLength + 1;                              ClearSizer();                              continue;                          }                            break;                      case 1:                          //HashSet Count                          if ((el & 0x80) > 0)                          {                              sizer[size] = el;                              size++;                          }                          else                          {                              mode = 2;                              sizer[size] = el;                              size++;                              valCnt = ToUInt32(sizer);                              ClearSizer();                                if (valCnt == 0)                              {                                  retD.Add(key' new List<byte[]>());                                  mode = 0;                              }                          }                          break;                      case 2:                          if ((el & 0x80) > 0)                          {                              sizer[size] = el;                              size++;                          }                          else                          {                              sizer[size] = el;                              size++;                              if (hc == 0)                                  mhs = new List<byte[]>();                              lenBa = ToUInt32(sizer);                              mhs.Add(encB.Substring(i + 1' (int)lenBa));                              i += (int)lenBa + 1;                              hc++;                              ClearSizer();                                if (valCnt == hc)                              {                                  mode = 0;                                  retD.Add(key' mhs);                              }                              continue;                            }                          break;                  }
Missing Default,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Encode_DICT_PROTO_STRING_UINTHASHSET,The following switch statement is missing a default case: switch (compression)              {                  case Compression.eCompressionMethod.Gzip:                      encB = encB.GZip_Compress();                      break;              }
Missing Default,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Decode_DICT_PROTO_STRING_UINTHASHSET,The following switch statement is missing a default case: switch (compression)              {                  case Compression.eCompressionMethod.Gzip:                      encB = encB.GZip_Decompress();                      break;              }
Missing Default,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Decode_DICT_PROTO_STRING_UINTHASHSET,The following switch statement is missing a default case: switch (mode)                  {                      case 0:                            if ((el & 0x80) > 0)                          {                              sizer[size] = el;                              size++;                          }                          else                          {                              hc = 0;                              mode = 1;                              sizer[size] = el;                              size++;                              keyLength = ToUInt32(sizer);                              key = System.Text.Encoding.UTF8.GetString(encB.Substring(i + 1' (int)keyLength));                              i += (int)keyLength + 1;                              ClearSizer();                              continue;                          }                            break;                      case 1:                          //HashSet Count                          if ((el & 0x80) > 0)                          {                              sizer[size] = el;                              size++;                          }                          else                          {                              mode = 2;                              sizer[size] = el;                              size++;                              valCnt = ToUInt32(sizer);                              ClearSizer();                                if (valCnt == 0)                              {                                  retD.Add(key' new HashSet<uint>());                                  mode = 0;                              }                          }                          break;                      case 2:                          if ((el & 0x80) > 0)                          {                              sizer[size] = el;                              size++;                          }                          else                          {                              sizer[size] = el;                              size++;                              if (hc == 0)                                  mhs = new HashSet<uint>();                              mhs.Add(ToUInt32(sizer));                              hc++;                              ClearSizer();                                if (valCnt == hc)                              {                                  mode = 0;                                  retD.Add(key' mhs);                              }                          }                          break;                  }
Missing Default,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Encode_DICT_PROTO_UINT_BYTEARRAY,The following switch statement is missing a default case: switch (compression)              {                  case Compression.eCompressionMethod.Gzip:                      encB = encB.GZip_Compress();                      break;              }
Missing Default,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Decode_DICT_PROTO_UINT_BYTEARRAY,The following switch statement is missing a default case: switch (compression)              {                  case Compression.eCompressionMethod.Gzip:                      encB = encB.GZip_Decompress();                      break;              }
Missing Default,DBreeze.Utils,Biser,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\Biser.cs,Decode_DICT_PROTO_UINT_BYTEARRAY,The following switch statement is missing a default case: switch (mode)                  {                      case 0:                          //Key' Size of BT //                          if ((el & 0x80) > 0)                          {                              sizer[size] = el;                              size++;                          }                          else                          {                              mode = 1;                              sizer[size] = el;                              size++;                              key = ToUInt32(sizer);                              ClearSizer();                          }                            break;                      case 1:                          //Value Size                          if ((el & 0x80) > 0)                          {                              sizer[size] = el;                              size++;                          }                          else                          {                              mode = 2;                              sizer[size] = el;                              size++;                              valLen = ToUInt32(sizer);                              ClearSizer();                                if (valLen == 0)                              {                                  retD.Add(key' null);                                  mode = 0;                                  break;                              }                                val = new byte[valLen];                              valCnt = 0;                          }                          break;                      case 2:                          val[valCnt] = el;                          valCnt++;                          if (valCnt == valLen)                          {                              retD.Add(key' val);                              mode = 0;                              break;                          }                          break;                  }
Missing Default,DBreeze.Utils.Hash,MurMurHash,C:\repos\hhblaze_DBreeze\DBreeze.NetStandard\Utils\MurMurHash.cs,MurmurHash3,The following switch statement is missing a default case: switch (curLength)              {                  case 3:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8                        | data[currentIndex++] << 16);                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 2:                      k1 = (uint)(data[currentIndex++]                        | data[currentIndex++] << 8);                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;                  case 1:                      k1 = data[currentIndex++];                      k1 *= c1;                      k1 = rotl32(k1' 15);                      k1 *= c2;                      h1 ^= k1;                      break;              }
Missing Default,DBreeze.TextSearch,SBlock,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\SBlock.cs,CreateBlock,The following switch statement is missing a default case: switch (operation)              {                  case eOperation.AND:                      b = new BlockAnd();                      break;                  case eOperation.OR:                      b = new BlockOr();                      break;                  case eOperation.XOR:                      b = new BlockXOR();                      break;                  case eOperation.EXCLUDE:                      b = new BlockEXCLUDE();                      break;                           }
Missing Default,DBreeze.TextSearch,SBlock,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\SBlock.cs,GetArrays,The following switch statement is missing a default case: switch (this.TransBlockOperation)              {                  case eOperation.AND:                      if (la == null || ra == null || la.Count == 0 || ra.Count == 0)                          return foundArrays;                      la.AddRange(ra);                      this.foundArrays = la;                      return this.foundArrays;                    case eOperation.OR:                                          if (ra == null)                          ra = new List<byte[]>();                      if (la == null)                          la = new List<byte[]>();                      la.AddRange(ra);                      mrg = WABI.MergeByOrLogic(la);                      if (mrg != null)                          this.foundArrays.Add(mrg);                      return this.foundArrays;                    case eOperation.XOR:                                         if (ra == null)                          ra = new List<byte[]>();                      if (la == null)                          la = new List<byte[]>();                      la.AddRange(ra);                      mrg = WABI.MergeByXorLogic(la);                      if (mrg != null)                          this.foundArrays.Add(mrg);                      return this.foundArrays;                    case eOperation.EXCLUDE:                      if (la == null || ra == null || la.Count == 0 || ra.Count == 0)                          return this.foundArrays;                      mrg = WABI.MergeByExcludeLogic(la.FirstOrDefault()' ra.FirstOrDefault());                      if (mrg != null)                          this.foundArrays.Add(mrg);                      return this.foundArrays;              }
Missing Default,DBreeze.TextSearch,SBlock,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\SBlock.cs,GetPureBlockArrays,The following switch statement is missing a default case: switch (this.InternalBlockOperation)                  {                      case eOperation.AND:                          if (wrd.Value)                          { //Word must be FullMatched and doesn't                               if (!this._tsm.RealWords.ContainsKey(wrd.Key))      //!!No match                              {                                  //Found arrays must be cleared out                                  this.foundArrays.Clear();                                  return; //Parsed Words                              }                              else//Adding word to block array                                  this.foundArrays.Add(this._tsm.RealWords[wrd.Key].wahArray);                          }                          else                          { //Value must have contains                              echoes = new List<byte[]>();                              foreach (var conw in this._tsm.PureWords[wrd.Key].StartsWith)   //Adding all pure word StartsWith echoes                                  if (this._tsm.RealWords.ContainsKey(conw))                                      echoes.Add(this._tsm.RealWords[conw].wahArray);                                if (this._tsm.RealWords.ContainsKey(wrd.Key))  //And word itself                                  echoes.Add(this._tsm.RealWords[wrd.Key].wahArray);                                if (echoes.Count > 0)                                  this.foundArrays.Add(WABI.MergeByOrLogic(echoes));  //Echoes must be merged by OrLogic                              else                              {                                  //Found arrays must be cleared out                                  this.foundArrays.Clear();                                  return; //Parsed Words                              }                          }                          break;                      case eOperation.OR:                          if (wrd.Value)                          {                              if (this._tsm.RealWords.ContainsKey(wrd.Key))  //And word itself                                  this.foundArrays.Add(this._tsm.RealWords[wrd.Key].wahArray);                          }                          else                          {                              echoes = new List<byte[]>();                              foreach (var conw in this._tsm.PureWords[wrd.Key].StartsWith)   //Adding all pure word StartsWith echoes                                  if (this._tsm.RealWords.ContainsKey(conw))                                      echoes.Add(this._tsm.RealWords[conw].wahArray);                                if (this._tsm.RealWords.ContainsKey(wrd.Key))  //And word itself                                  echoes.Add(this._tsm.RealWords[wrd.Key].wahArray);                                if (echoes.Count > 0)                                  this.foundArrays.Add(WABI.MergeByOrLogic(echoes));                          }                          break;                  }
Missing Default,DBreeze.TextSearch,TextSearchHandler,C:\repos\hhblaze_DBreeze\DBreeze\TextSearch\TextSearchHandler.cs,InsertDocumentText,The following switch statement is missing a default case: switch (iMode)                  {                      case eInsertMode.Insert:                          //Comparing                           if (oldSearchables.Intersect(pST.Keys).Count() == oldSearchables.Count && oldSearchables.Count == pST.Keys.Count)                              return; //Going out' nothing to insert                            foreach (var ps1i in pST)                          {                              sbPs.Append(ps1i.Key);                              sbPs.Append(" ");                          }                          break;                      case eInsertMode.Append:                      case eInsertMode.Remove:                            if ((iMode == eInsertMode.Append)                              &&                              oldSearchables.Intersect(pST.Keys).Count() == oldSearchables.Count                              &&                              oldSearchables.Count == pST.Keys.Count                              )                              return; //Going out' nothing to insert                            foreach (var ew in pST.Keys)                          {                              if (iMode == eInsertMode.Append)                                  oldSearchables.Add(ew);                              else                                  oldSearchables.Remove(ew);                          }                            foreach (var el in oldSearchables)                          {                              sbPs.Append(el);                              sbPs.Append(" ");                          }                            break;                  }
