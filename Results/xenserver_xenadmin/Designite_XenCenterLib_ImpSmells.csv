Implementation smell,Namespace,Class,File,Method,Description
Complex Method,XenCenterLib,PathValidator,C:\repos\xenserver_xenadmin\XenCenterLib\PathValidator.cs,IsPathValid,Cyclomatic complexity of the method is 8
Complex Method,XenCenterLib,StringUtility,C:\repos\xenserver_xenadmin\XenCenterLib\StringUtility.cs,IsValidNetmask,Cyclomatic complexity of the method is 10
Long Parameter List,XenCenterLib,NamedPipes,C:\repos\xenserver_xenadmin\XenCenterLib\NamedPipes.cs,CreateNamedPipe,The method has 8 parameters. Parameters: pipeName' openMode' pipeMode' maxInstances' outputBufferSize' inputBufferSize' timeoutInterval' pipeSecurityDescriptor
Long Parameter List,XenCenterLib,NamedPipes,C:\repos\xenserver_xenadmin\XenCenterLib\NamedPipes.cs,ReadFile,The method has 5 parameters. Parameters: fileHandle' dataBuffer' nNumberOfBytesToRead' lpNumberOfBytesRead' overlapped
Long Parameter List,XenCenterLib,NamedPipes,C:\repos\xenserver_xenadmin\XenCenterLib\NamedPipes.cs,WriteFile,The method has 5 parameters. Parameters: fileHandle' dataBuffer' nNumberOfBytesToWrite' lpNumberOfBytesWritten' overlapped
Long Parameter List,XenCenterLib,NamedPipes,C:\repos\xenserver_xenadmin\XenCenterLib\NamedPipes.cs,PeekNamedPipe,The method has 6 parameters. Parameters: handle' buffer' nBufferSize' bytesRead' bytesAvail' BytesLeftThisMessage
Long Parameter List,XenCenterLib,NamedPipes,C:\repos\xenserver_xenadmin\XenCenterLib\NamedPipes.cs,CallNamedPipe,The method has 7 parameters. Parameters: lpNamedPipeName' lpInBuffer' nInBufferSize' lpOutBuffer' nOutBufferSize' lpBytesRead' nTimeOut
Long Parameter List,XenCenterLib,Win32,C:\repos\xenserver_xenadmin\XenCenterLib\Win32.cs,ToUnicode,The method has 6 parameters. Parameters: wVirtKey' wScanCode' lpKeyState' pwszBuff' cchBuff' wFlags
Long Parameter List,XenCenterLib,Win32,C:\repos\xenserver_xenadmin\XenCenterLib\Win32.cs,CreateWindowEx,The method has 12 parameters. Parameters: dwExStyle' lpClassName' lpWindowName' dwStyle' x' y' nWidth' nHeight' hWndParent' hMenu' hInstance' lpParam
Long Parameter List,XenCenterLib,Win32,C:\repos\xenserver_xenadmin\XenCenterLib\Win32.cs,SetWindowPos,The method has 7 parameters. Parameters: hWnd' hWndInsertAfter' X' Y' cx' cy' uFlags
Long Parameter List,XenCenterLib,Win32,C:\repos\xenserver_xenadmin\XenCenterLib\Win32.cs,FormatMessage,The method has 7 parameters. Parameters: dwFlags' lpSource' dwMessageId' dwLanguageId' lpBuffer' nSize' pArguments
Long Parameter List,XenCenterLib,Win32,C:\repos\xenserver_xenadmin\XenCenterLib\Win32.cs,CallWindowProc,The method has 5 parameters. Parameters: lpPrevWndFunc' hWnd' Msg' wParam' lParam
Long Identifier,XenCenterLib,Win32,C:\repos\xenserver_xenadmin\XenCenterLib\Win32.cs,,The length of the parameter FORMAT_MESSAGE_ALLOCATE_BUFFER is 30.
Long Statement,XenCenterLib.Compression,CompressionFactory,C:\repos\xenserver_xenadmin\XenCenterLib\Compression\CompressionFactory.cs,Reader,The length of the statement  "            throw new NotSupportedException(String.Format("Type: {0} is not supported by CompressionStream Reader"' compressionType)); " is 122.
Long Statement,XenCenterLib.Compression,CompressionFactory,C:\repos\xenserver_xenadmin\XenCenterLib\Compression\CompressionFactory.cs,Writer,The length of the statement  "            throw new NotSupportedException(String.Format("Type: {0} is not supported by CompressionStream Writer"' compressionType)); " is 122.
Long Statement,XenCenterLib,StringUtility,C:\repos\xenserver_xenadmin\XenCenterLib\StringUtility.cs,IsValidNetmask,The length of the statement  "                //Converting value to byte if possible. The second check is to make sure that valid' but server side not supported values not get through (eg. 000' 00) " is 151.
Magic Number,XenCenterLib,Pipe,C:\repos\xenserver_xenadmin\XenCenterLib\NamedPipes.cs,Pipe,The following statement contains a magic number: Handle = CreateNamedPipe(pipePath' PIPE_ACCESS_DUPLEX'                      PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT'                      PIPE_UNLIMITED_INSTANCES' 512' 512' NMPWAIT_WAIT_FOREVER' IntPtr.Zero);
Magic Number,XenCenterLib,Pipe,C:\repos\xenserver_xenadmin\XenCenterLib\NamedPipes.cs,Pipe,The following statement contains a magic number: Handle = CreateNamedPipe(pipePath' PIPE_ACCESS_DUPLEX'                      PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT'                      PIPE_UNLIMITED_INSTANCES' 512' 512' NMPWAIT_WAIT_FOREVER' IntPtr.Zero);
Magic Number,XenCenterLib,Pipe,C:\repos\xenserver_xenadmin\XenCenterLib\NamedPipes.cs,Disconnect,The following statement contains a magic number: if (pipeThread != null)                  {                      byte[] msg = Encoding.UTF8.GetBytes(STOP_LISTENING_MSG);                      byte[] rcv = new byte[0];                      UInt32 bytesRead;                      UInt32 timeout = 30 * 1000;                        CallNamedPipe(pipePath' msg' (UInt32)msg.Length' rcv' (UInt32)rcv.Length' out bytesRead' timeout);                  }
Magic Number,XenCenterLib,Pipe,C:\repos\xenserver_xenadmin\XenCenterLib\NamedPipes.cs,Disconnect,The following statement contains a magic number: if (pipeThread != null)                  {                      byte[] msg = Encoding.UTF8.GetBytes(STOP_LISTENING_MSG);                      byte[] rcv = new byte[0];                      UInt32 bytesRead;                      UInt32 timeout = 30 * 1000;                        CallNamedPipe(pipePath' msg' (UInt32)msg.Length' rcv' (UInt32)rcv.Length' out bytesRead' timeout);                  }
Magic Number,XenCenterLib,Pipe,C:\repos\xenserver_xenadmin\XenCenterLib\NamedPipes.cs,BackgroundPipeThread,The following statement contains a magic number: while (run)                  {                      try                      {                          NativeOverlapped overlapped = new NativeOverlapped();                          if (!ConnectNamedPipe(Handle' ref overlapped))                          {                              Win32Exception exn = new Win32Exception();                              if (exn.NativeErrorCode == ERROR_PIPE_CONNECTED)                              {                                  // This is OK. It simply means a remote process has connected to the                                  // named pipe since we did the CreateNamedPipe.                              }                              else                              {                                  throw new Win32Exception("ConnectNamedPipe failed"' exn);                              }                          }                            ProcessPipeMessage();                            if (!DisconnectNamedPipe(Handle))                          {                              throw new Win32Exception("DisconnectNamedPipe failed"' new Win32Exception());                          }                      }                      catch (Exception exn)                      {                          log.Error("Error in named pipe thread."' exn);                          // Sanity: pause after errors to prevent massive log spamming/CPU drain                          // in the event of an infinite error loop                          Thread.Sleep(1000);                      }                  }
Magic Number,XenCenterLib,Pipe,C:\repos\xenserver_xenadmin\XenCenterLib\NamedPipes.cs,ProcessPipeMessage,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream())                  {                      while (true)                      {                          // Loop as follows:                          // Peek at the pipe to see how much data is available                          // Read the data and append it to the buffer                          // If we get ERROR_MORE_DATA' repeat                          UInt32 bytesRead' bytesAvailable' bytesLeft;                            // First peek into the pipe to see how much data is waiting.                          byte[] peekBuf = new byte[0];                          if (!PeekNamedPipe(Handle' peekBuf' (UInt32)peekBuf.Length' out bytesRead' out bytesAvailable' out bytesLeft))                          {                              throw new Win32Exception(                                  string.Format("PeekNamedPipe failed. bytesRead={0} bytesAvailable={1} bytesLeft={2}"'                                  bytesRead' bytesAvailable' bytesLeft)'                                  new Win32Exception());                          }                            // Sanity check: throw away message if it is > 1 MB                          if (ms.Length + bytesLeft > 1024 * 1024)                          {                              throw new Exception("Indecently large message sent into named pipe: rejecting.");                          }                            // Now allocate a buffer of the correct size and read in the message.                          byte[] readBuf = new byte[bytesAvailable];                          if (!ReadFile(Handle' readBuf' (UInt32)readBuf.Length' out bytesRead' ref overlapped))                          {                              Win32Exception exn = new Win32Exception();                              if (exn.NativeErrorCode == ERROR_MORE_DATA)                              {                                  // The peek may have looked into the pipe before the write operation                                  // had completed' and so reported a message size before the whole                                  // message was sent. In this case we need to go round the loop again                                  // with a larger buffer.                                  ms.Write(readBuf' 0' (int)bytesRead);                                  continue;                              }                              else                              {                                  throw new Win32Exception(                                      string.Format("ReadFile failed. readBuf.Length={0} bytesRead={1}"'                                      readBuf.Length' bytesRead)' exn);                              }                          }                          else                          {                              ms.Write(readBuf' 0' (int)bytesRead);                              break;                          }                      }                      readMessage = ms.ToArray();                  }
Magic Number,XenCenterLib,Pipe,C:\repos\xenserver_xenadmin\XenCenterLib\NamedPipes.cs,ProcessPipeMessage,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream())                  {                      while (true)                      {                          // Loop as follows:                          // Peek at the pipe to see how much data is available                          // Read the data and append it to the buffer                          // If we get ERROR_MORE_DATA' repeat                          UInt32 bytesRead' bytesAvailable' bytesLeft;                            // First peek into the pipe to see how much data is waiting.                          byte[] peekBuf = new byte[0];                          if (!PeekNamedPipe(Handle' peekBuf' (UInt32)peekBuf.Length' out bytesRead' out bytesAvailable' out bytesLeft))                          {                              throw new Win32Exception(                                  string.Format("PeekNamedPipe failed. bytesRead={0} bytesAvailable={1} bytesLeft={2}"'                                  bytesRead' bytesAvailable' bytesLeft)'                                  new Win32Exception());                          }                            // Sanity check: throw away message if it is > 1 MB                          if (ms.Length + bytesLeft > 1024 * 1024)                          {                              throw new Exception("Indecently large message sent into named pipe: rejecting.");                          }                            // Now allocate a buffer of the correct size and read in the message.                          byte[] readBuf = new byte[bytesAvailable];                          if (!ReadFile(Handle' readBuf' (UInt32)readBuf.Length' out bytesRead' ref overlapped))                          {                              Win32Exception exn = new Win32Exception();                              if (exn.NativeErrorCode == ERROR_MORE_DATA)                              {                                  // The peek may have looked into the pipe before the write operation                                  // had completed' and so reported a message size before the whole                                  // message was sent. In this case we need to go round the loop again                                  // with a larger buffer.                                  ms.Write(readBuf' 0' (int)bytesRead);                                  continue;                              }                              else                              {                                  throw new Win32Exception(                                      string.Format("ReadFile failed. readBuf.Length={0} bytesRead={1}"'                                      readBuf.Length' bytesRead)' exn);                              }                          }                          else                          {                              ms.Write(readBuf' 0' (int)bytesRead);                              break;                          }                      }                      readMessage = ms.ToArray();                  }
Magic Number,XenCenterLib,PartialIP,C:\repos\xenserver_xenadmin\XenCenterLib\PartialIP.cs,Equals,The following statement contains a magic number: if (A > -1 && A != addressBytes[0])                  return false;              else if (B > -1 && B != addressBytes[1])                  return false;              else if (C > -1 && C != addressBytes[2])                  return false;              else if (D > -1 && D != addressBytes[3])                  return false;
Magic Number,XenCenterLib,PartialIP,C:\repos\xenserver_xenadmin\XenCenterLib\PartialIP.cs,Equals,The following statement contains a magic number: if (A > -1 && A != addressBytes[0])                  return false;              else if (B > -1 && B != addressBytes[1])                  return false;              else if (C > -1 && C != addressBytes[2])                  return false;              else if (D > -1 && D != addressBytes[3])                  return false;
Magic Number,XenCenterLib,PartialIP,C:\repos\xenserver_xenadmin\XenCenterLib\PartialIP.cs,Parse,The following statement contains a magic number: return new PartialIP(GetSegment(segments' 0)' GetSegment(segments' 1)'                  GetSegment(segments' 2)' GetSegment(segments' 3));
Magic Number,XenCenterLib,PartialIP,C:\repos\xenserver_xenadmin\XenCenterLib\PartialIP.cs,Parse,The following statement contains a magic number: return new PartialIP(GetSegment(segments' 0)' GetSegment(segments' 1)'                  GetSegment(segments' 2)' GetSegment(segments' 3));
Magic Number,XenCenterLib,PathValidator,C:\repos\xenserver_xenadmin\XenCenterLib\PathValidator.cs,IsPathValid,The following statement contains a magic number: try  			{  				if (Path.IsPathRooted(path))  				{  					path = path[0] == '\\' && path.Length == 1  					       	? path.Substring(1)  					       	: path.Substring(2);  				}  			}  			catch(ArgumentException)  			{  				//path contains a character from Path.GetInvalidPathChars()  				return false;  			}
Magic Number,XenCenterLib,Processes,C:\repos\xenserver_xenadmin\XenCenterLib\Processes.cs,GetExePath,The following statement contains a magic number: Win32.GetModuleFileNameEx(proc.Handle' IntPtr.Zero' sb' 1024);
Magic Number,XenCenterLib,StreamUtilities,C:\repos\xenserver_xenadmin\XenCenterLib\StreamUtilities.cs,BufferedStreamCopy,The following statement contains a magic number: const long bufferSize = 2*1024*1024;
Magic Number,XenCenterLib,StreamUtilities,C:\repos\xenserver_xenadmin\XenCenterLib\StreamUtilities.cs,BufferedStreamCopy,The following statement contains a magic number: const long bufferSize = 2*1024*1024;
Magic Number,XenCenterLib,StreamUtilities,C:\repos\xenserver_xenadmin\XenCenterLib\StreamUtilities.cs,BufferedStreamCopy,The following statement contains a magic number: const long bufferSize = 2*1024*1024;
Magic Number,XenCenterLib,StringUtility,C:\repos\xenserver_xenadmin\XenCenterLib\StringUtility.cs,IsValidNetmask,The following statement contains a magic number: if (parts.Count != 4 || parts.Any(p => p.Length > 3))                  return false;
Magic Number,XenCenterLib,StringUtility,C:\repos\xenserver_xenadmin\XenCenterLib\StringUtility.cs,IsValidNetmask,The following statement contains a magic number: if (parts.Count != 4 || parts.Any(p => p.Length > 3))                  return false;
Magic Number,XenCenterLib,StringUtility,C:\repos\xenserver_xenadmin\XenCenterLib\StringUtility.cs,IsValidNetmask,The following statement contains a magic number: if (bits.Count != 32)                  return false;
Magic Number,XenCenterLib,StringUtility,C:\repos\xenserver_xenadmin\XenCenterLib\StringUtility.cs,IsValidNetmask,The following statement contains a magic number: for (int octetNo = 0; octetNo < 4; octetNo ++)                  for (int relPos = 7; relPos >=0 ; relPos --) //less significant bit is on the left                  {                      bool val = bits[octetNo * 8 +  relPos];                                            //if there is 1 again and there has been any 0 before' netmask is invalid. All other cases (if we get here) are valid.                      if (wasZero && val)                          return false;                        if (!val)                          wasZero = true;                  }
Magic Number,XenCenterLib,StringUtility,C:\repos\xenserver_xenadmin\XenCenterLib\StringUtility.cs,IsValidNetmask,The following statement contains a magic number: for (int octetNo = 0; octetNo < 4; octetNo ++)                  for (int relPos = 7; relPos >=0 ; relPos --) //less significant bit is on the left                  {                      bool val = bits[octetNo * 8 +  relPos];                                            //if there is 1 again and there has been any 0 before' netmask is invalid. All other cases (if we get here) are valid.                      if (wasZero && val)                          return false;                        if (!val)                          wasZero = true;                  }
Magic Number,XenCenterLib,StringUtility,C:\repos\xenserver_xenadmin\XenCenterLib\StringUtility.cs,IsValidNetmask,The following statement contains a magic number: for (int octetNo = 0; octetNo < 4; octetNo ++)                  for (int relPos = 7; relPos >=0 ; relPos --) //less significant bit is on the left                  {                      bool val = bits[octetNo * 8 +  relPos];                                            //if there is 1 again and there has been any 0 before' netmask is invalid. All other cases (if we get here) are valid.                      if (wasZero && val)                          return false;                        if (!val)                          wasZero = true;                  }
Magic Number,XenCenterLib,StringUtility,C:\repos\xenserver_xenadmin\XenCenterLib\StringUtility.cs,IsIPAddress,The following statement contains a magic number: for (int i = 1; i < 3; i++)              {                  int v;                  if (!int.TryParse(m.Groups[i].Value' out v))                      return false;                    if (v > 255)                      return false;              }
Magic Number,XenCenterLib,StringUtility,C:\repos\xenserver_xenadmin\XenCenterLib\StringUtility.cs,IsIPAddress,The following statement contains a magic number: for (int i = 1; i < 3; i++)              {                  int v;                  if (!int.TryParse(m.Groups[i].Value' out v))                      return false;                    if (v > 255)                      return false;              }
Magic Number,XenCenterLib,TimeUtil,C:\repos\xenserver_xenadmin\XenCenterLib\TimeUtil.cs,TicksToSeconds,The following statement contains a magic number: return ticks / 10000000;
Magic Number,XenCenterLib,Win32,C:\repos\xenserver_xenadmin\XenCenterLib\Win32.cs,FlashTaskbar,The following statement contains a magic number: fwi.uCount = 3;
Missing Default,XenCenterLib.Archive,DotNetZipZipIterator,C:\repos\xenserver_xenadmin\XenCenterLib\Archive\ZipArchiveIterator.cs,zipFile_ExtractProgress,The following switch statement is missing a default case: switch (e.EventType)              {                  case ZipProgressEventType.Extracting_EntryBytesWritten:                      {                          EventHandler<ExtractProgressChangedEventArgs> handler = CurrentFileExtractProgressChanged;                          if (handler != null)                              handler(this' new ExtractProgressChangedEventArgs(e.BytesTransferred' e.TotalBytesToTransfer));                      }                      break;                  case ZipProgressEventType.Extracting_AfterExtractEntry:                      {                          EventHandler<EventArgs> handler = CurrentFileExtractCompleted;                          if (handler != null)                              handler(this' e);                      }                      break;              }
