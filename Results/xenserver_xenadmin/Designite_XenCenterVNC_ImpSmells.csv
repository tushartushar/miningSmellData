Implementation smell,Namespace,Class,File,Method,Description
Long Method,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The method has 142 lines of code.
Long Method,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The method has 182 lines of code.
Complex Method,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,reverse,Cyclomatic complexity of the method is 9
Long Parameter List,DotNetVnc,GraphicsUtils,C:\repos\xenserver_xenadmin\XenCenterVNC\GraphicsUtils.cs,copyRect,The method has 8 parameters. Parameters: src' x' y' width' height' dest' dx' dy
Long Parameter List,DotNetVnc,GraphicsUtils,C:\repos\xenserver_xenadmin\XenCenterVNC\GraphicsUtils.cs,BitBlt,The method has 9 parameters. Parameters: hdc' nXDest' nYDest' nWidth' nHeight' hdcSrc' nXSrc' nYSrc' dwRop
Long Parameter List,DotNetVnc,IVNCGraphicsClient,C:\repos\xenserver_xenadmin\XenCenterVNC\IVNCGraphicsClient.cs,ClientCopyRectangle,The method has 6 parameters. Parameters: x' y' width' height' dx' dy
Long Parameter List,DotNetVnc,IVNCGraphicsClient,C:\repos\xenserver_xenadmin\XenCenterVNC\IVNCGraphicsClient.cs,ClientDrawImage,The method has 5 parameters. Parameters: image' x' y' width' height
Long Parameter List,DotNetVnc,IVNCGraphicsClient,C:\repos\xenserver_xenadmin\XenCenterVNC\IVNCGraphicsClient.cs,ClientFillRectangle,The method has 5 parameters. Parameters: x' y' width' height' color
Long Parameter List,DotNetVnc,IVNCGraphicsClient,C:\repos\xenserver_xenadmin\XenCenterVNC\IVNCGraphicsClient.cs,ClientSetCursor,The method has 5 parameters. Parameters: image' x' y' width' height
Long Parameter List,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,writeFramebufferUpdateRequest,The method has 5 parameters. Parameters: x' y' width' height' incremental
Long Parameter List,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The method has 8 parameters. Parameters: width' height' x' y' start' length' mask_length' cursor
Long Parameter List,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,BitmapToClient,The method has 8 parameters. Parameters: width' height' x' y' start' stride' cursor' img
Long Parameter List,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readRawEncoding_,The method has 6 parameters. Parameters: start' x' y' width' height' cursor
Long Parameter List,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,fillRectBytes,The method has 7 parameters. Parameters: data' stride' x' y' width' height' color
Long Identifier,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,,The length of the parameter BACKGROUND_SPECIFIED_SUBENCODING is 32.
Long Identifier,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,,The length of the parameter FOREGROUND_SPECIFIED_SUBENCODING is 32.
Empty Catch Block,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,Close,The method has an empty catch block.
Magic Number,DotNetVnc,KeyMap,C:\repos\xenserver_xenadmin\XenCenterVNC\KeyMap.cs,parse_keysym,The following statement contains a magic number: if (s != null)              {                  NumberStyles style;                    if (s.StartsWith("0x") || s.StartsWith("0X"))                  {                      s = s.Substring(2);                      style = NumberStyles.HexNumber;                  }                  else                  {                      style = NumberStyles.Integer;                  }                    int keysym;                  if (int.TryParse(s' style' null' out keysym))                  {                      return keysym;                  }              }
Magic Number,DotNetVnc,InterceptKeys,C:\repos\xenserver_xenadmin\XenCenterVNC\KeyMap.cs,HookCallback,The following statement contains a magic number: if (nCode < 0)              {                  return CallNextHookEx(_hookID' nCode' wParam' lParam);              }              else              {                  KBDLLHOOKSTRUCT kbStruct = *lParam;                    bool extended = (kbStruct.flags & FLAG_EXTENDED) == FLAG_EXTENDED;                  bool down = (wParam == WM_KEYDOWN) || (wParam == WM_SYSKEYDOWN);                  int scanCode = kbStruct.scanCode;                  int keySym = KeyMap.translateKey((Keys)kbStruct.vkCode);                    /* kbStruct.scanCode for NUM_LOCK and PAUSE are the same (69).                   * But NUM_LOCK is an extended key' where as PAUSE is not.                   * QEMU doesn't support PAUSE and expects NUM_LOCK scanCode                   * to be sent as 69                   */                    switch (scanCode)                  {                      /* Although RIGHT_SHIFT' NUMS_LOCK are extended keys'                       * scan code for these keys are not prefixed with 0xe0.                       */                      case RIGHT_SHIFT_SCAN:                      case NUM_LOCK_SCAN:                         break;                      default:                          /* 128 is added to scanCode to differentiate                           * an extended key. Scan code for all extended keys                           * needs to be prefixed with 0xe0' so adding 128                           * or ( | 0x80) will give a hint to qemu that this                           * scanCode is an extended one and qemu can then prefix                           * scanCode with 0xe0                           */                          scanCode += (extended ? 128 : 0);                          break;                  }                    if (InterceptKeys.keyEvent != null)                  {                      InterceptKeys.keyEvent(down' scanCode' keySym);                  }                    if (bubble || scanCode == NUM_LOCK_SCAN)                  {                      return CallNextHookEx(_hookID' nCode' wParam' lParam);                  }                  else                  {                      return 1; // Prevent the message being passed on.                  }              }
Magic Number,DotNetVnc,MyStream,C:\repos\xenserver_xenadmin\XenCenterVNC\MyStream.cs,MyStream,The following statement contains a magic number: this.outStream = new BufferedStream(stream' 1024);
Magic Number,DotNetVnc,MyStream,C:\repos\xenserver_xenadmin\XenCenterVNC\MyStream.cs,MyStream,The following statement contains a magic number: this.inStream = new BufferedStream(stream' 65536);
Magic Number,DotNetVnc,MyStream,C:\repos\xenserver_xenadmin\XenCenterVNC\MyStream.cs,writeInt16,The following statement contains a magic number: writebuf[0] = (byte)((v >> 8) & 0xff);
Magic Number,DotNetVnc,MyStream,C:\repos\xenserver_xenadmin\XenCenterVNC\MyStream.cs,writeInt16,The following statement contains a magic number: outStream.Write(writebuf' 0' 2);
Magic Number,DotNetVnc,MyStream,C:\repos\xenserver_xenadmin\XenCenterVNC\MyStream.cs,writeInt32,The following statement contains a magic number: writebuf[0] = (byte)((v >> 24) & 0xff);
Magic Number,DotNetVnc,MyStream,C:\repos\xenserver_xenadmin\XenCenterVNC\MyStream.cs,writeInt32,The following statement contains a magic number: writebuf[1] = (byte)((v >> 16) & 0xff);
Magic Number,DotNetVnc,MyStream,C:\repos\xenserver_xenadmin\XenCenterVNC\MyStream.cs,writeInt32,The following statement contains a magic number: writebuf[2] = (byte)((v >> 8)  & 0xff);
Magic Number,DotNetVnc,MyStream,C:\repos\xenserver_xenadmin\XenCenterVNC\MyStream.cs,writeInt32,The following statement contains a magic number: writebuf[2] = (byte)((v >> 8)  & 0xff);
Magic Number,DotNetVnc,MyStream,C:\repos\xenserver_xenadmin\XenCenterVNC\MyStream.cs,writeInt32,The following statement contains a magic number: writebuf[3] = (byte)( v        & 0xff);
Magic Number,DotNetVnc,MyStream,C:\repos\xenserver_xenadmin\XenCenterVNC\MyStream.cs,writeInt32,The following statement contains a magic number: outStream.Write(writebuf' 0' 4);
Magic Number,DotNetVnc,MyStream,C:\repos\xenserver_xenadmin\XenCenterVNC\MyStream.cs,readCard16,The following statement contains a magic number: return (short)((b1 << 8) | b0);
Magic Number,DotNetVnc,MyStream,C:\repos\xenserver_xenadmin\XenCenterVNC\MyStream.cs,readCard32,The following statement contains a magic number: return (b3 << 24) | (b2 << 16) | (b1 << 8) | b0;
Magic Number,DotNetVnc,MyStream,C:\repos\xenserver_xenadmin\XenCenterVNC\MyStream.cs,readCard32,The following statement contains a magic number: return (b3 << 24) | (b2 << 16) | (b1 << 8) | b0;
Magic Number,DotNetVnc,MyStream,C:\repos\xenserver_xenadmin\XenCenterVNC\MyStream.cs,readCard32,The following statement contains a magic number: return (b3 << 24) | (b2 << 16) | (b1 << 8) | b0;
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,VNCStream,The following statement contains a magic number: imageUpdateThreshold = freq / 3;
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,getProtocolVersion,The following statement contains a magic number: byte[] buffer = new byte[12];
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,getProtocolVersion,The following statement contains a magic number: this.stream.readFully(buffer' 0' 12);
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,getProtocolVersion,The following statement contains a magic number: char[] chars = new char[12];
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,getProtocolVersion,The following statement contains a magic number: Encoding.ASCII.GetDecoder().GetChars(buffer' 0' 12' chars' 0);
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,getProtocolVersion,The following statement contains a magic number: return new ProtocolVersion(Int32.Parse(match.Groups[1].Value)'                                         Int32.Parse(match.Groups[2].Value));
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readPixelFormat,The following statement contains a magic number: this.stream.readPadding(3);
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,writePixelFormat,The following statement contains a magic number: this.stream.writePadding(3);
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,writePixelFormat,The following statement contains a magic number: this.stream.writePadding(3);
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,force32bpp,The following statement contains a magic number: this.bitsPerPixel = 32;
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,force32bpp,The following statement contains a magic number: this.depth = 24;
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,force32bpp,The following statement contains a magic number: this.redMax = 255;
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,force32bpp,The following statement contains a magic number: this.greenMax = 255;
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,force32bpp,The following statement contains a magic number: this.blueMax = 255;
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,force32bpp,The following statement contains a magic number: this.redShift = 16;
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,force32bpp,The following statement contains a magic number: this.greenShift = 8;
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,setupPixelFormat,The following statement contains a magic number: bytesPerPixel = bitsPerPixel >> 3;
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,setupPixelFormat,The following statement contains a magic number: if (bitsPerPixel == 32 || bitsPerPixel == 8)              {                  pixelFormat = PixelFormat.Format32bppRgb;                  pixelFormatCursor = PixelFormat.Format32bppArgb;              }              else if (bitsPerPixel == 16)              {                  rgb565 = redShift == 11;                  pixelFormat =                      rgb565 ?                          PixelFormat.Format16bppRgb565 :                          PixelFormat.Format16bppRgb555;                  pixelFormatCursor = PixelFormat.Format16bppArgb1555;              }              else              {                  throw new IOException("unexpected bits per pixel: " + bitsPerPixel);              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,setupPixelFormat,The following statement contains a magic number: if (bitsPerPixel == 32 || bitsPerPixel == 8)              {                  pixelFormat = PixelFormat.Format32bppRgb;                  pixelFormatCursor = PixelFormat.Format32bppArgb;              }              else if (bitsPerPixel == 16)              {                  rgb565 = redShift == 11;                  pixelFormat =                      rgb565 ?                          PixelFormat.Format16bppRgb565 :                          PixelFormat.Format16bppRgb555;                  pixelFormatCursor = PixelFormat.Format16bppArgb1555;              }              else              {                  throw new IOException("unexpected bits per pixel: " + bitsPerPixel);              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,setupPixelFormat,The following statement contains a magic number: if (bitsPerPixel == 32 || bitsPerPixel == 8)              {                  pixelFormat = PixelFormat.Format32bppRgb;                  pixelFormatCursor = PixelFormat.Format32bppArgb;              }              else if (bitsPerPixel == 16)              {                  rgb565 = redShift == 11;                  pixelFormat =                      rgb565 ?                          PixelFormat.Format16bppRgb565 :                          PixelFormat.Format16bppRgb555;                  pixelFormatCursor = PixelFormat.Format16bppArgb1555;              }              else              {                  throw new IOException("unexpected bits per pixel: " + bitsPerPixel);              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,setupPixelFormat,The following statement contains a magic number: if (bitsPerPixel == 32 || bitsPerPixel == 8)              {                  pixelFormat = PixelFormat.Format32bppRgb;                  pixelFormatCursor = PixelFormat.Format32bppArgb;              }              else if (bitsPerPixel == 16)              {                  rgb565 = redShift == 11;                  pixelFormat =                      rgb565 ?                          PixelFormat.Format16bppRgb565 :                          PixelFormat.Format16bppRgb555;                  pixelFormatCursor = PixelFormat.Format16bppArgb1555;              }              else              {                  throw new IOException("unexpected bits per pixel: " + bitsPerPixel);              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,handshake,The following statement contains a magic number: if (protocolVersion.major < 3)              {                  throw new VNCException(                      "don't know protocol version " + protocolVersion.major                   );              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,authenticationExchange,The following statement contains a magic number: if (scheme == 0)              {                  String reason = this.stream.readString();                  throw new VNCException("connection failed: " + reason);              }              else if (scheme == 1)              {                  // no authentication needed              }              else if (scheme == 2)              {                  PasswordAuthentication(password);              }              else              {                  throw new VNCException(                      "unexpected authentication scheme: " + scheme                  );              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,PasswordAuthentication,The following statement contains a magic number: byte[] keyBytes = new byte[8];
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,PasswordAuthentication,The following statement contains a magic number: for (int i = 0; (i < 8) && (i < password.Length); ++i)              {                  keyBytes[i] = reverse((byte)password[i]);              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,PasswordAuthentication,The following statement contains a magic number: byte[] challenge = new byte[16];
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,PasswordAuthentication,The following statement contains a magic number: this.stream.readFully(challenge' 0' 16);
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,PasswordAuthentication,The following statement contains a magic number: byte[] response = chiper.TransformFinalBlock(challenge' 0' 16);
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,PasswordAuthentication,The following statement contains a magic number: this.stream.Write(response' 0' 16);
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,PasswordAuthentication,The following statement contains a magic number: if (status == 0)              {                  // ok              }              else if (status == 1 || status == 2)              {                  throw new VNCAuthenticationException();              }              else              {                  throw new VNCException("Bad Authentication Response");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,writeKey,The following statement contains a magic number: this.stream.writePadding(2);
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,pointerWheelEvent,The following statement contains a magic number: lock (this.writeLock)              {                  try                  {                      /*                        The RFB protocol specifies a down-up pair for each                        scroll of the wheel' on button 4 for scrolling up' and                        button 5 for scrolling down.                      */                        int m;                        if (r < 0)                      {                          r = -r;                          m = 8;                      }                      else                      {                          m = 16;                      }                      for (int i = 0; i < r; i++)                      {                          pointerEvent_(m' x' y);                          pointerEvent_(0' x' y);                      }                        this.stream.Flush();                  }                  catch (IOException e)                  {                      Log.Warn(e' e);                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,pointerWheelEvent,The following statement contains a magic number: lock (this.writeLock)              {                  try                  {                      /*                        The RFB protocol specifies a down-up pair for each                        scroll of the wheel' on button 4 for scrolling up' and                        button 5 for scrolling down.                      */                        int m;                        if (r < 0)                      {                          r = -r;                          m = 8;                      }                      else                      {                          m = 16;                      }                      for (int i = 0; i < r; i++)                      {                          pointerEvent_(m' x' y);                          pointerEvent_(0' x' y);                      }                        this.stream.Flush();                  }                  catch (IOException e)                  {                      Log.Warn(e' e);                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,clientCutText,The following statement contains a magic number: lock (this.writeLock)              {                  try                  {                      this.stream.writeInt8(CLIENT_CUT_TEXT);                      this.stream.writePadding(3);                      this.stream.writeString(text);                      this.stream.Flush();                  }                  catch (IOException e)                  {                      Log.Warn(e' e);                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,createImage,The following statement contains a magic number: if (bitsPerPixel == 32)              {                  stride = width * 4;                  data_to_render = data;                    System.Diagnostics.Debug.Assert(length == height * stride);                    if (cursor)                  {                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 4)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data[i + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }              }              else if (bitsPerPixel == 16)              {                  // Bitmap requires that stride is a multiple of 4' so we                   // will have to expand the data if width is odd.                  bool expand_data = width % 2 == 1;                  int stride_correction = expand_data ? 2 : 0;                  stride = width * 2 + stride_correction;                  data_to_render = expand_data ? new byte[stride * height] : data;                    System.Diagnostics.Debug.Assert(length == height * width * 2);                    if (cursor)                  {                      int p = 0;      // Byte within the destination data_to_render.                      // for mask                      int j = 0; // bit within the current byte (k)                      int k = start + length; //byte                      int m = 0; // bit within the current row                        for (int i = start; i < start + length; i += 2)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          byte mask_bit = (byte)(mask ? 0 : 0x80);                            if (rgb565)                          {                              // Convert the 565 data into 1555.                              data_to_render[p] = (byte)((data[i] & 0x1f) | ((data[i] & 0xe0) >> 1));                              data_to_render[p + 1] = (byte)(((data[i + 1] & 0x7) >> 1) | (data[i + 1] & 0x78) | mask_bit);                          }                          else                          {                              // Add the mask bit -- everything else is OK because it's already 555.                              data_to_render[p] = data[i];                              data_to_render[p + 1] = (byte)(data[i + 1] | mask_bit);                          }                            j++;                          m++;                          p += 2;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                              p += stride_correction;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                  }                  else if (expand_data)                  {                      int w2 = width * 2;                      int i = start;  // Byte within the source data.                      int p = 0;      // Byte within the destination data_to_render.                        for (int m = 0; m < height; m++)                      {                          Array.Copy(data' i' data_to_render' p' w2);                          i += w2;                          p += stride;                      }                  }              }              else if (bitsPerPixel == 8)              {                  stride = width * 4;                  data_to_render = data_8bpp;                    System.Diagnostics.Debug.Assert(length == width * height);                    // for mask                  int j = 0; // bit within the current byte (k)                  int k = start + length; //byte                  int m = 0; // bit within the current row                    for (int i = start' n = 0; i < start + length; i++' n += 4)                  {                      data_8bpp[n + 2] = (byte)(((((data[i] >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);                      data_8bpp[n + 1] = (byte)(((((data[i] >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);                      data_8bpp[n] = (byte)(((((data[i] >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);                      if (cursor)                      {                          bool mask = (data[k] & (1 << (7 - j))) == 0;                          data_8bpp[n + 3] = (byte)(mask ? 0 : 0xff);                            j++;                          m++;                            if (m == width)                          {                              j = 0;                              m = 0;                              k++;                          }                          else if (j > 7)                          {                              j = 0;                              k++;                          }                      }                      else                      {                          data_8bpp[n + 3] = 0;                      }                  }              }              else              {                  throw new Exception("unexpected bits per pixel");              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readRawEncoding_,The following statement contains a magic number: if (cursor)              {                  // 1 bit mask.                  int scanline = (width + 7) >> 3;                  mask_length = scanline * height;                  System.Diagnostics.Trace.Assert(this.data.Length >= start + length + mask_length);                  this.stream.readFully(this.data' start + length' mask_length);              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readRawEncoding_,The following statement contains a magic number: if (cursor)              {                  // 1 bit mask.                  int scanline = (width + 7) >> 3;                  mask_length = scanline * height;                  System.Diagnostics.Trace.Assert(this.data.Length >= start + length + mask_length);                  this.stream.readFully(this.data' start + length' mask_length);              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readColor,The following statement contains a magic number: return Color.FromArgb(color[2]' color[1]' color[0]);
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readColorBytes,The following statement contains a magic number: uint pixel =                  bitsPerPixel == 32 ?                      (uint)(color[start] |                             color[start + 1] << 8 |                             color[start + 2] << 16 |                             color[start + 3] << 24) :                  bitsPerPixel == 16 ?                      (uint)(color[start] |                             color[start + 1] << 8) :                      (uint)color[start];
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readColorBytes,The following statement contains a magic number: uint pixel =                  bitsPerPixel == 32 ?                      (uint)(color[start] |                             color[start + 1] << 8 |                             color[start + 2] << 16 |                             color[start + 3] << 24) :                  bitsPerPixel == 16 ?                      (uint)(color[start] |                             color[start + 1] << 8) :                      (uint)color[start];
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readColorBytes,The following statement contains a magic number: uint pixel =                  bitsPerPixel == 32 ?                      (uint)(color[start] |                             color[start + 1] << 8 |                             color[start + 2] << 16 |                             color[start + 3] << 24) :                  bitsPerPixel == 16 ?                      (uint)(color[start] |                             color[start + 1] << 8) :                      (uint)color[start];
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readColorBytes,The following statement contains a magic number: uint pixel =                  bitsPerPixel == 32 ?                      (uint)(color[start] |                             color[start + 1] << 8 |                             color[start + 2] << 16 |                             color[start + 3] << 24) :                  bitsPerPixel == 16 ?                      (uint)(color[start] |                             color[start + 1] << 8) :                      (uint)color[start];
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readColorBytes,The following statement contains a magic number: uint pixel =                  bitsPerPixel == 32 ?                      (uint)(color[start] |                             color[start + 1] << 8 |                             color[start + 2] << 16 |                             color[start + 3] << 24) :                  bitsPerPixel == 16 ?                      (uint)(color[start] |                             color[start + 1] << 8) :                      (uint)color[start];
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readColorBytes,The following statement contains a magic number: uint pixel =                  bitsPerPixel == 32 ?                      (uint)(color[start] |                             color[start + 1] << 8 |                             color[start + 2] << 16 |                             color[start + 3] << 24) :                  bitsPerPixel == 16 ?                      (uint)(color[start] |                             color[start + 1] << 8) :                      (uint)color[start];
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readColorBytes,The following statement contains a magic number: uint pixel =                  bitsPerPixel == 32 ?                      (uint)(color[start] |                             color[start + 1] << 8 |                             color[start + 2] << 16 |                             color[start + 3] << 24) :                  bitsPerPixel == 16 ?                      (uint)(color[start] |                             color[start + 1] << 8) :                      (uint)color[start];
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readColorBytes,The following statement contains a magic number: uint pixel =                  bitsPerPixel == 32 ?                      (uint)(color[start] |                             color[start + 1] << 8 |                             color[start + 2] << 16 |                             color[start + 3] << 24) :                  bitsPerPixel == 16 ?                      (uint)(color[start] |                             color[start + 1] << 8) :                      (uint)color[start];
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readColorBytes,The following statement contains a magic number: byte[] newColor = new byte[4];
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readColorBytes,The following statement contains a magic number: newColor[3] = 0xFF;
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readColorBytes,The following statement contains a magic number: newColor[2] = (byte)(((((pixel >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readColorBytes,The following statement contains a magic number: newColor[2] = (byte)(((((pixel >> redShift) & redMax) << 8) + redMaxOver2) / redMaxPlus1);
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readColorBytes,The following statement contains a magic number: newColor[1] = (byte)(((((pixel >> greenShift) & greenMax) << 8) + greenMaxOver2) / greenMaxPlus1);
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readColorBytes,The following statement contains a magic number: newColor[0] = (byte)(((((pixel >> blueShift) & blueMax) << 8) + blueMaxOver2) / blueMaxPlus1);
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readColorBytes,The following statement contains a magic number: int n = bitsPerPixel >> 3;
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readFillRectangles,The following statement contains a magic number: int pixelSize = (this.bitsPerPixel + 7) >> 3;
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readFillRectangles,The following statement contains a magic number: int pixelSize = (this.bitsPerPixel + 7) >> 3;
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readFillRectangles,The following statement contains a magic number: int length = n * (pixelSize + 2);
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readFillRectangles,The following statement contains a magic number: for (int i = 0; i < n; ++i)              {                  Color foreground = readColor();                  int sxy = data[index++] & 0xff;                  int sx = sxy >> 4;                  int sy = sxy & 0xf;                  int swh = data[index++] & 0xff;                  int sw = (swh >> 4) + 1;                  int sh = (swh & 0xf) + 1;                  client.ClientFillRectangle(                      rx + sx' ry + sy' sw' sh' foreground                  );              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readFillRectangles,The following statement contains a magic number: for (int i = 0; i < n; ++i)              {                  Color foreground = readColor();                  int sxy = data[index++] & 0xff;                  int sx = sxy >> 4;                  int sy = sxy & 0xf;                  int swh = data[index++] & 0xff;                  int sw = (swh >> 4) + 1;                  int sh = (swh & 0xf) + 1;                  client.ClientFillRectangle(                      rx + sx' ry + sy' sw' sh' foreground                  );              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readRectangles,The following statement contains a magic number: for (int i = 0; i < n; ++i)              {                  int sxy = this.stream.readCard8();                  int sx = sxy >> 4;                  int sy = sxy & 0xf;                  int swh = this.stream.readCard8();                  int sw = (swh >> 4) + 1;                  int sh = (swh & 0xf) + 1;                  client.ClientFillRectangle(                      rx + sx' ry + sy' sw' sh' foreground                  );              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readRectangles,The following statement contains a magic number: for (int i = 0; i < n; ++i)              {                  int sxy = this.stream.readCard8();                  int sx = sxy >> 4;                  int sy = sxy & 0xf;                  int swh = this.stream.readCard8();                  int sw = (swh >> 4) + 1;                  int sh = (swh & 0xf) + 1;                  client.ClientFillRectangle(                      rx + sx' ry + sy' sw' sh' foreground                  );              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,fillRectBytes,The following statement contains a magic number: int p = (y * stride) + (x * 4);
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,fillRectBytes,The following statement contains a magic number: if (width == 1 && height == 1)              {                  data[p + 0] = color[0];                  data[p + 1] = color[1];                  data[p + 2] = color[2];                  data[p + 3] = color[3];              }              else if (width == 1)              {                  skip = stride - 4;                    for (int i = 0; i < height; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += skip;                  }              }              else if (height == 1)              {                  for (int i = 0; i < width; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += 4;                  }              }              else              {                  skip = stride - (width * 4);                    for (int j = 0; j < height; j++)                  {                      for (int i = 0; i < width; i++)                      {                          data[p + 0] = color[0];                          data[p + 1] = color[1];                          data[p + 2] = color[2];                          data[p + 3] = color[3];                            p += 4;                      }                      p += skip;                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,fillRectBytes,The following statement contains a magic number: if (width == 1 && height == 1)              {                  data[p + 0] = color[0];                  data[p + 1] = color[1];                  data[p + 2] = color[2];                  data[p + 3] = color[3];              }              else if (width == 1)              {                  skip = stride - 4;                    for (int i = 0; i < height; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += skip;                  }              }              else if (height == 1)              {                  for (int i = 0; i < width; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += 4;                  }              }              else              {                  skip = stride - (width * 4);                    for (int j = 0; j < height; j++)                  {                      for (int i = 0; i < width; i++)                      {                          data[p + 0] = color[0];                          data[p + 1] = color[1];                          data[p + 2] = color[2];                          data[p + 3] = color[3];                            p += 4;                      }                      p += skip;                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,fillRectBytes,The following statement contains a magic number: if (width == 1 && height == 1)              {                  data[p + 0] = color[0];                  data[p + 1] = color[1];                  data[p + 2] = color[2];                  data[p + 3] = color[3];              }              else if (width == 1)              {                  skip = stride - 4;                    for (int i = 0; i < height; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += skip;                  }              }              else if (height == 1)              {                  for (int i = 0; i < width; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += 4;                  }              }              else              {                  skip = stride - (width * 4);                    for (int j = 0; j < height; j++)                  {                      for (int i = 0; i < width; i++)                      {                          data[p + 0] = color[0];                          data[p + 1] = color[1];                          data[p + 2] = color[2];                          data[p + 3] = color[3];                            p += 4;                      }                      p += skip;                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,fillRectBytes,The following statement contains a magic number: if (width == 1 && height == 1)              {                  data[p + 0] = color[0];                  data[p + 1] = color[1];                  data[p + 2] = color[2];                  data[p + 3] = color[3];              }              else if (width == 1)              {                  skip = stride - 4;                    for (int i = 0; i < height; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += skip;                  }              }              else if (height == 1)              {                  for (int i = 0; i < width; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += 4;                  }              }              else              {                  skip = stride - (width * 4);                    for (int j = 0; j < height; j++)                  {                      for (int i = 0; i < width; i++)                      {                          data[p + 0] = color[0];                          data[p + 1] = color[1];                          data[p + 2] = color[2];                          data[p + 3] = color[3];                            p += 4;                      }                      p += skip;                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,fillRectBytes,The following statement contains a magic number: if (width == 1 && height == 1)              {                  data[p + 0] = color[0];                  data[p + 1] = color[1];                  data[p + 2] = color[2];                  data[p + 3] = color[3];              }              else if (width == 1)              {                  skip = stride - 4;                    for (int i = 0; i < height; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += skip;                  }              }              else if (height == 1)              {                  for (int i = 0; i < width; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += 4;                  }              }              else              {                  skip = stride - (width * 4);                    for (int j = 0; j < height; j++)                  {                      for (int i = 0; i < width; i++)                      {                          data[p + 0] = color[0];                          data[p + 1] = color[1];                          data[p + 2] = color[2];                          data[p + 3] = color[3];                            p += 4;                      }                      p += skip;                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,fillRectBytes,The following statement contains a magic number: if (width == 1 && height == 1)              {                  data[p + 0] = color[0];                  data[p + 1] = color[1];                  data[p + 2] = color[2];                  data[p + 3] = color[3];              }              else if (width == 1)              {                  skip = stride - 4;                    for (int i = 0; i < height; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += skip;                  }              }              else if (height == 1)              {                  for (int i = 0; i < width; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += 4;                  }              }              else              {                  skip = stride - (width * 4);                    for (int j = 0; j < height; j++)                  {                      for (int i = 0; i < width; i++)                      {                          data[p + 0] = color[0];                          data[p + 1] = color[1];                          data[p + 2] = color[2];                          data[p + 3] = color[3];                            p += 4;                      }                      p += skip;                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,fillRectBytes,The following statement contains a magic number: if (width == 1 && height == 1)              {                  data[p + 0] = color[0];                  data[p + 1] = color[1];                  data[p + 2] = color[2];                  data[p + 3] = color[3];              }              else if (width == 1)              {                  skip = stride - 4;                    for (int i = 0; i < height; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += skip;                  }              }              else if (height == 1)              {                  for (int i = 0; i < width; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += 4;                  }              }              else              {                  skip = stride - (width * 4);                    for (int j = 0; j < height; j++)                  {                      for (int i = 0; i < width; i++)                      {                          data[p + 0] = color[0];                          data[p + 1] = color[1];                          data[p + 2] = color[2];                          data[p + 3] = color[3];                            p += 4;                      }                      p += skip;                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,fillRectBytes,The following statement contains a magic number: if (width == 1 && height == 1)              {                  data[p + 0] = color[0];                  data[p + 1] = color[1];                  data[p + 2] = color[2];                  data[p + 3] = color[3];              }              else if (width == 1)              {                  skip = stride - 4;                    for (int i = 0; i < height; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += skip;                  }              }              else if (height == 1)              {                  for (int i = 0; i < width; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += 4;                  }              }              else              {                  skip = stride - (width * 4);                    for (int j = 0; j < height; j++)                  {                      for (int i = 0; i < width; i++)                      {                          data[p + 0] = color[0];                          data[p + 1] = color[1];                          data[p + 2] = color[2];                          data[p + 3] = color[3];                            p += 4;                      }                      p += skip;                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,fillRectBytes,The following statement contains a magic number: if (width == 1 && height == 1)              {                  data[p + 0] = color[0];                  data[p + 1] = color[1];                  data[p + 2] = color[2];                  data[p + 3] = color[3];              }              else if (width == 1)              {                  skip = stride - 4;                    for (int i = 0; i < height; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += skip;                  }              }              else if (height == 1)              {                  for (int i = 0; i < width; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += 4;                  }              }              else              {                  skip = stride - (width * 4);                    for (int j = 0; j < height; j++)                  {                      for (int i = 0; i < width; i++)                      {                          data[p + 0] = color[0];                          data[p + 1] = color[1];                          data[p + 2] = color[2];                          data[p + 3] = color[3];                            p += 4;                      }                      p += skip;                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,fillRectBytes,The following statement contains a magic number: if (width == 1 && height == 1)              {                  data[p + 0] = color[0];                  data[p + 1] = color[1];                  data[p + 2] = color[2];                  data[p + 3] = color[3];              }              else if (width == 1)              {                  skip = stride - 4;                    for (int i = 0; i < height; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += skip;                  }              }              else if (height == 1)              {                  for (int i = 0; i < width; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += 4;                  }              }              else              {                  skip = stride - (width * 4);                    for (int j = 0; j < height; j++)                  {                      for (int i = 0; i < width; i++)                      {                          data[p + 0] = color[0];                          data[p + 1] = color[1];                          data[p + 2] = color[2];                          data[p + 3] = color[3];                            p += 4;                      }                      p += skip;                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,fillRectBytes,The following statement contains a magic number: if (width == 1 && height == 1)              {                  data[p + 0] = color[0];                  data[p + 1] = color[1];                  data[p + 2] = color[2];                  data[p + 3] = color[3];              }              else if (width == 1)              {                  skip = stride - 4;                    for (int i = 0; i < height; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += skip;                  }              }              else if (height == 1)              {                  for (int i = 0; i < width; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += 4;                  }              }              else              {                  skip = stride - (width * 4);                    for (int j = 0; j < height; j++)                  {                      for (int i = 0; i < width; i++)                      {                          data[p + 0] = color[0];                          data[p + 1] = color[1];                          data[p + 2] = color[2];                          data[p + 3] = color[3];                            p += 4;                      }                      p += skip;                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,fillRectBytes,The following statement contains a magic number: if (width == 1 && height == 1)              {                  data[p + 0] = color[0];                  data[p + 1] = color[1];                  data[p + 2] = color[2];                  data[p + 3] = color[3];              }              else if (width == 1)              {                  skip = stride - 4;                    for (int i = 0; i < height; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += skip;                  }              }              else if (height == 1)              {                  for (int i = 0; i < width; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += 4;                  }              }              else              {                  skip = stride - (width * 4);                    for (int j = 0; j < height; j++)                  {                      for (int i = 0; i < width; i++)                      {                          data[p + 0] = color[0];                          data[p + 1] = color[1];                          data[p + 2] = color[2];                          data[p + 3] = color[3];                            p += 4;                      }                      p += skip;                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,fillRectBytes,The following statement contains a magic number: if (width == 1 && height == 1)              {                  data[p + 0] = color[0];                  data[p + 1] = color[1];                  data[p + 2] = color[2];                  data[p + 3] = color[3];              }              else if (width == 1)              {                  skip = stride - 4;                    for (int i = 0; i < height; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += skip;                  }              }              else if (height == 1)              {                  for (int i = 0; i < width; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += 4;                  }              }              else              {                  skip = stride - (width * 4);                    for (int j = 0; j < height; j++)                  {                      for (int i = 0; i < width; i++)                      {                          data[p + 0] = color[0];                          data[p + 1] = color[1];                          data[p + 2] = color[2];                          data[p + 3] = color[3];                            p += 4;                      }                      p += skip;                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,fillRectBytes,The following statement contains a magic number: if (width == 1 && height == 1)              {                  data[p + 0] = color[0];                  data[p + 1] = color[1];                  data[p + 2] = color[2];                  data[p + 3] = color[3];              }              else if (width == 1)              {                  skip = stride - 4;                    for (int i = 0; i < height; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += skip;                  }              }              else if (height == 1)              {                  for (int i = 0; i < width; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += 4;                  }              }              else              {                  skip = stride - (width * 4);                    for (int j = 0; j < height; j++)                  {                      for (int i = 0; i < width; i++)                      {                          data[p + 0] = color[0];                          data[p + 1] = color[1];                          data[p + 2] = color[2];                          data[p + 3] = color[3];                            p += 4;                      }                      p += skip;                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,fillRectBytes,The following statement contains a magic number: if (width == 1 && height == 1)              {                  data[p + 0] = color[0];                  data[p + 1] = color[1];                  data[p + 2] = color[2];                  data[p + 3] = color[3];              }              else if (width == 1)              {                  skip = stride - 4;                    for (int i = 0; i < height; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += skip;                  }              }              else if (height == 1)              {                  for (int i = 0; i < width; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += 4;                  }              }              else              {                  skip = stride - (width * 4);                    for (int j = 0; j < height; j++)                  {                      for (int i = 0; i < width; i++)                      {                          data[p + 0] = color[0];                          data[p + 1] = color[1];                          data[p + 2] = color[2];                          data[p + 3] = color[3];                            p += 4;                      }                      p += skip;                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,fillRectBytes,The following statement contains a magic number: if (width == 1 && height == 1)              {                  data[p + 0] = color[0];                  data[p + 1] = color[1];                  data[p + 2] = color[2];                  data[p + 3] = color[3];              }              else if (width == 1)              {                  skip = stride - 4;                    for (int i = 0; i < height; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += skip;                  }              }              else if (height == 1)              {                  for (int i = 0; i < width; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += 4;                  }              }              else              {                  skip = stride - (width * 4);                    for (int j = 0; j < height; j++)                  {                      for (int i = 0; i < width; i++)                      {                          data[p + 0] = color[0];                          data[p + 1] = color[1];                          data[p + 2] = color[2];                          data[p + 3] = color[3];                            p += 4;                      }                      p += skip;                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,fillRectBytes,The following statement contains a magic number: if (width == 1 && height == 1)              {                  data[p + 0] = color[0];                  data[p + 1] = color[1];                  data[p + 2] = color[2];                  data[p + 3] = color[3];              }              else if (width == 1)              {                  skip = stride - 4;                    for (int i = 0; i < height; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += skip;                  }              }              else if (height == 1)              {                  for (int i = 0; i < width; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += 4;                  }              }              else              {                  skip = stride - (width * 4);                    for (int j = 0; j < height; j++)                  {                      for (int i = 0; i < width; i++)                      {                          data[p + 0] = color[0];                          data[p + 1] = color[1];                          data[p + 2] = color[2];                          data[p + 3] = color[3];                            p += 4;                      }                      p += skip;                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,fillRectBytes,The following statement contains a magic number: if (width == 1 && height == 1)              {                  data[p + 0] = color[0];                  data[p + 1] = color[1];                  data[p + 2] = color[2];                  data[p + 3] = color[3];              }              else if (width == 1)              {                  skip = stride - 4;                    for (int i = 0; i < height; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += skip;                  }              }              else if (height == 1)              {                  for (int i = 0; i < width; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += 4;                  }              }              else              {                  skip = stride - (width * 4);                    for (int j = 0; j < height; j++)                  {                      for (int i = 0; i < width; i++)                      {                          data[p + 0] = color[0];                          data[p + 1] = color[1];                          data[p + 2] = color[2];                          data[p + 3] = color[3];                            p += 4;                      }                      p += skip;                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,fillRectBytes,The following statement contains a magic number: if (width == 1 && height == 1)              {                  data[p + 0] = color[0];                  data[p + 1] = color[1];                  data[p + 2] = color[2];                  data[p + 3] = color[3];              }              else if (width == 1)              {                  skip = stride - 4;                    for (int i = 0; i < height; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += skip;                  }              }              else if (height == 1)              {                  for (int i = 0; i < width; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += 4;                  }              }              else              {                  skip = stride - (width * 4);                    for (int j = 0; j < height; j++)                  {                      for (int i = 0; i < width; i++)                      {                          data[p + 0] = color[0];                          data[p + 1] = color[1];                          data[p + 2] = color[2];                          data[p + 3] = color[3];                            p += 4;                      }                      p += skip;                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,fillRectBytes,The following statement contains a magic number: if (width == 1 && height == 1)              {                  data[p + 0] = color[0];                  data[p + 1] = color[1];                  data[p + 2] = color[2];                  data[p + 3] = color[3];              }              else if (width == 1)              {                  skip = stride - 4;                    for (int i = 0; i < height; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += skip;                  }              }              else if (height == 1)              {                  for (int i = 0; i < width; i++)                  {                      data[p + 0] = color[0];                      data[p + 1] = color[1];                      data[p + 2] = color[2];                      data[p + 3] = color[3];                        p += 4;                  }              }              else              {                  skip = stride - (width * 4);                    for (int j = 0; j < height; j++)                  {                      for (int i = 0; i < width; i++)                      {                          data[p + 0] = color[0];                          data[p + 1] = color[1];                          data[p + 2] = color[2];                          data[p + 3] = color[3];                            p += 4;                      }                      p += skip;                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readHextileEncoding,The following statement contains a magic number: if (width * height > 64)              {                  byte[] background = { 0' 0' 0' 0xFF }; // Black                  byte[] foreground = { 0xFF' 0xFF' 0xFF' 0xFF }; // White                    byte[] buff = new byte[width * height * 4]; //assume 32 bpp                  int stride = width * 4;                    for (int sy = 0; sy < height; sy += 16)                  {                      int sheight = Math.Min(16' height - sy);                        for (int sx = 0; sx < width; sx += 16)                      {                          int swidth = Math.Min(16' width - sx);                            int mask = this.stream.readCard8();                            if ((mask & RAW_SUBENCODING) != 0)                          {                              int length = swidth * sheight * 4;                              this.stream.readFully(this.data' 0' length);                                int index = 0;                              int skip = stride - (swidth * 4);                              int p = (sy * stride) + (sx * 4);                                for (int i = 0; i < sheight; i++)                              {                                  for (int j = 0; j < swidth; j++)                                  {                                      byte[] color = readColorBytes(this.data' index);                                        index += 4; //assumed 32bpp here                                        buff[p + 3] = color[3];                                      buff[p + 2] = color[2];                                      buff[p + 1] = color[1];                                      buff[p + 0] = color[0];                                        p += 4;                                  }                                    p += skip;                              }                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColorBytes();                              }                                fillRectBytes(buff' stride' sx' sy' swidth' sheight' background);                                if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColorBytes();                              }                                if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      int length = n * 6; //assume 32bpp                                      this.stream.readFully(data' 0' length);                                      int index = 0;                                      for (int i = 0; i < n; ++i)                                      {                                          byte[] color = new byte[4];                                          uint pixel = (uint)(data[index + 0] & 0xFF | data[index + 1] << 8                                                       | data[index + 2] << 16 | data[index + 3] << 24);                                            //ARGB Encoding                                          color[3] = 0xFF;                                          color[2] = (byte)((pixel >> this.redShift) & this.redMax);                                          color[1] = (byte)((pixel >> this.greenShift) & this.greenMax);                                          color[0] = (byte)((pixel >> this.blueShift) & this.blueMax);                                            index += 4;                                          int txy = data[index++] & 0xff;                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = data[index++] & 0xff;                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' color                                          );                                      }                                  }                                  else                                  {                                      for (int i = 0; i < n; ++i)                                      {                                          int txy = this.stream.readCard8();                                          int tx = txy >> 4;                                          int ty = txy & 0xf;                                          int twh = this.stream.readCard8();                                          int tw = (twh >> 4) + 1;                                          int th = (twh & 0xf) + 1;                                            this.fillRectBytes(                                              buff' stride' sx + tx' sy + ty' tw' th' foreground                                          );                                      }                                  }                              }                          }                      }                  }                    // Now convert to image and write to screen                  GCHandle handle = GCHandle.Alloc(buff' GCHandleType.Pinned);                  try                  {                      IntPtr pointer = Marshal.UnsafeAddrOfPinnedArrayElement(buff' 0);                      using (Bitmap bitmap = new Bitmap(width' height' stride' PixelFormat.Format32bppArgb' pointer))                      {                          client.ClientDrawImage(bitmap' x' y' width' height);                      }                  }                  finally                  {                      handle.Free();                  }              }              else              {                  Color foreground = Color.White;                  Color background = Color.Black;                    int xCount = (width + 15) >> 4;                  int yCount = (height + 15) >> 4;                  for (int yi = 0; yi < yCount; ++yi)                  {                      int ry = y + (yi << 4);                      int rh = (yi == (yCount - 1)) ? height & 0xf : 16;                      if (rh == 0)                      {                          rh = 16;                      }                      for (int xi = 0; xi < xCount; ++xi)                      {                          int rx = x + (xi << 4);                          int rw = (xi == (xCount - 1)) ? width & 0xf : 16;                          if (rw == 0)                          {                              rw = 16;                          }                          int mask = this.stream.readCard8();                          if ((mask & RAW_SUBENCODING) != 0)                          {                              readRawEncoding(rx' ry' rw' rh);                          }                          else                          {                              if ((mask & BACKGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  background = readColor();                              }                              client.ClientFillRectangle(rx' ry' rw' rh' background);                              if ((mask & FOREGROUND_SPECIFIED_SUBENCODING) != 0)                              {                                  foreground = readColor();                              }                              if ((mask & ANY_SUBRECTS_SUBENCODING) != 0)                              {                                  int n = this.stream.readCard8();                                  if ((mask & SUBRECTS_COLORED_SUBENCODING) != 0)                                  {                                      readFillRectangles(rx' ry' n);                                  }                                  else                                  {                                      readRectangles(rx' ry' n' foreground);                                  }                              }                          }                      }                  }              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,desktopSize,The following statement contains a magic number: if (bitsPerPixel == 8 && (data_8bpp == null || neededBytes * 4 > data_8bpp.Length))              {                  data_8bpp = new byte[neededBytes * 4];              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,desktopSize,The following statement contains a magic number: if (bitsPerPixel == 8 && (data_8bpp == null || neededBytes * 4 > data_8bpp.Length))              {                  data_8bpp = new byte[neededBytes * 4];              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,desktopSize,The following statement contains a magic number: if (bitsPerPixel == 8 && (data_8bpp == null || neededBytes * 4 > data_8bpp.Length))              {                  data_8bpp = new byte[neededBytes * 4];              }
Magic Number,DotNetVnc,VNCStream,C:\repos\xenserver_xenadmin\XenCenterVNC\VNCStream.cs,readServerCutText,The following statement contains a magic number: this.stream.readPadding(3);
