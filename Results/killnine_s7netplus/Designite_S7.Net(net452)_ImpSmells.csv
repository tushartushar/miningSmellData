Implementation smell,Namespace,Class,File,Method,Description
Long Method,S7.Net,PLCAddress,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLCAddress.cs,Parse,The method has 144 lines of code.
Long Method,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The method has 111 lines of code.
Complex Method,S7.Net,Conversion,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,Cyclomatic complexity of the method is 24
Complex Method,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ParseBytes,Cyclomatic complexity of the method is 25
Complex Method,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,VarTypeToByteLength,Cyclomatic complexity of the method is 8
Complex Method,S7.Net,PLCAddress,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLCAddress.cs,Parse,Cyclomatic complexity of the method is 24
Complex Method,S7.Net.Protocol,S7WriteMultiple,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\S7WriteMultiple.cs,ParseResponse,Cyclomatic complexity of the method is 8
Complex Method,S7.Net.Protocol,Serialization,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\Serialization.cs,SerializeValue,Cyclomatic complexity of the method is 19
Complex Method,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetIncreasedNumberOfBytes,Cyclomatic complexity of the method is 9
Complex Method,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,Cyclomatic complexity of the method is 16
Complex Method,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,SetBytesFromProperty,Cyclomatic complexity of the method is 13
Complex Method,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,Cyclomatic complexity of the method is 10
Complex Method,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,Cyclomatic complexity of the method is 20
Complex Method,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,Cyclomatic complexity of the method is 13
Long Parameter List,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,Plc,The method has 5 parameters. Parameters: cpu' ip' port' rack' slot
Long Parameter List,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ReadAsync,The method has 6 parameters. Parameters: dataType' db' startByteAdr' varType' varCount' bitAdr
Long Parameter List,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBitAsync,The method has 5 parameters. Parameters: dataType' db' startByteAdr' bitAdr' value
Long Parameter List,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBitAsync,The method has 5 parameters. Parameters: dataType' db' startByteAdr' bitAdr' value
Long Parameter List,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteAsync,The method has 5 parameters. Parameters: dataType' db' startByteAdr' value' bitAdr
Long Parameter List,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBitWithASingleRequestAsync,The method has 5 parameters. Parameters: dataType' db' startByteAdr' bitAdr' bitValue
Long Parameter List,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,Read,The method has 6 parameters. Parameters: dataType' db' startByteAdr' varType' varCount' bitAdr
Long Parameter List,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBit,The method has 5 parameters. Parameters: dataType' db' startByteAdr' bitAdr' value
Long Parameter List,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBit,The method has 5 parameters. Parameters: dataType' db' startByteAdr' bitAdr' value
Long Parameter List,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,Write,The method has 5 parameters. Parameters: dataType' db' startByteAdr' value' bitAdr
Long Parameter List,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBitWithASingleRequest,The method has 5 parameters. Parameters: dataType' db' startByteAdr' bitAdr' bitValue
Long Parameter List,S7.Net,PLCAddress,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLCAddress.cs,Parse,The method has 6 parameters. Parameters: input' dataType' dbNumber' varType' address' bitNumber
Long Identifier,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,,The length of the parameter CONNECTION_TIMED_OUT_ERROR_CODE is 31.
Long Statement,S7.Net,InvalidDataException,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\InvalidDataException.cs,FormatMessage,The length of the statement  "                    $"{nameof(errorIndex)} {errorIndex} is outside the bounds of {nameof(receivedData)} with length {receivedData.Length}."); " is 121.
Long Statement,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,AssertPduSizeForRead,The length of the statement  "            if (GetDataLength(dataItems) + dataItems.Count * 4 + 14 > MaxPDUSize) throw new Exception("Too much data requested for read"); " is 126.
Long Statement,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ReadMultipleVarsAsync,The length of the statement  "                    package.Add(CreateReadDataRequestPackage(dataItem.DataType' dataItem.DB' dataItem.StartByteAdr' VarTypeToByteLength(dataItem.VarType' dataItem.Count))); " is 152.
Long Statement,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesAsync,The length of the statement  "                await WriteBytesWithASingleRequestAsync(dataType' db' startByteAdr + localIndex' value.Skip(localIndex).Take(maxToWrite).ToArray()); " is 132.
Long Statement,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBitAsync,The length of the statement  "                throw new InvalidAddressException(string.Format("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' bitAdr)); " is 147.
Long Statement,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBytes,The length of the statement  "                WriteBytesWithASingleRequest(dataType' db' startByteAdr + localIndex' value.Skip(localIndex).Take(maxToWrite).ToArray()); " is 121.
Long Statement,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBit,The length of the statement  "                throw new InvalidAddressException(string.Format("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' bitAdr)); " is 147.
Long Statement,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ReadMultipleVars,The length of the statement  "                    package.Add(CreateReadDataRequestPackage(dataItem.DataType' dataItem.DB' dataItem.StartByteAdr' VarTypeToByteLength(dataItem.VarType' dataItem.Count))); " is 152.
Long Statement,S7.Net.Types,Bit,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Bit.cs,ToBitArray,The length of the statement  "            if (length > bytes.Length * 8) throw new ArgumentException($"Not enough data in bytes to return {length} bits."' nameof(bytes)); " is 128.
Long Statement,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The length of the statement  "                        throw new Exception("Cannot determine size of class' because an array is defined which has no fixed size greater than zero."); " is 126.
Long Statement,S7.Net.Types,StringEx,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\StringEx.cs,FromByteArray,The length of the statement  "                    $"Failed to parse {VarType.StringEx} from data. Following fields were read: size: '{size}'' actual length: '{length}'' total number of bytes (including header): '{bytes.Length}'."' " is 180.
Long Statement,S7.Net.Types,StringEx,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\StringEx.cs,ToByteArray,The length of the statement  "            if (reservedLength > byte.MaxValue) throw new ArgumentException($"The maximum string length supported is {byte.MaxValue}."); " is 124.
Magic Number,S7.Net,Conversion,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Conversion.cs,BinStringToByte,The following statement contains a magic number: txt.Length == 8
Magic Number,S7.Net,Conversion,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: switch (value.GetType().Name)                      {                          case "Byte":                              x = 7;                              longValue = (long)((byte)value);                              break;                          case "Int16":                              x = 15;                              longValue = (long)((Int16)value);                              break;                          case "Int32":                              x = 31;                              longValue = (long)((Int32)value);                              break;                          case "Int64":                              x = 63;                              longValue = (long)((Int64)value);                              break;                          default:                              throw new Exception();                      }
Magic Number,S7.Net,Conversion,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: switch (value.GetType().Name)                      {                          case "Byte":                              x = 7;                              longValue = (long)((byte)value);                              break;                          case "Int16":                              x = 15;                              longValue = (long)((Int16)value);                              break;                          case "Int32":                              x = 31;                              longValue = (long)((Int32)value);                              break;                          case "Int64":                              x = 63;                              longValue = (long)((Int64)value);                              break;                          default:                              throw new Exception();                      }
Magic Number,S7.Net,Conversion,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: switch (value.GetType().Name)                      {                          case "Byte":                              x = 7;                              longValue = (long)((byte)value);                              break;                          case "Int16":                              x = 15;                              longValue = (long)((Int16)value);                              break;                          case "Int32":                              x = 31;                              longValue = (long)((Int32)value);                              break;                          case "Int64":                              x = 63;                              longValue = (long)((Int64)value);                              break;                          default:                              throw new Exception();                      }
Magic Number,S7.Net,Conversion,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: switch (value.GetType().Name)                      {                          case "Byte":                              x = 7;                              longValue = (long)((byte)value);                              break;                          case "Int16":                              x = 15;                              longValue = (long)((Int16)value);                              break;                          case "Int32":                              x = 31;                              longValue = (long)((Int32)value);                              break;                          case "Int64":                              x = 63;                              longValue = (long)((Int64)value);                              break;                          default:                              throw new Exception();                      }
Magic Number,S7.Net,Conversion,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: ((Int64)longValue & (Int64)Math.Pow(2' cnt)) > 0
Magic Number,S7.Net,TPDU,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\COTP.cs,TPDU,The following statement contains a magic number: Data = br.ReadBytes(tPKT.Length - HeaderLength - 4);
Magic Number,S7.Net,TPDU,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\COTP.cs,TPDU,The following statement contains a magic number: HeaderLength >= 2
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,Plc,The following statement contains a magic number: MaxPDUSize = 240;
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,Plc,The following statement contains a magic number: Port = 102;
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,Plc,The following statement contains a magic number: MaxPDUSize = 240;
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,AssertPduSizeForRead,The following statement contains a magic number: (dataItems.Count + 1) * 12 > MaxPDUSize
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,AssertPduSizeForRead,The following statement contains a magic number: GetDataLength(dataItems) + dataItems.Count * 4 + 14 > MaxPDUSize
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,AssertPduSizeForRead,The following statement contains a magic number: GetDataLength(dataItems) + dataItems.Count * 4 + 14 > MaxPDUSize
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,AssertPduSizeForWrite,The following statement contains a magic number: dataItems.Count * 18 + 12 > MaxPDUSize
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,AssertPduSizeForWrite,The following statement contains a magic number: dataItems.Count * 18 + 12 > MaxPDUSize
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,AssertPduSizeForWrite,The following statement contains a magic number: GetDataLength(dataItems) + dataItems.Count * 16 + 12 > MaxPDUSize
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,AssertPduSizeForWrite,The following statement contains a magic number: GetDataLength(dataItems) + dataItems.Count * 16 + 12 > MaxPDUSize
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,OpenAsync,The following statement contains a magic number: await stream.WriteAsync(ConnectionRequest.GetCOTPConnectionRequest(CPU' Rack' Slot)' 0' 22);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,OpenAsync,The following statement contains a magic number: await stream.WriteAsync(GetS7ConnectionSetup()' 0' 25);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,OpenAsync,The following statement contains a magic number: MaxPDUSize = (short)(s7data[18] * 256 + s7data[19]);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,OpenAsync,The following statement contains a magic number: MaxPDUSize = (short)(s7data[18] * 256 + s7data[19]);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,OpenAsync,The following statement contains a magic number: MaxPDUSize = (short)(s7data[18] * 256 + s7data[19]);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ReadBytesAsync,The following statement contains a magic number: var maxToRead = (int)Math.Min(count' MaxPDUSize - 18);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ReadMultipleVarsAsync,The following statement contains a magic number: int packageSize = 19 + (dataItems.Count * 12);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ReadMultipleVarsAsync,The following statement contains a magic number: int packageSize = 19 + (dataItems.Count * 12);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ReadMultipleVarsAsync,The following statement contains a magic number: s7data == null || s7data[14] != 0xff
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesAsync,The following statement contains a magic number: var maxToWrite = (int)Math.Min(count' 200);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBitAsync,The following statement contains a magic number: bitAdr < 0 || bitAdr > 7
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ReadBytesWithSingleRequestAsync,The following statement contains a magic number: int packageSize = 31;
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ReadBytesWithSingleRequestAsync,The following statement contains a magic number: s7data == null || s7data[14] != 0xff
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ReadBytesWithSingleRequestAsync,The following statement contains a magic number: bytes[cnt] = s7data[cnt + 18];
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequestAsync,The following statement contains a magic number: byte[] bReceive = new byte[513];
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequestAsync,The following statement contains a magic number: int packageSize = 35 + value.Length;
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequestAsync,The following statement contains a magic number: package.Add(new byte[] { 3' 0' 0 });
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequestAsync,The following statement contains a magic number: package.Add(new byte[] { 2' 0xf0' 0x80' 0x32' 1' 0' 0 });
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequestAsync,The following statement contains a magic number: package.Add(Word.ToByteArray((ushort)(varCount + 4)));
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequestAsync,The following statement contains a magic number: var overflow = (int)(startByteAdr * 8 / 0xffffU);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequestAsync,The following statement contains a magic number: package.Add(Word.ToByteArray((ushort)(startByteAdr * 8)));
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequestAsync,The following statement contains a magic number: package.Add(new byte[] { 0' 4 });
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequestAsync,The following statement contains a magic number: package.Add(Word.ToByteArray((ushort)(varCount * 8)));
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequestAsync,The following statement contains a magic number: s7data == null || s7data[14] != 0xff
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBitWithASingleRequestAsync,The following statement contains a magic number: byte[] bReceive = new byte[513];
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBitWithASingleRequestAsync,The following statement contains a magic number: int packageSize = 35 + value.Length;
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBitWithASingleRequestAsync,The following statement contains a magic number: package.Add(new byte[] { 3' 0' 0 });
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBitWithASingleRequestAsync,The following statement contains a magic number: package.Add(new byte[] { 2' 0xf0' 0x80' 0x32' 1' 0' 0 });
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBitWithASingleRequestAsync,The following statement contains a magic number: package.Add(Word.ToByteArray((ushort)(varCount + 4)));
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBitWithASingleRequestAsync,The following statement contains a magic number: int overflow = (int)(startByteAdr * 8 / 0xffffU);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBitWithASingleRequestAsync,The following statement contains a magic number: package.Add(Word.ToByteArray((ushort)(startByteAdr * 8 + bitAdr)));
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBitWithASingleRequestAsync,The following statement contains a magic number: s7data == null || s7data[14] != 0xff
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ReadHeaderPackage,The following statement contains a magic number: var package = new Types.ByteArray(19);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ReadHeaderPackage,The following statement contains a magic number: package.Add(Types.Int.ToByteArray((short)(19 + (12 * amount))));
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ReadHeaderPackage,The following statement contains a magic number: package.Add(Types.Int.ToByteArray((short)(19 + (12 * amount))));
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ReadHeaderPackage,The following statement contains a magic number: package.Add(Types.Word.ToByteArray((ushort)(2 + (amount * 12))));
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ReadHeaderPackage,The following statement contains a magic number: package.Add(Types.Word.ToByteArray((ushort)(2 + (amount * 12))));
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,CreateReadDataRequestPackage,The following statement contains a magic number: var package = new Types.ByteArray(12);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,CreateReadDataRequestPackage,The following statement contains a magic number: var overflow = (int)(startByteAdr * 8 / 0xffffU);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,CreateReadDataRequestPackage,The following statement contains a magic number: switch (dataType)              {                  case DataType.Timer:                  case DataType.Counter:                      package.Add(Types.Word.ToByteArray((ushort)(startByteAdr)));                      break;                  default:                      package.Add(Types.Word.ToByteArray((ushort)((startByteAdr) * 8)));                      break;              }
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ParseBytes,The following statement contains a magic number: switch (varType)              {                  case VarType.Byte:                      if (varCount == 1)                          return bytes[0];                      else                          return bytes;                  case VarType.Word:                      if (varCount == 1)                          return Word.FromByteArray(bytes);                      else                          return Word.ToArray(bytes);                  case VarType.Int:                      if (varCount == 1)                          return Int.FromByteArray(bytes);                      else                          return Int.ToArray(bytes);                  case VarType.DWord:                      if (varCount == 1)                          return DWord.FromByteArray(bytes);                      else                          return DWord.ToArray(bytes);                  case VarType.DInt:                      if (varCount == 1)                          return DInt.FromByteArray(bytes);                      else                          return DInt.ToArray(bytes);                  case VarType.Real:                      if (varCount == 1)                          return Types.Single.FromByteArray(bytes);                      else                          return Types.Single.ToArray(bytes);                    case VarType.String:                      return Types.String.FromByteArray(bytes);                  case VarType.StringEx:                      return StringEx.FromByteArray(bytes);                    case VarType.Timer:                      if (varCount == 1)                          return Timer.FromByteArray(bytes);                      else                          return Timer.ToArray(bytes);                  case VarType.Counter:                      if (varCount == 1)                          return Counter.FromByteArray(bytes);                      else                          return Counter.ToArray(bytes);                  case VarType.Bit:                      if (varCount == 1)                      {                          if (bitAdr > 7)                              return null;                          else                              return Bit.FromByte(bytes[0]' bitAdr);                      }                      else                      {                          return Bit.ToBitArray(bytes' varCount);                      }                  case VarType.DateTime:                      if (varCount == 1)                      {                          return DateTime.FromByteArray(bytes);                      }                      else                      {                          return DateTime.ToArray(bytes);                      }                  default:                      return null;              }
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,VarTypeToByteLength,The following statement contains a magic number: switch (varType)              {                  case VarType.Bit:                      return varCount + 7 / 8;                  case VarType.Byte:                      return (varCount < 1) ? 1 : varCount;                  case VarType.String:                      return varCount;                  case VarType.StringEx:                      return varCount + 2;                  case VarType.Word:                  case VarType.Timer:                  case VarType.Int:                  case VarType.Counter:                      return varCount * 2;                  case VarType.DWord:                  case VarType.DInt:                  case VarType.Real:                      return varCount * 4;                  case VarType.DateTime:                      return varCount * 8;                  default:                      return 0;              }
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,VarTypeToByteLength,The following statement contains a magic number: switch (varType)              {                  case VarType.Bit:                      return varCount + 7 / 8;                  case VarType.Byte:                      return (varCount < 1) ? 1 : varCount;                  case VarType.String:                      return varCount;                  case VarType.StringEx:                      return varCount + 2;                  case VarType.Word:                  case VarType.Timer:                  case VarType.Int:                  case VarType.Counter:                      return varCount * 2;                  case VarType.DWord:                  case VarType.DInt:                  case VarType.Real:                      return varCount * 4;                  case VarType.DateTime:                      return varCount * 8;                  default:                      return 0;              }
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,VarTypeToByteLength,The following statement contains a magic number: switch (varType)              {                  case VarType.Bit:                      return varCount + 7 / 8;                  case VarType.Byte:                      return (varCount < 1) ? 1 : varCount;                  case VarType.String:                      return varCount;                  case VarType.StringEx:                      return varCount + 2;                  case VarType.Word:                  case VarType.Timer:                  case VarType.Int:                  case VarType.Counter:                      return varCount * 2;                  case VarType.DWord:                  case VarType.DInt:                  case VarType.Real:                      return varCount * 4;                  case VarType.DateTime:                      return varCount * 8;                  default:                      return 0;              }
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,VarTypeToByteLength,The following statement contains a magic number: switch (varType)              {                  case VarType.Bit:                      return varCount + 7 / 8;                  case VarType.Byte:                      return (varCount < 1) ? 1 : varCount;                  case VarType.String:                      return varCount;                  case VarType.StringEx:                      return varCount + 2;                  case VarType.Word:                  case VarType.Timer:                  case VarType.Int:                  case VarType.Counter:                      return varCount * 2;                  case VarType.DWord:                  case VarType.DInt:                  case VarType.Real:                      return varCount * 4;                  case VarType.DateTime:                      return varCount * 8;                  default:                      return 0;              }
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,VarTypeToByteLength,The following statement contains a magic number: switch (varType)              {                  case VarType.Bit:                      return varCount + 7 / 8;                  case VarType.Byte:                      return (varCount < 1) ? 1 : varCount;                  case VarType.String:                      return varCount;                  case VarType.StringEx:                      return varCount + 2;                  case VarType.Word:                  case VarType.Timer:                  case VarType.Int:                  case VarType.Counter:                      return varCount * 2;                  case VarType.DWord:                  case VarType.DInt:                  case VarType.Real:                      return varCount * 4;                  case VarType.DateTime:                      return varCount * 8;                  default:                      return 0;              }
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,VarTypeToByteLength,The following statement contains a magic number: switch (varType)              {                  case VarType.Bit:                      return varCount + 7 / 8;                  case VarType.Byte:                      return (varCount < 1) ? 1 : varCount;                  case VarType.String:                      return varCount;                  case VarType.StringEx:                      return varCount + 2;                  case VarType.Word:                  case VarType.Timer:                  case VarType.Int:                  case VarType.Counter:                      return varCount * 2;                  case VarType.DWord:                  case VarType.DInt:                  case VarType.Real:                      return varCount * 4;                  case VarType.DateTime:                      return varCount * 8;                  default:                      return 0;              }
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,GetS7ConnectionSetup,The following statement contains a magic number: return new byte[] {  3' 0' 0' 25' 2' 240' 128' 50' 1' 0' 0' 255' 255' 0' 8' 0' 0' 240' 0' 0' 3' 0' 3'                      3' 192 // Use 960 PDU size              };
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,GetS7ConnectionSetup,The following statement contains a magic number: return new byte[] {  3' 0' 0' 25' 2' 240' 128' 50' 1' 0' 0' 255' 255' 0' 8' 0' 0' 240' 0' 0' 3' 0' 3'                      3' 192 // Use 960 PDU size              };
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,GetS7ConnectionSetup,The following statement contains a magic number: return new byte[] {  3' 0' 0' 25' 2' 240' 128' 50' 1' 0' 0' 255' 255' 0' 8' 0' 0' 240' 0' 0' 3' 0' 3'                      3' 192 // Use 960 PDU size              };
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,GetS7ConnectionSetup,The following statement contains a magic number: return new byte[] {  3' 0' 0' 25' 2' 240' 128' 50' 1' 0' 0' 255' 255' 0' 8' 0' 0' 240' 0' 0' 3' 0' 3'                      3' 192 // Use 960 PDU size              };
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,GetS7ConnectionSetup,The following statement contains a magic number: return new byte[] {  3' 0' 0' 25' 2' 240' 128' 50' 1' 0' 0' 255' 255' 0' 8' 0' 0' 240' 0' 0' 3' 0' 3'                      3' 192 // Use 960 PDU size              };
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,GetS7ConnectionSetup,The following statement contains a magic number: return new byte[] {  3' 0' 0' 25' 2' 240' 128' 50' 1' 0' 0' 255' 255' 0' 8' 0' 0' 240' 0' 0' 3' 0' 3'                      3' 192 // Use 960 PDU size              };
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,GetS7ConnectionSetup,The following statement contains a magic number: return new byte[] {  3' 0' 0' 25' 2' 240' 128' 50' 1' 0' 0' 255' 255' 0' 8' 0' 0' 240' 0' 0' 3' 0' 3'                      3' 192 // Use 960 PDU size              };
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,GetS7ConnectionSetup,The following statement contains a magic number: return new byte[] {  3' 0' 0' 25' 2' 240' 128' 50' 1' 0' 0' 255' 255' 0' 8' 0' 0' 240' 0' 0' 3' 0' 3'                      3' 192 // Use 960 PDU size              };
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,GetS7ConnectionSetup,The following statement contains a magic number: return new byte[] {  3' 0' 0' 25' 2' 240' 128' 50' 1' 0' 0' 255' 255' 0' 8' 0' 0' 240' 0' 0' 3' 0' 3'                      3' 192 // Use 960 PDU size              };
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,GetS7ConnectionSetup,The following statement contains a magic number: return new byte[] {  3' 0' 0' 25' 2' 240' 128' 50' 1' 0' 0' 255' 255' 0' 8' 0' 0' 240' 0' 0' 3' 0' 3'                      3' 192 // Use 960 PDU size              };
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,GetS7ConnectionSetup,The following statement contains a magic number: return new byte[] {  3' 0' 0' 25' 2' 240' 128' 50' 1' 0' 0' 255' 255' 0' 8' 0' 0' 240' 0' 0' 3' 0' 3'                      3' 192 // Use 960 PDU size              };
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,GetS7ConnectionSetup,The following statement contains a magic number: return new byte[] {  3' 0' 0' 25' 2' 240' 128' 50' 1' 0' 0' 255' 255' 0' 8' 0' 0' 240' 0' 0' 3' 0' 3'                      3' 192 // Use 960 PDU size              };
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,GetS7ConnectionSetup,The following statement contains a magic number: return new byte[] {  3' 0' 0' 25' 2' 240' 128' 50' 1' 0' 0' 255' 255' 0' 8' 0' 0' 240' 0' 0' 3' 0' 3'                      3' 192 // Use 960 PDU size              };
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,GetS7ConnectionSetup,The following statement contains a magic number: return new byte[] {  3' 0' 0' 25' 2' 240' 128' 50' 1' 0' 0' 255' 255' 0' 8' 0' 0' 240' 0' 0' 3' 0' 3'                      3' 192 // Use 960 PDU size              };
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ParseDataIntoDataItems,The following statement contains a magic number: int offset = 14;
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ParseDataIntoDataItems,The following statement contains a magic number: offset += 4;
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ParseDataIntoDataItems,The following statement contains a magic number: dataItem.Count % 2 != 0 && (dataItem.VarType == VarType.Byte || dataItem.VarType == VarType.Bit)
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: stream.Write(ConnectionRequest.GetCOTPConnectionRequest(CPU' Rack' Slot)' 0' 22);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: stream.Write(GetS7ConnectionSetup()' 0' 25);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: MaxPDUSize = (short)(s7data[18] * 256 + s7data[19]);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: MaxPDUSize = (short)(s7data[18] * 256 + s7data[19]);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: MaxPDUSize = (short)(s7data[18] * 256 + s7data[19]);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ReadBytes,The following statement contains a magic number: var maxToRead = (int)Math.Min(count' MaxPDUSize - 18);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBytes,The following statement contains a magic number: var maxToWrite = Math.Min(count' MaxPDUSize - 28);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBit,The following statement contains a magic number: bitAdr < 0 || bitAdr > 7
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ReadBytesWithSingleRequest,The following statement contains a magic number: int packageSize = 31;
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ReadBytesWithSingleRequest,The following statement contains a magic number: s7data == null || s7data[14] != 0xff
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ReadBytesWithSingleRequest,The following statement contains a magic number: bytes[cnt] = s7data[cnt + 18];
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: int packageSize = 35 + value.Length;
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: package.Add(new byte[] { 3' 0 });
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: package.Add(new byte[] { 2' 0xf0' 0x80' 0x32' 1' 0' 0 });
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: package.Add(Word.ToByteArray((ushort)(varCount + 4)));
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: var overflow = (int)(startByteAdr * 8 / 0xffffU);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: package.Add(Word.ToByteArray((ushort)(startByteAdr * 8)));
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: package.Add(new byte[] { 0' 4 });
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: package.Add(Word.ToByteArray((ushort)(varCount * 8)));
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: s7data == null || s7data[14] != 0xff
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBitWithASingleRequest,The following statement contains a magic number: int packageSize = 35 + value.Length;
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBitWithASingleRequest,The following statement contains a magic number: package.Add(new byte[] { 3' 0' 0 });
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBitWithASingleRequest,The following statement contains a magic number: package.Add(new byte[] { 2' 0xf0' 0x80' 0x32' 1' 0' 0 });
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBitWithASingleRequest,The following statement contains a magic number: package.Add(Word.ToByteArray((ushort)(varCount + 4)));
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBitWithASingleRequest,The following statement contains a magic number: int overflow = (int)(startByteAdr * 8 / 0xffffU);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBitWithASingleRequest,The following statement contains a magic number: package.Add(Word.ToByteArray((ushort)(startByteAdr * 8 + bitAdr)));
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,WriteBitWithASingleRequest,The following statement contains a magic number: s7data == null || s7data[14] != 0xff
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ReadMultipleVars,The following statement contains a magic number: int packageSize = 19 + (dataItems.Count * 12);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ReadMultipleVars,The following statement contains a magic number: int packageSize = 19 + (dataItems.Count * 12);
Magic Number,S7.Net,Plc,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLC.cs,ReadMultipleVars,The following statement contains a magic number: s7data == null || s7data[14] != 0xff
Magic Number,S7.Net,PLCAddress,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLCAddress.cs,Parse,The following statement contains a magic number: switch (input.Substring(0' 2))              {                  case "DB":                      string[] strings = input.Split(new char[] { '.' });                      if (strings.Length < 2)                          throw new InvalidAddressException("To few periods for DB address");                        dataType = DataType.DataBlock;                      dbNumber = int.Parse(strings[0].Substring(2));                      address = int.Parse(strings[1].Substring(3));                        string dbType = strings[1].Substring(0' 3);                      switch (dbType)                      {                          case "DBB":                              varType = VarType.Byte;                              return;                          case "DBW":                              varType = VarType.Word;                              return;                          case "DBD":                              varType = VarType.DWord;                              return;                          case "DBX":                              bitNumber = int.Parse(strings[2]);                              if (bitNumber > 7)                                  throw new InvalidAddressException("Bit can only be 0-7");                              varType = VarType.Bit;                              return;                          default:                              throw new InvalidAddressException();                      }                  case "EB":                      // Input byte                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "EW":                      // Input word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "ED":                      // Input double-word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "AB":                      // Output byte                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "AW":                      // Output word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "AD":                      // Output double-word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "MB":                      // Memory byte                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "MW":                      // Memory word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "MD":                      // Memory double-word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  default:                      switch (input.Substring(0' 1))                      {                          case "E":                          case "I":                              // Input                              dataType = DataType.Input;                              varType = VarType.Bit;                              break;                          case "A":                          case "O":                              // Output                              dataType = DataType.Output;                              varType = VarType.Bit;                              break;                          case "M":                              // Memory                              dataType = DataType.Memory;                              varType = VarType.Byte;                              break;                          case "T":                              // Timer                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Timer;                              return;                          case "Z":                          case "C":                              // Counter                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Counter;                              return;                          default:                              throw new InvalidAddressException(string.Format("{0} is not a valid address"' input.Substring(0' 1)));                      }                        string txt2 = input.Substring(1);                      if (txt2.IndexOf(".") == -1)                          throw new InvalidAddressException("To few periods for DB address");                        address = int.Parse(txt2.Substring(0' txt2.IndexOf(".")));                      bitNumber = int.Parse(txt2.Substring(txt2.IndexOf(".") + 1));                      if (bitNumber > 7)                          throw new InvalidAddressException("Bit can only be 0-7");                      return;              }
Magic Number,S7.Net,PLCAddress,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLCAddress.cs,Parse,The following statement contains a magic number: switch (input.Substring(0' 2))              {                  case "DB":                      string[] strings = input.Split(new char[] { '.' });                      if (strings.Length < 2)                          throw new InvalidAddressException("To few periods for DB address");                        dataType = DataType.DataBlock;                      dbNumber = int.Parse(strings[0].Substring(2));                      address = int.Parse(strings[1].Substring(3));                        string dbType = strings[1].Substring(0' 3);                      switch (dbType)                      {                          case "DBB":                              varType = VarType.Byte;                              return;                          case "DBW":                              varType = VarType.Word;                              return;                          case "DBD":                              varType = VarType.DWord;                              return;                          case "DBX":                              bitNumber = int.Parse(strings[2]);                              if (bitNumber > 7)                                  throw new InvalidAddressException("Bit can only be 0-7");                              varType = VarType.Bit;                              return;                          default:                              throw new InvalidAddressException();                      }                  case "EB":                      // Input byte                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "EW":                      // Input word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "ED":                      // Input double-word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "AB":                      // Output byte                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "AW":                      // Output word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "AD":                      // Output double-word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "MB":                      // Memory byte                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "MW":                      // Memory word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "MD":                      // Memory double-word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  default:                      switch (input.Substring(0' 1))                      {                          case "E":                          case "I":                              // Input                              dataType = DataType.Input;                              varType = VarType.Bit;                              break;                          case "A":                          case "O":                              // Output                              dataType = DataType.Output;                              varType = VarType.Bit;                              break;                          case "M":                              // Memory                              dataType = DataType.Memory;                              varType = VarType.Byte;                              break;                          case "T":                              // Timer                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Timer;                              return;                          case "Z":                          case "C":                              // Counter                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Counter;                              return;                          default:                              throw new InvalidAddressException(string.Format("{0} is not a valid address"' input.Substring(0' 1)));                      }                        string txt2 = input.Substring(1);                      if (txt2.IndexOf(".") == -1)                          throw new InvalidAddressException("To few periods for DB address");                        address = int.Parse(txt2.Substring(0' txt2.IndexOf(".")));                      bitNumber = int.Parse(txt2.Substring(txt2.IndexOf(".") + 1));                      if (bitNumber > 7)                          throw new InvalidAddressException("Bit can only be 0-7");                      return;              }
Magic Number,S7.Net,PLCAddress,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLCAddress.cs,Parse,The following statement contains a magic number: switch (input.Substring(0' 2))              {                  case "DB":                      string[] strings = input.Split(new char[] { '.' });                      if (strings.Length < 2)                          throw new InvalidAddressException("To few periods for DB address");                        dataType = DataType.DataBlock;                      dbNumber = int.Parse(strings[0].Substring(2));                      address = int.Parse(strings[1].Substring(3));                        string dbType = strings[1].Substring(0' 3);                      switch (dbType)                      {                          case "DBB":                              varType = VarType.Byte;                              return;                          case "DBW":                              varType = VarType.Word;                              return;                          case "DBD":                              varType = VarType.DWord;                              return;                          case "DBX":                              bitNumber = int.Parse(strings[2]);                              if (bitNumber > 7)                                  throw new InvalidAddressException("Bit can only be 0-7");                              varType = VarType.Bit;                              return;                          default:                              throw new InvalidAddressException();                      }                  case "EB":                      // Input byte                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "EW":                      // Input word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "ED":                      // Input double-word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "AB":                      // Output byte                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "AW":                      // Output word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "AD":                      // Output double-word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "MB":                      // Memory byte                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "MW":                      // Memory word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "MD":                      // Memory double-word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  default:                      switch (input.Substring(0' 1))                      {                          case "E":                          case "I":                              // Input                              dataType = DataType.Input;                              varType = VarType.Bit;                              break;                          case "A":                          case "O":                              // Output                              dataType = DataType.Output;                              varType = VarType.Bit;                              break;                          case "M":                              // Memory                              dataType = DataType.Memory;                              varType = VarType.Byte;                              break;                          case "T":                              // Timer                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Timer;                              return;                          case "Z":                          case "C":                              // Counter                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Counter;                              return;                          default:                              throw new InvalidAddressException(string.Format("{0} is not a valid address"' input.Substring(0' 1)));                      }                        string txt2 = input.Substring(1);                      if (txt2.IndexOf(".") == -1)                          throw new InvalidAddressException("To few periods for DB address");                        address = int.Parse(txt2.Substring(0' txt2.IndexOf(".")));                      bitNumber = int.Parse(txt2.Substring(txt2.IndexOf(".") + 1));                      if (bitNumber > 7)                          throw new InvalidAddressException("Bit can only be 0-7");                      return;              }
Magic Number,S7.Net,PLCAddress,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLCAddress.cs,Parse,The following statement contains a magic number: switch (input.Substring(0' 2))              {                  case "DB":                      string[] strings = input.Split(new char[] { '.' });                      if (strings.Length < 2)                          throw new InvalidAddressException("To few periods for DB address");                        dataType = DataType.DataBlock;                      dbNumber = int.Parse(strings[0].Substring(2));                      address = int.Parse(strings[1].Substring(3));                        string dbType = strings[1].Substring(0' 3);                      switch (dbType)                      {                          case "DBB":                              varType = VarType.Byte;                              return;                          case "DBW":                              varType = VarType.Word;                              return;                          case "DBD":                              varType = VarType.DWord;                              return;                          case "DBX":                              bitNumber = int.Parse(strings[2]);                              if (bitNumber > 7)                                  throw new InvalidAddressException("Bit can only be 0-7");                              varType = VarType.Bit;                              return;                          default:                              throw new InvalidAddressException();                      }                  case "EB":                      // Input byte                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "EW":                      // Input word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "ED":                      // Input double-word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "AB":                      // Output byte                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "AW":                      // Output word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "AD":                      // Output double-word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "MB":                      // Memory byte                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "MW":                      // Memory word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "MD":                      // Memory double-word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  default:                      switch (input.Substring(0' 1))                      {                          case "E":                          case "I":                              // Input                              dataType = DataType.Input;                              varType = VarType.Bit;                              break;                          case "A":                          case "O":                              // Output                              dataType = DataType.Output;                              varType = VarType.Bit;                              break;                          case "M":                              // Memory                              dataType = DataType.Memory;                              varType = VarType.Byte;                              break;                          case "T":                              // Timer                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Timer;                              return;                          case "Z":                          case "C":                              // Counter                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Counter;                              return;                          default:                              throw new InvalidAddressException(string.Format("{0} is not a valid address"' input.Substring(0' 1)));                      }                        string txt2 = input.Substring(1);                      if (txt2.IndexOf(".") == -1)                          throw new InvalidAddressException("To few periods for DB address");                        address = int.Parse(txt2.Substring(0' txt2.IndexOf(".")));                      bitNumber = int.Parse(txt2.Substring(txt2.IndexOf(".") + 1));                      if (bitNumber > 7)                          throw new InvalidAddressException("Bit can only be 0-7");                      return;              }
Magic Number,S7.Net,PLCAddress,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLCAddress.cs,Parse,The following statement contains a magic number: switch (input.Substring(0' 2))              {                  case "DB":                      string[] strings = input.Split(new char[] { '.' });                      if (strings.Length < 2)                          throw new InvalidAddressException("To few periods for DB address");                        dataType = DataType.DataBlock;                      dbNumber = int.Parse(strings[0].Substring(2));                      address = int.Parse(strings[1].Substring(3));                        string dbType = strings[1].Substring(0' 3);                      switch (dbType)                      {                          case "DBB":                              varType = VarType.Byte;                              return;                          case "DBW":                              varType = VarType.Word;                              return;                          case "DBD":                              varType = VarType.DWord;                              return;                          case "DBX":                              bitNumber = int.Parse(strings[2]);                              if (bitNumber > 7)                                  throw new InvalidAddressException("Bit can only be 0-7");                              varType = VarType.Bit;                              return;                          default:                              throw new InvalidAddressException();                      }                  case "EB":                      // Input byte                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "EW":                      // Input word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "ED":                      // Input double-word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "AB":                      // Output byte                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "AW":                      // Output word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "AD":                      // Output double-word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "MB":                      // Memory byte                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "MW":                      // Memory word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "MD":                      // Memory double-word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  default:                      switch (input.Substring(0' 1))                      {                          case "E":                          case "I":                              // Input                              dataType = DataType.Input;                              varType = VarType.Bit;                              break;                          case "A":                          case "O":                              // Output                              dataType = DataType.Output;                              varType = VarType.Bit;                              break;                          case "M":                              // Memory                              dataType = DataType.Memory;                              varType = VarType.Byte;                              break;                          case "T":                              // Timer                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Timer;                              return;                          case "Z":                          case "C":                              // Counter                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Counter;                              return;                          default:                              throw new InvalidAddressException(string.Format("{0} is not a valid address"' input.Substring(0' 1)));                      }                        string txt2 = input.Substring(1);                      if (txt2.IndexOf(".") == -1)                          throw new InvalidAddressException("To few periods for DB address");                        address = int.Parse(txt2.Substring(0' txt2.IndexOf(".")));                      bitNumber = int.Parse(txt2.Substring(txt2.IndexOf(".") + 1));                      if (bitNumber > 7)                          throw new InvalidAddressException("Bit can only be 0-7");                      return;              }
Magic Number,S7.Net,PLCAddress,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLCAddress.cs,Parse,The following statement contains a magic number: switch (input.Substring(0' 2))              {                  case "DB":                      string[] strings = input.Split(new char[] { '.' });                      if (strings.Length < 2)                          throw new InvalidAddressException("To few periods for DB address");                        dataType = DataType.DataBlock;                      dbNumber = int.Parse(strings[0].Substring(2));                      address = int.Parse(strings[1].Substring(3));                        string dbType = strings[1].Substring(0' 3);                      switch (dbType)                      {                          case "DBB":                              varType = VarType.Byte;                              return;                          case "DBW":                              varType = VarType.Word;                              return;                          case "DBD":                              varType = VarType.DWord;                              return;                          case "DBX":                              bitNumber = int.Parse(strings[2]);                              if (bitNumber > 7)                                  throw new InvalidAddressException("Bit can only be 0-7");                              varType = VarType.Bit;                              return;                          default:                              throw new InvalidAddressException();                      }                  case "EB":                      // Input byte                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "EW":                      // Input word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "ED":                      // Input double-word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "AB":                      // Output byte                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "AW":                      // Output word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "AD":                      // Output double-word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "MB":                      // Memory byte                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "MW":                      // Memory word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "MD":                      // Memory double-word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  default:                      switch (input.Substring(0' 1))                      {                          case "E":                          case "I":                              // Input                              dataType = DataType.Input;                              varType = VarType.Bit;                              break;                          case "A":                          case "O":                              // Output                              dataType = DataType.Output;                              varType = VarType.Bit;                              break;                          case "M":                              // Memory                              dataType = DataType.Memory;                              varType = VarType.Byte;                              break;                          case "T":                              // Timer                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Timer;                              return;                          case "Z":                          case "C":                              // Counter                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Counter;                              return;                          default:                              throw new InvalidAddressException(string.Format("{0} is not a valid address"' input.Substring(0' 1)));                      }                        string txt2 = input.Substring(1);                      if (txt2.IndexOf(".") == -1)                          throw new InvalidAddressException("To few periods for DB address");                        address = int.Parse(txt2.Substring(0' txt2.IndexOf(".")));                      bitNumber = int.Parse(txt2.Substring(txt2.IndexOf(".") + 1));                      if (bitNumber > 7)                          throw new InvalidAddressException("Bit can only be 0-7");                      return;              }
Magic Number,S7.Net,PLCAddress,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLCAddress.cs,Parse,The following statement contains a magic number: switch (input.Substring(0' 2))              {                  case "DB":                      string[] strings = input.Split(new char[] { '.' });                      if (strings.Length < 2)                          throw new InvalidAddressException("To few periods for DB address");                        dataType = DataType.DataBlock;                      dbNumber = int.Parse(strings[0].Substring(2));                      address = int.Parse(strings[1].Substring(3));                        string dbType = strings[1].Substring(0' 3);                      switch (dbType)                      {                          case "DBB":                              varType = VarType.Byte;                              return;                          case "DBW":                              varType = VarType.Word;                              return;                          case "DBD":                              varType = VarType.DWord;                              return;                          case "DBX":                              bitNumber = int.Parse(strings[2]);                              if (bitNumber > 7)                                  throw new InvalidAddressException("Bit can only be 0-7");                              varType = VarType.Bit;                              return;                          default:                              throw new InvalidAddressException();                      }                  case "EB":                      // Input byte                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "EW":                      // Input word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "ED":                      // Input double-word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "AB":                      // Output byte                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "AW":                      // Output word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "AD":                      // Output double-word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "MB":                      // Memory byte                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "MW":                      // Memory word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "MD":                      // Memory double-word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  default:                      switch (input.Substring(0' 1))                      {                          case "E":                          case "I":                              // Input                              dataType = DataType.Input;                              varType = VarType.Bit;                              break;                          case "A":                          case "O":                              // Output                              dataType = DataType.Output;                              varType = VarType.Bit;                              break;                          case "M":                              // Memory                              dataType = DataType.Memory;                              varType = VarType.Byte;                              break;                          case "T":                              // Timer                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Timer;                              return;                          case "Z":                          case "C":                              // Counter                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Counter;                              return;                          default:                              throw new InvalidAddressException(string.Format("{0} is not a valid address"' input.Substring(0' 1)));                      }                        string txt2 = input.Substring(1);                      if (txt2.IndexOf(".") == -1)                          throw new InvalidAddressException("To few periods for DB address");                        address = int.Parse(txt2.Substring(0' txt2.IndexOf(".")));                      bitNumber = int.Parse(txt2.Substring(txt2.IndexOf(".") + 1));                      if (bitNumber > 7)                          throw new InvalidAddressException("Bit can only be 0-7");                      return;              }
Magic Number,S7.Net,PLCAddress,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLCAddress.cs,Parse,The following statement contains a magic number: switch (input.Substring(0' 2))              {                  case "DB":                      string[] strings = input.Split(new char[] { '.' });                      if (strings.Length < 2)                          throw new InvalidAddressException("To few periods for DB address");                        dataType = DataType.DataBlock;                      dbNumber = int.Parse(strings[0].Substring(2));                      address = int.Parse(strings[1].Substring(3));                        string dbType = strings[1].Substring(0' 3);                      switch (dbType)                      {                          case "DBB":                              varType = VarType.Byte;                              return;                          case "DBW":                              varType = VarType.Word;                              return;                          case "DBD":                              varType = VarType.DWord;                              return;                          case "DBX":                              bitNumber = int.Parse(strings[2]);                              if (bitNumber > 7)                                  throw new InvalidAddressException("Bit can only be 0-7");                              varType = VarType.Bit;                              return;                          default:                              throw new InvalidAddressException();                      }                  case "EB":                      // Input byte                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "EW":                      // Input word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "ED":                      // Input double-word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "AB":                      // Output byte                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "AW":                      // Output word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "AD":                      // Output double-word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "MB":                      // Memory byte                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "MW":                      // Memory word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "MD":                      // Memory double-word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  default:                      switch (input.Substring(0' 1))                      {                          case "E":                          case "I":                              // Input                              dataType = DataType.Input;                              varType = VarType.Bit;                              break;                          case "A":                          case "O":                              // Output                              dataType = DataType.Output;                              varType = VarType.Bit;                              break;                          case "M":                              // Memory                              dataType = DataType.Memory;                              varType = VarType.Byte;                              break;                          case "T":                              // Timer                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Timer;                              return;                          case "Z":                          case "C":                              // Counter                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Counter;                              return;                          default:                              throw new InvalidAddressException(string.Format("{0} is not a valid address"' input.Substring(0' 1)));                      }                        string txt2 = input.Substring(1);                      if (txt2.IndexOf(".") == -1)                          throw new InvalidAddressException("To few periods for DB address");                        address = int.Parse(txt2.Substring(0' txt2.IndexOf(".")));                      bitNumber = int.Parse(txt2.Substring(txt2.IndexOf(".") + 1));                      if (bitNumber > 7)                          throw new InvalidAddressException("Bit can only be 0-7");                      return;              }
Magic Number,S7.Net,PLCAddress,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLCAddress.cs,Parse,The following statement contains a magic number: switch (input.Substring(0' 2))              {                  case "DB":                      string[] strings = input.Split(new char[] { '.' });                      if (strings.Length < 2)                          throw new InvalidAddressException("To few periods for DB address");                        dataType = DataType.DataBlock;                      dbNumber = int.Parse(strings[0].Substring(2));                      address = int.Parse(strings[1].Substring(3));                        string dbType = strings[1].Substring(0' 3);                      switch (dbType)                      {                          case "DBB":                              varType = VarType.Byte;                              return;                          case "DBW":                              varType = VarType.Word;                              return;                          case "DBD":                              varType = VarType.DWord;                              return;                          case "DBX":                              bitNumber = int.Parse(strings[2]);                              if (bitNumber > 7)                                  throw new InvalidAddressException("Bit can only be 0-7");                              varType = VarType.Bit;                              return;                          default:                              throw new InvalidAddressException();                      }                  case "EB":                      // Input byte                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "EW":                      // Input word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "ED":                      // Input double-word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "AB":                      // Output byte                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "AW":                      // Output word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "AD":                      // Output double-word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "MB":                      // Memory byte                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "MW":                      // Memory word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "MD":                      // Memory double-word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  default:                      switch (input.Substring(0' 1))                      {                          case "E":                          case "I":                              // Input                              dataType = DataType.Input;                              varType = VarType.Bit;                              break;                          case "A":                          case "O":                              // Output                              dataType = DataType.Output;                              varType = VarType.Bit;                              break;                          case "M":                              // Memory                              dataType = DataType.Memory;                              varType = VarType.Byte;                              break;                          case "T":                              // Timer                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Timer;                              return;                          case "Z":                          case "C":                              // Counter                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Counter;                              return;                          default:                              throw new InvalidAddressException(string.Format("{0} is not a valid address"' input.Substring(0' 1)));                      }                        string txt2 = input.Substring(1);                      if (txt2.IndexOf(".") == -1)                          throw new InvalidAddressException("To few periods for DB address");                        address = int.Parse(txt2.Substring(0' txt2.IndexOf(".")));                      bitNumber = int.Parse(txt2.Substring(txt2.IndexOf(".") + 1));                      if (bitNumber > 7)                          throw new InvalidAddressException("Bit can only be 0-7");                      return;              }
Magic Number,S7.Net,PLCAddress,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLCAddress.cs,Parse,The following statement contains a magic number: switch (input.Substring(0' 2))              {                  case "DB":                      string[] strings = input.Split(new char[] { '.' });                      if (strings.Length < 2)                          throw new InvalidAddressException("To few periods for DB address");                        dataType = DataType.DataBlock;                      dbNumber = int.Parse(strings[0].Substring(2));                      address = int.Parse(strings[1].Substring(3));                        string dbType = strings[1].Substring(0' 3);                      switch (dbType)                      {                          case "DBB":                              varType = VarType.Byte;                              return;                          case "DBW":                              varType = VarType.Word;                              return;                          case "DBD":                              varType = VarType.DWord;                              return;                          case "DBX":                              bitNumber = int.Parse(strings[2]);                              if (bitNumber > 7)                                  throw new InvalidAddressException("Bit can only be 0-7");                              varType = VarType.Bit;                              return;                          default:                              throw new InvalidAddressException();                      }                  case "EB":                      // Input byte                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "EW":                      // Input word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "ED":                      // Input double-word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "AB":                      // Output byte                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "AW":                      // Output word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "AD":                      // Output double-word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "MB":                      // Memory byte                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "MW":                      // Memory word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "MD":                      // Memory double-word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  default:                      switch (input.Substring(0' 1))                      {                          case "E":                          case "I":                              // Input                              dataType = DataType.Input;                              varType = VarType.Bit;                              break;                          case "A":                          case "O":                              // Output                              dataType = DataType.Output;                              varType = VarType.Bit;                              break;                          case "M":                              // Memory                              dataType = DataType.Memory;                              varType = VarType.Byte;                              break;                          case "T":                              // Timer                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Timer;                              return;                          case "Z":                          case "C":                              // Counter                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Counter;                              return;                          default:                              throw new InvalidAddressException(string.Format("{0} is not a valid address"' input.Substring(0' 1)));                      }                        string txt2 = input.Substring(1);                      if (txt2.IndexOf(".") == -1)                          throw new InvalidAddressException("To few periods for DB address");                        address = int.Parse(txt2.Substring(0' txt2.IndexOf(".")));                      bitNumber = int.Parse(txt2.Substring(txt2.IndexOf(".") + 1));                      if (bitNumber > 7)                          throw new InvalidAddressException("Bit can only be 0-7");                      return;              }
Magic Number,S7.Net,PLCAddress,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLCAddress.cs,Parse,The following statement contains a magic number: switch (input.Substring(0' 2))              {                  case "DB":                      string[] strings = input.Split(new char[] { '.' });                      if (strings.Length < 2)                          throw new InvalidAddressException("To few periods for DB address");                        dataType = DataType.DataBlock;                      dbNumber = int.Parse(strings[0].Substring(2));                      address = int.Parse(strings[1].Substring(3));                        string dbType = strings[1].Substring(0' 3);                      switch (dbType)                      {                          case "DBB":                              varType = VarType.Byte;                              return;                          case "DBW":                              varType = VarType.Word;                              return;                          case "DBD":                              varType = VarType.DWord;                              return;                          case "DBX":                              bitNumber = int.Parse(strings[2]);                              if (bitNumber > 7)                                  throw new InvalidAddressException("Bit can only be 0-7");                              varType = VarType.Bit;                              return;                          default:                              throw new InvalidAddressException();                      }                  case "EB":                      // Input byte                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "EW":                      // Input word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "ED":                      // Input double-word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "AB":                      // Output byte                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "AW":                      // Output word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "AD":                      // Output double-word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "MB":                      // Memory byte                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "MW":                      // Memory word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "MD":                      // Memory double-word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  default:                      switch (input.Substring(0' 1))                      {                          case "E":                          case "I":                              // Input                              dataType = DataType.Input;                              varType = VarType.Bit;                              break;                          case "A":                          case "O":                              // Output                              dataType = DataType.Output;                              varType = VarType.Bit;                              break;                          case "M":                              // Memory                              dataType = DataType.Memory;                              varType = VarType.Byte;                              break;                          case "T":                              // Timer                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Timer;                              return;                          case "Z":                          case "C":                              // Counter                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Counter;                              return;                          default:                              throw new InvalidAddressException(string.Format("{0} is not a valid address"' input.Substring(0' 1)));                      }                        string txt2 = input.Substring(1);                      if (txt2.IndexOf(".") == -1)                          throw new InvalidAddressException("To few periods for DB address");                        address = int.Parse(txt2.Substring(0' txt2.IndexOf(".")));                      bitNumber = int.Parse(txt2.Substring(txt2.IndexOf(".") + 1));                      if (bitNumber > 7)                          throw new InvalidAddressException("Bit can only be 0-7");                      return;              }
Magic Number,S7.Net,PLCAddress,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLCAddress.cs,Parse,The following statement contains a magic number: switch (input.Substring(0' 2))              {                  case "DB":                      string[] strings = input.Split(new char[] { '.' });                      if (strings.Length < 2)                          throw new InvalidAddressException("To few periods for DB address");                        dataType = DataType.DataBlock;                      dbNumber = int.Parse(strings[0].Substring(2));                      address = int.Parse(strings[1].Substring(3));                        string dbType = strings[1].Substring(0' 3);                      switch (dbType)                      {                          case "DBB":                              varType = VarType.Byte;                              return;                          case "DBW":                              varType = VarType.Word;                              return;                          case "DBD":                              varType = VarType.DWord;                              return;                          case "DBX":                              bitNumber = int.Parse(strings[2]);                              if (bitNumber > 7)                                  throw new InvalidAddressException("Bit can only be 0-7");                              varType = VarType.Bit;                              return;                          default:                              throw new InvalidAddressException();                      }                  case "EB":                      // Input byte                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "EW":                      // Input word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "ED":                      // Input double-word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "AB":                      // Output byte                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "AW":                      // Output word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "AD":                      // Output double-word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "MB":                      // Memory byte                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "MW":                      // Memory word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "MD":                      // Memory double-word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  default:                      switch (input.Substring(0' 1))                      {                          case "E":                          case "I":                              // Input                              dataType = DataType.Input;                              varType = VarType.Bit;                              break;                          case "A":                          case "O":                              // Output                              dataType = DataType.Output;                              varType = VarType.Bit;                              break;                          case "M":                              // Memory                              dataType = DataType.Memory;                              varType = VarType.Byte;                              break;                          case "T":                              // Timer                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Timer;                              return;                          case "Z":                          case "C":                              // Counter                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Counter;                              return;                          default:                              throw new InvalidAddressException(string.Format("{0} is not a valid address"' input.Substring(0' 1)));                      }                        string txt2 = input.Substring(1);                      if (txt2.IndexOf(".") == -1)                          throw new InvalidAddressException("To few periods for DB address");                        address = int.Parse(txt2.Substring(0' txt2.IndexOf(".")));                      bitNumber = int.Parse(txt2.Substring(txt2.IndexOf(".") + 1));                      if (bitNumber > 7)                          throw new InvalidAddressException("Bit can only be 0-7");                      return;              }
Magic Number,S7.Net,PLCAddress,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLCAddress.cs,Parse,The following statement contains a magic number: switch (input.Substring(0' 2))              {                  case "DB":                      string[] strings = input.Split(new char[] { '.' });                      if (strings.Length < 2)                          throw new InvalidAddressException("To few periods for DB address");                        dataType = DataType.DataBlock;                      dbNumber = int.Parse(strings[0].Substring(2));                      address = int.Parse(strings[1].Substring(3));                        string dbType = strings[1].Substring(0' 3);                      switch (dbType)                      {                          case "DBB":                              varType = VarType.Byte;                              return;                          case "DBW":                              varType = VarType.Word;                              return;                          case "DBD":                              varType = VarType.DWord;                              return;                          case "DBX":                              bitNumber = int.Parse(strings[2]);                              if (bitNumber > 7)                                  throw new InvalidAddressException("Bit can only be 0-7");                              varType = VarType.Bit;                              return;                          default:                              throw new InvalidAddressException();                      }                  case "EB":                      // Input byte                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "EW":                      // Input word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "ED":                      // Input double-word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "AB":                      // Output byte                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "AW":                      // Output word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "AD":                      // Output double-word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "MB":                      // Memory byte                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "MW":                      // Memory word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "MD":                      // Memory double-word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  default:                      switch (input.Substring(0' 1))                      {                          case "E":                          case "I":                              // Input                              dataType = DataType.Input;                              varType = VarType.Bit;                              break;                          case "A":                          case "O":                              // Output                              dataType = DataType.Output;                              varType = VarType.Bit;                              break;                          case "M":                              // Memory                              dataType = DataType.Memory;                              varType = VarType.Byte;                              break;                          case "T":                              // Timer                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Timer;                              return;                          case "Z":                          case "C":                              // Counter                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Counter;                              return;                          default:                              throw new InvalidAddressException(string.Format("{0} is not a valid address"' input.Substring(0' 1)));                      }                        string txt2 = input.Substring(1);                      if (txt2.IndexOf(".") == -1)                          throw new InvalidAddressException("To few periods for DB address");                        address = int.Parse(txt2.Substring(0' txt2.IndexOf(".")));                      bitNumber = int.Parse(txt2.Substring(txt2.IndexOf(".") + 1));                      if (bitNumber > 7)                          throw new InvalidAddressException("Bit can only be 0-7");                      return;              }
Magic Number,S7.Net,PLCAddress,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLCAddress.cs,Parse,The following statement contains a magic number: switch (input.Substring(0' 2))              {                  case "DB":                      string[] strings = input.Split(new char[] { '.' });                      if (strings.Length < 2)                          throw new InvalidAddressException("To few periods for DB address");                        dataType = DataType.DataBlock;                      dbNumber = int.Parse(strings[0].Substring(2));                      address = int.Parse(strings[1].Substring(3));                        string dbType = strings[1].Substring(0' 3);                      switch (dbType)                      {                          case "DBB":                              varType = VarType.Byte;                              return;                          case "DBW":                              varType = VarType.Word;                              return;                          case "DBD":                              varType = VarType.DWord;                              return;                          case "DBX":                              bitNumber = int.Parse(strings[2]);                              if (bitNumber > 7)                                  throw new InvalidAddressException("Bit can only be 0-7");                              varType = VarType.Bit;                              return;                          default:                              throw new InvalidAddressException();                      }                  case "EB":                      // Input byte                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "EW":                      // Input word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "ED":                      // Input double-word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "AB":                      // Output byte                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "AW":                      // Output word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "AD":                      // Output double-word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "MB":                      // Memory byte                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "MW":                      // Memory word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "MD":                      // Memory double-word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  default:                      switch (input.Substring(0' 1))                      {                          case "E":                          case "I":                              // Input                              dataType = DataType.Input;                              varType = VarType.Bit;                              break;                          case "A":                          case "O":                              // Output                              dataType = DataType.Output;                              varType = VarType.Bit;                              break;                          case "M":                              // Memory                              dataType = DataType.Memory;                              varType = VarType.Byte;                              break;                          case "T":                              // Timer                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Timer;                              return;                          case "Z":                          case "C":                              // Counter                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Counter;                              return;                          default:                              throw new InvalidAddressException(string.Format("{0} is not a valid address"' input.Substring(0' 1)));                      }                        string txt2 = input.Substring(1);                      if (txt2.IndexOf(".") == -1)                          throw new InvalidAddressException("To few periods for DB address");                        address = int.Parse(txt2.Substring(0' txt2.IndexOf(".")));                      bitNumber = int.Parse(txt2.Substring(txt2.IndexOf(".") + 1));                      if (bitNumber > 7)                          throw new InvalidAddressException("Bit can only be 0-7");                      return;              }
Magic Number,S7.Net,PLCAddress,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLCAddress.cs,Parse,The following statement contains a magic number: switch (input.Substring(0' 2))              {                  case "DB":                      string[] strings = input.Split(new char[] { '.' });                      if (strings.Length < 2)                          throw new InvalidAddressException("To few periods for DB address");                        dataType = DataType.DataBlock;                      dbNumber = int.Parse(strings[0].Substring(2));                      address = int.Parse(strings[1].Substring(3));                        string dbType = strings[1].Substring(0' 3);                      switch (dbType)                      {                          case "DBB":                              varType = VarType.Byte;                              return;                          case "DBW":                              varType = VarType.Word;                              return;                          case "DBD":                              varType = VarType.DWord;                              return;                          case "DBX":                              bitNumber = int.Parse(strings[2]);                              if (bitNumber > 7)                                  throw new InvalidAddressException("Bit can only be 0-7");                              varType = VarType.Bit;                              return;                          default:                              throw new InvalidAddressException();                      }                  case "EB":                      // Input byte                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "EW":                      // Input word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "ED":                      // Input double-word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "AB":                      // Output byte                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "AW":                      // Output word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "AD":                      // Output double-word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "MB":                      // Memory byte                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "MW":                      // Memory word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "MD":                      // Memory double-word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  default:                      switch (input.Substring(0' 1))                      {                          case "E":                          case "I":                              // Input                              dataType = DataType.Input;                              varType = VarType.Bit;                              break;                          case "A":                          case "O":                              // Output                              dataType = DataType.Output;                              varType = VarType.Bit;                              break;                          case "M":                              // Memory                              dataType = DataType.Memory;                              varType = VarType.Byte;                              break;                          case "T":                              // Timer                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Timer;                              return;                          case "Z":                          case "C":                              // Counter                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Counter;                              return;                          default:                              throw new InvalidAddressException(string.Format("{0} is not a valid address"' input.Substring(0' 1)));                      }                        string txt2 = input.Substring(1);                      if (txt2.IndexOf(".") == -1)                          throw new InvalidAddressException("To few periods for DB address");                        address = int.Parse(txt2.Substring(0' txt2.IndexOf(".")));                      bitNumber = int.Parse(txt2.Substring(txt2.IndexOf(".") + 1));                      if (bitNumber > 7)                          throw new InvalidAddressException("Bit can only be 0-7");                      return;              }
Magic Number,S7.Net,PLCAddress,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLCAddress.cs,Parse,The following statement contains a magic number: switch (input.Substring(0' 2))              {                  case "DB":                      string[] strings = input.Split(new char[] { '.' });                      if (strings.Length < 2)                          throw new InvalidAddressException("To few periods for DB address");                        dataType = DataType.DataBlock;                      dbNumber = int.Parse(strings[0].Substring(2));                      address = int.Parse(strings[1].Substring(3));                        string dbType = strings[1].Substring(0' 3);                      switch (dbType)                      {                          case "DBB":                              varType = VarType.Byte;                              return;                          case "DBW":                              varType = VarType.Word;                              return;                          case "DBD":                              varType = VarType.DWord;                              return;                          case "DBX":                              bitNumber = int.Parse(strings[2]);                              if (bitNumber > 7)                                  throw new InvalidAddressException("Bit can only be 0-7");                              varType = VarType.Bit;                              return;                          default:                              throw new InvalidAddressException();                      }                  case "EB":                      // Input byte                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "EW":                      // Input word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "ED":                      // Input double-word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "AB":                      // Output byte                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "AW":                      // Output word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "AD":                      // Output double-word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "MB":                      // Memory byte                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "MW":                      // Memory word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "MD":                      // Memory double-word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  default:                      switch (input.Substring(0' 1))                      {                          case "E":                          case "I":                              // Input                              dataType = DataType.Input;                              varType = VarType.Bit;                              break;                          case "A":                          case "O":                              // Output                              dataType = DataType.Output;                              varType = VarType.Bit;                              break;                          case "M":                              // Memory                              dataType = DataType.Memory;                              varType = VarType.Byte;                              break;                          case "T":                              // Timer                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Timer;                              return;                          case "Z":                          case "C":                              // Counter                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Counter;                              return;                          default:                              throw new InvalidAddressException(string.Format("{0} is not a valid address"' input.Substring(0' 1)));                      }                        string txt2 = input.Substring(1);                      if (txt2.IndexOf(".") == -1)                          throw new InvalidAddressException("To few periods for DB address");                        address = int.Parse(txt2.Substring(0' txt2.IndexOf(".")));                      bitNumber = int.Parse(txt2.Substring(txt2.IndexOf(".") + 1));                      if (bitNumber > 7)                          throw new InvalidAddressException("Bit can only be 0-7");                      return;              }
Magic Number,S7.Net,PLCAddress,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\PLCAddress.cs,Parse,The following statement contains a magic number: switch (input.Substring(0' 2))              {                  case "DB":                      string[] strings = input.Split(new char[] { '.' });                      if (strings.Length < 2)                          throw new InvalidAddressException("To few periods for DB address");                        dataType = DataType.DataBlock;                      dbNumber = int.Parse(strings[0].Substring(2));                      address = int.Parse(strings[1].Substring(3));                        string dbType = strings[1].Substring(0' 3);                      switch (dbType)                      {                          case "DBB":                              varType = VarType.Byte;                              return;                          case "DBW":                              varType = VarType.Word;                              return;                          case "DBD":                              varType = VarType.DWord;                              return;                          case "DBX":                              bitNumber = int.Parse(strings[2]);                              if (bitNumber > 7)                                  throw new InvalidAddressException("Bit can only be 0-7");                              varType = VarType.Bit;                              return;                          default:                              throw new InvalidAddressException();                      }                  case "EB":                      // Input byte                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "EW":                      // Input word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "ED":                      // Input double-word                      dataType = DataType.Input;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "AB":                      // Output byte                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "AW":                      // Output word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "AD":                      // Output double-word                      dataType = DataType.Output;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  case "MB":                      // Memory byte                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Byte;                      return;                  case "MW":                      // Memory word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.Word;                      return;                  case "MD":                      // Memory double-word                      dataType = DataType.Memory;                      dbNumber = 0;                      address = int.Parse(input.Substring(2));                      varType = VarType.DWord;                      return;                  default:                      switch (input.Substring(0' 1))                      {                          case "E":                          case "I":                              // Input                              dataType = DataType.Input;                              varType = VarType.Bit;                              break;                          case "A":                          case "O":                              // Output                              dataType = DataType.Output;                              varType = VarType.Bit;                              break;                          case "M":                              // Memory                              dataType = DataType.Memory;                              varType = VarType.Byte;                              break;                          case "T":                              // Timer                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Timer;                              return;                          case "Z":                          case "C":                              // Counter                              dataType = DataType.Timer;                              dbNumber = 0;                              address = int.Parse(input.Substring(1));                              varType = VarType.Counter;                              return;                          default:                              throw new InvalidAddressException(string.Format("{0} is not a valid address"' input.Substring(0' 1)));                      }                        string txt2 = input.Substring(1);                      if (txt2.IndexOf(".") == -1)                          throw new InvalidAddressException("To few periods for DB address");                        address = int.Parse(txt2.Substring(0' txt2.IndexOf(".")));                      bitNumber = int.Parse(txt2.Substring(txt2.IndexOf(".") + 1));                      if (bitNumber > 7)                          throw new InvalidAddressException("Bit can only be 0-7");                      return;              }
Magic Number,S7.Net,TPKT,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\TPKT.cs,Read,The following statement contains a magic number: var buf = new byte[4];
Magic Number,S7.Net,TPKT,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\TPKT.cs,Read,The following statement contains a magic number: int len = stream.Read(buf' 0' 4);
Magic Number,S7.Net,TPKT,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\TPKT.cs,Read,The following statement contains a magic number: len < 4
Magic Number,S7.Net,TPKT,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\TPKT.cs,Read,The following statement contains a magic number: var pkt = new TPKT              {                  Version = buf[0]'                  Reserved1 = buf[1]'                  Length = buf[2] * 256 + buf[3] //BigEndian              };
Magic Number,S7.Net,TPKT,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\TPKT.cs,Read,The following statement contains a magic number: var pkt = new TPKT              {                  Version = buf[0]'                  Reserved1 = buf[1]'                  Length = buf[2] * 256 + buf[3] //BigEndian              };
Magic Number,S7.Net,TPKT,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\TPKT.cs,Read,The following statement contains a magic number: var pkt = new TPKT              {                  Version = buf[0]'                  Reserved1 = buf[1]'                  Length = buf[2] * 256 + buf[3] //BigEndian              };
Magic Number,S7.Net,TPKT,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\TPKT.cs,Read,The following statement contains a magic number: pkt.Data = new byte[pkt.Length - 4];
Magic Number,S7.Net,TPKT,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\TPKT.cs,Read,The following statement contains a magic number: len = stream.Read(pkt.Data' 0' pkt.Length - 4);
Magic Number,S7.Net,TPKT,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\TPKT.cs,Read,The following statement contains a magic number: len < pkt.Length - 4
Magic Number,S7.Net,TPKT,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\TPKT.cs,ReadAsync,The following statement contains a magic number: var buf = new byte[4];
Magic Number,S7.Net,TPKT,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\TPKT.cs,ReadAsync,The following statement contains a magic number: int len = await stream.ReadAsync(buf' 0' 4);
Magic Number,S7.Net,TPKT,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\TPKT.cs,ReadAsync,The following statement contains a magic number: len < 4
Magic Number,S7.Net,TPKT,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\TPKT.cs,ReadAsync,The following statement contains a magic number: var pkt = new TPKT              {                  Version = buf[0]'                  Reserved1 = buf[1]'                  Length = buf[2] * 256 + buf[3] //BigEndian              };
Magic Number,S7.Net,TPKT,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\TPKT.cs,ReadAsync,The following statement contains a magic number: var pkt = new TPKT              {                  Version = buf[0]'                  Reserved1 = buf[1]'                  Length = buf[2] * 256 + buf[3] //BigEndian              };
Magic Number,S7.Net,TPKT,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\TPKT.cs,ReadAsync,The following statement contains a magic number: var pkt = new TPKT              {                  Version = buf[0]'                  Reserved1 = buf[1]'                  Length = buf[2] * 256 + buf[3] //BigEndian              };
Magic Number,S7.Net,TPKT,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\TPKT.cs,ReadAsync,The following statement contains a magic number: pkt.Data = new byte[pkt.Length - 4];
Magic Number,S7.Net,TPKT,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\TPKT.cs,ReadAsync,The following statement contains a magic number: len = await stream.ReadAsync(pkt.Data' 0' pkt.Length - 4);
Magic Number,S7.Net,TPKT,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\TPKT.cs,ReadAsync,The following statement contains a magic number: len < pkt.Length - 4
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: byte[] bSend1 = {                      3' 0' 0' 22' //TPKT                      17'     //COTP Header Length                      224'    //Connect Request                       0' 0'   //Destination Reference                      0' 46'  //Source Reference                      0'      //Flags                      193'    //Parameter Code (src-tasp)                      2'      //Parameter Length                      1' 0'   //Source TASP                      194'    //Parameter Code (dst-tasp)                      2'      //Parameter Length                      3' 0'   //Destination TASP                      192'    //Parameter Code (tpdu-size)                      1'      //Parameter Length                      10      //TPDU Size (2^10 = 1024)                  };
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: byte[] bSend1 = {                      3' 0' 0' 22' //TPKT                      17'     //COTP Header Length                      224'    //Connect Request                       0' 0'   //Destination Reference                      0' 46'  //Source Reference                      0'      //Flags                      193'    //Parameter Code (src-tasp)                      2'      //Parameter Length                      1' 0'   //Source TASP                      194'    //Parameter Code (dst-tasp)                      2'      //Parameter Length                      3' 0'   //Destination TASP                      192'    //Parameter Code (tpdu-size)                      1'      //Parameter Length                      10      //TPDU Size (2^10 = 1024)                  };
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: byte[] bSend1 = {                      3' 0' 0' 22' //TPKT                      17'     //COTP Header Length                      224'    //Connect Request                       0' 0'   //Destination Reference                      0' 46'  //Source Reference                      0'      //Flags                      193'    //Parameter Code (src-tasp)                      2'      //Parameter Length                      1' 0'   //Source TASP                      194'    //Parameter Code (dst-tasp)                      2'      //Parameter Length                      3' 0'   //Destination TASP                      192'    //Parameter Code (tpdu-size)                      1'      //Parameter Length                      10      //TPDU Size (2^10 = 1024)                  };
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: byte[] bSend1 = {                      3' 0' 0' 22' //TPKT                      17'     //COTP Header Length                      224'    //Connect Request                       0' 0'   //Destination Reference                      0' 46'  //Source Reference                      0'      //Flags                      193'    //Parameter Code (src-tasp)                      2'      //Parameter Length                      1' 0'   //Source TASP                      194'    //Parameter Code (dst-tasp)                      2'      //Parameter Length                      3' 0'   //Destination TASP                      192'    //Parameter Code (tpdu-size)                      1'      //Parameter Length                      10      //TPDU Size (2^10 = 1024)                  };
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: byte[] bSend1 = {                      3' 0' 0' 22' //TPKT                      17'     //COTP Header Length                      224'    //Connect Request                       0' 0'   //Destination Reference                      0' 46'  //Source Reference                      0'      //Flags                      193'    //Parameter Code (src-tasp)                      2'      //Parameter Length                      1' 0'   //Source TASP                      194'    //Parameter Code (dst-tasp)                      2'      //Parameter Length                      3' 0'   //Destination TASP                      192'    //Parameter Code (tpdu-size)                      1'      //Parameter Length                      10      //TPDU Size (2^10 = 1024)                  };
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: byte[] bSend1 = {                      3' 0' 0' 22' //TPKT                      17'     //COTP Header Length                      224'    //Connect Request                       0' 0'   //Destination Reference                      0' 46'  //Source Reference                      0'      //Flags                      193'    //Parameter Code (src-tasp)                      2'      //Parameter Length                      1' 0'   //Source TASP                      194'    //Parameter Code (dst-tasp)                      2'      //Parameter Length                      3' 0'   //Destination TASP                      192'    //Parameter Code (tpdu-size)                      1'      //Parameter Length                      10      //TPDU Size (2^10 = 1024)                  };
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: byte[] bSend1 = {                      3' 0' 0' 22' //TPKT                      17'     //COTP Header Length                      224'    //Connect Request                       0' 0'   //Destination Reference                      0' 46'  //Source Reference                      0'      //Flags                      193'    //Parameter Code (src-tasp)                      2'      //Parameter Length                      1' 0'   //Source TASP                      194'    //Parameter Code (dst-tasp)                      2'      //Parameter Length                      3' 0'   //Destination TASP                      192'    //Parameter Code (tpdu-size)                      1'      //Parameter Length                      10      //TPDU Size (2^10 = 1024)                  };
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: byte[] bSend1 = {                      3' 0' 0' 22' //TPKT                      17'     //COTP Header Length                      224'    //Connect Request                       0' 0'   //Destination Reference                      0' 46'  //Source Reference                      0'      //Flags                      193'    //Parameter Code (src-tasp)                      2'      //Parameter Length                      1' 0'   //Source TASP                      194'    //Parameter Code (dst-tasp)                      2'      //Parameter Length                      3' 0'   //Destination TASP                      192'    //Parameter Code (tpdu-size)                      1'      //Parameter Length                      10      //TPDU Size (2^10 = 1024)                  };
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: byte[] bSend1 = {                      3' 0' 0' 22' //TPKT                      17'     //COTP Header Length                      224'    //Connect Request                       0' 0'   //Destination Reference                      0' 46'  //Source Reference                      0'      //Flags                      193'    //Parameter Code (src-tasp)                      2'      //Parameter Length                      1' 0'   //Source TASP                      194'    //Parameter Code (dst-tasp)                      2'      //Parameter Length                      3' 0'   //Destination TASP                      192'    //Parameter Code (tpdu-size)                      1'      //Parameter Length                      10      //TPDU Size (2^10 = 1024)                  };
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: byte[] bSend1 = {                      3' 0' 0' 22' //TPKT                      17'     //COTP Header Length                      224'    //Connect Request                       0' 0'   //Destination Reference                      0' 46'  //Source Reference                      0'      //Flags                      193'    //Parameter Code (src-tasp)                      2'      //Parameter Length                      1' 0'   //Source TASP                      194'    //Parameter Code (dst-tasp)                      2'      //Parameter Length                      3' 0'   //Destination TASP                      192'    //Parameter Code (tpdu-size)                      1'      //Parameter Length                      10      //TPDU Size (2^10 = 1024)                  };
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: byte[] bSend1 = {                      3' 0' 0' 22' //TPKT                      17'     //COTP Header Length                      224'    //Connect Request                       0' 0'   //Destination Reference                      0' 46'  //Source Reference                      0'      //Flags                      193'    //Parameter Code (src-tasp)                      2'      //Parameter Length                      1' 0'   //Source TASP                      194'    //Parameter Code (dst-tasp)                      2'      //Parameter Length                      3' 0'   //Destination TASP                      192'    //Parameter Code (tpdu-size)                      1'      //Parameter Length                      10      //TPDU Size (2^10 = 1024)                  };
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: byte[] bSend1 = {                      3' 0' 0' 22' //TPKT                      17'     //COTP Header Length                      224'    //Connect Request                       0' 0'   //Destination Reference                      0' 46'  //Source Reference                      0'      //Flags                      193'    //Parameter Code (src-tasp)                      2'      //Parameter Length                      1' 0'   //Source TASP                      194'    //Parameter Code (dst-tasp)                      2'      //Parameter Length                      3' 0'   //Destination TASP                      192'    //Parameter Code (tpdu-size)                      1'      //Parameter Length                      10      //TPDU Size (2^10 = 1024)                  };
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: switch (cpu)              {                  case CpuType.S7200:                      //S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x00;                      //S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap                      bSend1[17] = 0x10;                      bSend1[18] = 0x00;                      break;                  case CpuType.Logo0BA8:                      // These values are taken from NodeS7' it's not verified if these are                      // exact requirements to connect to the Logo0BA8.                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      bSend1[17] = 0x01;                      bSend1[18] = 0x02;                      break;                  case CpuType.S71200:                  case CpuType.S7300:                  case CpuType.S7400:                      //S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      //S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  case CpuType.S71500:                      // Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x02;                      // Fredmer Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  default:                      throw new Exception("Wrong CPU Type Secified");              }
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: switch (cpu)              {                  case CpuType.S7200:                      //S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x00;                      //S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap                      bSend1[17] = 0x10;                      bSend1[18] = 0x00;                      break;                  case CpuType.Logo0BA8:                      // These values are taken from NodeS7' it's not verified if these are                      // exact requirements to connect to the Logo0BA8.                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      bSend1[17] = 0x01;                      bSend1[18] = 0x02;                      break;                  case CpuType.S71200:                  case CpuType.S7300:                  case CpuType.S7400:                      //S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      //S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  case CpuType.S71500:                      // Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x02;                      // Fredmer Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  default:                      throw new Exception("Wrong CPU Type Secified");              }
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: switch (cpu)              {                  case CpuType.S7200:                      //S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x00;                      //S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap                      bSend1[17] = 0x10;                      bSend1[18] = 0x00;                      break;                  case CpuType.Logo0BA8:                      // These values are taken from NodeS7' it's not verified if these are                      // exact requirements to connect to the Logo0BA8.                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      bSend1[17] = 0x01;                      bSend1[18] = 0x02;                      break;                  case CpuType.S71200:                  case CpuType.S7300:                  case CpuType.S7400:                      //S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      //S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  case CpuType.S71500:                      // Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x02;                      // Fredmer Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  default:                      throw new Exception("Wrong CPU Type Secified");              }
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: switch (cpu)              {                  case CpuType.S7200:                      //S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x00;                      //S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap                      bSend1[17] = 0x10;                      bSend1[18] = 0x00;                      break;                  case CpuType.Logo0BA8:                      // These values are taken from NodeS7' it's not verified if these are                      // exact requirements to connect to the Logo0BA8.                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      bSend1[17] = 0x01;                      bSend1[18] = 0x02;                      break;                  case CpuType.S71200:                  case CpuType.S7300:                  case CpuType.S7400:                      //S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      //S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  case CpuType.S71500:                      // Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x02;                      // Fredmer Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  default:                      throw new Exception("Wrong CPU Type Secified");              }
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: switch (cpu)              {                  case CpuType.S7200:                      //S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x00;                      //S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap                      bSend1[17] = 0x10;                      bSend1[18] = 0x00;                      break;                  case CpuType.Logo0BA8:                      // These values are taken from NodeS7' it's not verified if these are                      // exact requirements to connect to the Logo0BA8.                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      bSend1[17] = 0x01;                      bSend1[18] = 0x02;                      break;                  case CpuType.S71200:                  case CpuType.S7300:                  case CpuType.S7400:                      //S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      //S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  case CpuType.S71500:                      // Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x02;                      // Fredmer Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  default:                      throw new Exception("Wrong CPU Type Secified");              }
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: switch (cpu)              {                  case CpuType.S7200:                      //S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x00;                      //S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap                      bSend1[17] = 0x10;                      bSend1[18] = 0x00;                      break;                  case CpuType.Logo0BA8:                      // These values are taken from NodeS7' it's not verified if these are                      // exact requirements to connect to the Logo0BA8.                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      bSend1[17] = 0x01;                      bSend1[18] = 0x02;                      break;                  case CpuType.S71200:                  case CpuType.S7300:                  case CpuType.S7400:                      //S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      //S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  case CpuType.S71500:                      // Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x02;                      // Fredmer Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  default:                      throw new Exception("Wrong CPU Type Secified");              }
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: switch (cpu)              {                  case CpuType.S7200:                      //S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x00;                      //S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap                      bSend1[17] = 0x10;                      bSend1[18] = 0x00;                      break;                  case CpuType.Logo0BA8:                      // These values are taken from NodeS7' it's not verified if these are                      // exact requirements to connect to the Logo0BA8.                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      bSend1[17] = 0x01;                      bSend1[18] = 0x02;                      break;                  case CpuType.S71200:                  case CpuType.S7300:                  case CpuType.S7400:                      //S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      //S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  case CpuType.S71500:                      // Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x02;                      // Fredmer Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  default:                      throw new Exception("Wrong CPU Type Secified");              }
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: switch (cpu)              {                  case CpuType.S7200:                      //S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x00;                      //S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap                      bSend1[17] = 0x10;                      bSend1[18] = 0x00;                      break;                  case CpuType.Logo0BA8:                      // These values are taken from NodeS7' it's not verified if these are                      // exact requirements to connect to the Logo0BA8.                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      bSend1[17] = 0x01;                      bSend1[18] = 0x02;                      break;                  case CpuType.S71200:                  case CpuType.S7300:                  case CpuType.S7400:                      //S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      //S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  case CpuType.S71500:                      // Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x02;                      // Fredmer Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  default:                      throw new Exception("Wrong CPU Type Secified");              }
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: switch (cpu)              {                  case CpuType.S7200:                      //S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x00;                      //S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap                      bSend1[17] = 0x10;                      bSend1[18] = 0x00;                      break;                  case CpuType.Logo0BA8:                      // These values are taken from NodeS7' it's not verified if these are                      // exact requirements to connect to the Logo0BA8.                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      bSend1[17] = 0x01;                      bSend1[18] = 0x02;                      break;                  case CpuType.S71200:                  case CpuType.S7300:                  case CpuType.S7400:                      //S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      //S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  case CpuType.S71500:                      // Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x02;                      // Fredmer Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  default:                      throw new Exception("Wrong CPU Type Secified");              }
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: switch (cpu)              {                  case CpuType.S7200:                      //S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x00;                      //S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap                      bSend1[17] = 0x10;                      bSend1[18] = 0x00;                      break;                  case CpuType.Logo0BA8:                      // These values are taken from NodeS7' it's not verified if these are                      // exact requirements to connect to the Logo0BA8.                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      bSend1[17] = 0x01;                      bSend1[18] = 0x02;                      break;                  case CpuType.S71200:                  case CpuType.S7300:                  case CpuType.S7400:                      //S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      //S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  case CpuType.S71500:                      // Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x02;                      // Fredmer Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  default:                      throw new Exception("Wrong CPU Type Secified");              }
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: switch (cpu)              {                  case CpuType.S7200:                      //S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x00;                      //S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap                      bSend1[17] = 0x10;                      bSend1[18] = 0x00;                      break;                  case CpuType.Logo0BA8:                      // These values are taken from NodeS7' it's not verified if these are                      // exact requirements to connect to the Logo0BA8.                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      bSend1[17] = 0x01;                      bSend1[18] = 0x02;                      break;                  case CpuType.S71200:                  case CpuType.S7300:                  case CpuType.S7400:                      //S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      //S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  case CpuType.S71500:                      // Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x02;                      // Fredmer Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  default:                      throw new Exception("Wrong CPU Type Secified");              }
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: switch (cpu)              {                  case CpuType.S7200:                      //S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x00;                      //S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap                      bSend1[17] = 0x10;                      bSend1[18] = 0x00;                      break;                  case CpuType.Logo0BA8:                      // These values are taken from NodeS7' it's not verified if these are                      // exact requirements to connect to the Logo0BA8.                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      bSend1[17] = 0x01;                      bSend1[18] = 0x02;                      break;                  case CpuType.S71200:                  case CpuType.S7300:                  case CpuType.S7400:                      //S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      //S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  case CpuType.S71500:                      // Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x02;                      // Fredmer Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  default:                      throw new Exception("Wrong CPU Type Secified");              }
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: switch (cpu)              {                  case CpuType.S7200:                      //S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x00;                      //S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap                      bSend1[17] = 0x10;                      bSend1[18] = 0x00;                      break;                  case CpuType.Logo0BA8:                      // These values are taken from NodeS7' it's not verified if these are                      // exact requirements to connect to the Logo0BA8.                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      bSend1[17] = 0x01;                      bSend1[18] = 0x02;                      break;                  case CpuType.S71200:                  case CpuType.S7300:                  case CpuType.S7400:                      //S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      //S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  case CpuType.S71500:                      // Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x02;                      // Fredmer Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  default:                      throw new Exception("Wrong CPU Type Secified");              }
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: switch (cpu)              {                  case CpuType.S7200:                      //S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x00;                      //S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap                      bSend1[17] = 0x10;                      bSend1[18] = 0x00;                      break;                  case CpuType.Logo0BA8:                      // These values are taken from NodeS7' it's not verified if these are                      // exact requirements to connect to the Logo0BA8.                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      bSend1[17] = 0x01;                      bSend1[18] = 0x02;                      break;                  case CpuType.S71200:                  case CpuType.S7300:                  case CpuType.S7400:                      //S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      //S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  case CpuType.S71500:                      // Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x02;                      // Fredmer Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  default:                      throw new Exception("Wrong CPU Type Secified");              }
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: switch (cpu)              {                  case CpuType.S7200:                      //S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x00;                      //S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap                      bSend1[17] = 0x10;                      bSend1[18] = 0x00;                      break;                  case CpuType.Logo0BA8:                      // These values are taken from NodeS7' it's not verified if these are                      // exact requirements to connect to the Logo0BA8.                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      bSend1[17] = 0x01;                      bSend1[18] = 0x02;                      break;                  case CpuType.S71200:                  case CpuType.S7300:                  case CpuType.S7400:                      //S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      //S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  case CpuType.S71500:                      // Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x02;                      // Fredmer Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  default:                      throw new Exception("Wrong CPU Type Secified");              }
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: switch (cpu)              {                  case CpuType.S7200:                      //S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x00;                      //S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap                      bSend1[17] = 0x10;                      bSend1[18] = 0x00;                      break;                  case CpuType.Logo0BA8:                      // These values are taken from NodeS7' it's not verified if these are                      // exact requirements to connect to the Logo0BA8.                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      bSend1[17] = 0x01;                      bSend1[18] = 0x02;                      break;                  case CpuType.S71200:                  case CpuType.S7300:                  case CpuType.S7400:                      //S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      //S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  case CpuType.S71500:                      // Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x02;                      // Fredmer Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  default:                      throw new Exception("Wrong CPU Type Secified");              }
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: switch (cpu)              {                  case CpuType.S7200:                      //S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x00;                      //S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap                      bSend1[17] = 0x10;                      bSend1[18] = 0x00;                      break;                  case CpuType.Logo0BA8:                      // These values are taken from NodeS7' it's not verified if these are                      // exact requirements to connect to the Logo0BA8.                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      bSend1[17] = 0x01;                      bSend1[18] = 0x02;                      break;                  case CpuType.S71200:                  case CpuType.S7300:                  case CpuType.S7400:                      //S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      //S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  case CpuType.S71500:                      // Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x02;                      // Fredmer Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  default:                      throw new Exception("Wrong CPU Type Secified");              }
Magic Number,S7.Net.Protocol,ConnectionRequest,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\ConnectionRequest.cs,GetCOTPConnectionRequest,The following statement contains a magic number: switch (cpu)              {                  case CpuType.S7200:                      //S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x00;                      //S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap                      bSend1[17] = 0x10;                      bSend1[18] = 0x00;                      break;                  case CpuType.Logo0BA8:                      // These values are taken from NodeS7' it's not verified if these are                      // exact requirements to connect to the Logo0BA8.                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      bSend1[17] = 0x01;                      bSend1[18] = 0x02;                      break;                  case CpuType.S71200:                  case CpuType.S7300:                  case CpuType.S7400:                      //S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap                      bSend1[13] = 0x01;                      bSend1[14] = 0x00;                      //S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  case CpuType.S71500:                      // Eigener Tsap                      bSend1[13] = 0x10;                      bSend1[14] = 0x02;                      // Fredmer Tsap                      bSend1[17] = 0x03;                      bSend1[18] = (byte) ((rack << 5) | (int) slot);                      break;                  default:                      throw new Exception("Wrong CPU Type Secified");              }
Magic Number,S7.Net.Protocol,S7WriteMultiple,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\S7WriteMultiple.cs,CreateRequest,The following statement contains a magic number: Serialization.SetWordAt(message' Header.Offsets.ParameterSize'                  (ushort) (2 + paramSize));
Magic Number,S7.Net.Protocol,S7WriteMultiple,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\S7WriteMultiple.cs,CreateRequest,The following statement contains a magic number: var wordLen = item.Value is bool ? 1 : 2;
Magic Number,S7.Net.Protocol,S7WriteMultiple,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\S7WriteMultiple.cs,CreateRequest,The following statement contains a magic number: item.BitAdr > 7
Magic Number,S7.Net.Protocol,S7WriteMultiple,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\S7WriteMultiple.cs,ParseResponse,The following statement contains a magic number: length < 12
Magic Number,S7.Net.Protocol,S7WriteMultiple,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\S7WriteMultiple.cs,ParseResponse,The following statement contains a magic number: var messageError = Serialization.GetWordAt(message' 10);
Magic Number,S7.Net.Protocol,S7WriteMultiple,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\S7WriteMultiple.cs,ParseResponse,The following statement contains a magic number: length < 14 + dataItems.Length
Magic Number,S7.Net.Protocol,S7WriteMultiple,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\S7WriteMultiple.cs,ParseResponse,The following statement contains a magic number: IList<byte> itemResults = new ArraySegment<byte>(message' 14' dataItems.Length);
Magic Number,S7.Net.Protocol,Serialization,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\Serialization.cs,GetWordAt,The following statement contains a magic number: return (ushort)((buf[index] << 8) + buf[index]);
Magic Number,S7.Net.Protocol,Serialization,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\Serialization.cs,SetAddressAt,The following statement contains a magic number: var start = startByte * 8 + bitNumber;
Magic Number,S7.Net.Protocol,Serialization,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\Serialization.cs,SetAddressAt,The following statement contains a magic number: buffer[index + 2] = (byte)start;
Magic Number,S7.Net.Protocol,Serialization,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\Serialization.cs,SetAddressAt,The following statement contains a magic number: start = start >> 8;
Magic Number,S7.Net.Protocol,Serialization,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\Serialization.cs,SetAddressAt,The following statement contains a magic number: start = start >> 8;
Magic Number,S7.Net.Protocol,Serialization,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Protocol\Serialization.cs,SetWordAt,The following statement contains a magic number: buffer[index] = (byte)(value >> 8);
Magic Number,S7.Net.Types,Bit,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Bit.cs,ToBitArray,The following statement contains a magic number: length > bytes.Length * 8
Magic Number,S7.Net.Types,ByteArray,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\ByteArray.cs,AddWord,The following statement contains a magic number: list.Add((byte) (value >> 8));
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetIncreasedNumberOfBytes,The following statement contains a magic number: switch (type.Name)              {                  case "Boolean":                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      numBytes++;                      break;                  case "Int16":                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 2;                      break;                  case "Int32":                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 4;                      break;                  case "Single":                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 4;                      break;                  default:                      var propertyClass = Activator.CreateInstance(type);                      numBytes = GetClassSize(propertyClass' numBytes' true);                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetIncreasedNumberOfBytes,The following statement contains a magic number: switch (type.Name)              {                  case "Boolean":                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      numBytes++;                      break;                  case "Int16":                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 2;                      break;                  case "Int32":                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 4;                      break;                  case "Single":                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 4;                      break;                  default:                      var propertyClass = Activator.CreateInstance(type);                      numBytes = GetClassSize(propertyClass' numBytes' true);                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetIncreasedNumberOfBytes,The following statement contains a magic number: switch (type.Name)              {                  case "Boolean":                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      numBytes++;                      break;                  case "Int16":                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 2;                      break;                  case "Int32":                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 4;                      break;                  case "Single":                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 4;                      break;                  default:                      var propertyClass = Activator.CreateInstance(type);                      numBytes = GetClassSize(propertyClass' numBytes' true);                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetIncreasedNumberOfBytes,The following statement contains a magic number: switch (type.Name)              {                  case "Boolean":                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      numBytes++;                      break;                  case "Int16":                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 2;                      break;                  case "Int32":                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 4;                      break;                  case "Single":                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 4;                      break;                  default:                      var propertyClass = Activator.CreateInstance(type);                      numBytes = GetClassSize(propertyClass' numBytes' true);                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetIncreasedNumberOfBytes,The following statement contains a magic number: switch (type.Name)              {                  case "Boolean":                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      numBytes++;                      break;                  case "Int16":                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 2;                      break;                  case "Int32":                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 4;                      break;                  case "Single":                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 4;                      break;                  default:                      var propertyClass = Activator.CreateInstance(type);                      numBytes = GetClassSize(propertyClass' numBytes' true);                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetIncreasedNumberOfBytes,The following statement contains a magic number: switch (type.Name)              {                  case "Boolean":                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      numBytes++;                      break;                  case "Int16":                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 2;                      break;                  case "Int32":                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 4;                      break;                  case "Single":                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 4;                      break;                  default:                      var propertyClass = Activator.CreateInstance(type);                      numBytes = GetClassSize(propertyClass' numBytes' true);                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetIncreasedNumberOfBytes,The following statement contains a magic number: switch (type.Name)              {                  case "Boolean":                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      numBytes++;                      break;                  case "Int16":                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 2;                      break;                  case "Int32":                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 4;                      break;                  case "Single":                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 4;                      break;                  default:                      var propertyClass = Activator.CreateInstance(type);                      numBytes = GetClassSize(propertyClass' numBytes' true);                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetIncreasedNumberOfBytes,The following statement contains a magic number: switch (type.Name)              {                  case "Boolean":                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      numBytes++;                      break;                  case "Int16":                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 2;                      break;                  case "Int32":                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 4;                      break;                  case "Single":                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 4;                      break;                  default:                      var propertyClass = Activator.CreateInstance(type);                      numBytes = GetClassSize(propertyClass' numBytes' true);                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetIncreasedNumberOfBytes,The following statement contains a magic number: switch (type.Name)              {                  case "Boolean":                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      numBytes++;                      break;                  case "Int16":                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 2;                      break;                  case "Int32":                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 4;                      break;                  case "Single":                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 4;                      break;                  default:                      var propertyClass = Activator.CreateInstance(type);                      numBytes = GetClassSize(propertyClass' numBytes' true);                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetIncreasedNumberOfBytes,The following statement contains a magic number: switch (type.Name)              {                  case "Boolean":                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      numBytes++;                      break;                  case "Int16":                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 2;                      break;                  case "Int32":                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 4;                      break;                  case "Single":                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      numBytes += 4;                      break;                  default:                      var propertyClass = Activator.CreateInstance(type);                      numBytes = GetClassSize(propertyClass' numBytes' true);                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: (numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: (numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,GetPropertyValue,The following statement contains a magic number: switch (propertyType.Name)              {                  case "Boolean":                      // get the value                      int bytePos = (int)Math.Floor(numBytes);                      int bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                          value = true;                      else                          value = false;                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = Math.Ceiling(numBytes);                      value = (byte)(bytes[(int)numBytes]);                      numBytes++;                      break;                  case "Int16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      value = source.ConvertToShort();                      numBytes += 2;                      break;                  case "UInt16":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                      numBytes += 2;                      break;                  case "Int32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                         bytes[(int)numBytes + 2]'                                                                         bytes[(int)numBytes + 1]'                                                                         bytes[(int)numBytes + 0]);                      value = sourceUInt.ConvertToInt();                      numBytes += 4;                      break;                  case "UInt32":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = DWord.FromBytes(                          bytes[(int)numBytes]'                          bytes[(int)numBytes + 1]'                          bytes[(int)numBytes + 2]'                          bytes[(int)numBytes + 3]);                      numBytes += 4;                      break;                  case "Double":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Double.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  case "Single":                      numBytes = Math.Ceiling(numBytes);                      if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                          numBytes++;                      // hier auswerten                      value = Single.FromByteArray(                          new byte[] {                              bytes[(int)numBytes]'                              bytes[(int)numBytes + 1]'                              bytes[(int)numBytes + 2]'                              bytes[(int)numBytes + 3] });                      numBytes += 4;                      break;                  default:                      var propClass = Activator.CreateInstance(propertyType);                      numBytes = FromBytes(propClass' bytes' numBytes);                      value = propClass;                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,SetBytesFromProperty,The following statement contains a magic number: switch (propertyValue.GetType().Name)              {                  case "Boolean":                      // get the value                      bytePos = (int)Math.Floor(numBytes);                      bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bool)propertyValue)                          bytes[bytePos] |= (byte)Math.Pow(2' bitPos);            // is true                      else                          bytes[bytePos] &= (byte)(~(byte)Math.Pow(2' bitPos));   // is false                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = (int)Math.Ceiling(numBytes);                      bytePos = (int)numBytes;                      bytes[bytePos] = (byte)propertyValue;                      numBytes++;                      break;                  case "Int16":                      bytes2 = Int.ToByteArray((Int16)propertyValue);                      break;                  case "UInt16":                      bytes2 = Word.ToByteArray((UInt16)propertyValue);                      break;                  case "Int32":                      bytes2 = DInt.ToByteArray((Int32)propertyValue);                      break;                  case "UInt32":                      bytes2 = DWord.ToByteArray((UInt32)propertyValue);                      break;                  case "Double":                      bytes2 = Double.ToByteArray((double)propertyValue);                      break;                  case "Single":                      bytes2 = Single.ToByteArray((float)propertyValue);                      break;                  default:                      numBytes = ToBytes(propertyValue' bytes' numBytes);                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,SetBytesFromProperty,The following statement contains a magic number: switch (propertyValue.GetType().Name)              {                  case "Boolean":                      // get the value                      bytePos = (int)Math.Floor(numBytes);                      bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bool)propertyValue)                          bytes[bytePos] |= (byte)Math.Pow(2' bitPos);            // is true                      else                          bytes[bytePos] &= (byte)(~(byte)Math.Pow(2' bitPos));   // is false                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = (int)Math.Ceiling(numBytes);                      bytePos = (int)numBytes;                      bytes[bytePos] = (byte)propertyValue;                      numBytes++;                      break;                  case "Int16":                      bytes2 = Int.ToByteArray((Int16)propertyValue);                      break;                  case "UInt16":                      bytes2 = Word.ToByteArray((UInt16)propertyValue);                      break;                  case "Int32":                      bytes2 = DInt.ToByteArray((Int32)propertyValue);                      break;                  case "UInt32":                      bytes2 = DWord.ToByteArray((UInt32)propertyValue);                      break;                  case "Double":                      bytes2 = Double.ToByteArray((double)propertyValue);                      break;                  case "Single":                      bytes2 = Single.ToByteArray((float)propertyValue);                      break;                  default:                      numBytes = ToBytes(propertyValue' bytes' numBytes);                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,SetBytesFromProperty,The following statement contains a magic number: switch (propertyValue.GetType().Name)              {                  case "Boolean":                      // get the value                      bytePos = (int)Math.Floor(numBytes);                      bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bool)propertyValue)                          bytes[bytePos] |= (byte)Math.Pow(2' bitPos);            // is true                      else                          bytes[bytePos] &= (byte)(~(byte)Math.Pow(2' bitPos));   // is false                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = (int)Math.Ceiling(numBytes);                      bytePos = (int)numBytes;                      bytes[bytePos] = (byte)propertyValue;                      numBytes++;                      break;                  case "Int16":                      bytes2 = Int.ToByteArray((Int16)propertyValue);                      break;                  case "UInt16":                      bytes2 = Word.ToByteArray((UInt16)propertyValue);                      break;                  case "Int32":                      bytes2 = DInt.ToByteArray((Int32)propertyValue);                      break;                  case "UInt32":                      bytes2 = DWord.ToByteArray((UInt32)propertyValue);                      break;                  case "Double":                      bytes2 = Double.ToByteArray((double)propertyValue);                      break;                  case "Single":                      bytes2 = Single.ToByteArray((float)propertyValue);                      break;                  default:                      numBytes = ToBytes(propertyValue' bytes' numBytes);                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,SetBytesFromProperty,The following statement contains a magic number: switch (propertyValue.GetType().Name)              {                  case "Boolean":                      // get the value                      bytePos = (int)Math.Floor(numBytes);                      bitPos = (int)((numBytes - (double)bytePos) / 0.125);                      if ((bool)propertyValue)                          bytes[bytePos] |= (byte)Math.Pow(2' bitPos);            // is true                      else                          bytes[bytePos] &= (byte)(~(byte)Math.Pow(2' bitPos));   // is false                      numBytes += 0.125;                      break;                  case "Byte":                      numBytes = (int)Math.Ceiling(numBytes);                      bytePos = (int)numBytes;                      bytes[bytePos] = (byte)propertyValue;                      numBytes++;                      break;                  case "Int16":                      bytes2 = Int.ToByteArray((Int16)propertyValue);                      break;                  case "UInt16":                      bytes2 = Word.ToByteArray((UInt16)propertyValue);                      break;                  case "Int32":                      bytes2 = DInt.ToByteArray((Int32)propertyValue);                      break;                  case "UInt32":                      bytes2 = DWord.ToByteArray((UInt32)propertyValue);                      break;                  case "Double":                      bytes2 = Double.ToByteArray((double)propertyValue);                      break;                  case "Single":                      bytes2 = Single.ToByteArray((float)propertyValue);                      break;                  default:                      numBytes = ToBytes(propertyValue' bytes' numBytes);                      break;              }
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,SetBytesFromProperty,The following statement contains a magic number: (numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0
Magic Number,S7.Net.Types,Class,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Class.cs,SetBytesFromProperty,The following statement contains a magic number: (numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0
Magic Number,S7.Net.Types,Counter,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Counter.cs,FromByteArray,The following statement contains a magic number: bytes.Length != 2
Magic Number,S7.Net.Types,Counter,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Counter.cs,FromByteArray,The following statement contains a magic number: return (UInt16)((bytes[0] << 8) | bytes[1]);
Magic Number,S7.Net.Types,Counter,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Counter.cs,ToByteArray,The following statement contains a magic number: byte[] bytes = new byte[2];
Magic Number,S7.Net.Types,Counter,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Counter.cs,ToByteArray,The following statement contains a magic number: bytes[0] = (byte)((value << 8) & 0xFF);
Magic Number,S7.Net.Types,Counter,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Counter.cs,ToArray,The following statement contains a magic number: UInt16[] values = new UInt16[bytes.Length / 2];
Magic Number,S7.Net.Types,Counter,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Counter.cs,ToArray,The following statement contains a magic number: cnt < bytes.Length / 2
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,ToArray,The following statement contains a magic number: bytes.Length % 8 != 0
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,ToArray,The following statement contains a magic number: var cnt = bytes.Length / 8;
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,ToArray,The following statement contains a magic number: var result = new System.DateTime[bytes.Length / 8];
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,ToArray,The following statement contains a magic number: result[i] = FromByteArrayImpl(new ArraySegment<byte>(bytes' i * 8' 8));
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,ToArray,The following statement contains a magic number: result[i] = FromByteArrayImpl(new ArraySegment<byte>(bytes' i * 8' 8));
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,FromByteArrayImpl,The following statement contains a magic number: bytes.Count != 8
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,FromByteArrayImpl,The following statement contains a magic number: int DecodeBcd(byte input) => 10 * (input >> 4) + (input & 0b00001111);
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,FromByteArrayImpl,The following statement contains a magic number: int DecodeBcd(byte input) => 10 * (input >> 4) + (input & 0b00001111);
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,FromByteArrayImpl,The following statement contains a magic number: return input + 2000;
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,FromByteArrayImpl,The following statement contains a magic number: input < 90
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,FromByteArrayImpl,The following statement contains a magic number: return input + 1900;
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,FromByteArrayImpl,The following statement contains a magic number: input < 100
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,FromByteArrayImpl,The following statement contains a magic number: var month = AssertRangeInclusive(DecodeBcd(bytes[1])' 1' 12' "month");
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,FromByteArrayImpl,The following statement contains a magic number: var day = AssertRangeInclusive(DecodeBcd(bytes[2])' 1' 31' "day of month");
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,FromByteArrayImpl,The following statement contains a magic number: var day = AssertRangeInclusive(DecodeBcd(bytes[2])' 1' 31' "day of month");
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,FromByteArrayImpl,The following statement contains a magic number: var hour = AssertRangeInclusive(DecodeBcd(bytes[3])' 0' 23' "hour");
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,FromByteArrayImpl,The following statement contains a magic number: var hour = AssertRangeInclusive(DecodeBcd(bytes[3])' 0' 23' "hour");
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,FromByteArrayImpl,The following statement contains a magic number: var minute = AssertRangeInclusive(DecodeBcd(bytes[4])' 0' 59' "minute");
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,FromByteArrayImpl,The following statement contains a magic number: var minute = AssertRangeInclusive(DecodeBcd(bytes[4])' 0' 59' "minute");
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,FromByteArrayImpl,The following statement contains a magic number: var second = AssertRangeInclusive(DecodeBcd(bytes[5])' 0' 59' "second");
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,FromByteArrayImpl,The following statement contains a magic number: var second = AssertRangeInclusive(DecodeBcd(bytes[5])' 0' 59' "second");
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,FromByteArrayImpl,The following statement contains a magic number: var hsec = AssertRangeInclusive(DecodeBcd(bytes[6])' 0' 99' "first two millisecond digits");
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,FromByteArrayImpl,The following statement contains a magic number: var hsec = AssertRangeInclusive(DecodeBcd(bytes[6])' 0' 99' "first two millisecond digits");
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,FromByteArrayImpl,The following statement contains a magic number: var msec = AssertRangeInclusive(bytes[7] >> 4' 0' 9' "third millisecond digit");
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,FromByteArrayImpl,The following statement contains a magic number: var msec = AssertRangeInclusive(bytes[7] >> 4' 0' 9' "third millisecond digit");
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,FromByteArrayImpl,The following statement contains a magic number: var msec = AssertRangeInclusive(bytes[7] >> 4' 0' 9' "third millisecond digit");
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,FromByteArrayImpl,The following statement contains a magic number: var dayOfWeek = AssertRangeInclusive(bytes[7] & 0b00001111' 1' 7' "day of week");
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,FromByteArrayImpl,The following statement contains a magic number: var dayOfWeek = AssertRangeInclusive(bytes[7] & 0b00001111' 1' 7' "day of week");
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,FromByteArrayImpl,The following statement contains a magic number: return new System.DateTime(year' month' day' hour' minute' second' hsec * 10 + msec);
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,ToByteArray,The following statement contains a magic number: return (byte) ((value / 10 << 4) | value % 10);
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,ToByteArray,The following statement contains a magic number: return (byte) ((value / 10 << 4) | value % 10);
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,ToByteArray,The following statement contains a magic number: return (byte) ((value / 10 << 4) | value % 10);
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,ToByteArray,The following statement contains a magic number: byte MapYear(int year) => (byte) (year < 2000 ? year - 1900 : year - 2000);
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,ToByteArray,The following statement contains a magic number: byte MapYear(int year) => (byte) (year < 2000 ? year - 1900 : year - 2000);
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,ToByteArray,The following statement contains a magic number: byte MapYear(int year) => (byte) (year < 2000 ? year - 1900 : year - 2000);
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,ToByteArray,The following statement contains a magic number: return new[]              {                  EncodeBcd(MapYear(dateTime.Year))'                  EncodeBcd(dateTime.Month)'                  EncodeBcd(dateTime.Day)'                  EncodeBcd(dateTime.Hour)'                  EncodeBcd(dateTime.Minute)'                  EncodeBcd(dateTime.Second)'                  EncodeBcd(dateTime.Millisecond / 10)'                  (byte) (dateTime.Millisecond % 10 << 4 | DayOfWeekToInt(dateTime.DayOfWeek))              };
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,ToByteArray,The following statement contains a magic number: return new[]              {                  EncodeBcd(MapYear(dateTime.Year))'                  EncodeBcd(dateTime.Month)'                  EncodeBcd(dateTime.Day)'                  EncodeBcd(dateTime.Hour)'                  EncodeBcd(dateTime.Minute)'                  EncodeBcd(dateTime.Second)'                  EncodeBcd(dateTime.Millisecond / 10)'                  (byte) (dateTime.Millisecond % 10 << 4 | DayOfWeekToInt(dateTime.DayOfWeek))              };
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,ToByteArray,The following statement contains a magic number: return new[]              {                  EncodeBcd(MapYear(dateTime.Year))'                  EncodeBcd(dateTime.Month)'                  EncodeBcd(dateTime.Day)'                  EncodeBcd(dateTime.Hour)'                  EncodeBcd(dateTime.Minute)'                  EncodeBcd(dateTime.Second)'                  EncodeBcd(dateTime.Millisecond / 10)'                  (byte) (dateTime.Millisecond % 10 << 4 | DayOfWeekToInt(dateTime.DayOfWeek))              };
Magic Number,S7.Net.Types,DateTime,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DateTime.cs,ToByteArray,The following statement contains a magic number: var bytes = new List<byte>(dateTimes.Length * 8);
Magic Number,S7.Net.Types,DInt,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DInt.cs,FromByteArray,The following statement contains a magic number: bytes.Length != 4
Magic Number,S7.Net.Types,DInt,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DInt.cs,FromByteArray,The following statement contains a magic number: return bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3];
Magic Number,S7.Net.Types,DInt,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DInt.cs,FromByteArray,The following statement contains a magic number: return bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3];
Magic Number,S7.Net.Types,DInt,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DInt.cs,FromByteArray,The following statement contains a magic number: return bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3];
Magic Number,S7.Net.Types,DInt,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DInt.cs,FromByteArray,The following statement contains a magic number: return bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3];
Magic Number,S7.Net.Types,DInt,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DInt.cs,FromByteArray,The following statement contains a magic number: return bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3];
Magic Number,S7.Net.Types,DInt,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DInt.cs,ToByteArray,The following statement contains a magic number: byte[] bytes = new byte[4];
Magic Number,S7.Net.Types,DInt,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DInt.cs,ToByteArray,The following statement contains a magic number: bytes[0] = (byte)((value >> 24) & 0xFF);
Magic Number,S7.Net.Types,DInt,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DInt.cs,ToByteArray,The following statement contains a magic number: bytes[1] = (byte)((value >> 16) & 0xFF);
Magic Number,S7.Net.Types,DInt,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DInt.cs,ToByteArray,The following statement contains a magic number: bytes[2] = (byte)((value >> 8) & 0xFF);
Magic Number,S7.Net.Types,DInt,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DInt.cs,ToByteArray,The following statement contains a magic number: bytes[2] = (byte)((value >> 8) & 0xFF);
Magic Number,S7.Net.Types,DInt,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DInt.cs,ToByteArray,The following statement contains a magic number: bytes[3] = (byte)((value) & 0xFF);
Magic Number,S7.Net.Types,DInt,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DInt.cs,ToArray,The following statement contains a magic number: Int32[] values = new Int32[bytes.Length / 4];
Magic Number,S7.Net.Types,DInt,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DInt.cs,ToArray,The following statement contains a magic number: cnt < bytes.Length / 4
Magic Number,S7.Net.Types,Double,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Double.cs,FromByteArray,The following statement contains a magic number: bytes.Length != 4
Magic Number,S7.Net.Types,Double,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Double.cs,FromByteArray,The following statement contains a magic number: bytes = new byte[] { bytes[3]' bytes[2]' bytes[1]' bytes[0] };
Magic Number,S7.Net.Types,Double,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Double.cs,FromByteArray,The following statement contains a magic number: bytes = new byte[] { bytes[3]' bytes[2]' bytes[1]' bytes[0] };
Magic Number,S7.Net.Types,Double,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: return new byte[] { bytes[3]' bytes[2]' bytes[1]' bytes[0] };
Magic Number,S7.Net.Types,Double,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: return new byte[] { bytes[3]' bytes[2]' bytes[1]' bytes[0] };
Magic Number,S7.Net.Types,Double,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Double.cs,ToArray,The following statement contains a magic number: double[] values = new double[bytes.Length / 4];
Magic Number,S7.Net.Types,Double,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Double.cs,ToArray,The following statement contains a magic number: cnt < bytes.Length / 4
Magic Number,S7.Net.Types,DWord,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DWord.cs,FromByteArray,The following statement contains a magic number: return (UInt32)(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3]);
Magic Number,S7.Net.Types,DWord,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DWord.cs,FromByteArray,The following statement contains a magic number: return (UInt32)(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3]);
Magic Number,S7.Net.Types,DWord,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DWord.cs,FromByteArray,The following statement contains a magic number: return (UInt32)(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3]);
Magic Number,S7.Net.Types,DWord,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DWord.cs,FromByteArray,The following statement contains a magic number: return (UInt32)(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3]);
Magic Number,S7.Net.Types,DWord,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DWord.cs,FromByteArray,The following statement contains a magic number: return (UInt32)(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3]);
Magic Number,S7.Net.Types,DWord,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DWord.cs,FromBytes,The following statement contains a magic number: return (UInt32)((b4 << 24) | (b3 << 16) | (b2 << 8) | b1);
Magic Number,S7.Net.Types,DWord,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DWord.cs,FromBytes,The following statement contains a magic number: return (UInt32)((b4 << 24) | (b3 << 16) | (b2 << 8) | b1);
Magic Number,S7.Net.Types,DWord,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DWord.cs,FromBytes,The following statement contains a magic number: return (UInt32)((b4 << 24) | (b3 << 16) | (b2 << 8) | b1);
Magic Number,S7.Net.Types,DWord,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DWord.cs,ToByteArray,The following statement contains a magic number: byte[] bytes = new byte[4];
Magic Number,S7.Net.Types,DWord,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DWord.cs,ToByteArray,The following statement contains a magic number: bytes[0] = (byte)((value >> 24) & 0xFF);
Magic Number,S7.Net.Types,DWord,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DWord.cs,ToByteArray,The following statement contains a magic number: bytes[1] = (byte)((value >> 16) & 0xFF);
Magic Number,S7.Net.Types,DWord,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DWord.cs,ToByteArray,The following statement contains a magic number: bytes[2] = (byte)((value >> 8) & 0xFF);
Magic Number,S7.Net.Types,DWord,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DWord.cs,ToByteArray,The following statement contains a magic number: bytes[2] = (byte)((value >> 8) & 0xFF);
Magic Number,S7.Net.Types,DWord,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DWord.cs,ToByteArray,The following statement contains a magic number: bytes[3] = (byte)((value) & 0xFF);
Magic Number,S7.Net.Types,DWord,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DWord.cs,ToArray,The following statement contains a magic number: UInt32[] values = new UInt32[bytes.Length / 4];
Magic Number,S7.Net.Types,DWord,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\DWord.cs,ToArray,The following statement contains a magic number: cnt < bytes.Length / 4
Magic Number,S7.Net.Types,Int,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Int.cs,FromByteArray,The following statement contains a magic number: bytes.Length != 2
Magic Number,S7.Net.Types,Int,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Int.cs,FromByteArray,The following statement contains a magic number: return (short)((int)(bytes[1]) | ((int)(bytes[0]) << 8));
Magic Number,S7.Net.Types,Int,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Int.cs,ToByteArray,The following statement contains a magic number: byte[] bytes = new byte[2];
Magic Number,S7.Net.Types,Int,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Int.cs,ToByteArray,The following statement contains a magic number: bytes[0] = (byte) (value >> 8 & 0xFF);
Magic Number,S7.Net.Types,Int,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Int.cs,ToByteArray,The following statement contains a magic number: byte[] bytes = new byte[value.Length * 2];
Magic Number,S7.Net.Types,Int,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Int.cs,ToByteArray,The following statement contains a magic number: bytes[bytesPos++] = (byte)((value[i] >> 8) & 0xFF);
Magic Number,S7.Net.Types,Int,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Int.cs,ToArray,The following statement contains a magic number: int shortsCount = bytes.Length / 2;
Magic Number,S7.Net.Types,Int,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Int.cs,CWord,The following statement contains a magic number: value -= 32768;
Magic Number,S7.Net.Types,Int,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Int.cs,CWord,The following statement contains a magic number: value = 32768 - value;
Magic Number,S7.Net.Types,Int,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Int.cs,CWord,The following statement contains a magic number: value > 32767
Magic Number,S7.Net.Types,Single,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Single.cs,FromByteArray,The following statement contains a magic number: bytes.Length != 4
Magic Number,S7.Net.Types,Single,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Single.cs,FromByteArray,The following statement contains a magic number: bytes = new byte[] { bytes[3]' bytes[2]' bytes[1]' bytes[0] };
Magic Number,S7.Net.Types,Single,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Single.cs,FromByteArray,The following statement contains a magic number: bytes = new byte[] { bytes[3]' bytes[2]' bytes[1]' bytes[0] };
Magic Number,S7.Net.Types,Single,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Single.cs,ToByteArray,The following statement contains a magic number: return new byte[] { bytes[3]' bytes[2]' bytes[1]' bytes[0] };
Magic Number,S7.Net.Types,Single,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Single.cs,ToByteArray,The following statement contains a magic number: return new byte[] { bytes[3]' bytes[2]' bytes[1]' bytes[0] };
Magic Number,S7.Net.Types,Single,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Single.cs,ToArray,The following statement contains a magic number: float[] values = new float[bytes.Length / 4];
Magic Number,S7.Net.Types,Single,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Single.cs,ToArray,The following statement contains a magic number: cnt < bytes.Length / 4
Magic Number,S7.Net.Types,StringEx,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\StringEx.cs,FromByteArray,The following statement contains a magic number: bytes.Length < 2
Magic Number,S7.Net.Types,StringEx,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\StringEx.cs,FromByteArray,The following statement contains a magic number: return Encoding.ASCII.GetString(bytes' 2' length);
Magic Number,S7.Net.Types,StringEx,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\StringEx.cs,ToByteArray,The following statement contains a magic number: var bytes = new byte[(length ?? 0) + 2];
Magic Number,S7.Net.Types,StringEx,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\StringEx.cs,ToByteArray,The following statement contains a magic number: bytes[1] = (byte) Encoding.ASCII.GetBytes(value' 0' length.Value' bytes' 2);
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          numBytes++;                          break;                      case "Int16":                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 2;                          break;                      case "Int32":                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "Single":                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      default:                          numBytes += GetStructSize(info.FieldType);                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          numBytes++;                          break;                      case "Int16":                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 2;                          break;                      case "Int32":                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "Single":                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      default:                          numBytes += GetStructSize(info.FieldType);                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          numBytes++;                          break;                      case "Int16":                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 2;                          break;                      case "Int32":                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "Single":                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      default:                          numBytes += GetStructSize(info.FieldType);                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          numBytes++;                          break;                      case "Int16":                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 2;                          break;                      case "Int32":                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "Single":                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      default:                          numBytes += GetStructSize(info.FieldType);                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          numBytes++;                          break;                      case "Int16":                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 2;                          break;                      case "Int32":                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "Single":                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      default:                          numBytes += GetStructSize(info.FieldType);                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          numBytes++;                          break;                      case "Int16":                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 2;                          break;                      case "Int32":                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "Single":                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      default:                          numBytes += GetStructSize(info.FieldType);                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          numBytes++;                          break;                      case "Int16":                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 2;                          break;                      case "Int32":                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "Single":                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      default:                          numBytes += GetStructSize(info.FieldType);                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          numBytes++;                          break;                      case "Int16":                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 2;                          break;                      case "Int32":                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "Single":                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      default:                          numBytes += GetStructSize(info.FieldType);                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          numBytes++;                          break;                      case "Int16":                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 2;                          break;                      case "Int32":                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "Single":                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      default:                          numBytes += GetStructSize(info.FieldType);                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          numBytes++;                          break;                      case "Int16":                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 2;                          break;                      case "Int32":                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "Single":                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      default:                          numBytes += GetStructSize(info.FieldType);                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "Int16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          ushort source = Word.FromBytes(bytes[(int)numBytes + 1]' bytes[(int)numBytes]);                          info.SetValue(structValue' source.ConvertToShort());                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Word.FromBytes(bytes[(int)numBytes + 1]'                                                                            bytes[(int)numBytes]));                          numBytes += 2;                          break;                      case "Int32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          uint sourceUInt = DWord.FromBytes(bytes[(int)numBytes + 3]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 0]);                          info.SetValue(structValue' sourceUInt.ConvertToInt());                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' DWord.FromBytes(bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3]));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Double.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      case "Single":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' Single.FromByteArray(new byte[] { bytes[(int)numBytes]'                                                                             bytes[(int)numBytes + 1]'                                                                             bytes[(int)numBytes + 2]'                                                                             bytes[(int)numBytes + 3] }));                          numBytes += 4;                          break;                      default:                          var buffer = new byte[GetStructSize(info.FieldType)];                          if (buffer.Length == 0)                              continue;                          Buffer.BlockCopy(bytes' (int)Math.Ceiling(numBytes)' buffer' 0' buffer.Length);                          info.SetValue(structValue' FromBytes(info.FieldType' buffer));                          numBytes += buffer.Length;                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bool)info.GetValue(structValue))                              bytes[bytePos] |= (byte)Math.Pow(2' bitPos);            // is true                          else                              bytes[bytePos] &= (byte)(~(byte)Math.Pow(2' bitPos));   // is false                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = (int)Math.Ceiling(numBytes);                          bytePos = (int)numBytes;                          bytes[bytePos] = (byte)info.GetValue(structValue);                          numBytes++;                          break;                      case "Int16":                          bytes2 = Int.ToByteArray((Int16)info.GetValue(structValue));                          break;                      case "UInt16":                          bytes2 = Word.ToByteArray((UInt16)info.GetValue(structValue));                          break;                      case "Int32":                          bytes2 = DInt.ToByteArray((Int32)info.GetValue(structValue));                          break;                      case "UInt32":                          bytes2 = DWord.ToByteArray((UInt32)info.GetValue(structValue));                          break;                      case "Double":                          bytes2 = Double.ToByteArray((double)info.GetValue(structValue));                          break;                      case "Single":                          bytes2 = Single.ToByteArray((float)info.GetValue(structValue));                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bool)info.GetValue(structValue))                              bytes[bytePos] |= (byte)Math.Pow(2' bitPos);            // is true                          else                              bytes[bytePos] &= (byte)(~(byte)Math.Pow(2' bitPos));   // is false                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = (int)Math.Ceiling(numBytes);                          bytePos = (int)numBytes;                          bytes[bytePos] = (byte)info.GetValue(structValue);                          numBytes++;                          break;                      case "Int16":                          bytes2 = Int.ToByteArray((Int16)info.GetValue(structValue));                          break;                      case "UInt16":                          bytes2 = Word.ToByteArray((UInt16)info.GetValue(structValue));                          break;                      case "Int32":                          bytes2 = DInt.ToByteArray((Int32)info.GetValue(structValue));                          break;                      case "UInt32":                          bytes2 = DWord.ToByteArray((UInt32)info.GetValue(structValue));                          break;                      case "Double":                          bytes2 = Double.ToByteArray((double)info.GetValue(structValue));                          break;                      case "Single":                          bytes2 = Single.ToByteArray((float)info.GetValue(structValue));                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bool)info.GetValue(structValue))                              bytes[bytePos] |= (byte)Math.Pow(2' bitPos);            // is true                          else                              bytes[bytePos] &= (byte)(~(byte)Math.Pow(2' bitPos));   // is false                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = (int)Math.Ceiling(numBytes);                          bytePos = (int)numBytes;                          bytes[bytePos] = (byte)info.GetValue(structValue);                          numBytes++;                          break;                      case "Int16":                          bytes2 = Int.ToByteArray((Int16)info.GetValue(structValue));                          break;                      case "UInt16":                          bytes2 = Word.ToByteArray((UInt16)info.GetValue(structValue));                          break;                      case "Int32":                          bytes2 = DInt.ToByteArray((Int32)info.GetValue(structValue));                          break;                      case "UInt32":                          bytes2 = DWord.ToByteArray((UInt32)info.GetValue(structValue));                          break;                      case "Double":                          bytes2 = Double.ToByteArray((double)info.GetValue(structValue));                          break;                      case "Single":                          bytes2 = Single.ToByteArray((float)info.GetValue(structValue));                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bool)info.GetValue(structValue))                              bytes[bytePos] |= (byte)Math.Pow(2' bitPos);            // is true                          else                              bytes[bytePos] &= (byte)(~(byte)Math.Pow(2' bitPos));   // is false                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = (int)Math.Ceiling(numBytes);                          bytePos = (int)numBytes;                          bytes[bytePos] = (byte)info.GetValue(structValue);                          numBytes++;                          break;                      case "Int16":                          bytes2 = Int.ToByteArray((Int16)info.GetValue(structValue));                          break;                      case "UInt16":                          bytes2 = Word.ToByteArray((UInt16)info.GetValue(structValue));                          break;                      case "Int32":                          bytes2 = DInt.ToByteArray((Int32)info.GetValue(structValue));                          break;                      case "UInt32":                          bytes2 = DWord.ToByteArray((UInt32)info.GetValue(structValue));                          break;                      case "Double":                          bytes2 = Double.ToByteArray((double)info.GetValue(structValue));                          break;                      case "Single":                          bytes2 = Single.ToByteArray((float)info.GetValue(structValue));                          break;                  }
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: (numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0
Magic Number,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: (numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0
Magic Number,S7.Net.Types,Timer,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: wert = ((bytes[0]) & 0x0F) * 100.0;
Magic Number,S7.Net.Types,Timer,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: wert += ((bytes[1] >> 4) & 0x0F) * 10.0;
Magic Number,S7.Net.Types,Timer,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: wert += ((bytes[1] >> 4) & 0x0F) * 10.0;
Magic Number,S7.Net.Types,Timer,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: switch ((bytes[0] >> 4) & 0x03)              {                  case 0:                      wert *= 0.01;                      break;                  case 1:                      wert *= 0.1;                      break;                  case 2:                      wert *= 1.0;                      break;                  case 3:                      wert *= 10.0;                      break;              }
Magic Number,S7.Net.Types,Timer,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: switch ((bytes[0] >> 4) & 0x03)              {                  case 0:                      wert *= 0.01;                      break;                  case 1:                      wert *= 0.1;                      break;                  case 2:                      wert *= 1.0;                      break;                  case 3:                      wert *= 10.0;                      break;              }
Magic Number,S7.Net.Types,Timer,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: switch ((bytes[0] >> 4) & 0x03)              {                  case 0:                      wert *= 0.01;                      break;                  case 1:                      wert *= 0.1;                      break;                  case 2:                      wert *= 1.0;                      break;                  case 3:                      wert *= 10.0;                      break;              }
Magic Number,S7.Net.Types,Timer,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: switch ((bytes[0] >> 4) & 0x03)              {                  case 0:                      wert *= 0.01;                      break;                  case 1:                      wert *= 0.1;                      break;                  case 2:                      wert *= 1.0;                      break;                  case 3:                      wert *= 10.0;                      break;              }
Magic Number,S7.Net.Types,Timer,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: switch ((bytes[0] >> 4) & 0x03)              {                  case 0:                      wert *= 0.01;                      break;                  case 1:                      wert *= 0.1;                      break;                  case 2:                      wert *= 1.0;                      break;                  case 3:                      wert *= 10.0;                      break;              }
Magic Number,S7.Net.Types,Timer,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: switch ((bytes[0] >> 4) & 0x03)              {                  case 0:                      wert *= 0.01;                      break;                  case 1:                      wert *= 0.1;                      break;                  case 2:                      wert *= 1.0;                      break;                  case 3:                      wert *= 10.0;                      break;              }
Magic Number,S7.Net.Types,Timer,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Timer.cs,ToByteArray,The following statement contains a magic number: byte[] bytes = new byte[2];
Magic Number,S7.Net.Types,Timer,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Timer.cs,ToByteArray,The following statement contains a magic number: bytes[0] = (byte)((int)value >> 8 & 0xFF);
Magic Number,S7.Net.Types,Timer,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Timer.cs,ToArray,The following statement contains a magic number: double[] values = new double[bytes.Length / 2];
Magic Number,S7.Net.Types,Timer,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Timer.cs,ToArray,The following statement contains a magic number: cnt < bytes.Length / 2
Magic Number,S7.Net.Types,Word,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Word.cs,FromByteArray,The following statement contains a magic number: bytes.Length != 2
Magic Number,S7.Net.Types,Word,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Word.cs,FromByteArray,The following statement contains a magic number: return (UInt16)((bytes[0] << 8) | bytes[1]);
Magic Number,S7.Net.Types,Word,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Word.cs,FromBytes,The following statement contains a magic number: return (UInt16)((b2 << 8) | b1);
Magic Number,S7.Net.Types,Word,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Word.cs,ToByteArray,The following statement contains a magic number: byte[] bytes = new byte[2];
Magic Number,S7.Net.Types,Word,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Word.cs,ToByteArray,The following statement contains a magic number: bytes[0] = (byte)((value>>8) & 0xFF);
Magic Number,S7.Net.Types,Word,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Word.cs,ToArray,The following statement contains a magic number: UInt16[] values = new UInt16[bytes.Length/2];
Magic Number,S7.Net.Types,Word,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Word.cs,ToArray,The following statement contains a magic number: cnt < bytes.Length/2
Missing Default,S7.Net.Types,Struct,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following switch statement is missing a default case: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bool)info.GetValue(structValue))                              bytes[bytePos] |= (byte)Math.Pow(2' bitPos);            // is true                          else                              bytes[bytePos] &= (byte)(~(byte)Math.Pow(2' bitPos));   // is false                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = (int)Math.Ceiling(numBytes);                          bytePos = (int)numBytes;                          bytes[bytePos] = (byte)info.GetValue(structValue);                          numBytes++;                          break;                      case "Int16":                          bytes2 = Int.ToByteArray((Int16)info.GetValue(structValue));                          break;                      case "UInt16":                          bytes2 = Word.ToByteArray((UInt16)info.GetValue(structValue));                          break;                      case "Int32":                          bytes2 = DInt.ToByteArray((Int32)info.GetValue(structValue));                          break;                      case "UInt32":                          bytes2 = DWord.ToByteArray((UInt32)info.GetValue(structValue));                          break;                      case "Double":                          bytes2 = Double.ToByteArray((double)info.GetValue(structValue));                          break;                      case "Single":                          bytes2 = Single.ToByteArray((float)info.GetValue(structValue));                          break;                  }
Missing Default,S7.Net.Types,Timer,D:\research\architectureSmells\repos\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following switch statement is missing a default case: switch ((bytes[0] >> 4) & 0x03)              {                  case 0:                      wert *= 0.01;                      break;                  case 1:                      wert *= 0.1;                      break;                  case 2:                      wert *= 1.0;                      break;                  case 3:                      wert *= 10.0;                      break;              }
