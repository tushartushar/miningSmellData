Implementation smell,Namespace,Class,File,Method,Description
Long Method,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The method has 143 lines of code.
Long Method,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The method has 130 lines of code.
Long Method,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The method has 146 lines of code.
Complex Method,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,Cyclomatic complexity of the method is 59
Complex Method,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,Cyclomatic complexity of the method is 48
Complex Method,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadMultipleVars,Cyclomatic complexity of the method is 9
Complex Method,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,Cyclomatic complexity of the method is 38
Complex Method,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,Cyclomatic complexity of the method is 40
Complex Method,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,Cyclomatic complexity of the method is 39
Complex Method,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,CreateReadDataRequestPackage,Cyclomatic complexity of the method is 13
Complex Method,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ParseBytes,Cyclomatic complexity of the method is 11
Complex Method,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,VarTypeToByteLength,Cyclomatic complexity of the method is 11
Complex Method,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,Cyclomatic complexity of the method is 32
Complex Method,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,Cyclomatic complexity of the method is 60
Complex Method,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,ToBytes,Cyclomatic complexity of the method is 33
Complex Method,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,Cyclomatic complexity of the method is 32
Complex Method,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,Cyclomatic complexity of the method is 58
Complex Method,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,Cyclomatic complexity of the method is 33
Complex Method,S7.Net.Types,Timer,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,Cyclomatic complexity of the method is 12
Long Parameter List,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The method has 5 parameters.
Long Statement,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadMultipleVars,The length of the statement  "			package.Add (CreateReadDataRequestPackage (dataItem.DataType' dataItem.DB' dataItem.StartByteAdr' VarTypeToByteLength (dataItem.VarType' dataItem.Count))); " is 155.
Long Statement,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,WriteBytes,The length of the statement  "		ErrorCode lastError = WriteBytesWithASingleRequest (dataType' db' startByteAdr + localIndex' value.Skip (localIndex).Take (maxToWrite).ToArray ()); " is 147.
Long Statement,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The length of the statement  "					throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit)); " is 133.
Long Statement,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The length of the statement  "				throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType)); " is 187.
Long Statement,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The length of the statement  "				throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation)); " is 182.
Long Statement,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The length of the statement  "				throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit)); " is 133.
Long Statement,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The length of the statement  "		LastErrorString = "The variable'" + variable + "' could not be parsed. Please check the syntax and try again.\nException: " + exc.Message; " is 138.
Long Statement,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The length of the statement  "			uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]); " is 143.
Long Statement,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The length of the statement  "			property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null); " is 160.
Long Statement,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The length of the statement  "			uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]); " is 143.
Long Statement,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The length of the statement  "			info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])); " is 150.
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,BinStringToInt32,The following statement contains a magic number: for (cnt = txt.Length - 1; cnt >= 0; cnt += -1) {  	if (int.Parse (txt.Substring (cnt' 1)) == 1) {  		ret += (int)(Math.Pow (2' (txt.Length - 1 - cnt)));  	}  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,BinStringToInt32,The following statement contains a magic number: if (int.Parse (txt.Substring (cnt' 1)) == 1) {  	ret += (int)(Math.Pow (2' (txt.Length - 1 - cnt)));  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,BinStringToInt32,The following statement contains a magic number: ret += (int)(Math.Pow (2' (txt.Length - 1 - cnt)));  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,BinStringToByte,The following statement contains a magic number: if (txt.Length == 8) {  	for (cnt = 7; cnt >= 0; cnt += -1) {  		if (int.Parse (txt.Substring (cnt' 1)) == 1) {  			ret += (int)(Math.Pow (2' (txt.Length - 1 - cnt)));  		}  	}  	return (byte)ret;  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,BinStringToByte,The following statement contains a magic number: if (txt.Length == 8) {  	for (cnt = 7; cnt >= 0; cnt += -1) {  		if (int.Parse (txt.Substring (cnt' 1)) == 1) {  			ret += (int)(Math.Pow (2' (txt.Length - 1 - cnt)));  		}  	}  	return (byte)ret;  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,BinStringToByte,The following statement contains a magic number: if (txt.Length == 8) {  	for (cnt = 7; cnt >= 0; cnt += -1) {  		if (int.Parse (txt.Substring (cnt' 1)) == 1) {  			ret += (int)(Math.Pow (2' (txt.Length - 1 - cnt)));  		}  	}  	return (byte)ret;  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,BinStringToByte,The following statement contains a magic number: for (cnt = 7; cnt >= 0; cnt += -1) {  	if (int.Parse (txt.Substring (cnt' 1)) == 1) {  		ret += (int)(Math.Pow (2' (txt.Length - 1 - cnt)));  	}  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,BinStringToByte,The following statement contains a magic number: for (cnt = 7; cnt >= 0; cnt += -1) {  	if (int.Parse (txt.Substring (cnt' 1)) == 1) {  		ret += (int)(Math.Pow (2' (txt.Length - 1 - cnt)));  	}  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,BinStringToByte,The following statement contains a magic number: cnt = 7
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,BinStringToByte,The following statement contains a magic number: if (int.Parse (txt.Substring (cnt' 1)) == 1) {  	ret += (int)(Math.Pow (2' (txt.Length - 1 - cnt)));  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,BinStringToByte,The following statement contains a magic number: ret += (int)(Math.Pow (2' (txt.Length - 1 - cnt)));  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: try {  	if (value.GetType ().Name.IndexOf ("[]") < 0) {  		// ist nur ein Wert  		switch (value.GetType ().Name) {  		case "Byte":  			x = 7;  			longValue = (long)((byte)value);  			break;  		case "Int16":  			x = 15;  			longValue = (long)((Int16)value);  			break;  		case "Int32":  			x = 31;  			longValue = (long)((Int32)value);  			break;  		case "Int64":  			x = 63;  			longValue = (long)((Int64)value);  			break;  		default:  			throw new Exception ();  		}  		for (cnt = x; cnt >= 0; cnt += -1) {  			if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  		}  	} else {  		// ist ein Array  		switch (value.GetType ().Name) {  		case "Byte[]":  			x = 7;  			byte[] ByteArr = (byte[])value;  			for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int16[]":  			x = 15;  			Int16[] Int16Arr = (Int16[])value;  			for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int32[]":  			x = 31;  			Int32[] Int32Arr = (Int32[])value;  			for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int64[]":  			x = 63;  			byte[] Int64Arr = (byte[])value;  			for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		default:  			throw new Exception ();  		}  	}  	return txt;  } catch {  	return "";  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: try {  	if (value.GetType ().Name.IndexOf ("[]") < 0) {  		// ist nur ein Wert  		switch (value.GetType ().Name) {  		case "Byte":  			x = 7;  			longValue = (long)((byte)value);  			break;  		case "Int16":  			x = 15;  			longValue = (long)((Int16)value);  			break;  		case "Int32":  			x = 31;  			longValue = (long)((Int32)value);  			break;  		case "Int64":  			x = 63;  			longValue = (long)((Int64)value);  			break;  		default:  			throw new Exception ();  		}  		for (cnt = x; cnt >= 0; cnt += -1) {  			if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  		}  	} else {  		// ist ein Array  		switch (value.GetType ().Name) {  		case "Byte[]":  			x = 7;  			byte[] ByteArr = (byte[])value;  			for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int16[]":  			x = 15;  			Int16[] Int16Arr = (Int16[])value;  			for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int32[]":  			x = 31;  			Int32[] Int32Arr = (Int32[])value;  			for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int64[]":  			x = 63;  			byte[] Int64Arr = (byte[])value;  			for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		default:  			throw new Exception ();  		}  	}  	return txt;  } catch {  	return "";  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: try {  	if (value.GetType ().Name.IndexOf ("[]") < 0) {  		// ist nur ein Wert  		switch (value.GetType ().Name) {  		case "Byte":  			x = 7;  			longValue = (long)((byte)value);  			break;  		case "Int16":  			x = 15;  			longValue = (long)((Int16)value);  			break;  		case "Int32":  			x = 31;  			longValue = (long)((Int32)value);  			break;  		case "Int64":  			x = 63;  			longValue = (long)((Int64)value);  			break;  		default:  			throw new Exception ();  		}  		for (cnt = x; cnt >= 0; cnt += -1) {  			if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  		}  	} else {  		// ist ein Array  		switch (value.GetType ().Name) {  		case "Byte[]":  			x = 7;  			byte[] ByteArr = (byte[])value;  			for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int16[]":  			x = 15;  			Int16[] Int16Arr = (Int16[])value;  			for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int32[]":  			x = 31;  			Int32[] Int32Arr = (Int32[])value;  			for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int64[]":  			x = 63;  			byte[] Int64Arr = (byte[])value;  			for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		default:  			throw new Exception ();  		}  	}  	return txt;  } catch {  	return "";  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: try {  	if (value.GetType ().Name.IndexOf ("[]") < 0) {  		// ist nur ein Wert  		switch (value.GetType ().Name) {  		case "Byte":  			x = 7;  			longValue = (long)((byte)value);  			break;  		case "Int16":  			x = 15;  			longValue = (long)((Int16)value);  			break;  		case "Int32":  			x = 31;  			longValue = (long)((Int32)value);  			break;  		case "Int64":  			x = 63;  			longValue = (long)((Int64)value);  			break;  		default:  			throw new Exception ();  		}  		for (cnt = x; cnt >= 0; cnt += -1) {  			if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  		}  	} else {  		// ist ein Array  		switch (value.GetType ().Name) {  		case "Byte[]":  			x = 7;  			byte[] ByteArr = (byte[])value;  			for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int16[]":  			x = 15;  			Int16[] Int16Arr = (Int16[])value;  			for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int32[]":  			x = 31;  			Int32[] Int32Arr = (Int32[])value;  			for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int64[]":  			x = 63;  			byte[] Int64Arr = (byte[])value;  			for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		default:  			throw new Exception ();  		}  	}  	return txt;  } catch {  	return "";  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: try {  	if (value.GetType ().Name.IndexOf ("[]") < 0) {  		// ist nur ein Wert  		switch (value.GetType ().Name) {  		case "Byte":  			x = 7;  			longValue = (long)((byte)value);  			break;  		case "Int16":  			x = 15;  			longValue = (long)((Int16)value);  			break;  		case "Int32":  			x = 31;  			longValue = (long)((Int32)value);  			break;  		case "Int64":  			x = 63;  			longValue = (long)((Int64)value);  			break;  		default:  			throw new Exception ();  		}  		for (cnt = x; cnt >= 0; cnt += -1) {  			if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  		}  	} else {  		// ist ein Array  		switch (value.GetType ().Name) {  		case "Byte[]":  			x = 7;  			byte[] ByteArr = (byte[])value;  			for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int16[]":  			x = 15;  			Int16[] Int16Arr = (Int16[])value;  			for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int32[]":  			x = 31;  			Int32[] Int32Arr = (Int32[])value;  			for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int64[]":  			x = 63;  			byte[] Int64Arr = (byte[])value;  			for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		default:  			throw new Exception ();  		}  	}  	return txt;  } catch {  	return "";  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: try {  	if (value.GetType ().Name.IndexOf ("[]") < 0) {  		// ist nur ein Wert  		switch (value.GetType ().Name) {  		case "Byte":  			x = 7;  			longValue = (long)((byte)value);  			break;  		case "Int16":  			x = 15;  			longValue = (long)((Int16)value);  			break;  		case "Int32":  			x = 31;  			longValue = (long)((Int32)value);  			break;  		case "Int64":  			x = 63;  			longValue = (long)((Int64)value);  			break;  		default:  			throw new Exception ();  		}  		for (cnt = x; cnt >= 0; cnt += -1) {  			if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  		}  	} else {  		// ist ein Array  		switch (value.GetType ().Name) {  		case "Byte[]":  			x = 7;  			byte[] ByteArr = (byte[])value;  			for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int16[]":  			x = 15;  			Int16[] Int16Arr = (Int16[])value;  			for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int32[]":  			x = 31;  			Int32[] Int32Arr = (Int32[])value;  			for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int64[]":  			x = 63;  			byte[] Int64Arr = (byte[])value;  			for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		default:  			throw new Exception ();  		}  	}  	return txt;  } catch {  	return "";  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: try {  	if (value.GetType ().Name.IndexOf ("[]") < 0) {  		// ist nur ein Wert  		switch (value.GetType ().Name) {  		case "Byte":  			x = 7;  			longValue = (long)((byte)value);  			break;  		case "Int16":  			x = 15;  			longValue = (long)((Int16)value);  			break;  		case "Int32":  			x = 31;  			longValue = (long)((Int32)value);  			break;  		case "Int64":  			x = 63;  			longValue = (long)((Int64)value);  			break;  		default:  			throw new Exception ();  		}  		for (cnt = x; cnt >= 0; cnt += -1) {  			if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  		}  	} else {  		// ist ein Array  		switch (value.GetType ().Name) {  		case "Byte[]":  			x = 7;  			byte[] ByteArr = (byte[])value;  			for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int16[]":  			x = 15;  			Int16[] Int16Arr = (Int16[])value;  			for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int32[]":  			x = 31;  			Int32[] Int32Arr = (Int32[])value;  			for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int64[]":  			x = 63;  			byte[] Int64Arr = (byte[])value;  			for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		default:  			throw new Exception ();  		}  	}  	return txt;  } catch {  	return "";  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: try {  	if (value.GetType ().Name.IndexOf ("[]") < 0) {  		// ist nur ein Wert  		switch (value.GetType ().Name) {  		case "Byte":  			x = 7;  			longValue = (long)((byte)value);  			break;  		case "Int16":  			x = 15;  			longValue = (long)((Int16)value);  			break;  		case "Int32":  			x = 31;  			longValue = (long)((Int32)value);  			break;  		case "Int64":  			x = 63;  			longValue = (long)((Int64)value);  			break;  		default:  			throw new Exception ();  		}  		for (cnt = x; cnt >= 0; cnt += -1) {  			if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  		}  	} else {  		// ist ein Array  		switch (value.GetType ().Name) {  		case "Byte[]":  			x = 7;  			byte[] ByteArr = (byte[])value;  			for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int16[]":  			x = 15;  			Int16[] Int16Arr = (Int16[])value;  			for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int32[]":  			x = 31;  			Int32[] Int32Arr = (Int32[])value;  			for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int64[]":  			x = 63;  			byte[] Int64Arr = (byte[])value;  			for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		default:  			throw new Exception ();  		}  	}  	return txt;  } catch {  	return "";  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: try {  	if (value.GetType ().Name.IndexOf ("[]") < 0) {  		// ist nur ein Wert  		switch (value.GetType ().Name) {  		case "Byte":  			x = 7;  			longValue = (long)((byte)value);  			break;  		case "Int16":  			x = 15;  			longValue = (long)((Int16)value);  			break;  		case "Int32":  			x = 31;  			longValue = (long)((Int32)value);  			break;  		case "Int64":  			x = 63;  			longValue = (long)((Int64)value);  			break;  		default:  			throw new Exception ();  		}  		for (cnt = x; cnt >= 0; cnt += -1) {  			if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  		}  	} else {  		// ist ein Array  		switch (value.GetType ().Name) {  		case "Byte[]":  			x = 7;  			byte[] ByteArr = (byte[])value;  			for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int16[]":  			x = 15;  			Int16[] Int16Arr = (Int16[])value;  			for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int32[]":  			x = 31;  			Int32[] Int32Arr = (Int32[])value;  			for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int64[]":  			x = 63;  			byte[] Int64Arr = (byte[])value;  			for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		default:  			throw new Exception ();  		}  	}  	return txt;  } catch {  	return "";  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: try {  	if (value.GetType ().Name.IndexOf ("[]") < 0) {  		// ist nur ein Wert  		switch (value.GetType ().Name) {  		case "Byte":  			x = 7;  			longValue = (long)((byte)value);  			break;  		case "Int16":  			x = 15;  			longValue = (long)((Int16)value);  			break;  		case "Int32":  			x = 31;  			longValue = (long)((Int32)value);  			break;  		case "Int64":  			x = 63;  			longValue = (long)((Int64)value);  			break;  		default:  			throw new Exception ();  		}  		for (cnt = x; cnt >= 0; cnt += -1) {  			if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  		}  	} else {  		// ist ein Array  		switch (value.GetType ().Name) {  		case "Byte[]":  			x = 7;  			byte[] ByteArr = (byte[])value;  			for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int16[]":  			x = 15;  			Int16[] Int16Arr = (Int16[])value;  			for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int32[]":  			x = 31;  			Int32[] Int32Arr = (Int32[])value;  			for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int64[]":  			x = 63;  			byte[] Int64Arr = (byte[])value;  			for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		default:  			throw new Exception ();  		}  	}  	return txt;  } catch {  	return "";  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: try {  	if (value.GetType ().Name.IndexOf ("[]") < 0) {  		// ist nur ein Wert  		switch (value.GetType ().Name) {  		case "Byte":  			x = 7;  			longValue = (long)((byte)value);  			break;  		case "Int16":  			x = 15;  			longValue = (long)((Int16)value);  			break;  		case "Int32":  			x = 31;  			longValue = (long)((Int32)value);  			break;  		case "Int64":  			x = 63;  			longValue = (long)((Int64)value);  			break;  		default:  			throw new Exception ();  		}  		for (cnt = x; cnt >= 0; cnt += -1) {  			if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  		}  	} else {  		// ist ein Array  		switch (value.GetType ().Name) {  		case "Byte[]":  			x = 7;  			byte[] ByteArr = (byte[])value;  			for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int16[]":  			x = 15;  			Int16[] Int16Arr = (Int16[])value;  			for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int32[]":  			x = 31;  			Int32[] Int32Arr = (Int32[])value;  			for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int64[]":  			x = 63;  			byte[] Int64Arr = (byte[])value;  			for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		default:  			throw new Exception ();  		}  	}  	return txt;  } catch {  	return "";  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: try {  	if (value.GetType ().Name.IndexOf ("[]") < 0) {  		// ist nur ein Wert  		switch (value.GetType ().Name) {  		case "Byte":  			x = 7;  			longValue = (long)((byte)value);  			break;  		case "Int16":  			x = 15;  			longValue = (long)((Int16)value);  			break;  		case "Int32":  			x = 31;  			longValue = (long)((Int32)value);  			break;  		case "Int64":  			x = 63;  			longValue = (long)((Int64)value);  			break;  		default:  			throw new Exception ();  		}  		for (cnt = x; cnt >= 0; cnt += -1) {  			if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  		}  	} else {  		// ist ein Array  		switch (value.GetType ().Name) {  		case "Byte[]":  			x = 7;  			byte[] ByteArr = (byte[])value;  			for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int16[]":  			x = 15;  			Int16[] Int16Arr = (Int16[])value;  			for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int32[]":  			x = 31;  			Int32[] Int32Arr = (Int32[])value;  			for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int64[]":  			x = 63;  			byte[] Int64Arr = (byte[])value;  			for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		default:  			throw new Exception ();  		}  	}  	return txt;  } catch {  	return "";  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: try {  	if (value.GetType ().Name.IndexOf ("[]") < 0) {  		// ist nur ein Wert  		switch (value.GetType ().Name) {  		case "Byte":  			x = 7;  			longValue = (long)((byte)value);  			break;  		case "Int16":  			x = 15;  			longValue = (long)((Int16)value);  			break;  		case "Int32":  			x = 31;  			longValue = (long)((Int32)value);  			break;  		case "Int64":  			x = 63;  			longValue = (long)((Int64)value);  			break;  		default:  			throw new Exception ();  		}  		for (cnt = x; cnt >= 0; cnt += -1) {  			if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  		}  	} else {  		// ist ein Array  		switch (value.GetType ().Name) {  		case "Byte[]":  			x = 7;  			byte[] ByteArr = (byte[])value;  			for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int16[]":  			x = 15;  			Int16[] Int16Arr = (Int16[])value;  			for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int32[]":  			x = 31;  			Int32[] Int32Arr = (Int32[])value;  			for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		case "Int64[]":  			x = 63;  			byte[] Int64Arr = (byte[])value;  			for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  				for (cnt = x; cnt >= 0; cnt += -1)  					if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  						txt += "1";  					else  						txt += "0";  			}  			break;  		default:  			throw new Exception ();  		}  	}  	return txt;  } catch {  	return "";  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: if (value.GetType ().Name.IndexOf ("[]") < 0) {  	// ist nur ein Wert  	switch (value.GetType ().Name) {  	case "Byte":  		x = 7;  		longValue = (long)((byte)value);  		break;  	case "Int16":  		x = 15;  		longValue = (long)((Int16)value);  		break;  	case "Int32":  		x = 31;  		longValue = (long)((Int32)value);  		break;  	case "Int64":  		x = 63;  		longValue = (long)((Int64)value);  		break;  	default:  		throw new Exception ();  	}  	for (cnt = x; cnt >= 0; cnt += -1) {  		if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  			txt += "1";  		else  			txt += "0";  	}  } else {  	// ist ein Array  	switch (value.GetType ().Name) {  	case "Byte[]":  		x = 7;  		byte[] ByteArr = (byte[])value;  		for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int16[]":  		x = 15;  		Int16[] Int16Arr = (Int16[])value;  		for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int32[]":  		x = 31;  		Int32[] Int32Arr = (Int32[])value;  		for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int64[]":  		x = 63;  		byte[] Int64Arr = (byte[])value;  		for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	default:  		throw new Exception ();  	}  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: if (value.GetType ().Name.IndexOf ("[]") < 0) {  	// ist nur ein Wert  	switch (value.GetType ().Name) {  	case "Byte":  		x = 7;  		longValue = (long)((byte)value);  		break;  	case "Int16":  		x = 15;  		longValue = (long)((Int16)value);  		break;  	case "Int32":  		x = 31;  		longValue = (long)((Int32)value);  		break;  	case "Int64":  		x = 63;  		longValue = (long)((Int64)value);  		break;  	default:  		throw new Exception ();  	}  	for (cnt = x; cnt >= 0; cnt += -1) {  		if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  			txt += "1";  		else  			txt += "0";  	}  } else {  	// ist ein Array  	switch (value.GetType ().Name) {  	case "Byte[]":  		x = 7;  		byte[] ByteArr = (byte[])value;  		for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int16[]":  		x = 15;  		Int16[] Int16Arr = (Int16[])value;  		for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int32[]":  		x = 31;  		Int32[] Int32Arr = (Int32[])value;  		for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int64[]":  		x = 63;  		byte[] Int64Arr = (byte[])value;  		for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	default:  		throw new Exception ();  	}  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: if (value.GetType ().Name.IndexOf ("[]") < 0) {  	// ist nur ein Wert  	switch (value.GetType ().Name) {  	case "Byte":  		x = 7;  		longValue = (long)((byte)value);  		break;  	case "Int16":  		x = 15;  		longValue = (long)((Int16)value);  		break;  	case "Int32":  		x = 31;  		longValue = (long)((Int32)value);  		break;  	case "Int64":  		x = 63;  		longValue = (long)((Int64)value);  		break;  	default:  		throw new Exception ();  	}  	for (cnt = x; cnt >= 0; cnt += -1) {  		if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  			txt += "1";  		else  			txt += "0";  	}  } else {  	// ist ein Array  	switch (value.GetType ().Name) {  	case "Byte[]":  		x = 7;  		byte[] ByteArr = (byte[])value;  		for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int16[]":  		x = 15;  		Int16[] Int16Arr = (Int16[])value;  		for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int32[]":  		x = 31;  		Int32[] Int32Arr = (Int32[])value;  		for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int64[]":  		x = 63;  		byte[] Int64Arr = (byte[])value;  		for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	default:  		throw new Exception ();  	}  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: if (value.GetType ().Name.IndexOf ("[]") < 0) {  	// ist nur ein Wert  	switch (value.GetType ().Name) {  	case "Byte":  		x = 7;  		longValue = (long)((byte)value);  		break;  	case "Int16":  		x = 15;  		longValue = (long)((Int16)value);  		break;  	case "Int32":  		x = 31;  		longValue = (long)((Int32)value);  		break;  	case "Int64":  		x = 63;  		longValue = (long)((Int64)value);  		break;  	default:  		throw new Exception ();  	}  	for (cnt = x; cnt >= 0; cnt += -1) {  		if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  			txt += "1";  		else  			txt += "0";  	}  } else {  	// ist ein Array  	switch (value.GetType ().Name) {  	case "Byte[]":  		x = 7;  		byte[] ByteArr = (byte[])value;  		for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int16[]":  		x = 15;  		Int16[] Int16Arr = (Int16[])value;  		for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int32[]":  		x = 31;  		Int32[] Int32Arr = (Int32[])value;  		for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int64[]":  		x = 63;  		byte[] Int64Arr = (byte[])value;  		for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	default:  		throw new Exception ();  	}  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: if (value.GetType ().Name.IndexOf ("[]") < 0) {  	// ist nur ein Wert  	switch (value.GetType ().Name) {  	case "Byte":  		x = 7;  		longValue = (long)((byte)value);  		break;  	case "Int16":  		x = 15;  		longValue = (long)((Int16)value);  		break;  	case "Int32":  		x = 31;  		longValue = (long)((Int32)value);  		break;  	case "Int64":  		x = 63;  		longValue = (long)((Int64)value);  		break;  	default:  		throw new Exception ();  	}  	for (cnt = x; cnt >= 0; cnt += -1) {  		if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  			txt += "1";  		else  			txt += "0";  	}  } else {  	// ist ein Array  	switch (value.GetType ().Name) {  	case "Byte[]":  		x = 7;  		byte[] ByteArr = (byte[])value;  		for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int16[]":  		x = 15;  		Int16[] Int16Arr = (Int16[])value;  		for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int32[]":  		x = 31;  		Int32[] Int32Arr = (Int32[])value;  		for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int64[]":  		x = 63;  		byte[] Int64Arr = (byte[])value;  		for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	default:  		throw new Exception ();  	}  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: if (value.GetType ().Name.IndexOf ("[]") < 0) {  	// ist nur ein Wert  	switch (value.GetType ().Name) {  	case "Byte":  		x = 7;  		longValue = (long)((byte)value);  		break;  	case "Int16":  		x = 15;  		longValue = (long)((Int16)value);  		break;  	case "Int32":  		x = 31;  		longValue = (long)((Int32)value);  		break;  	case "Int64":  		x = 63;  		longValue = (long)((Int64)value);  		break;  	default:  		throw new Exception ();  	}  	for (cnt = x; cnt >= 0; cnt += -1) {  		if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  			txt += "1";  		else  			txt += "0";  	}  } else {  	// ist ein Array  	switch (value.GetType ().Name) {  	case "Byte[]":  		x = 7;  		byte[] ByteArr = (byte[])value;  		for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int16[]":  		x = 15;  		Int16[] Int16Arr = (Int16[])value;  		for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int32[]":  		x = 31;  		Int32[] Int32Arr = (Int32[])value;  		for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int64[]":  		x = 63;  		byte[] Int64Arr = (byte[])value;  		for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	default:  		throw new Exception ();  	}  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: if (value.GetType ().Name.IndexOf ("[]") < 0) {  	// ist nur ein Wert  	switch (value.GetType ().Name) {  	case "Byte":  		x = 7;  		longValue = (long)((byte)value);  		break;  	case "Int16":  		x = 15;  		longValue = (long)((Int16)value);  		break;  	case "Int32":  		x = 31;  		longValue = (long)((Int32)value);  		break;  	case "Int64":  		x = 63;  		longValue = (long)((Int64)value);  		break;  	default:  		throw new Exception ();  	}  	for (cnt = x; cnt >= 0; cnt += -1) {  		if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  			txt += "1";  		else  			txt += "0";  	}  } else {  	// ist ein Array  	switch (value.GetType ().Name) {  	case "Byte[]":  		x = 7;  		byte[] ByteArr = (byte[])value;  		for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int16[]":  		x = 15;  		Int16[] Int16Arr = (Int16[])value;  		for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int32[]":  		x = 31;  		Int32[] Int32Arr = (Int32[])value;  		for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int64[]":  		x = 63;  		byte[] Int64Arr = (byte[])value;  		for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	default:  		throw new Exception ();  	}  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: if (value.GetType ().Name.IndexOf ("[]") < 0) {  	// ist nur ein Wert  	switch (value.GetType ().Name) {  	case "Byte":  		x = 7;  		longValue = (long)((byte)value);  		break;  	case "Int16":  		x = 15;  		longValue = (long)((Int16)value);  		break;  	case "Int32":  		x = 31;  		longValue = (long)((Int32)value);  		break;  	case "Int64":  		x = 63;  		longValue = (long)((Int64)value);  		break;  	default:  		throw new Exception ();  	}  	for (cnt = x; cnt >= 0; cnt += -1) {  		if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  			txt += "1";  		else  			txt += "0";  	}  } else {  	// ist ein Array  	switch (value.GetType ().Name) {  	case "Byte[]":  		x = 7;  		byte[] ByteArr = (byte[])value;  		for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int16[]":  		x = 15;  		Int16[] Int16Arr = (Int16[])value;  		for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int32[]":  		x = 31;  		Int32[] Int32Arr = (Int32[])value;  		for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int64[]":  		x = 63;  		byte[] Int64Arr = (byte[])value;  		for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	default:  		throw new Exception ();  	}  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: if (value.GetType ().Name.IndexOf ("[]") < 0) {  	// ist nur ein Wert  	switch (value.GetType ().Name) {  	case "Byte":  		x = 7;  		longValue = (long)((byte)value);  		break;  	case "Int16":  		x = 15;  		longValue = (long)((Int16)value);  		break;  	case "Int32":  		x = 31;  		longValue = (long)((Int32)value);  		break;  	case "Int64":  		x = 63;  		longValue = (long)((Int64)value);  		break;  	default:  		throw new Exception ();  	}  	for (cnt = x; cnt >= 0; cnt += -1) {  		if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  			txt += "1";  		else  			txt += "0";  	}  } else {  	// ist ein Array  	switch (value.GetType ().Name) {  	case "Byte[]":  		x = 7;  		byte[] ByteArr = (byte[])value;  		for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int16[]":  		x = 15;  		Int16[] Int16Arr = (Int16[])value;  		for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int32[]":  		x = 31;  		Int32[] Int32Arr = (Int32[])value;  		for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int64[]":  		x = 63;  		byte[] Int64Arr = (byte[])value;  		for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	default:  		throw new Exception ();  	}  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: if (value.GetType ().Name.IndexOf ("[]") < 0) {  	// ist nur ein Wert  	switch (value.GetType ().Name) {  	case "Byte":  		x = 7;  		longValue = (long)((byte)value);  		break;  	case "Int16":  		x = 15;  		longValue = (long)((Int16)value);  		break;  	case "Int32":  		x = 31;  		longValue = (long)((Int32)value);  		break;  	case "Int64":  		x = 63;  		longValue = (long)((Int64)value);  		break;  	default:  		throw new Exception ();  	}  	for (cnt = x; cnt >= 0; cnt += -1) {  		if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  			txt += "1";  		else  			txt += "0";  	}  } else {  	// ist ein Array  	switch (value.GetType ().Name) {  	case "Byte[]":  		x = 7;  		byte[] ByteArr = (byte[])value;  		for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int16[]":  		x = 15;  		Int16[] Int16Arr = (Int16[])value;  		for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int32[]":  		x = 31;  		Int32[] Int32Arr = (Int32[])value;  		for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int64[]":  		x = 63;  		byte[] Int64Arr = (byte[])value;  		for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	default:  		throw new Exception ();  	}  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: if (value.GetType ().Name.IndexOf ("[]") < 0) {  	// ist nur ein Wert  	switch (value.GetType ().Name) {  	case "Byte":  		x = 7;  		longValue = (long)((byte)value);  		break;  	case "Int16":  		x = 15;  		longValue = (long)((Int16)value);  		break;  	case "Int32":  		x = 31;  		longValue = (long)((Int32)value);  		break;  	case "Int64":  		x = 63;  		longValue = (long)((Int64)value);  		break;  	default:  		throw new Exception ();  	}  	for (cnt = x; cnt >= 0; cnt += -1) {  		if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  			txt += "1";  		else  			txt += "0";  	}  } else {  	// ist ein Array  	switch (value.GetType ().Name) {  	case "Byte[]":  		x = 7;  		byte[] ByteArr = (byte[])value;  		for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int16[]":  		x = 15;  		Int16[] Int16Arr = (Int16[])value;  		for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int32[]":  		x = 31;  		Int32[] Int32Arr = (Int32[])value;  		for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int64[]":  		x = 63;  		byte[] Int64Arr = (byte[])value;  		for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	default:  		throw new Exception ();  	}  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: if (value.GetType ().Name.IndexOf ("[]") < 0) {  	// ist nur ein Wert  	switch (value.GetType ().Name) {  	case "Byte":  		x = 7;  		longValue = (long)((byte)value);  		break;  	case "Int16":  		x = 15;  		longValue = (long)((Int16)value);  		break;  	case "Int32":  		x = 31;  		longValue = (long)((Int32)value);  		break;  	case "Int64":  		x = 63;  		longValue = (long)((Int64)value);  		break;  	default:  		throw new Exception ();  	}  	for (cnt = x; cnt >= 0; cnt += -1) {  		if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  			txt += "1";  		else  			txt += "0";  	}  } else {  	// ist ein Array  	switch (value.GetType ().Name) {  	case "Byte[]":  		x = 7;  		byte[] ByteArr = (byte[])value;  		for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int16[]":  		x = 15;  		Int16[] Int16Arr = (Int16[])value;  		for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int32[]":  		x = 31;  		Int32[] Int32Arr = (Int32[])value;  		for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int64[]":  		x = 63;  		byte[] Int64Arr = (byte[])value;  		for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	default:  		throw new Exception ();  	}  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: if (value.GetType ().Name.IndexOf ("[]") < 0) {  	// ist nur ein Wert  	switch (value.GetType ().Name) {  	case "Byte":  		x = 7;  		longValue = (long)((byte)value);  		break;  	case "Int16":  		x = 15;  		longValue = (long)((Int16)value);  		break;  	case "Int32":  		x = 31;  		longValue = (long)((Int32)value);  		break;  	case "Int64":  		x = 63;  		longValue = (long)((Int64)value);  		break;  	default:  		throw new Exception ();  	}  	for (cnt = x; cnt >= 0; cnt += -1) {  		if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  			txt += "1";  		else  			txt += "0";  	}  } else {  	// ist ein Array  	switch (value.GetType ().Name) {  	case "Byte[]":  		x = 7;  		byte[] ByteArr = (byte[])value;  		for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int16[]":  		x = 15;  		Int16[] Int16Arr = (Int16[])value;  		for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int32[]":  		x = 31;  		Int32[] Int32Arr = (Int32[])value;  		for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	case "Int64[]":  		x = 63;  		byte[] Int64Arr = (byte[])value;  		for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  			for (cnt = x; cnt >= 0; cnt += -1)  				if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  					txt += "1";  				else  					txt += "0";  		}  		break;  	default:  		throw new Exception ();  	}  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: switch (value.GetType ().Name) {  case "Byte":  	x = 7;  	longValue = (long)((byte)value);  	break;  case "Int16":  	x = 15;  	longValue = (long)((Int16)value);  	break;  case "Int32":  	x = 31;  	longValue = (long)((Int32)value);  	break;  case "Int64":  	x = 63;  	longValue = (long)((Int64)value);  	break;  default:  	throw new Exception ();  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: switch (value.GetType ().Name) {  case "Byte":  	x = 7;  	longValue = (long)((byte)value);  	break;  case "Int16":  	x = 15;  	longValue = (long)((Int16)value);  	break;  case "Int32":  	x = 31;  	longValue = (long)((Int32)value);  	break;  case "Int64":  	x = 63;  	longValue = (long)((Int64)value);  	break;  default:  	throw new Exception ();  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: switch (value.GetType ().Name) {  case "Byte":  	x = 7;  	longValue = (long)((byte)value);  	break;  case "Int16":  	x = 15;  	longValue = (long)((Int16)value);  	break;  case "Int32":  	x = 31;  	longValue = (long)((Int32)value);  	break;  case "Int64":  	x = 63;  	longValue = (long)((Int64)value);  	break;  default:  	throw new Exception ();  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: switch (value.GetType ().Name) {  case "Byte":  	x = 7;  	longValue = (long)((byte)value);  	break;  case "Int16":  	x = 15;  	longValue = (long)((Int16)value);  	break;  case "Int32":  	x = 31;  	longValue = (long)((Int32)value);  	break;  case "Int64":  	x = 63;  	longValue = (long)((Int64)value);  	break;  default:  	throw new Exception ();  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: x = 7;  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: x = 15;  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: x = 31;  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: x = 63;  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: for (cnt = x; cnt >= 0; cnt += -1) {  	if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  		txt += "1";  	else  		txt += "0";  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: if (((Int64)longValue & (Int64)Math.Pow (2' cnt)) > 0)  	txt += "1";  else  	txt += "0";  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: switch (value.GetType ().Name) {  case "Byte[]":  	x = 7;  	byte[] ByteArr = (byte[])value;  	for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  case "Int16[]":  	x = 15;  	Int16[] Int16Arr = (Int16[])value;  	for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  case "Int32[]":  	x = 31;  	Int32[] Int32Arr = (Int32[])value;  	for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  case "Int64[]":  	x = 63;  	byte[] Int64Arr = (byte[])value;  	for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  default:  	throw new Exception ();  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: switch (value.GetType ().Name) {  case "Byte[]":  	x = 7;  	byte[] ByteArr = (byte[])value;  	for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  case "Int16[]":  	x = 15;  	Int16[] Int16Arr = (Int16[])value;  	for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  case "Int32[]":  	x = 31;  	Int32[] Int32Arr = (Int32[])value;  	for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  case "Int64[]":  	x = 63;  	byte[] Int64Arr = (byte[])value;  	for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  default:  	throw new Exception ();  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: switch (value.GetType ().Name) {  case "Byte[]":  	x = 7;  	byte[] ByteArr = (byte[])value;  	for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  case "Int16[]":  	x = 15;  	Int16[] Int16Arr = (Int16[])value;  	for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  case "Int32[]":  	x = 31;  	Int32[] Int32Arr = (Int32[])value;  	for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  case "Int64[]":  	x = 63;  	byte[] Int64Arr = (byte[])value;  	for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  default:  	throw new Exception ();  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: switch (value.GetType ().Name) {  case "Byte[]":  	x = 7;  	byte[] ByteArr = (byte[])value;  	for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  case "Int16[]":  	x = 15;  	Int16[] Int16Arr = (Int16[])value;  	for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  case "Int32[]":  	x = 31;  	Int32[] Int32Arr = (Int32[])value;  	for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  case "Int64[]":  	x = 63;  	byte[] Int64Arr = (byte[])value;  	for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  default:  	throw new Exception ();  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: switch (value.GetType ().Name) {  case "Byte[]":  	x = 7;  	byte[] ByteArr = (byte[])value;  	for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  case "Int16[]":  	x = 15;  	Int16[] Int16Arr = (Int16[])value;  	for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  case "Int32[]":  	x = 31;  	Int32[] Int32Arr = (Int32[])value;  	for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  case "Int64[]":  	x = 63;  	byte[] Int64Arr = (byte[])value;  	for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  default:  	throw new Exception ();  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: switch (value.GetType ().Name) {  case "Byte[]":  	x = 7;  	byte[] ByteArr = (byte[])value;  	for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  case "Int16[]":  	x = 15;  	Int16[] Int16Arr = (Int16[])value;  	for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  case "Int32[]":  	x = 31;  	Int32[] Int32Arr = (Int32[])value;  	for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  case "Int64[]":  	x = 63;  	byte[] Int64Arr = (byte[])value;  	for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  default:  	throw new Exception ();  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: switch (value.GetType ().Name) {  case "Byte[]":  	x = 7;  	byte[] ByteArr = (byte[])value;  	for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  case "Int16[]":  	x = 15;  	Int16[] Int16Arr = (Int16[])value;  	for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  case "Int32[]":  	x = 31;  	Int32[] Int32Arr = (Int32[])value;  	for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  case "Int64[]":  	x = 63;  	byte[] Int64Arr = (byte[])value;  	for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  default:  	throw new Exception ();  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: switch (value.GetType ().Name) {  case "Byte[]":  	x = 7;  	byte[] ByteArr = (byte[])value;  	for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  case "Int16[]":  	x = 15;  	Int16[] Int16Arr = (Int16[])value;  	for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  case "Int32[]":  	x = 31;  	Int32[] Int32Arr = (Int32[])value;  	for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  case "Int64[]":  	x = 63;  	byte[] Int64Arr = (byte[])value;  	for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  		for (cnt = x; cnt >= 0; cnt += -1)  			if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  				txt += "1";  			else  				txt += "0";  	}  	break;  default:  	throw new Exception ();  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: x = 7;  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: for (cnt2 = 0; cnt2 <= ByteArr.Length - 1; cnt2++) {  	for (cnt = x; cnt >= 0; cnt += -1)  		if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  			txt += "1";  		else  			txt += "0";  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: for (cnt = x; cnt >= 0; cnt += -1)  	if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  		txt += "1";  	else  		txt += "0";  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: if ((ByteArr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  	txt += "1";  else  	txt += "0";  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: x = 15;  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: for (cnt2 = 0; cnt2 <= Int16Arr.Length - 1; cnt2++) {  	for (cnt = x; cnt >= 0; cnt += -1)  		if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  			txt += "1";  		else  			txt += "0";  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: for (cnt = x; cnt >= 0; cnt += -1)  	if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  		txt += "1";  	else  		txt += "0";  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: if ((Int16Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  	txt += "1";  else  	txt += "0";  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: x = 31;  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: for (cnt2 = 0; cnt2 <= Int32Arr.Length - 1; cnt2++) {  	for (cnt = x; cnt >= 0; cnt += -1)  		if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  			txt += "1";  		else  			txt += "0";  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: for (cnt = x; cnt >= 0; cnt += -1)  	if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  		txt += "1";  	else  		txt += "0";  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: if ((Int32Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  	txt += "1";  else  	txt += "0";  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: x = 63;  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: for (cnt2 = 0; cnt2 <= Int64Arr.Length - 1; cnt2++) {  	for (cnt = x; cnt >= 0; cnt += -1)  		if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  			txt += "1";  		else  			txt += "0";  }  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: for (cnt = x; cnt >= 0; cnt += -1)  	if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  		txt += "1";  	else  		txt += "0";  
Magic Number,S7.Net,Conversion,F:\newReposMay17\killnine_s7netplus\S7.Net\Conversion.cs,ValToBinString,The following statement contains a magic number: if ((Int64Arr [cnt2] & (byte)Math.Pow (2' cnt)) > 0)  	txt += "1";  else  	txt += "0";  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	_mSocket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp);  	_mSocket.SetSocketOption (SocketOptionLevel.Socket' SocketOptionName.ReceiveTimeout' 1000);  	_mSocket.SetSocketOption (SocketOptionLevel.Socket' SocketOptionName.SendTimeout' 1000);  	IPEndPoint server = new IPEndPoint (IPAddress.Parse (IP)' 102);  	_mSocket.Connect (server);  } catch (Exception ex) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = ex.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	_mSocket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp);  	_mSocket.SetSocketOption (SocketOptionLevel.Socket' SocketOptionName.ReceiveTimeout' 1000);  	_mSocket.SetSocketOption (SocketOptionLevel.Socket' SocketOptionName.SendTimeout' 1000);  	IPEndPoint server = new IPEndPoint (IPAddress.Parse (IP)' 102);  	_mSocket.Connect (server);  } catch (Exception ex) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = ex.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	_mSocket = new Socket (AddressFamily.InterNetwork' SocketType.Stream' ProtocolType.Tcp);  	_mSocket.SetSocketOption (SocketOptionLevel.Socket' SocketOptionName.ReceiveTimeout' 1000);  	_mSocket.SetSocketOption (SocketOptionLevel.Socket' SocketOptionName.SendTimeout' 1000);  	IPEndPoint server = new IPEndPoint (IPAddress.Parse (IP)' 102);  	_mSocket.Connect (server);  } catch (Exception ex) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = ex.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: _mSocket.SetSocketOption (SocketOptionLevel.Socket' SocketOptionName.ReceiveTimeout' 1000);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: _mSocket.SetSocketOption (SocketOptionLevel.Socket' SocketOptionName.SendTimeout' 1000);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: try {  	byte[] bSend1 =  {  		3'  		0'  		0'  		22'  		17'  		224'  		0'  		0'  		0'  		46'  		0'  		193'  		2'  		1'  		0'  		194'  		2'  		3'  		0'  		192'  		1'  		9  	};  	switch (CPU) {  	case CpuType.S7200:  		//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 16;  		bSend1 [14] = 0;  		//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 16;  		bSend1 [18] = 0;  		break;  	case CpuType.S71200:  	case CpuType.S7300:  		//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S7400:  		//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 1;  		bSend1 [14] = 0;  		//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	case CpuType.S71500:  		// Eigener Tsap  		bSend1 [11] = 193;  		bSend1 [12] = 2;  		bSend1 [13] = 0x10;  		bSend1 [14] = 0x2;  		// Fredmer Tsap  		bSend1 [15] = 194;  		bSend1 [16] = 2;  		bSend1 [17] = 0x3;  		bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  		break;  	default:  		return ErrorCode.WrongCPU_Type;  	}  	_mSocket.Send (bSend1' 22' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	byte[] bsend2 =  {  		3'  		0'  		0'  		25'  		2'  		240'  		128'  		50'  		1'  		0'  		0'  		255'  		255'  		0'  		8'  		0'  		0'  		240'  		0'  		0'  		3'  		0'  		3'  		1'  		0  	};  	_mSocket.Send (bsend2' 25' SocketFlags.None);  	if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.ConnectionError;  	LastErrorString = "Couldn't establish the connection to " + IP + ".\nMessage: " + exc.Message;  	return ErrorCode.ConnectionError;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: switch (CPU) {  case CpuType.S7200:  	//S7200: Chr(193) & Chr(2) & Chr(16) & Chr(0) 'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 16;  	bSend1 [14] = 0;  	//S7200: Chr(194) & Chr(2) & Chr(16) & Chr(0) 'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 16;  	bSend1 [18] = 0;  	break;  case CpuType.S71200:  case CpuType.S7300:  	//S7300: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7300: Chr(194) & Chr(2) & Chr(3) & Chr(2)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S7400:  	//S7400: Chr(193) & Chr(2) & Chr(1) & Chr(0)  'Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 1;  	bSend1 [14] = 0;  	//S7400: Chr(194) & Chr(2) & Chr(3) & Chr(3)  'Fremder Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  case CpuType.S71500:  	// Eigener Tsap  	bSend1 [11] = 193;  	bSend1 [12] = 2;  	bSend1 [13] = 0x10;  	bSend1 [14] = 0x2;  	// Fredmer Tsap  	bSend1 [15] = 194;  	bSend1 [16] = 2;  	bSend1 [17] = 0x3;  	bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  	break;  default:  	return ErrorCode.WrongCPU_Type;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [11] = 193;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [11] = 193;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [12] = 2;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [12] = 2;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [13] = 16;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [13] = 16;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [14] = 0;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [15] = 194;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [15] = 194;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [16] = 2;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [16] = 2;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [17] = 16;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [17] = 16;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [18] = 0;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [11] = 193;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [11] = 193;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [12] = 2;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [12] = 2;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [13] = 1;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [14] = 0;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [15] = 194;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [15] = 194;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [16] = 2;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [16] = 2;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [17] = 3;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [17] = 3;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [11] = 193;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [11] = 193;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [12] = 2;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [12] = 2;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [13] = 1;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [14] = 0;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [15] = 194;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [15] = 194;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [16] = 2;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [16] = 2;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [17] = 3;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [17] = 3;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [11] = 193;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [11] = 193;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [12] = 2;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [12] = 2;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [13] = 0x10;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [14] = 0x2;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [15] = 194;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [15] = 194;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [16] = 2;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [16] = 2;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [17] = 0x3;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: bSend1 [18] = (byte)(Rack * 2 * 16 + Slot);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: _mSocket.Send (bSend1' 22' SocketFlags.None);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  	throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: if (_mSocket.Receive (bReceive' 22' SocketFlags.None) != 22) {  	throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: _mSocket.Send (bsend2' 25' SocketFlags.None);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  	throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Open,The following statement contains a magic number: if (_mSocket.Receive (bReceive' 27' SocketFlags.None) != 27) {  	throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadMultipleVars,The following statement contains a magic number: if (dataItems.Count > 20)  	throw new Exception ("Too many vars requested");  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadMultipleVars,The following statement contains a magic number: if (cntBytes > 222)  	throw new Exception ("Too many bytes requested");  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadMultipleVars,The following statement contains a magic number: try {  	// first create the header  	int packageSize = 19 + (dataItems.Count * 12);  	Types.ByteArray package = new ByteArray (packageSize);  	package.Add (ReadHeaderPackage (dataItems.Count));  	// package.Add(0x02);  // datenart  	foreach (var dataItem in dataItems) {  		package.Add (CreateReadDataRequestPackage (dataItem.DataType' dataItem.DB' dataItem.StartByteAdr' VarTypeToByteLength (dataItem.VarType' dataItem.Count)));  	}  	_mSocket.Send (package.array' package.array.Length' SocketFlags.None);  	byte[] bReceive = new byte[512];  	int numReceived = _mSocket.Receive (bReceive' 512' SocketFlags.None);  	if (bReceive [21] != 0xff)  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	int offset = 25;  	foreach (var dataItem in dataItems) {  		int byteCnt = VarTypeToByteLength (dataItem.VarType' dataItem.Count);  		byte[] bytes = new byte[byteCnt];  		for (int i = 0; i < byteCnt; i++) {  			bytes [i] = bReceive [i + offset];  		}  		offset += byteCnt + 4;  		dataItem.Value = ParseBytes (dataItem.VarType' bytes' dataItem.Count);  	}  } catch (SocketException socketException) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = socketException.Message;  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = exc.Message;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadMultipleVars,The following statement contains a magic number: try {  	// first create the header  	int packageSize = 19 + (dataItems.Count * 12);  	Types.ByteArray package = new ByteArray (packageSize);  	package.Add (ReadHeaderPackage (dataItems.Count));  	// package.Add(0x02);  // datenart  	foreach (var dataItem in dataItems) {  		package.Add (CreateReadDataRequestPackage (dataItem.DataType' dataItem.DB' dataItem.StartByteAdr' VarTypeToByteLength (dataItem.VarType' dataItem.Count)));  	}  	_mSocket.Send (package.array' package.array.Length' SocketFlags.None);  	byte[] bReceive = new byte[512];  	int numReceived = _mSocket.Receive (bReceive' 512' SocketFlags.None);  	if (bReceive [21] != 0xff)  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	int offset = 25;  	foreach (var dataItem in dataItems) {  		int byteCnt = VarTypeToByteLength (dataItem.VarType' dataItem.Count);  		byte[] bytes = new byte[byteCnt];  		for (int i = 0; i < byteCnt; i++) {  			bytes [i] = bReceive [i + offset];  		}  		offset += byteCnt + 4;  		dataItem.Value = ParseBytes (dataItem.VarType' bytes' dataItem.Count);  	}  } catch (SocketException socketException) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = socketException.Message;  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = exc.Message;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadMultipleVars,The following statement contains a magic number: try {  	// first create the header  	int packageSize = 19 + (dataItems.Count * 12);  	Types.ByteArray package = new ByteArray (packageSize);  	package.Add (ReadHeaderPackage (dataItems.Count));  	// package.Add(0x02);  // datenart  	foreach (var dataItem in dataItems) {  		package.Add (CreateReadDataRequestPackage (dataItem.DataType' dataItem.DB' dataItem.StartByteAdr' VarTypeToByteLength (dataItem.VarType' dataItem.Count)));  	}  	_mSocket.Send (package.array' package.array.Length' SocketFlags.None);  	byte[] bReceive = new byte[512];  	int numReceived = _mSocket.Receive (bReceive' 512' SocketFlags.None);  	if (bReceive [21] != 0xff)  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	int offset = 25;  	foreach (var dataItem in dataItems) {  		int byteCnt = VarTypeToByteLength (dataItem.VarType' dataItem.Count);  		byte[] bytes = new byte[byteCnt];  		for (int i = 0; i < byteCnt; i++) {  			bytes [i] = bReceive [i + offset];  		}  		offset += byteCnt + 4;  		dataItem.Value = ParseBytes (dataItem.VarType' bytes' dataItem.Count);  	}  } catch (SocketException socketException) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = socketException.Message;  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = exc.Message;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadMultipleVars,The following statement contains a magic number: try {  	// first create the header  	int packageSize = 19 + (dataItems.Count * 12);  	Types.ByteArray package = new ByteArray (packageSize);  	package.Add (ReadHeaderPackage (dataItems.Count));  	// package.Add(0x02);  // datenart  	foreach (var dataItem in dataItems) {  		package.Add (CreateReadDataRequestPackage (dataItem.DataType' dataItem.DB' dataItem.StartByteAdr' VarTypeToByteLength (dataItem.VarType' dataItem.Count)));  	}  	_mSocket.Send (package.array' package.array.Length' SocketFlags.None);  	byte[] bReceive = new byte[512];  	int numReceived = _mSocket.Receive (bReceive' 512' SocketFlags.None);  	if (bReceive [21] != 0xff)  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	int offset = 25;  	foreach (var dataItem in dataItems) {  		int byteCnt = VarTypeToByteLength (dataItem.VarType' dataItem.Count);  		byte[] bytes = new byte[byteCnt];  		for (int i = 0; i < byteCnt; i++) {  			bytes [i] = bReceive [i + offset];  		}  		offset += byteCnt + 4;  		dataItem.Value = ParseBytes (dataItem.VarType' bytes' dataItem.Count);  	}  } catch (SocketException socketException) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = socketException.Message;  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = exc.Message;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadMultipleVars,The following statement contains a magic number: try {  	// first create the header  	int packageSize = 19 + (dataItems.Count * 12);  	Types.ByteArray package = new ByteArray (packageSize);  	package.Add (ReadHeaderPackage (dataItems.Count));  	// package.Add(0x02);  // datenart  	foreach (var dataItem in dataItems) {  		package.Add (CreateReadDataRequestPackage (dataItem.DataType' dataItem.DB' dataItem.StartByteAdr' VarTypeToByteLength (dataItem.VarType' dataItem.Count)));  	}  	_mSocket.Send (package.array' package.array.Length' SocketFlags.None);  	byte[] bReceive = new byte[512];  	int numReceived = _mSocket.Receive (bReceive' 512' SocketFlags.None);  	if (bReceive [21] != 0xff)  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	int offset = 25;  	foreach (var dataItem in dataItems) {  		int byteCnt = VarTypeToByteLength (dataItem.VarType' dataItem.Count);  		byte[] bytes = new byte[byteCnt];  		for (int i = 0; i < byteCnt; i++) {  			bytes [i] = bReceive [i + offset];  		}  		offset += byteCnt + 4;  		dataItem.Value = ParseBytes (dataItem.VarType' bytes' dataItem.Count);  	}  } catch (SocketException socketException) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = socketException.Message;  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = exc.Message;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadMultipleVars,The following statement contains a magic number: try {  	// first create the header  	int packageSize = 19 + (dataItems.Count * 12);  	Types.ByteArray package = new ByteArray (packageSize);  	package.Add (ReadHeaderPackage (dataItems.Count));  	// package.Add(0x02);  // datenart  	foreach (var dataItem in dataItems) {  		package.Add (CreateReadDataRequestPackage (dataItem.DataType' dataItem.DB' dataItem.StartByteAdr' VarTypeToByteLength (dataItem.VarType' dataItem.Count)));  	}  	_mSocket.Send (package.array' package.array.Length' SocketFlags.None);  	byte[] bReceive = new byte[512];  	int numReceived = _mSocket.Receive (bReceive' 512' SocketFlags.None);  	if (bReceive [21] != 0xff)  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	int offset = 25;  	foreach (var dataItem in dataItems) {  		int byteCnt = VarTypeToByteLength (dataItem.VarType' dataItem.Count);  		byte[] bytes = new byte[byteCnt];  		for (int i = 0; i < byteCnt; i++) {  			bytes [i] = bReceive [i + offset];  		}  		offset += byteCnt + 4;  		dataItem.Value = ParseBytes (dataItem.VarType' bytes' dataItem.Count);  	}  } catch (SocketException socketException) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = socketException.Message;  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = exc.Message;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadMultipleVars,The following statement contains a magic number: try {  	// first create the header  	int packageSize = 19 + (dataItems.Count * 12);  	Types.ByteArray package = new ByteArray (packageSize);  	package.Add (ReadHeaderPackage (dataItems.Count));  	// package.Add(0x02);  // datenart  	foreach (var dataItem in dataItems) {  		package.Add (CreateReadDataRequestPackage (dataItem.DataType' dataItem.DB' dataItem.StartByteAdr' VarTypeToByteLength (dataItem.VarType' dataItem.Count)));  	}  	_mSocket.Send (package.array' package.array.Length' SocketFlags.None);  	byte[] bReceive = new byte[512];  	int numReceived = _mSocket.Receive (bReceive' 512' SocketFlags.None);  	if (bReceive [21] != 0xff)  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	int offset = 25;  	foreach (var dataItem in dataItems) {  		int byteCnt = VarTypeToByteLength (dataItem.VarType' dataItem.Count);  		byte[] bytes = new byte[byteCnt];  		for (int i = 0; i < byteCnt; i++) {  			bytes [i] = bReceive [i + offset];  		}  		offset += byteCnt + 4;  		dataItem.Value = ParseBytes (dataItem.VarType' bytes' dataItem.Count);  	}  } catch (SocketException socketException) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = socketException.Message;  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = exc.Message;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadMultipleVars,The following statement contains a magic number: if (bReceive [21] != 0xff)  	throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadMultipleVars,The following statement contains a magic number: foreach (var dataItem in dataItems) {  	int byteCnt = VarTypeToByteLength (dataItem.VarType' dataItem.Count);  	byte[] bytes = new byte[byteCnt];  	for (int i = 0; i < byteCnt; i++) {  		bytes [i] = bReceive [i + offset];  	}  	offset += byteCnt + 4;  	dataItem.Value = ParseBytes (dataItem.VarType' bytes' dataItem.Count);  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadMultipleVars,The following statement contains a magic number: offset += byteCnt + 4;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadBytes,The following statement contains a magic number: while (count > 0) {  	var maxToRead = (int)Math.Min (count' 200);  	byte[] bytes = ReadBytesWithASingleRequest (dataType' db' index' maxToRead);  	if (bytes == null)  		return resultBytes.ToArray ();  	resultBytes.AddRange (bytes);  	count -= maxToRead;  	index += maxToRead;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  			return obj;  		case "DBW":  			UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  			return objI;  		case "DBD":  			UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  			return objU;  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7)  				throw new Exception ();  			byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			objBoolArray = new BitArray (new byte[] {  				obj2  			});  			return objBoolArray [mBit];  		default:  			throw new Exception ();  		}  	case "EB":  		// Input byte  		objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "EW":  		// Input word  		objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "ED":  		// Input double-word  		objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "AB":  		// Output byte  		objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "AW":  		// Output word  		objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "AD":  		// Output double-word  		objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "MB":  		// Memory byte  		objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "MW":  		// Memory word  		objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "MD":  		// Memory double-word  		objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  			return objDouble;  		case "Z":  		case "C":  			// Counter  			objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  			return objUInt16;  		default:  			throw new Exception ();  		}  		string txt2 = txt.Substring (1);  		if (txt2.IndexOf (".") == -1)  			throw new Exception ();  		mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  		mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  		if (mBit > 7)  			throw new Exception ();  		var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj3  		});  		return objBoolArray [mBit];  	}  } catch {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be read. Please check the syntax and try again.";  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  			return obj;  		case "DBW":  			UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  			return objI;  		case "DBD":  			UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  			return objU;  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7)  				throw new Exception ();  			byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			objBoolArray = new BitArray (new byte[] {  				obj2  			});  			return objBoolArray [mBit];  		default:  			throw new Exception ();  		}  	case "EB":  		// Input byte  		objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "EW":  		// Input word  		objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "ED":  		// Input double-word  		objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "AB":  		// Output byte  		objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "AW":  		// Output word  		objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "AD":  		// Output double-word  		objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "MB":  		// Memory byte  		objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "MW":  		// Memory word  		objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "MD":  		// Memory double-word  		objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  			return objDouble;  		case "Z":  		case "C":  			// Counter  			objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  			return objUInt16;  		default:  			throw new Exception ();  		}  		string txt2 = txt.Substring (1);  		if (txt2.IndexOf (".") == -1)  			throw new Exception ();  		mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  		mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  		if (mBit > 7)  			throw new Exception ();  		var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj3  		});  		return objBoolArray [mBit];  	}  } catch {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be read. Please check the syntax and try again.";  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  			return obj;  		case "DBW":  			UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  			return objI;  		case "DBD":  			UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  			return objU;  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7)  				throw new Exception ();  			byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			objBoolArray = new BitArray (new byte[] {  				obj2  			});  			return objBoolArray [mBit];  		default:  			throw new Exception ();  		}  	case "EB":  		// Input byte  		objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "EW":  		// Input word  		objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "ED":  		// Input double-word  		objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "AB":  		// Output byte  		objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "AW":  		// Output word  		objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "AD":  		// Output double-word  		objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "MB":  		// Memory byte  		objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "MW":  		// Memory word  		objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "MD":  		// Memory double-word  		objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  			return objDouble;  		case "Z":  		case "C":  			// Counter  			objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  			return objUInt16;  		default:  			throw new Exception ();  		}  		string txt2 = txt.Substring (1);  		if (txt2.IndexOf (".") == -1)  			throw new Exception ();  		mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  		mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  		if (mBit > 7)  			throw new Exception ();  		var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj3  		});  		return objBoolArray [mBit];  	}  } catch {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be read. Please check the syntax and try again.";  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  			return obj;  		case "DBW":  			UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  			return objI;  		case "DBD":  			UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  			return objU;  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7)  				throw new Exception ();  			byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			objBoolArray = new BitArray (new byte[] {  				obj2  			});  			return objBoolArray [mBit];  		default:  			throw new Exception ();  		}  	case "EB":  		// Input byte  		objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "EW":  		// Input word  		objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "ED":  		// Input double-word  		objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "AB":  		// Output byte  		objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "AW":  		// Output word  		objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "AD":  		// Output double-word  		objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "MB":  		// Memory byte  		objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "MW":  		// Memory word  		objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "MD":  		// Memory double-word  		objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  			return objDouble;  		case "Z":  		case "C":  			// Counter  			objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  			return objUInt16;  		default:  			throw new Exception ();  		}  		string txt2 = txt.Substring (1);  		if (txt2.IndexOf (".") == -1)  			throw new Exception ();  		mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  		mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  		if (mBit > 7)  			throw new Exception ();  		var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj3  		});  		return objBoolArray [mBit];  	}  } catch {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be read. Please check the syntax and try again.";  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  			return obj;  		case "DBW":  			UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  			return objI;  		case "DBD":  			UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  			return objU;  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7)  				throw new Exception ();  			byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			objBoolArray = new BitArray (new byte[] {  				obj2  			});  			return objBoolArray [mBit];  		default:  			throw new Exception ();  		}  	case "EB":  		// Input byte  		objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "EW":  		// Input word  		objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "ED":  		// Input double-word  		objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "AB":  		// Output byte  		objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "AW":  		// Output word  		objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "AD":  		// Output double-word  		objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "MB":  		// Memory byte  		objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "MW":  		// Memory word  		objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "MD":  		// Memory double-word  		objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  			return objDouble;  		case "Z":  		case "C":  			// Counter  			objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  			return objUInt16;  		default:  			throw new Exception ();  		}  		string txt2 = txt.Substring (1);  		if (txt2.IndexOf (".") == -1)  			throw new Exception ();  		mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  		mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  		if (mBit > 7)  			throw new Exception ();  		var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj3  		});  		return objBoolArray [mBit];  	}  } catch {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be read. Please check the syntax and try again.";  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  			return obj;  		case "DBW":  			UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  			return objI;  		case "DBD":  			UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  			return objU;  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7)  				throw new Exception ();  			byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			objBoolArray = new BitArray (new byte[] {  				obj2  			});  			return objBoolArray [mBit];  		default:  			throw new Exception ();  		}  	case "EB":  		// Input byte  		objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "EW":  		// Input word  		objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "ED":  		// Input double-word  		objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "AB":  		// Output byte  		objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "AW":  		// Output word  		objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "AD":  		// Output double-word  		objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "MB":  		// Memory byte  		objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "MW":  		// Memory word  		objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "MD":  		// Memory double-word  		objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  			return objDouble;  		case "Z":  		case "C":  			// Counter  			objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  			return objUInt16;  		default:  			throw new Exception ();  		}  		string txt2 = txt.Substring (1);  		if (txt2.IndexOf (".") == -1)  			throw new Exception ();  		mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  		mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  		if (mBit > 7)  			throw new Exception ();  		var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj3  		});  		return objBoolArray [mBit];  	}  } catch {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be read. Please check the syntax and try again.";  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  			return obj;  		case "DBW":  			UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  			return objI;  		case "DBD":  			UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  			return objU;  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7)  				throw new Exception ();  			byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			objBoolArray = new BitArray (new byte[] {  				obj2  			});  			return objBoolArray [mBit];  		default:  			throw new Exception ();  		}  	case "EB":  		// Input byte  		objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "EW":  		// Input word  		objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "ED":  		// Input double-word  		objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "AB":  		// Output byte  		objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "AW":  		// Output word  		objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "AD":  		// Output double-word  		objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "MB":  		// Memory byte  		objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "MW":  		// Memory word  		objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "MD":  		// Memory double-word  		objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  			return objDouble;  		case "Z":  		case "C":  			// Counter  			objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  			return objUInt16;  		default:  			throw new Exception ();  		}  		string txt2 = txt.Substring (1);  		if (txt2.IndexOf (".") == -1)  			throw new Exception ();  		mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  		mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  		if (mBit > 7)  			throw new Exception ();  		var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj3  		});  		return objBoolArray [mBit];  	}  } catch {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be read. Please check the syntax and try again.";  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  			return obj;  		case "DBW":  			UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  			return objI;  		case "DBD":  			UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  			return objU;  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7)  				throw new Exception ();  			byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			objBoolArray = new BitArray (new byte[] {  				obj2  			});  			return objBoolArray [mBit];  		default:  			throw new Exception ();  		}  	case "EB":  		// Input byte  		objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "EW":  		// Input word  		objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "ED":  		// Input double-word  		objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "AB":  		// Output byte  		objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "AW":  		// Output word  		objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "AD":  		// Output double-word  		objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "MB":  		// Memory byte  		objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "MW":  		// Memory word  		objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "MD":  		// Memory double-word  		objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  			return objDouble;  		case "Z":  		case "C":  			// Counter  			objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  			return objUInt16;  		default:  			throw new Exception ();  		}  		string txt2 = txt.Substring (1);  		if (txt2.IndexOf (".") == -1)  			throw new Exception ();  		mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  		mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  		if (mBit > 7)  			throw new Exception ();  		var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj3  		});  		return objBoolArray [mBit];  	}  } catch {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be read. Please check the syntax and try again.";  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  			return obj;  		case "DBW":  			UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  			return objI;  		case "DBD":  			UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  			return objU;  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7)  				throw new Exception ();  			byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			objBoolArray = new BitArray (new byte[] {  				obj2  			});  			return objBoolArray [mBit];  		default:  			throw new Exception ();  		}  	case "EB":  		// Input byte  		objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "EW":  		// Input word  		objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "ED":  		// Input double-word  		objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "AB":  		// Output byte  		objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "AW":  		// Output word  		objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "AD":  		// Output double-word  		objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "MB":  		// Memory byte  		objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "MW":  		// Memory word  		objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "MD":  		// Memory double-word  		objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  			return objDouble;  		case "Z":  		case "C":  			// Counter  			objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  			return objUInt16;  		default:  			throw new Exception ();  		}  		string txt2 = txt.Substring (1);  		if (txt2.IndexOf (".") == -1)  			throw new Exception ();  		mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  		mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  		if (mBit > 7)  			throw new Exception ();  		var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj3  		});  		return objBoolArray [mBit];  	}  } catch {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be read. Please check the syntax and try again.";  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  			return obj;  		case "DBW":  			UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  			return objI;  		case "DBD":  			UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  			return objU;  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7)  				throw new Exception ();  			byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			objBoolArray = new BitArray (new byte[] {  				obj2  			});  			return objBoolArray [mBit];  		default:  			throw new Exception ();  		}  	case "EB":  		// Input byte  		objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "EW":  		// Input word  		objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "ED":  		// Input double-word  		objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "AB":  		// Output byte  		objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "AW":  		// Output word  		objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "AD":  		// Output double-word  		objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "MB":  		// Memory byte  		objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "MW":  		// Memory word  		objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "MD":  		// Memory double-word  		objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  			return objDouble;  		case "Z":  		case "C":  			// Counter  			objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  			return objUInt16;  		default:  			throw new Exception ();  		}  		string txt2 = txt.Substring (1);  		if (txt2.IndexOf (".") == -1)  			throw new Exception ();  		mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  		mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  		if (mBit > 7)  			throw new Exception ();  		var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj3  		});  		return objBoolArray [mBit];  	}  } catch {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be read. Please check the syntax and try again.";  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  			return obj;  		case "DBW":  			UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  			return objI;  		case "DBD":  			UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  			return objU;  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7)  				throw new Exception ();  			byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			objBoolArray = new BitArray (new byte[] {  				obj2  			});  			return objBoolArray [mBit];  		default:  			throw new Exception ();  		}  	case "EB":  		// Input byte  		objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "EW":  		// Input word  		objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "ED":  		// Input double-word  		objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "AB":  		// Output byte  		objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "AW":  		// Output word  		objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "AD":  		// Output double-word  		objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "MB":  		// Memory byte  		objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "MW":  		// Memory word  		objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "MD":  		// Memory double-word  		objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  			return objDouble;  		case "Z":  		case "C":  			// Counter  			objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  			return objUInt16;  		default:  			throw new Exception ();  		}  		string txt2 = txt.Substring (1);  		if (txt2.IndexOf (".") == -1)  			throw new Exception ();  		mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  		mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  		if (mBit > 7)  			throw new Exception ();  		var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj3  		});  		return objBoolArray [mBit];  	}  } catch {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be read. Please check the syntax and try again.";  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  			return obj;  		case "DBW":  			UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  			return objI;  		case "DBD":  			UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  			return objU;  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7)  				throw new Exception ();  			byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			objBoolArray = new BitArray (new byte[] {  				obj2  			});  			return objBoolArray [mBit];  		default:  			throw new Exception ();  		}  	case "EB":  		// Input byte  		objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "EW":  		// Input word  		objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "ED":  		// Input double-word  		objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "AB":  		// Output byte  		objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "AW":  		// Output word  		objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "AD":  		// Output double-word  		objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "MB":  		// Memory byte  		objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "MW":  		// Memory word  		objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "MD":  		// Memory double-word  		objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  			return objDouble;  		case "Z":  		case "C":  			// Counter  			objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  			return objUInt16;  		default:  			throw new Exception ();  		}  		string txt2 = txt.Substring (1);  		if (txt2.IndexOf (".") == -1)  			throw new Exception ();  		mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  		mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  		if (mBit > 7)  			throw new Exception ();  		var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj3  		});  		return objBoolArray [mBit];  	}  } catch {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be read. Please check the syntax and try again.";  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  			return obj;  		case "DBW":  			UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  			return objI;  		case "DBD":  			UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  			return objU;  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7)  				throw new Exception ();  			byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			objBoolArray = new BitArray (new byte[] {  				obj2  			});  			return objBoolArray [mBit];  		default:  			throw new Exception ();  		}  	case "EB":  		// Input byte  		objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "EW":  		// Input word  		objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "ED":  		// Input double-word  		objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "AB":  		// Output byte  		objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "AW":  		// Output word  		objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "AD":  		// Output double-word  		objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "MB":  		// Memory byte  		objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "MW":  		// Memory word  		objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "MD":  		// Memory double-word  		objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  			return objDouble;  		case "Z":  		case "C":  			// Counter  			objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  			return objUInt16;  		default:  			throw new Exception ();  		}  		string txt2 = txt.Substring (1);  		if (txt2.IndexOf (".") == -1)  			throw new Exception ();  		mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  		mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  		if (mBit > 7)  			throw new Exception ();  		var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj3  		});  		return objBoolArray [mBit];  	}  } catch {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be read. Please check the syntax and try again.";  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  			return obj;  		case "DBW":  			UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  			return objI;  		case "DBD":  			UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  			return objU;  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7)  				throw new Exception ();  			byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			objBoolArray = new BitArray (new byte[] {  				obj2  			});  			return objBoolArray [mBit];  		default:  			throw new Exception ();  		}  	case "EB":  		// Input byte  		objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "EW":  		// Input word  		objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "ED":  		// Input double-word  		objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "AB":  		// Output byte  		objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "AW":  		// Output word  		objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "AD":  		// Output double-word  		objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "MB":  		// Memory byte  		objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "MW":  		// Memory word  		objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "MD":  		// Memory double-word  		objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  			return objDouble;  		case "Z":  		case "C":  			// Counter  			objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  			return objUInt16;  		default:  			throw new Exception ();  		}  		string txt2 = txt.Substring (1);  		if (txt2.IndexOf (".") == -1)  			throw new Exception ();  		mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  		mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  		if (mBit > 7)  			throw new Exception ();  		var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj3  		});  		return objBoolArray [mBit];  	}  } catch {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be read. Please check the syntax and try again.";  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  			return obj;  		case "DBW":  			UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  			return objI;  		case "DBD":  			UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  			return objU;  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7)  				throw new Exception ();  			byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			objBoolArray = new BitArray (new byte[] {  				obj2  			});  			return objBoolArray [mBit];  		default:  			throw new Exception ();  		}  	case "EB":  		// Input byte  		objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "EW":  		// Input word  		objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "ED":  		// Input double-word  		objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "AB":  		// Output byte  		objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "AW":  		// Output word  		objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "AD":  		// Output double-word  		objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "MB":  		// Memory byte  		objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "MW":  		// Memory word  		objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "MD":  		// Memory double-word  		objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  			return objDouble;  		case "Z":  		case "C":  			// Counter  			objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  			return objUInt16;  		default:  			throw new Exception ();  		}  		string txt2 = txt.Substring (1);  		if (txt2.IndexOf (".") == -1)  			throw new Exception ();  		mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  		mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  		if (mBit > 7)  			throw new Exception ();  		var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj3  		});  		return objBoolArray [mBit];  	}  } catch {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be read. Please check the syntax and try again.";  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  			return obj;  		case "DBW":  			UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  			return objI;  		case "DBD":  			UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  			return objU;  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7)  				throw new Exception ();  			byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			objBoolArray = new BitArray (new byte[] {  				obj2  			});  			return objBoolArray [mBit];  		default:  			throw new Exception ();  		}  	case "EB":  		// Input byte  		objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "EW":  		// Input word  		objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "ED":  		// Input double-word  		objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "AB":  		// Output byte  		objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "AW":  		// Output word  		objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "AD":  		// Output double-word  		objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "MB":  		// Memory byte  		objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "MW":  		// Memory word  		objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "MD":  		// Memory double-word  		objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  			return objDouble;  		case "Z":  		case "C":  			// Counter  			objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  			return objUInt16;  		default:  			throw new Exception ();  		}  		string txt2 = txt.Substring (1);  		if (txt2.IndexOf (".") == -1)  			throw new Exception ();  		mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  		mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  		if (mBit > 7)  			throw new Exception ();  		var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj3  		});  		return objBoolArray [mBit];  	}  } catch {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be read. Please check the syntax and try again.";  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  			return obj;  		case "DBW":  			UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  			return objI;  		case "DBD":  			UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  			return objU;  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7)  				throw new Exception ();  			byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			objBoolArray = new BitArray (new byte[] {  				obj2  			});  			return objBoolArray [mBit];  		default:  			throw new Exception ();  		}  	case "EB":  		// Input byte  		objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "EW":  		// Input word  		objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "ED":  		// Input double-word  		objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "AB":  		// Output byte  		objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "AW":  		// Output word  		objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "AD":  		// Output double-word  		objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	case "MB":  		// Memory byte  		objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  		return objByte;  	case "MW":  		// Memory word  		objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  		return objUInt16;  	case "MD":  		// Memory double-word  		objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  		return objUInt32;  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  			return objDouble;  		case "Z":  		case "C":  			// Counter  			objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  			return objUInt16;  		default:  			throw new Exception ();  		}  		string txt2 = txt.Substring (1);  		if (txt2.IndexOf (".") == -1)  			throw new Exception ();  		mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  		mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  		if (mBit > 7)  			throw new Exception ();  		var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj3  		});  		return objBoolArray [mBit];  	}  } catch {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be read. Please check the syntax and try again.";  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  		return obj;  	case "DBW":  		UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  		return objI;  	case "DBD":  		UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  		return objU;  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7)  			throw new Exception ();  		byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj2  		});  		return objBoolArray [mBit];  	default:  		throw new Exception ();  	}  case "EB":  	// Input byte  	objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "EW":  	// Input word  	objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "ED":  	// Input double-word  	objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "AB":  	// Output byte  	objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "AW":  	// Output word  	objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "AD":  	// Output double-word  	objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "MB":  	// Memory byte  	objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "MW":  	// Memory word  	objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "MD":  	// Memory double-word  	objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  		return objDouble;  	case "Z":  	case "C":  		// Counter  		objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  		return objUInt16;  	default:  		throw new Exception ();  	}  	string txt2 = txt.Substring (1);  	if (txt2.IndexOf (".") == -1)  		throw new Exception ();  	mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  	mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  	if (mBit > 7)  		throw new Exception ();  	var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	objBoolArray = new BitArray (new byte[] {  		obj3  	});  	return objBoolArray [mBit];  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  		return obj;  	case "DBW":  		UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  		return objI;  	case "DBD":  		UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  		return objU;  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7)  			throw new Exception ();  		byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj2  		});  		return objBoolArray [mBit];  	default:  		throw new Exception ();  	}  case "EB":  	// Input byte  	objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "EW":  	// Input word  	objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "ED":  	// Input double-word  	objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "AB":  	// Output byte  	objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "AW":  	// Output word  	objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "AD":  	// Output double-word  	objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "MB":  	// Memory byte  	objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "MW":  	// Memory word  	objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "MD":  	// Memory double-word  	objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  		return objDouble;  	case "Z":  	case "C":  		// Counter  		objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  		return objUInt16;  	default:  		throw new Exception ();  	}  	string txt2 = txt.Substring (1);  	if (txt2.IndexOf (".") == -1)  		throw new Exception ();  	mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  	mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  	if (mBit > 7)  		throw new Exception ();  	var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	objBoolArray = new BitArray (new byte[] {  		obj3  	});  	return objBoolArray [mBit];  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  		return obj;  	case "DBW":  		UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  		return objI;  	case "DBD":  		UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  		return objU;  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7)  			throw new Exception ();  		byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj2  		});  		return objBoolArray [mBit];  	default:  		throw new Exception ();  	}  case "EB":  	// Input byte  	objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "EW":  	// Input word  	objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "ED":  	// Input double-word  	objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "AB":  	// Output byte  	objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "AW":  	// Output word  	objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "AD":  	// Output double-word  	objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "MB":  	// Memory byte  	objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "MW":  	// Memory word  	objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "MD":  	// Memory double-word  	objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  		return objDouble;  	case "Z":  	case "C":  		// Counter  		objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  		return objUInt16;  	default:  		throw new Exception ();  	}  	string txt2 = txt.Substring (1);  	if (txt2.IndexOf (".") == -1)  		throw new Exception ();  	mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  	mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  	if (mBit > 7)  		throw new Exception ();  	var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	objBoolArray = new BitArray (new byte[] {  		obj3  	});  	return objBoolArray [mBit];  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  		return obj;  	case "DBW":  		UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  		return objI;  	case "DBD":  		UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  		return objU;  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7)  			throw new Exception ();  		byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj2  		});  		return objBoolArray [mBit];  	default:  		throw new Exception ();  	}  case "EB":  	// Input byte  	objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "EW":  	// Input word  	objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "ED":  	// Input double-word  	objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "AB":  	// Output byte  	objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "AW":  	// Output word  	objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "AD":  	// Output double-word  	objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "MB":  	// Memory byte  	objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "MW":  	// Memory word  	objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "MD":  	// Memory double-word  	objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  		return objDouble;  	case "Z":  	case "C":  		// Counter  		objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  		return objUInt16;  	default:  		throw new Exception ();  	}  	string txt2 = txt.Substring (1);  	if (txt2.IndexOf (".") == -1)  		throw new Exception ();  	mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  	mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  	if (mBit > 7)  		throw new Exception ();  	var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	objBoolArray = new BitArray (new byte[] {  		obj3  	});  	return objBoolArray [mBit];  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  		return obj;  	case "DBW":  		UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  		return objI;  	case "DBD":  		UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  		return objU;  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7)  			throw new Exception ();  		byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj2  		});  		return objBoolArray [mBit];  	default:  		throw new Exception ();  	}  case "EB":  	// Input byte  	objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "EW":  	// Input word  	objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "ED":  	// Input double-word  	objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "AB":  	// Output byte  	objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "AW":  	// Output word  	objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "AD":  	// Output double-word  	objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "MB":  	// Memory byte  	objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "MW":  	// Memory word  	objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "MD":  	// Memory double-word  	objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  		return objDouble;  	case "Z":  	case "C":  		// Counter  		objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  		return objUInt16;  	default:  		throw new Exception ();  	}  	string txt2 = txt.Substring (1);  	if (txt2.IndexOf (".") == -1)  		throw new Exception ();  	mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  	mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  	if (mBit > 7)  		throw new Exception ();  	var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	objBoolArray = new BitArray (new byte[] {  		obj3  	});  	return objBoolArray [mBit];  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  		return obj;  	case "DBW":  		UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  		return objI;  	case "DBD":  		UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  		return objU;  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7)  			throw new Exception ();  		byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj2  		});  		return objBoolArray [mBit];  	default:  		throw new Exception ();  	}  case "EB":  	// Input byte  	objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "EW":  	// Input word  	objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "ED":  	// Input double-word  	objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "AB":  	// Output byte  	objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "AW":  	// Output word  	objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "AD":  	// Output double-word  	objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "MB":  	// Memory byte  	objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "MW":  	// Memory word  	objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "MD":  	// Memory double-word  	objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  		return objDouble;  	case "Z":  	case "C":  		// Counter  		objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  		return objUInt16;  	default:  		throw new Exception ();  	}  	string txt2 = txt.Substring (1);  	if (txt2.IndexOf (".") == -1)  		throw new Exception ();  	mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  	mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  	if (mBit > 7)  		throw new Exception ();  	var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	objBoolArray = new BitArray (new byte[] {  		obj3  	});  	return objBoolArray [mBit];  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  		return obj;  	case "DBW":  		UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  		return objI;  	case "DBD":  		UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  		return objU;  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7)  			throw new Exception ();  		byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj2  		});  		return objBoolArray [mBit];  	default:  		throw new Exception ();  	}  case "EB":  	// Input byte  	objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "EW":  	// Input word  	objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "ED":  	// Input double-word  	objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "AB":  	// Output byte  	objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "AW":  	// Output word  	objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "AD":  	// Output double-word  	objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "MB":  	// Memory byte  	objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "MW":  	// Memory word  	objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "MD":  	// Memory double-word  	objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  		return objDouble;  	case "Z":  	case "C":  		// Counter  		objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  		return objUInt16;  	default:  		throw new Exception ();  	}  	string txt2 = txt.Substring (1);  	if (txt2.IndexOf (".") == -1)  		throw new Exception ();  	mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  	mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  	if (mBit > 7)  		throw new Exception ();  	var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	objBoolArray = new BitArray (new byte[] {  		obj3  	});  	return objBoolArray [mBit];  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  		return obj;  	case "DBW":  		UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  		return objI;  	case "DBD":  		UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  		return objU;  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7)  			throw new Exception ();  		byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj2  		});  		return objBoolArray [mBit];  	default:  		throw new Exception ();  	}  case "EB":  	// Input byte  	objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "EW":  	// Input word  	objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "ED":  	// Input double-word  	objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "AB":  	// Output byte  	objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "AW":  	// Output word  	objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "AD":  	// Output double-word  	objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "MB":  	// Memory byte  	objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "MW":  	// Memory word  	objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "MD":  	// Memory double-word  	objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  		return objDouble;  	case "Z":  	case "C":  		// Counter  		objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  		return objUInt16;  	default:  		throw new Exception ();  	}  	string txt2 = txt.Substring (1);  	if (txt2.IndexOf (".") == -1)  		throw new Exception ();  	mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  	mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  	if (mBit > 7)  		throw new Exception ();  	var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	objBoolArray = new BitArray (new byte[] {  		obj3  	});  	return objBoolArray [mBit];  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  		return obj;  	case "DBW":  		UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  		return objI;  	case "DBD":  		UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  		return objU;  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7)  			throw new Exception ();  		byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj2  		});  		return objBoolArray [mBit];  	default:  		throw new Exception ();  	}  case "EB":  	// Input byte  	objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "EW":  	// Input word  	objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "ED":  	// Input double-word  	objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "AB":  	// Output byte  	objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "AW":  	// Output word  	objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "AD":  	// Output double-word  	objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "MB":  	// Memory byte  	objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "MW":  	// Memory word  	objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "MD":  	// Memory double-word  	objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  		return objDouble;  	case "Z":  	case "C":  		// Counter  		objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  		return objUInt16;  	default:  		throw new Exception ();  	}  	string txt2 = txt.Substring (1);  	if (txt2.IndexOf (".") == -1)  		throw new Exception ();  	mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  	mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  	if (mBit > 7)  		throw new Exception ();  	var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	objBoolArray = new BitArray (new byte[] {  		obj3  	});  	return objBoolArray [mBit];  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  		return obj;  	case "DBW":  		UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  		return objI;  	case "DBD":  		UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  		return objU;  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7)  			throw new Exception ();  		byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj2  		});  		return objBoolArray [mBit];  	default:  		throw new Exception ();  	}  case "EB":  	// Input byte  	objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "EW":  	// Input word  	objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "ED":  	// Input double-word  	objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "AB":  	// Output byte  	objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "AW":  	// Output word  	objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "AD":  	// Output double-word  	objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "MB":  	// Memory byte  	objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "MW":  	// Memory word  	objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "MD":  	// Memory double-word  	objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  		return objDouble;  	case "Z":  	case "C":  		// Counter  		objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  		return objUInt16;  	default:  		throw new Exception ();  	}  	string txt2 = txt.Substring (1);  	if (txt2.IndexOf (".") == -1)  		throw new Exception ();  	mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  	mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  	if (mBit > 7)  		throw new Exception ();  	var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	objBoolArray = new BitArray (new byte[] {  		obj3  	});  	return objBoolArray [mBit];  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  		return obj;  	case "DBW":  		UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  		return objI;  	case "DBD":  		UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  		return objU;  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7)  			throw new Exception ();  		byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj2  		});  		return objBoolArray [mBit];  	default:  		throw new Exception ();  	}  case "EB":  	// Input byte  	objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "EW":  	// Input word  	objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "ED":  	// Input double-word  	objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "AB":  	// Output byte  	objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "AW":  	// Output word  	objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "AD":  	// Output double-word  	objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "MB":  	// Memory byte  	objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "MW":  	// Memory word  	objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "MD":  	// Memory double-word  	objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  		return objDouble;  	case "Z":  	case "C":  		// Counter  		objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  		return objUInt16;  	default:  		throw new Exception ();  	}  	string txt2 = txt.Substring (1);  	if (txt2.IndexOf (".") == -1)  		throw new Exception ();  	mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  	mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  	if (mBit > 7)  		throw new Exception ();  	var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	objBoolArray = new BitArray (new byte[] {  		obj3  	});  	return objBoolArray [mBit];  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  		return obj;  	case "DBW":  		UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  		return objI;  	case "DBD":  		UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  		return objU;  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7)  			throw new Exception ();  		byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj2  		});  		return objBoolArray [mBit];  	default:  		throw new Exception ();  	}  case "EB":  	// Input byte  	objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "EW":  	// Input word  	objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "ED":  	// Input double-word  	objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "AB":  	// Output byte  	objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "AW":  	// Output word  	objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "AD":  	// Output double-word  	objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "MB":  	// Memory byte  	objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "MW":  	// Memory word  	objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "MD":  	// Memory double-word  	objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  		return objDouble;  	case "Z":  	case "C":  		// Counter  		objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  		return objUInt16;  	default:  		throw new Exception ();  	}  	string txt2 = txt.Substring (1);  	if (txt2.IndexOf (".") == -1)  		throw new Exception ();  	mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  	mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  	if (mBit > 7)  		throw new Exception ();  	var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	objBoolArray = new BitArray (new byte[] {  		obj3  	});  	return objBoolArray [mBit];  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  		return obj;  	case "DBW":  		UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  		return objI;  	case "DBD":  		UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  		return objU;  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7)  			throw new Exception ();  		byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj2  		});  		return objBoolArray [mBit];  	default:  		throw new Exception ();  	}  case "EB":  	// Input byte  	objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "EW":  	// Input word  	objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "ED":  	// Input double-word  	objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "AB":  	// Output byte  	objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "AW":  	// Output word  	objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "AD":  	// Output double-word  	objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "MB":  	// Memory byte  	objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "MW":  	// Memory word  	objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "MD":  	// Memory double-word  	objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  		return objDouble;  	case "Z":  	case "C":  		// Counter  		objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  		return objUInt16;  	default:  		throw new Exception ();  	}  	string txt2 = txt.Substring (1);  	if (txt2.IndexOf (".") == -1)  		throw new Exception ();  	mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  	mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  	if (mBit > 7)  		throw new Exception ();  	var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	objBoolArray = new BitArray (new byte[] {  		obj3  	});  	return objBoolArray [mBit];  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  		return obj;  	case "DBW":  		UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  		return objI;  	case "DBD":  		UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  		return objU;  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7)  			throw new Exception ();  		byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj2  		});  		return objBoolArray [mBit];  	default:  		throw new Exception ();  	}  case "EB":  	// Input byte  	objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "EW":  	// Input word  	objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "ED":  	// Input double-word  	objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "AB":  	// Output byte  	objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "AW":  	// Output word  	objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "AD":  	// Output double-word  	objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "MB":  	// Memory byte  	objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "MW":  	// Memory word  	objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "MD":  	// Memory double-word  	objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  		return objDouble;  	case "Z":  	case "C":  		// Counter  		objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  		return objUInt16;  	default:  		throw new Exception ();  	}  	string txt2 = txt.Substring (1);  	if (txt2.IndexOf (".") == -1)  		throw new Exception ();  	mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  	mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  	if (mBit > 7)  		throw new Exception ();  	var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	objBoolArray = new BitArray (new byte[] {  		obj3  	});  	return objBoolArray [mBit];  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  		return obj;  	case "DBW":  		UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  		return objI;  	case "DBD":  		UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  		return objU;  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7)  			throw new Exception ();  		byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj2  		});  		return objBoolArray [mBit];  	default:  		throw new Exception ();  	}  case "EB":  	// Input byte  	objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "EW":  	// Input word  	objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "ED":  	// Input double-word  	objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "AB":  	// Output byte  	objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "AW":  	// Output word  	objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "AD":  	// Output double-word  	objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "MB":  	// Memory byte  	objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "MW":  	// Memory word  	objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "MD":  	// Memory double-word  	objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  		return objDouble;  	case "Z":  	case "C":  		// Counter  		objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  		return objUInt16;  	default:  		throw new Exception ();  	}  	string txt2 = txt.Substring (1);  	if (txt2.IndexOf (".") == -1)  		throw new Exception ();  	mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  	mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  	if (mBit > 7)  		throw new Exception ();  	var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	objBoolArray = new BitArray (new byte[] {  		obj3  	});  	return objBoolArray [mBit];  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  		return obj;  	case "DBW":  		UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  		return objI;  	case "DBD":  		UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  		return objU;  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7)  			throw new Exception ();  		byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj2  		});  		return objBoolArray [mBit];  	default:  		throw new Exception ();  	}  case "EB":  	// Input byte  	objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "EW":  	// Input word  	objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "ED":  	// Input double-word  	objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "AB":  	// Output byte  	objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "AW":  	// Output word  	objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "AD":  	// Output double-word  	objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "MB":  	// Memory byte  	objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "MW":  	// Memory word  	objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "MD":  	// Memory double-word  	objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  		return objDouble;  	case "Z":  	case "C":  		// Counter  		objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  		return objUInt16;  	default:  		throw new Exception ();  	}  	string txt2 = txt.Substring (1);  	if (txt2.IndexOf (".") == -1)  		throw new Exception ();  	mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  	mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  	if (mBit > 7)  		throw new Exception ();  	var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	objBoolArray = new BitArray (new byte[] {  		obj3  	});  	return objBoolArray [mBit];  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  		return obj;  	case "DBW":  		UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  		return objI;  	case "DBD":  		UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  		return objU;  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7)  			throw new Exception ();  		byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		objBoolArray = new BitArray (new byte[] {  			obj2  		});  		return objBoolArray [mBit];  	default:  		throw new Exception ();  	}  case "EB":  	// Input byte  	objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "EW":  	// Input word  	objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "ED":  	// Input double-word  	objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "AB":  	// Output byte  	objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "AW":  	// Output word  	objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "AD":  	// Output double-word  	objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  case "MB":  	// Memory byte  	objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  	return objByte;  case "MW":  	// Memory word  	objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  	return objUInt16;  case "MD":  	// Memory double-word  	objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  	return objUInt32;  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		objDouble = (double)Read (DataType.Timer' 0' int.Parse (txt.Substring (1))' VarType.Timer' 1);  		return objDouble;  	case "Z":  	case "C":  		// Counter  		objUInt16 = (UInt16)Read (DataType.Counter' 0' int.Parse (txt.Substring (1))' VarType.Counter' 1);  		return objUInt16;  	default:  		throw new Exception ();  	}  	string txt2 = txt.Substring (1);  	if (txt2.IndexOf (".") == -1)  		throw new Exception ();  	mByte = int.Parse (txt2.Substring (0' txt2.IndexOf (".")));  	mBit = int.Parse (txt2.Substring (txt2.IndexOf (".") + 1));  	if (mBit > 7)  		throw new Exception ();  	var obj3 = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	objBoolArray = new BitArray (new byte[] {  		obj3  	});  	return objBoolArray [mBit];  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: if (strings.Length < 2)  	throw new Exception ();  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: mDB = int.Parse (strings [0].Substring (2));  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: switch (dbType) {  case "DBB":  	byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  	return obj;  case "DBW":  	UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  	return objI;  case "DBD":  	UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  	return objU;  case "DBX":  	mByte = dbIndex;  	mBit = int.Parse (strings [2]);  	if (mBit > 7)  		throw new Exception ();  	byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  	objBoolArray = new BitArray (new byte[] {  		obj2  	});  	return objBoolArray [mBit];  default:  	throw new Exception ();  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: switch (dbType) {  case "DBB":  	byte obj = (byte)Read (DataType.DataBlock' mDB' dbIndex' VarType.Byte' 1);  	return obj;  case "DBW":  	UInt16 objI = (UInt16)Read (DataType.DataBlock' mDB' dbIndex' VarType.Word' 1);  	return objI;  case "DBD":  	UInt32 objU = (UInt32)Read (DataType.DataBlock' mDB' dbIndex' VarType.DWord' 1);  	return objU;  case "DBX":  	mByte = dbIndex;  	mBit = int.Parse (strings [2]);  	if (mBit > 7)  		throw new Exception ();  	byte obj2 = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  	objBoolArray = new BitArray (new byte[] {  		obj2  	});  	return objBoolArray [mBit];  default:  	throw new Exception ();  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: mBit = int.Parse (strings [2]);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: if (mBit > 7)  	throw new Exception ();  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: objByte = (byte)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: objUInt16 = (UInt16)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: objUInt32 = (UInt32)Read (DataType.Input' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: objByte = (byte)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: objUInt16 = (UInt16)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: objUInt32 = (UInt32)Read (DataType.Output' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: objByte = (byte)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Byte' 1);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: objUInt16 = (UInt16)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.Word' 1);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: objUInt32 = (UInt32)Read (DataType.Memory' 0' int.Parse (txt.Substring (2))' VarType.DWord' 1);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Read,The following statement contains a magic number: if (mBit > 7)  	throw new Exception ();  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,WriteBytes,The following statement contains a magic number: while (count > 0) {  	var maxToWrite = (int)Math.Min (count' 200);  	ErrorCode lastError = WriteBytesWithASingleRequest (dataType' db' startByteAdr + localIndex' value.Skip (localIndex).Take (maxToWrite).ToArray ());  	if (lastError != ErrorCode.NoError) {  		return lastError;  	}  	count -= maxToWrite;  	localIndex += maxToWrite;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			objValue = Convert.ChangeType (value' typeof(byte));  			return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  		case "DBW":  			if (value is short) {  				objValue = ((short)value).ConvertToUshort ();  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt16));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  		case "DBD":  			if (value is int) {  				return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt32));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7) {  				throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  			}  			byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			if (Convert.ToInt32 (value) == 1)  				b = (byte)(b | (byte)Math.Pow (2' mBit));  			// Bit setzen  			else  				b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  			// Bit rücksetzen  			return Write (DataType.DataBlock' mDB' mByte' (byte)b);  		case "DBS":  			// DB-String  			return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  		default:  			throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  		}  	case "EB":  		// Input Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "EW":  		// Input Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "ED":  		// Input Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "AB":  		// Output Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "AW":  		// Output Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "AD":  		// Output Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "MB":  		// Memory Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "MW":  		// Memory Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "MD":  		// Memory Double-Word  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  		case "Z":  		case "C":  			// Counter  			return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  		default:  			throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  		}  		addressLocation = txt.Substring (1);  		int decimalPointIndex = addressLocation.IndexOf (".");  		if (decimalPointIndex == -1) {  			throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  		}  		mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  		mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		if ((int)value == 1)  			_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  		// Set bit  		else  			_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  		// Reset bit  		return Write (mDataType' 0' mByte' (byte)_byte);  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be parsed. Please check the syntax and try again.\nException: " + exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			objValue = Convert.ChangeType (value' typeof(byte));  			return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  		case "DBW":  			if (value is short) {  				objValue = ((short)value).ConvertToUshort ();  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt16));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  		case "DBD":  			if (value is int) {  				return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt32));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7) {  				throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  			}  			byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			if (Convert.ToInt32 (value) == 1)  				b = (byte)(b | (byte)Math.Pow (2' mBit));  			// Bit setzen  			else  				b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  			// Bit rücksetzen  			return Write (DataType.DataBlock' mDB' mByte' (byte)b);  		case "DBS":  			// DB-String  			return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  		default:  			throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  		}  	case "EB":  		// Input Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "EW":  		// Input Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "ED":  		// Input Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "AB":  		// Output Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "AW":  		// Output Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "AD":  		// Output Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "MB":  		// Memory Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "MW":  		// Memory Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "MD":  		// Memory Double-Word  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  		case "Z":  		case "C":  			// Counter  			return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  		default:  			throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  		}  		addressLocation = txt.Substring (1);  		int decimalPointIndex = addressLocation.IndexOf (".");  		if (decimalPointIndex == -1) {  			throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  		}  		mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  		mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		if ((int)value == 1)  			_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  		// Set bit  		else  			_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  		// Reset bit  		return Write (mDataType' 0' mByte' (byte)_byte);  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be parsed. Please check the syntax and try again.\nException: " + exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			objValue = Convert.ChangeType (value' typeof(byte));  			return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  		case "DBW":  			if (value is short) {  				objValue = ((short)value).ConvertToUshort ();  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt16));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  		case "DBD":  			if (value is int) {  				return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt32));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7) {  				throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  			}  			byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			if (Convert.ToInt32 (value) == 1)  				b = (byte)(b | (byte)Math.Pow (2' mBit));  			// Bit setzen  			else  				b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  			// Bit rücksetzen  			return Write (DataType.DataBlock' mDB' mByte' (byte)b);  		case "DBS":  			// DB-String  			return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  		default:  			throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  		}  	case "EB":  		// Input Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "EW":  		// Input Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "ED":  		// Input Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "AB":  		// Output Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "AW":  		// Output Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "AD":  		// Output Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "MB":  		// Memory Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "MW":  		// Memory Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "MD":  		// Memory Double-Word  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  		case "Z":  		case "C":  			// Counter  			return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  		default:  			throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  		}  		addressLocation = txt.Substring (1);  		int decimalPointIndex = addressLocation.IndexOf (".");  		if (decimalPointIndex == -1) {  			throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  		}  		mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  		mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		if ((int)value == 1)  			_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  		// Set bit  		else  			_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  		// Reset bit  		return Write (mDataType' 0' mByte' (byte)_byte);  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be parsed. Please check the syntax and try again.\nException: " + exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			objValue = Convert.ChangeType (value' typeof(byte));  			return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  		case "DBW":  			if (value is short) {  				objValue = ((short)value).ConvertToUshort ();  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt16));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  		case "DBD":  			if (value is int) {  				return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt32));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7) {  				throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  			}  			byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			if (Convert.ToInt32 (value) == 1)  				b = (byte)(b | (byte)Math.Pow (2' mBit));  			// Bit setzen  			else  				b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  			// Bit rücksetzen  			return Write (DataType.DataBlock' mDB' mByte' (byte)b);  		case "DBS":  			// DB-String  			return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  		default:  			throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  		}  	case "EB":  		// Input Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "EW":  		// Input Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "ED":  		// Input Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "AB":  		// Output Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "AW":  		// Output Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "AD":  		// Output Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "MB":  		// Memory Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "MW":  		// Memory Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "MD":  		// Memory Double-Word  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  		case "Z":  		case "C":  			// Counter  			return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  		default:  			throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  		}  		addressLocation = txt.Substring (1);  		int decimalPointIndex = addressLocation.IndexOf (".");  		if (decimalPointIndex == -1) {  			throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  		}  		mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  		mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		if ((int)value == 1)  			_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  		// Set bit  		else  			_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  		// Reset bit  		return Write (mDataType' 0' mByte' (byte)_byte);  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be parsed. Please check the syntax and try again.\nException: " + exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			objValue = Convert.ChangeType (value' typeof(byte));  			return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  		case "DBW":  			if (value is short) {  				objValue = ((short)value).ConvertToUshort ();  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt16));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  		case "DBD":  			if (value is int) {  				return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt32));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7) {  				throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  			}  			byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			if (Convert.ToInt32 (value) == 1)  				b = (byte)(b | (byte)Math.Pow (2' mBit));  			// Bit setzen  			else  				b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  			// Bit rücksetzen  			return Write (DataType.DataBlock' mDB' mByte' (byte)b);  		case "DBS":  			// DB-String  			return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  		default:  			throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  		}  	case "EB":  		// Input Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "EW":  		// Input Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "ED":  		// Input Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "AB":  		// Output Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "AW":  		// Output Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "AD":  		// Output Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "MB":  		// Memory Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "MW":  		// Memory Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "MD":  		// Memory Double-Word  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  		case "Z":  		case "C":  			// Counter  			return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  		default:  			throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  		}  		addressLocation = txt.Substring (1);  		int decimalPointIndex = addressLocation.IndexOf (".");  		if (decimalPointIndex == -1) {  			throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  		}  		mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  		mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		if ((int)value == 1)  			_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  		// Set bit  		else  			_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  		// Reset bit  		return Write (mDataType' 0' mByte' (byte)_byte);  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be parsed. Please check the syntax and try again.\nException: " + exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			objValue = Convert.ChangeType (value' typeof(byte));  			return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  		case "DBW":  			if (value is short) {  				objValue = ((short)value).ConvertToUshort ();  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt16));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  		case "DBD":  			if (value is int) {  				return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt32));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7) {  				throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  			}  			byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			if (Convert.ToInt32 (value) == 1)  				b = (byte)(b | (byte)Math.Pow (2' mBit));  			// Bit setzen  			else  				b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  			// Bit rücksetzen  			return Write (DataType.DataBlock' mDB' mByte' (byte)b);  		case "DBS":  			// DB-String  			return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  		default:  			throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  		}  	case "EB":  		// Input Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "EW":  		// Input Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "ED":  		// Input Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "AB":  		// Output Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "AW":  		// Output Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "AD":  		// Output Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "MB":  		// Memory Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "MW":  		// Memory Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "MD":  		// Memory Double-Word  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  		case "Z":  		case "C":  			// Counter  			return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  		default:  			throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  		}  		addressLocation = txt.Substring (1);  		int decimalPointIndex = addressLocation.IndexOf (".");  		if (decimalPointIndex == -1) {  			throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  		}  		mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  		mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		if ((int)value == 1)  			_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  		// Set bit  		else  			_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  		// Reset bit  		return Write (mDataType' 0' mByte' (byte)_byte);  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be parsed. Please check the syntax and try again.\nException: " + exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			objValue = Convert.ChangeType (value' typeof(byte));  			return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  		case "DBW":  			if (value is short) {  				objValue = ((short)value).ConvertToUshort ();  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt16));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  		case "DBD":  			if (value is int) {  				return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt32));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7) {  				throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  			}  			byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			if (Convert.ToInt32 (value) == 1)  				b = (byte)(b | (byte)Math.Pow (2' mBit));  			// Bit setzen  			else  				b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  			// Bit rücksetzen  			return Write (DataType.DataBlock' mDB' mByte' (byte)b);  		case "DBS":  			// DB-String  			return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  		default:  			throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  		}  	case "EB":  		// Input Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "EW":  		// Input Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "ED":  		// Input Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "AB":  		// Output Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "AW":  		// Output Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "AD":  		// Output Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "MB":  		// Memory Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "MW":  		// Memory Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "MD":  		// Memory Double-Word  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  		case "Z":  		case "C":  			// Counter  			return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  		default:  			throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  		}  		addressLocation = txt.Substring (1);  		int decimalPointIndex = addressLocation.IndexOf (".");  		if (decimalPointIndex == -1) {  			throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  		}  		mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  		mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		if ((int)value == 1)  			_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  		// Set bit  		else  			_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  		// Reset bit  		return Write (mDataType' 0' mByte' (byte)_byte);  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be parsed. Please check the syntax and try again.\nException: " + exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			objValue = Convert.ChangeType (value' typeof(byte));  			return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  		case "DBW":  			if (value is short) {  				objValue = ((short)value).ConvertToUshort ();  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt16));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  		case "DBD":  			if (value is int) {  				return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt32));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7) {  				throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  			}  			byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			if (Convert.ToInt32 (value) == 1)  				b = (byte)(b | (byte)Math.Pow (2' mBit));  			// Bit setzen  			else  				b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  			// Bit rücksetzen  			return Write (DataType.DataBlock' mDB' mByte' (byte)b);  		case "DBS":  			// DB-String  			return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  		default:  			throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  		}  	case "EB":  		// Input Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "EW":  		// Input Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "ED":  		// Input Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "AB":  		// Output Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "AW":  		// Output Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "AD":  		// Output Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "MB":  		// Memory Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "MW":  		// Memory Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "MD":  		// Memory Double-Word  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  		case "Z":  		case "C":  			// Counter  			return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  		default:  			throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  		}  		addressLocation = txt.Substring (1);  		int decimalPointIndex = addressLocation.IndexOf (".");  		if (decimalPointIndex == -1) {  			throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  		}  		mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  		mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		if ((int)value == 1)  			_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  		// Set bit  		else  			_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  		// Reset bit  		return Write (mDataType' 0' mByte' (byte)_byte);  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be parsed. Please check the syntax and try again.\nException: " + exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			objValue = Convert.ChangeType (value' typeof(byte));  			return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  		case "DBW":  			if (value is short) {  				objValue = ((short)value).ConvertToUshort ();  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt16));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  		case "DBD":  			if (value is int) {  				return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt32));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7) {  				throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  			}  			byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			if (Convert.ToInt32 (value) == 1)  				b = (byte)(b | (byte)Math.Pow (2' mBit));  			// Bit setzen  			else  				b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  			// Bit rücksetzen  			return Write (DataType.DataBlock' mDB' mByte' (byte)b);  		case "DBS":  			// DB-String  			return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  		default:  			throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  		}  	case "EB":  		// Input Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "EW":  		// Input Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "ED":  		// Input Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "AB":  		// Output Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "AW":  		// Output Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "AD":  		// Output Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "MB":  		// Memory Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "MW":  		// Memory Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "MD":  		// Memory Double-Word  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  		case "Z":  		case "C":  			// Counter  			return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  		default:  			throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  		}  		addressLocation = txt.Substring (1);  		int decimalPointIndex = addressLocation.IndexOf (".");  		if (decimalPointIndex == -1) {  			throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  		}  		mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  		mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		if ((int)value == 1)  			_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  		// Set bit  		else  			_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  		// Reset bit  		return Write (mDataType' 0' mByte' (byte)_byte);  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be parsed. Please check the syntax and try again.\nException: " + exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			objValue = Convert.ChangeType (value' typeof(byte));  			return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  		case "DBW":  			if (value is short) {  				objValue = ((short)value).ConvertToUshort ();  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt16));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  		case "DBD":  			if (value is int) {  				return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt32));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7) {  				throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  			}  			byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			if (Convert.ToInt32 (value) == 1)  				b = (byte)(b | (byte)Math.Pow (2' mBit));  			// Bit setzen  			else  				b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  			// Bit rücksetzen  			return Write (DataType.DataBlock' mDB' mByte' (byte)b);  		case "DBS":  			// DB-String  			return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  		default:  			throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  		}  	case "EB":  		// Input Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "EW":  		// Input Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "ED":  		// Input Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "AB":  		// Output Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "AW":  		// Output Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "AD":  		// Output Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "MB":  		// Memory Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "MW":  		// Memory Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "MD":  		// Memory Double-Word  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  		case "Z":  		case "C":  			// Counter  			return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  		default:  			throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  		}  		addressLocation = txt.Substring (1);  		int decimalPointIndex = addressLocation.IndexOf (".");  		if (decimalPointIndex == -1) {  			throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  		}  		mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  		mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		if ((int)value == 1)  			_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  		// Set bit  		else  			_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  		// Reset bit  		return Write (mDataType' 0' mByte' (byte)_byte);  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be parsed. Please check the syntax and try again.\nException: " + exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			objValue = Convert.ChangeType (value' typeof(byte));  			return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  		case "DBW":  			if (value is short) {  				objValue = ((short)value).ConvertToUshort ();  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt16));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  		case "DBD":  			if (value is int) {  				return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt32));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7) {  				throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  			}  			byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			if (Convert.ToInt32 (value) == 1)  				b = (byte)(b | (byte)Math.Pow (2' mBit));  			// Bit setzen  			else  				b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  			// Bit rücksetzen  			return Write (DataType.DataBlock' mDB' mByte' (byte)b);  		case "DBS":  			// DB-String  			return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  		default:  			throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  		}  	case "EB":  		// Input Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "EW":  		// Input Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "ED":  		// Input Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "AB":  		// Output Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "AW":  		// Output Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "AD":  		// Output Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "MB":  		// Memory Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "MW":  		// Memory Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "MD":  		// Memory Double-Word  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  		case "Z":  		case "C":  			// Counter  			return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  		default:  			throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  		}  		addressLocation = txt.Substring (1);  		int decimalPointIndex = addressLocation.IndexOf (".");  		if (decimalPointIndex == -1) {  			throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  		}  		mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  		mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		if ((int)value == 1)  			_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  		// Set bit  		else  			_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  		// Reset bit  		return Write (mDataType' 0' mByte' (byte)_byte);  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be parsed. Please check the syntax and try again.\nException: " + exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			objValue = Convert.ChangeType (value' typeof(byte));  			return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  		case "DBW":  			if (value is short) {  				objValue = ((short)value).ConvertToUshort ();  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt16));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  		case "DBD":  			if (value is int) {  				return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt32));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7) {  				throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  			}  			byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			if (Convert.ToInt32 (value) == 1)  				b = (byte)(b | (byte)Math.Pow (2' mBit));  			// Bit setzen  			else  				b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  			// Bit rücksetzen  			return Write (DataType.DataBlock' mDB' mByte' (byte)b);  		case "DBS":  			// DB-String  			return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  		default:  			throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  		}  	case "EB":  		// Input Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "EW":  		// Input Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "ED":  		// Input Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "AB":  		// Output Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "AW":  		// Output Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "AD":  		// Output Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "MB":  		// Memory Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "MW":  		// Memory Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "MD":  		// Memory Double-Word  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  		case "Z":  		case "C":  			// Counter  			return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  		default:  			throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  		}  		addressLocation = txt.Substring (1);  		int decimalPointIndex = addressLocation.IndexOf (".");  		if (decimalPointIndex == -1) {  			throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  		}  		mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  		mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		if ((int)value == 1)  			_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  		// Set bit  		else  			_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  		// Reset bit  		return Write (mDataType' 0' mByte' (byte)_byte);  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be parsed. Please check the syntax and try again.\nException: " + exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			objValue = Convert.ChangeType (value' typeof(byte));  			return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  		case "DBW":  			if (value is short) {  				objValue = ((short)value).ConvertToUshort ();  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt16));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  		case "DBD":  			if (value is int) {  				return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt32));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7) {  				throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  			}  			byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			if (Convert.ToInt32 (value) == 1)  				b = (byte)(b | (byte)Math.Pow (2' mBit));  			// Bit setzen  			else  				b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  			// Bit rücksetzen  			return Write (DataType.DataBlock' mDB' mByte' (byte)b);  		case "DBS":  			// DB-String  			return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  		default:  			throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  		}  	case "EB":  		// Input Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "EW":  		// Input Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "ED":  		// Input Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "AB":  		// Output Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "AW":  		// Output Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "AD":  		// Output Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "MB":  		// Memory Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "MW":  		// Memory Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "MD":  		// Memory Double-Word  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  		case "Z":  		case "C":  			// Counter  			return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  		default:  			throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  		}  		addressLocation = txt.Substring (1);  		int decimalPointIndex = addressLocation.IndexOf (".");  		if (decimalPointIndex == -1) {  			throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  		}  		mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  		mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		if ((int)value == 1)  			_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  		// Set bit  		else  			_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  		// Reset bit  		return Write (mDataType' 0' mByte' (byte)_byte);  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be parsed. Please check the syntax and try again.\nException: " + exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			objValue = Convert.ChangeType (value' typeof(byte));  			return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  		case "DBW":  			if (value is short) {  				objValue = ((short)value).ConvertToUshort ();  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt16));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  		case "DBD":  			if (value is int) {  				return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt32));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7) {  				throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  			}  			byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			if (Convert.ToInt32 (value) == 1)  				b = (byte)(b | (byte)Math.Pow (2' mBit));  			// Bit setzen  			else  				b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  			// Bit rücksetzen  			return Write (DataType.DataBlock' mDB' mByte' (byte)b);  		case "DBS":  			// DB-String  			return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  		default:  			throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  		}  	case "EB":  		// Input Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "EW":  		// Input Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "ED":  		// Input Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "AB":  		// Output Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "AW":  		// Output Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "AD":  		// Output Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "MB":  		// Memory Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "MW":  		// Memory Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "MD":  		// Memory Double-Word  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  		case "Z":  		case "C":  			// Counter  			return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  		default:  			throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  		}  		addressLocation = txt.Substring (1);  		int decimalPointIndex = addressLocation.IndexOf (".");  		if (decimalPointIndex == -1) {  			throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  		}  		mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  		mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		if ((int)value == 1)  			_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  		// Set bit  		else  			_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  		// Reset bit  		return Write (mDataType' 0' mByte' (byte)_byte);  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be parsed. Please check the syntax and try again.\nException: " + exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			objValue = Convert.ChangeType (value' typeof(byte));  			return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  		case "DBW":  			if (value is short) {  				objValue = ((short)value).ConvertToUshort ();  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt16));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  		case "DBD":  			if (value is int) {  				return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt32));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7) {  				throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  			}  			byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			if (Convert.ToInt32 (value) == 1)  				b = (byte)(b | (byte)Math.Pow (2' mBit));  			// Bit setzen  			else  				b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  			// Bit rücksetzen  			return Write (DataType.DataBlock' mDB' mByte' (byte)b);  		case "DBS":  			// DB-String  			return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  		default:  			throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  		}  	case "EB":  		// Input Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "EW":  		// Input Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "ED":  		// Input Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "AB":  		// Output Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "AW":  		// Output Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "AD":  		// Output Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "MB":  		// Memory Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "MW":  		// Memory Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "MD":  		// Memory Double-Word  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  		case "Z":  		case "C":  			// Counter  			return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  		default:  			throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  		}  		addressLocation = txt.Substring (1);  		int decimalPointIndex = addressLocation.IndexOf (".");  		if (decimalPointIndex == -1) {  			throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  		}  		mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  		mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		if ((int)value == 1)  			_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  		// Set bit  		else  			_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  		// Reset bit  		return Write (mDataType' 0' mByte' (byte)_byte);  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be parsed. Please check the syntax and try again.\nException: " + exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			objValue = Convert.ChangeType (value' typeof(byte));  			return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  		case "DBW":  			if (value is short) {  				objValue = ((short)value).ConvertToUshort ();  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt16));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  		case "DBD":  			if (value is int) {  				return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt32));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7) {  				throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  			}  			byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			if (Convert.ToInt32 (value) == 1)  				b = (byte)(b | (byte)Math.Pow (2' mBit));  			// Bit setzen  			else  				b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  			// Bit rücksetzen  			return Write (DataType.DataBlock' mDB' mByte' (byte)b);  		case "DBS":  			// DB-String  			return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  		default:  			throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  		}  	case "EB":  		// Input Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "EW":  		// Input Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "ED":  		// Input Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "AB":  		// Output Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "AW":  		// Output Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "AD":  		// Output Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "MB":  		// Memory Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "MW":  		// Memory Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "MD":  		// Memory Double-Word  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  		case "Z":  		case "C":  			// Counter  			return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  		default:  			throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  		}  		addressLocation = txt.Substring (1);  		int decimalPointIndex = addressLocation.IndexOf (".");  		if (decimalPointIndex == -1) {  			throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  		}  		mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  		mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		if ((int)value == 1)  			_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  		// Set bit  		else  			_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  		// Reset bit  		return Write (mDataType' 0' mByte' (byte)_byte);  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be parsed. Please check the syntax and try again.\nException: " + exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			objValue = Convert.ChangeType (value' typeof(byte));  			return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  		case "DBW":  			if (value is short) {  				objValue = ((short)value).ConvertToUshort ();  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt16));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  		case "DBD":  			if (value is int) {  				return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt32));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7) {  				throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  			}  			byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			if (Convert.ToInt32 (value) == 1)  				b = (byte)(b | (byte)Math.Pow (2' mBit));  			// Bit setzen  			else  				b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  			// Bit rücksetzen  			return Write (DataType.DataBlock' mDB' mByte' (byte)b);  		case "DBS":  			// DB-String  			return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  		default:  			throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  		}  	case "EB":  		// Input Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "EW":  		// Input Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "ED":  		// Input Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "AB":  		// Output Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "AW":  		// Output Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "AD":  		// Output Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "MB":  		// Memory Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "MW":  		// Memory Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "MD":  		// Memory Double-Word  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  		case "Z":  		case "C":  			// Counter  			return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  		default:  			throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  		}  		addressLocation = txt.Substring (1);  		int decimalPointIndex = addressLocation.IndexOf (".");  		if (decimalPointIndex == -1) {  			throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  		}  		mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  		mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		if ((int)value == 1)  			_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  		// Set bit  		else  			_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  		// Reset bit  		return Write (mDataType' 0' mByte' (byte)_byte);  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be parsed. Please check the syntax and try again.\nException: " + exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			objValue = Convert.ChangeType (value' typeof(byte));  			return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  		case "DBW":  			if (value is short) {  				objValue = ((short)value).ConvertToUshort ();  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt16));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  		case "DBD":  			if (value is int) {  				return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt32));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7) {  				throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  			}  			byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			if (Convert.ToInt32 (value) == 1)  				b = (byte)(b | (byte)Math.Pow (2' mBit));  			// Bit setzen  			else  				b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  			// Bit rücksetzen  			return Write (DataType.DataBlock' mDB' mByte' (byte)b);  		case "DBS":  			// DB-String  			return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  		default:  			throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  		}  	case "EB":  		// Input Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "EW":  		// Input Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "ED":  		// Input Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "AB":  		// Output Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "AW":  		// Output Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "AD":  		// Output Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "MB":  		// Memory Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "MW":  		// Memory Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "MD":  		// Memory Double-Word  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  		case "Z":  		case "C":  			// Counter  			return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  		default:  			throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  		}  		addressLocation = txt.Substring (1);  		int decimalPointIndex = addressLocation.IndexOf (".");  		if (decimalPointIndex == -1) {  			throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  		}  		mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  		mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		if ((int)value == 1)  			_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  		// Set bit  		else  			_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  		// Reset bit  		return Write (mDataType' 0' mByte' (byte)_byte);  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be parsed. Please check the syntax and try again.\nException: " + exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			objValue = Convert.ChangeType (value' typeof(byte));  			return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  		case "DBW":  			if (value is short) {  				objValue = ((short)value).ConvertToUshort ();  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt16));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  		case "DBD":  			if (value is int) {  				return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt32));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7) {  				throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  			}  			byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			if (Convert.ToInt32 (value) == 1)  				b = (byte)(b | (byte)Math.Pow (2' mBit));  			// Bit setzen  			else  				b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  			// Bit rücksetzen  			return Write (DataType.DataBlock' mDB' mByte' (byte)b);  		case "DBS":  			// DB-String  			return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  		default:  			throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  		}  	case "EB":  		// Input Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "EW":  		// Input Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "ED":  		// Input Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "AB":  		// Output Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "AW":  		// Output Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "AD":  		// Output Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "MB":  		// Memory Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "MW":  		// Memory Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "MD":  		// Memory Double-Word  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  		case "Z":  		case "C":  			// Counter  			return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  		default:  			throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  		}  		addressLocation = txt.Substring (1);  		int decimalPointIndex = addressLocation.IndexOf (".");  		if (decimalPointIndex == -1) {  			throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  		}  		mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  		mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		if ((int)value == 1)  			_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  		// Set bit  		else  			_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  		// Reset bit  		return Write (mDataType' 0' mByte' (byte)_byte);  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be parsed. Please check the syntax and try again.\nException: " + exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			objValue = Convert.ChangeType (value' typeof(byte));  			return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  		case "DBW":  			if (value is short) {  				objValue = ((short)value).ConvertToUshort ();  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt16));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  		case "DBD":  			if (value is int) {  				return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt32));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7) {  				throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  			}  			byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			if (Convert.ToInt32 (value) == 1)  				b = (byte)(b | (byte)Math.Pow (2' mBit));  			// Bit setzen  			else  				b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  			// Bit rücksetzen  			return Write (DataType.DataBlock' mDB' mByte' (byte)b);  		case "DBS":  			// DB-String  			return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  		default:  			throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  		}  	case "EB":  		// Input Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "EW":  		// Input Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "ED":  		// Input Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "AB":  		// Output Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "AW":  		// Output Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "AD":  		// Output Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "MB":  		// Memory Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "MW":  		// Memory Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "MD":  		// Memory Double-Word  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  		case "Z":  		case "C":  			// Counter  			return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  		default:  			throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  		}  		addressLocation = txt.Substring (1);  		int decimalPointIndex = addressLocation.IndexOf (".");  		if (decimalPointIndex == -1) {  			throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  		}  		mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  		mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		if ((int)value == 1)  			_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  		// Set bit  		else  			_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  		// Reset bit  		return Write (mDataType' 0' mByte' (byte)_byte);  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be parsed. Please check the syntax and try again.\nException: " + exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: try {  	switch (txt.Substring (0' 2)) {  	case "DB":  		string[] strings = txt.Split (new char[] {  			'.'  		});  		if (strings.Length < 2)  			throw new Exception ();  		mDB = int.Parse (strings [0].Substring (2));  		string dbType = strings [1].Substring (0' 3);  		int dbIndex = int.Parse (strings [1].Substring (3));  		switch (dbType) {  		case "DBB":  			objValue = Convert.ChangeType (value' typeof(byte));  			return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  		case "DBW":  			if (value is short) {  				objValue = ((short)value).ConvertToUshort ();  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt16));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  		case "DBD":  			if (value is int) {  				return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  			} else {  				objValue = Convert.ChangeType (value' typeof(UInt32));  			}  			return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  		case "DBX":  			mByte = dbIndex;  			mBit = int.Parse (strings [2]);  			if (mBit > 7) {  				throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  			}  			byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  			if (Convert.ToInt32 (value) == 1)  				b = (byte)(b | (byte)Math.Pow (2' mBit));  			// Bit setzen  			else  				b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  			// Bit rücksetzen  			return Write (DataType.DataBlock' mDB' mByte' (byte)b);  		case "DBS":  			// DB-String  			return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  		default:  			throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  		}  	case "EB":  		// Input Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "EW":  		// Input Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "ED":  		// Input Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "AB":  		// Output Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "AW":  		// Output Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "AD":  		// Output Double-Word  		objValue = Convert.ChangeType (value' typeof(UInt32));  		return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  	case "MB":  		// Memory Byte  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  	case "MW":  		// Memory Word  		objValue = Convert.ChangeType (value' typeof(UInt16));  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  	case "MD":  		// Memory Double-Word  		return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  	default:  		switch (txt.Substring (0' 1)) {  		case "E":  		case "I":  			// Input  			mDataType = DataType.Input;  			break;  		case "A":  		case "O":  			// Output  			mDataType = DataType.Output;  			break;  		case "M":  			// Memory  			mDataType = DataType.Memory;  			break;  		case "T":  			// Timer  			return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  		case "Z":  		case "C":  			// Counter  			return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  		default:  			throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  		}  		addressLocation = txt.Substring (1);  		int decimalPointIndex = addressLocation.IndexOf (".");  		if (decimalPointIndex == -1) {  			throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  		}  		mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  		mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  		if ((int)value == 1)  			_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  		// Set bit  		else  			_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  		// Reset bit  		return Write (mDataType' 0' mByte' (byte)_byte);  	}  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WrongVarFormat;  	LastErrorString = "The variable'" + variable + "' could not be parsed. Please check the syntax and try again.\nException: " + exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  	case "DBW":  		if (value is short) {  			objValue = ((short)value).ConvertToUshort ();  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt16));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  	case "DBD":  		if (value is int) {  			return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt32));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		if (Convert.ToInt32 (value) == 1)  			b = (byte)(b | (byte)Math.Pow (2' mBit));  		// Bit setzen  		else  			b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  		// Bit rücksetzen  		return Write (DataType.DataBlock' mDB' mByte' (byte)b);  	case "DBS":  		// DB-String  		return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  	default:  		throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  	}  case "EB":  	// Input Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "EW":  	// Input Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "ED":  	// Input Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "AB":  	// Output Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "AW":  	// Output Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "AD":  	// Output Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "MB":  	// Memory Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "MW":  	// Memory Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "MD":  	// Memory Double-Word  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  	case "Z":  	case "C":  		// Counter  		return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  	default:  		throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  	}  	addressLocation = txt.Substring (1);  	int decimalPointIndex = addressLocation.IndexOf (".");  	if (decimalPointIndex == -1) {  		throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  	}  	mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  	mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	if ((int)value == 1)  		_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  	// Set bit  	else  		_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  	// Reset bit  	return Write (mDataType' 0' mByte' (byte)_byte);  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  	case "DBW":  		if (value is short) {  			objValue = ((short)value).ConvertToUshort ();  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt16));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  	case "DBD":  		if (value is int) {  			return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt32));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		if (Convert.ToInt32 (value) == 1)  			b = (byte)(b | (byte)Math.Pow (2' mBit));  		// Bit setzen  		else  			b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  		// Bit rücksetzen  		return Write (DataType.DataBlock' mDB' mByte' (byte)b);  	case "DBS":  		// DB-String  		return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  	default:  		throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  	}  case "EB":  	// Input Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "EW":  	// Input Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "ED":  	// Input Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "AB":  	// Output Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "AW":  	// Output Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "AD":  	// Output Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "MB":  	// Memory Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "MW":  	// Memory Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "MD":  	// Memory Double-Word  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  	case "Z":  	case "C":  		// Counter  		return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  	default:  		throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  	}  	addressLocation = txt.Substring (1);  	int decimalPointIndex = addressLocation.IndexOf (".");  	if (decimalPointIndex == -1) {  		throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  	}  	mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  	mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	if ((int)value == 1)  		_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  	// Set bit  	else  		_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  	// Reset bit  	return Write (mDataType' 0' mByte' (byte)_byte);  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  	case "DBW":  		if (value is short) {  			objValue = ((short)value).ConvertToUshort ();  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt16));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  	case "DBD":  		if (value is int) {  			return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt32));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		if (Convert.ToInt32 (value) == 1)  			b = (byte)(b | (byte)Math.Pow (2' mBit));  		// Bit setzen  		else  			b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  		// Bit rücksetzen  		return Write (DataType.DataBlock' mDB' mByte' (byte)b);  	case "DBS":  		// DB-String  		return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  	default:  		throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  	}  case "EB":  	// Input Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "EW":  	// Input Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "ED":  	// Input Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "AB":  	// Output Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "AW":  	// Output Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "AD":  	// Output Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "MB":  	// Memory Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "MW":  	// Memory Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "MD":  	// Memory Double-Word  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  	case "Z":  	case "C":  		// Counter  		return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  	default:  		throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  	}  	addressLocation = txt.Substring (1);  	int decimalPointIndex = addressLocation.IndexOf (".");  	if (decimalPointIndex == -1) {  		throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  	}  	mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  	mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	if ((int)value == 1)  		_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  	// Set bit  	else  		_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  	// Reset bit  	return Write (mDataType' 0' mByte' (byte)_byte);  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  	case "DBW":  		if (value is short) {  			objValue = ((short)value).ConvertToUshort ();  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt16));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  	case "DBD":  		if (value is int) {  			return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt32));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		if (Convert.ToInt32 (value) == 1)  			b = (byte)(b | (byte)Math.Pow (2' mBit));  		// Bit setzen  		else  			b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  		// Bit rücksetzen  		return Write (DataType.DataBlock' mDB' mByte' (byte)b);  	case "DBS":  		// DB-String  		return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  	default:  		throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  	}  case "EB":  	// Input Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "EW":  	// Input Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "ED":  	// Input Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "AB":  	// Output Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "AW":  	// Output Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "AD":  	// Output Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "MB":  	// Memory Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "MW":  	// Memory Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "MD":  	// Memory Double-Word  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  	case "Z":  	case "C":  		// Counter  		return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  	default:  		throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  	}  	addressLocation = txt.Substring (1);  	int decimalPointIndex = addressLocation.IndexOf (".");  	if (decimalPointIndex == -1) {  		throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  	}  	mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  	mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	if ((int)value == 1)  		_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  	// Set bit  	else  		_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  	// Reset bit  	return Write (mDataType' 0' mByte' (byte)_byte);  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  	case "DBW":  		if (value is short) {  			objValue = ((short)value).ConvertToUshort ();  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt16));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  	case "DBD":  		if (value is int) {  			return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt32));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		if (Convert.ToInt32 (value) == 1)  			b = (byte)(b | (byte)Math.Pow (2' mBit));  		// Bit setzen  		else  			b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  		// Bit rücksetzen  		return Write (DataType.DataBlock' mDB' mByte' (byte)b);  	case "DBS":  		// DB-String  		return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  	default:  		throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  	}  case "EB":  	// Input Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "EW":  	// Input Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "ED":  	// Input Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "AB":  	// Output Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "AW":  	// Output Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "AD":  	// Output Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "MB":  	// Memory Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "MW":  	// Memory Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "MD":  	// Memory Double-Word  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  	case "Z":  	case "C":  		// Counter  		return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  	default:  		throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  	}  	addressLocation = txt.Substring (1);  	int decimalPointIndex = addressLocation.IndexOf (".");  	if (decimalPointIndex == -1) {  		throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  	}  	mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  	mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	if ((int)value == 1)  		_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  	// Set bit  	else  		_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  	// Reset bit  	return Write (mDataType' 0' mByte' (byte)_byte);  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  	case "DBW":  		if (value is short) {  			objValue = ((short)value).ConvertToUshort ();  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt16));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  	case "DBD":  		if (value is int) {  			return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt32));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		if (Convert.ToInt32 (value) == 1)  			b = (byte)(b | (byte)Math.Pow (2' mBit));  		// Bit setzen  		else  			b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  		// Bit rücksetzen  		return Write (DataType.DataBlock' mDB' mByte' (byte)b);  	case "DBS":  		// DB-String  		return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  	default:  		throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  	}  case "EB":  	// Input Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "EW":  	// Input Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "ED":  	// Input Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "AB":  	// Output Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "AW":  	// Output Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "AD":  	// Output Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "MB":  	// Memory Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "MW":  	// Memory Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "MD":  	// Memory Double-Word  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  	case "Z":  	case "C":  		// Counter  		return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  	default:  		throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  	}  	addressLocation = txt.Substring (1);  	int decimalPointIndex = addressLocation.IndexOf (".");  	if (decimalPointIndex == -1) {  		throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  	}  	mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  	mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	if ((int)value == 1)  		_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  	// Set bit  	else  		_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  	// Reset bit  	return Write (mDataType' 0' mByte' (byte)_byte);  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  	case "DBW":  		if (value is short) {  			objValue = ((short)value).ConvertToUshort ();  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt16));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  	case "DBD":  		if (value is int) {  			return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt32));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		if (Convert.ToInt32 (value) == 1)  			b = (byte)(b | (byte)Math.Pow (2' mBit));  		// Bit setzen  		else  			b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  		// Bit rücksetzen  		return Write (DataType.DataBlock' mDB' mByte' (byte)b);  	case "DBS":  		// DB-String  		return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  	default:  		throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  	}  case "EB":  	// Input Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "EW":  	// Input Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "ED":  	// Input Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "AB":  	// Output Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "AW":  	// Output Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "AD":  	// Output Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "MB":  	// Memory Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "MW":  	// Memory Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "MD":  	// Memory Double-Word  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  	case "Z":  	case "C":  		// Counter  		return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  	default:  		throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  	}  	addressLocation = txt.Substring (1);  	int decimalPointIndex = addressLocation.IndexOf (".");  	if (decimalPointIndex == -1) {  		throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  	}  	mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  	mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	if ((int)value == 1)  		_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  	// Set bit  	else  		_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  	// Reset bit  	return Write (mDataType' 0' mByte' (byte)_byte);  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  	case "DBW":  		if (value is short) {  			objValue = ((short)value).ConvertToUshort ();  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt16));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  	case "DBD":  		if (value is int) {  			return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt32));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		if (Convert.ToInt32 (value) == 1)  			b = (byte)(b | (byte)Math.Pow (2' mBit));  		// Bit setzen  		else  			b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  		// Bit rücksetzen  		return Write (DataType.DataBlock' mDB' mByte' (byte)b);  	case "DBS":  		// DB-String  		return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  	default:  		throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  	}  case "EB":  	// Input Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "EW":  	// Input Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "ED":  	// Input Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "AB":  	// Output Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "AW":  	// Output Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "AD":  	// Output Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "MB":  	// Memory Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "MW":  	// Memory Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "MD":  	// Memory Double-Word  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  	case "Z":  	case "C":  		// Counter  		return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  	default:  		throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  	}  	addressLocation = txt.Substring (1);  	int decimalPointIndex = addressLocation.IndexOf (".");  	if (decimalPointIndex == -1) {  		throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  	}  	mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  	mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	if ((int)value == 1)  		_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  	// Set bit  	else  		_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  	// Reset bit  	return Write (mDataType' 0' mByte' (byte)_byte);  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  	case "DBW":  		if (value is short) {  			objValue = ((short)value).ConvertToUshort ();  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt16));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  	case "DBD":  		if (value is int) {  			return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt32));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		if (Convert.ToInt32 (value) == 1)  			b = (byte)(b | (byte)Math.Pow (2' mBit));  		// Bit setzen  		else  			b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  		// Bit rücksetzen  		return Write (DataType.DataBlock' mDB' mByte' (byte)b);  	case "DBS":  		// DB-String  		return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  	default:  		throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  	}  case "EB":  	// Input Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "EW":  	// Input Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "ED":  	// Input Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "AB":  	// Output Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "AW":  	// Output Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "AD":  	// Output Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "MB":  	// Memory Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "MW":  	// Memory Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "MD":  	// Memory Double-Word  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  	case "Z":  	case "C":  		// Counter  		return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  	default:  		throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  	}  	addressLocation = txt.Substring (1);  	int decimalPointIndex = addressLocation.IndexOf (".");  	if (decimalPointIndex == -1) {  		throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  	}  	mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  	mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	if ((int)value == 1)  		_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  	// Set bit  	else  		_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  	// Reset bit  	return Write (mDataType' 0' mByte' (byte)_byte);  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  	case "DBW":  		if (value is short) {  			objValue = ((short)value).ConvertToUshort ();  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt16));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  	case "DBD":  		if (value is int) {  			return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt32));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		if (Convert.ToInt32 (value) == 1)  			b = (byte)(b | (byte)Math.Pow (2' mBit));  		// Bit setzen  		else  			b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  		// Bit rücksetzen  		return Write (DataType.DataBlock' mDB' mByte' (byte)b);  	case "DBS":  		// DB-String  		return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  	default:  		throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  	}  case "EB":  	// Input Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "EW":  	// Input Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "ED":  	// Input Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "AB":  	// Output Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "AW":  	// Output Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "AD":  	// Output Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "MB":  	// Memory Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "MW":  	// Memory Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "MD":  	// Memory Double-Word  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  	case "Z":  	case "C":  		// Counter  		return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  	default:  		throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  	}  	addressLocation = txt.Substring (1);  	int decimalPointIndex = addressLocation.IndexOf (".");  	if (decimalPointIndex == -1) {  		throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  	}  	mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  	mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	if ((int)value == 1)  		_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  	// Set bit  	else  		_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  	// Reset bit  	return Write (mDataType' 0' mByte' (byte)_byte);  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  	case "DBW":  		if (value is short) {  			objValue = ((short)value).ConvertToUshort ();  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt16));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  	case "DBD":  		if (value is int) {  			return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt32));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		if (Convert.ToInt32 (value) == 1)  			b = (byte)(b | (byte)Math.Pow (2' mBit));  		// Bit setzen  		else  			b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  		// Bit rücksetzen  		return Write (DataType.DataBlock' mDB' mByte' (byte)b);  	case "DBS":  		// DB-String  		return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  	default:  		throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  	}  case "EB":  	// Input Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "EW":  	// Input Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "ED":  	// Input Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "AB":  	// Output Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "AW":  	// Output Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "AD":  	// Output Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "MB":  	// Memory Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "MW":  	// Memory Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "MD":  	// Memory Double-Word  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  	case "Z":  	case "C":  		// Counter  		return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  	default:  		throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  	}  	addressLocation = txt.Substring (1);  	int decimalPointIndex = addressLocation.IndexOf (".");  	if (decimalPointIndex == -1) {  		throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  	}  	mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  	mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	if ((int)value == 1)  		_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  	// Set bit  	else  		_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  	// Reset bit  	return Write (mDataType' 0' mByte' (byte)_byte);  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  	case "DBW":  		if (value is short) {  			objValue = ((short)value).ConvertToUshort ();  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt16));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  	case "DBD":  		if (value is int) {  			return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt32));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		if (Convert.ToInt32 (value) == 1)  			b = (byte)(b | (byte)Math.Pow (2' mBit));  		// Bit setzen  		else  			b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  		// Bit rücksetzen  		return Write (DataType.DataBlock' mDB' mByte' (byte)b);  	case "DBS":  		// DB-String  		return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  	default:  		throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  	}  case "EB":  	// Input Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "EW":  	// Input Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "ED":  	// Input Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "AB":  	// Output Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "AW":  	// Output Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "AD":  	// Output Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "MB":  	// Memory Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "MW":  	// Memory Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "MD":  	// Memory Double-Word  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  	case "Z":  	case "C":  		// Counter  		return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  	default:  		throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  	}  	addressLocation = txt.Substring (1);  	int decimalPointIndex = addressLocation.IndexOf (".");  	if (decimalPointIndex == -1) {  		throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  	}  	mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  	mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	if ((int)value == 1)  		_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  	// Set bit  	else  		_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  	// Reset bit  	return Write (mDataType' 0' mByte' (byte)_byte);  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  	case "DBW":  		if (value is short) {  			objValue = ((short)value).ConvertToUshort ();  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt16));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  	case "DBD":  		if (value is int) {  			return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt32));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		if (Convert.ToInt32 (value) == 1)  			b = (byte)(b | (byte)Math.Pow (2' mBit));  		// Bit setzen  		else  			b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  		// Bit rücksetzen  		return Write (DataType.DataBlock' mDB' mByte' (byte)b);  	case "DBS":  		// DB-String  		return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  	default:  		throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  	}  case "EB":  	// Input Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "EW":  	// Input Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "ED":  	// Input Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "AB":  	// Output Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "AW":  	// Output Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "AD":  	// Output Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "MB":  	// Memory Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "MW":  	// Memory Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "MD":  	// Memory Double-Word  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  	case "Z":  	case "C":  		// Counter  		return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  	default:  		throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  	}  	addressLocation = txt.Substring (1);  	int decimalPointIndex = addressLocation.IndexOf (".");  	if (decimalPointIndex == -1) {  		throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  	}  	mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  	mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	if ((int)value == 1)  		_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  	// Set bit  	else  		_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  	// Reset bit  	return Write (mDataType' 0' mByte' (byte)_byte);  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  	case "DBW":  		if (value is short) {  			objValue = ((short)value).ConvertToUshort ();  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt16));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  	case "DBD":  		if (value is int) {  			return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt32));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		if (Convert.ToInt32 (value) == 1)  			b = (byte)(b | (byte)Math.Pow (2' mBit));  		// Bit setzen  		else  			b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  		// Bit rücksetzen  		return Write (DataType.DataBlock' mDB' mByte' (byte)b);  	case "DBS":  		// DB-String  		return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  	default:  		throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  	}  case "EB":  	// Input Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "EW":  	// Input Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "ED":  	// Input Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "AB":  	// Output Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "AW":  	// Output Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "AD":  	// Output Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "MB":  	// Memory Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "MW":  	// Memory Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "MD":  	// Memory Double-Word  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  	case "Z":  	case "C":  		// Counter  		return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  	default:  		throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  	}  	addressLocation = txt.Substring (1);  	int decimalPointIndex = addressLocation.IndexOf (".");  	if (decimalPointIndex == -1) {  		throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  	}  	mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  	mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	if ((int)value == 1)  		_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  	// Set bit  	else  		_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  	// Reset bit  	return Write (mDataType' 0' mByte' (byte)_byte);  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  	case "DBW":  		if (value is short) {  			objValue = ((short)value).ConvertToUshort ();  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt16));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  	case "DBD":  		if (value is int) {  			return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt32));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		if (Convert.ToInt32 (value) == 1)  			b = (byte)(b | (byte)Math.Pow (2' mBit));  		// Bit setzen  		else  			b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  		// Bit rücksetzen  		return Write (DataType.DataBlock' mDB' mByte' (byte)b);  	case "DBS":  		// DB-String  		return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  	default:  		throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  	}  case "EB":  	// Input Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "EW":  	// Input Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "ED":  	// Input Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "AB":  	// Output Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "AW":  	// Output Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "AD":  	// Output Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "MB":  	// Memory Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "MW":  	// Memory Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "MD":  	// Memory Double-Word  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  	case "Z":  	case "C":  		// Counter  		return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  	default:  		throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  	}  	addressLocation = txt.Substring (1);  	int decimalPointIndex = addressLocation.IndexOf (".");  	if (decimalPointIndex == -1) {  		throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  	}  	mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  	mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	if ((int)value == 1)  		_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  	// Set bit  	else  		_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  	// Reset bit  	return Write (mDataType' 0' mByte' (byte)_byte);  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  	case "DBW":  		if (value is short) {  			objValue = ((short)value).ConvertToUshort ();  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt16));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  	case "DBD":  		if (value is int) {  			return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt32));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		if (Convert.ToInt32 (value) == 1)  			b = (byte)(b | (byte)Math.Pow (2' mBit));  		// Bit setzen  		else  			b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  		// Bit rücksetzen  		return Write (DataType.DataBlock' mDB' mByte' (byte)b);  	case "DBS":  		// DB-String  		return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  	default:  		throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  	}  case "EB":  	// Input Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "EW":  	// Input Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "ED":  	// Input Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "AB":  	// Output Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "AW":  	// Output Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "AD":  	// Output Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "MB":  	// Memory Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "MW":  	// Memory Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "MD":  	// Memory Double-Word  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  	case "Z":  	case "C":  		// Counter  		return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  	default:  		throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  	}  	addressLocation = txt.Substring (1);  	int decimalPointIndex = addressLocation.IndexOf (".");  	if (decimalPointIndex == -1) {  		throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  	}  	mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  	mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	if ((int)value == 1)  		_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  	// Set bit  	else  		_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  	// Reset bit  	return Write (mDataType' 0' mByte' (byte)_byte);  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  	case "DBW":  		if (value is short) {  			objValue = ((short)value).ConvertToUshort ();  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt16));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  	case "DBD":  		if (value is int) {  			return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt32));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		if (Convert.ToInt32 (value) == 1)  			b = (byte)(b | (byte)Math.Pow (2' mBit));  		// Bit setzen  		else  			b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  		// Bit rücksetzen  		return Write (DataType.DataBlock' mDB' mByte' (byte)b);  	case "DBS":  		// DB-String  		return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  	default:  		throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  	}  case "EB":  	// Input Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "EW":  	// Input Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "ED":  	// Input Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "AB":  	// Output Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "AW":  	// Output Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "AD":  	// Output Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "MB":  	// Memory Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "MW":  	// Memory Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "MD":  	// Memory Double-Word  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  	case "Z":  	case "C":  		// Counter  		return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  	default:  		throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  	}  	addressLocation = txt.Substring (1);  	int decimalPointIndex = addressLocation.IndexOf (".");  	if (decimalPointIndex == -1) {  		throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  	}  	mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  	mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	if ((int)value == 1)  		_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  	// Set bit  	else  		_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  	// Reset bit  	return Write (mDataType' 0' mByte' (byte)_byte);  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  	case "DBW":  		if (value is short) {  			objValue = ((short)value).ConvertToUshort ();  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt16));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  	case "DBD":  		if (value is int) {  			return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt32));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		if (Convert.ToInt32 (value) == 1)  			b = (byte)(b | (byte)Math.Pow (2' mBit));  		// Bit setzen  		else  			b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  		// Bit rücksetzen  		return Write (DataType.DataBlock' mDB' mByte' (byte)b);  	case "DBS":  		// DB-String  		return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  	default:  		throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  	}  case "EB":  	// Input Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "EW":  	// Input Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "ED":  	// Input Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "AB":  	// Output Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "AW":  	// Output Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "AD":  	// Output Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "MB":  	// Memory Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "MW":  	// Memory Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "MD":  	// Memory Double-Word  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  	case "Z":  	case "C":  		// Counter  		return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  	default:  		throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  	}  	addressLocation = txt.Substring (1);  	int decimalPointIndex = addressLocation.IndexOf (".");  	if (decimalPointIndex == -1) {  		throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  	}  	mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  	mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	if ((int)value == 1)  		_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  	// Set bit  	else  		_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  	// Reset bit  	return Write (mDataType' 0' mByte' (byte)_byte);  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  	case "DBW":  		if (value is short) {  			objValue = ((short)value).ConvertToUshort ();  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt16));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  	case "DBD":  		if (value is int) {  			return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt32));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		if (Convert.ToInt32 (value) == 1)  			b = (byte)(b | (byte)Math.Pow (2' mBit));  		// Bit setzen  		else  			b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  		// Bit rücksetzen  		return Write (DataType.DataBlock' mDB' mByte' (byte)b);  	case "DBS":  		// DB-String  		return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  	default:  		throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  	}  case "EB":  	// Input Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "EW":  	// Input Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "ED":  	// Input Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "AB":  	// Output Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "AW":  	// Output Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "AD":  	// Output Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "MB":  	// Memory Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "MW":  	// Memory Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "MD":  	// Memory Double-Word  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  	case "Z":  	case "C":  		// Counter  		return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  	default:  		throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  	}  	addressLocation = txt.Substring (1);  	int decimalPointIndex = addressLocation.IndexOf (".");  	if (decimalPointIndex == -1) {  		throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  	}  	mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  	mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	if ((int)value == 1)  		_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  	// Set bit  	else  		_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  	// Reset bit  	return Write (mDataType' 0' mByte' (byte)_byte);  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  	case "DBW":  		if (value is short) {  			objValue = ((short)value).ConvertToUshort ();  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt16));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  	case "DBD":  		if (value is int) {  			return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt32));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		if (Convert.ToInt32 (value) == 1)  			b = (byte)(b | (byte)Math.Pow (2' mBit));  		// Bit setzen  		else  			b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  		// Bit rücksetzen  		return Write (DataType.DataBlock' mDB' mByte' (byte)b);  	case "DBS":  		// DB-String  		return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  	default:  		throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  	}  case "EB":  	// Input Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "EW":  	// Input Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "ED":  	// Input Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "AB":  	// Output Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "AW":  	// Output Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "AD":  	// Output Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "MB":  	// Memory Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "MW":  	// Memory Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "MD":  	// Memory Double-Word  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  	case "Z":  	case "C":  		// Counter  		return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  	default:  		throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  	}  	addressLocation = txt.Substring (1);  	int decimalPointIndex = addressLocation.IndexOf (".");  	if (decimalPointIndex == -1) {  		throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  	}  	mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  	mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	if ((int)value == 1)  		_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  	// Set bit  	else  		_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  	// Reset bit  	return Write (mDataType' 0' mByte' (byte)_byte);  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (txt.Substring (0' 2)) {  case "DB":  	string[] strings = txt.Split (new char[] {  		'.'  	});  	if (strings.Length < 2)  		throw new Exception ();  	mDB = int.Parse (strings [0].Substring (2));  	string dbType = strings [1].Substring (0' 3);  	int dbIndex = int.Parse (strings [1].Substring (3));  	switch (dbType) {  	case "DBB":  		objValue = Convert.ChangeType (value' typeof(byte));  		return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  	case "DBW":  		if (value is short) {  			objValue = ((short)value).ConvertToUshort ();  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt16));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  	case "DBD":  		if (value is int) {  			return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  		} else {  			objValue = Convert.ChangeType (value' typeof(UInt32));  		}  		return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  	case "DBX":  		mByte = dbIndex;  		mBit = int.Parse (strings [2]);  		if (mBit > 7) {  			throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  		}  		byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  		if (Convert.ToInt32 (value) == 1)  			b = (byte)(b | (byte)Math.Pow (2' mBit));  		// Bit setzen  		else  			b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  		// Bit rücksetzen  		return Write (DataType.DataBlock' mDB' mByte' (byte)b);  	case "DBS":  		// DB-String  		return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  	default:  		throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  	}  case "EB":  	// Input Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "EW":  	// Input Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "ED":  	// Input Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "AB":  	// Output Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "AW":  	// Output Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "AD":  	// Output Double-Word  	objValue = Convert.ChangeType (value' typeof(UInt32));  	return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  case "MB":  	// Memory Byte  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  case "MW":  	// Memory Word  	objValue = Convert.ChangeType (value' typeof(UInt16));  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  case "MD":  	// Memory Double-Word  	return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  default:  	switch (txt.Substring (0' 1)) {  	case "E":  	case "I":  		// Input  		mDataType = DataType.Input;  		break;  	case "A":  	case "O":  		// Output  		mDataType = DataType.Output;  		break;  	case "M":  		// Memory  		mDataType = DataType.Memory;  		break;  	case "T":  		// Timer  		return Write (DataType.Timer' 0' int.Parse (txt.Substring (1))' (double)value);  	case "Z":  	case "C":  		// Counter  		return Write (DataType.Counter' 0' int.Parse (txt.Substring (1))' (short)value);  	default:  		throw new Exception (string.Format ("Unknown variable type {0}."' txt.Substring (0' 1)));  	}  	addressLocation = txt.Substring (1);  	int decimalPointIndex = addressLocation.IndexOf (".");  	if (decimalPointIndex == -1) {  		throw new Exception (string.Format ("Cannot parse variable {0}. Input' Output' Memory Address' Timer' and Counter types require bit-level addressing (e.g. I0.1)."' addressLocation));  	}  	mByte = int.Parse (addressLocation.Substring (0' decimalPointIndex));  	mBit = int.Parse (addressLocation.Substring (decimalPointIndex + 1));  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	_byte = (byte)Read (mDataType' 0' mByte' VarType.Byte' 1);  	if ((int)value == 1)  		_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  	// Set bit  	else  		_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  	// Reset bit  	return Write (mDataType' 0' mByte' (byte)_byte);  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: if (strings.Length < 2)  	throw new Exception ();  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: mDB = int.Parse (strings [0].Substring (2));  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (dbType) {  case "DBB":  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  case "DBW":  	if (value is short) {  		objValue = ((short)value).ConvertToUshort ();  	} else {  		objValue = Convert.ChangeType (value' typeof(UInt16));  	}  	return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  case "DBD":  	if (value is int) {  		return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  	} else {  		objValue = Convert.ChangeType (value' typeof(UInt32));  	}  	return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  case "DBX":  	mByte = dbIndex;  	mBit = int.Parse (strings [2]);  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  	if (Convert.ToInt32 (value) == 1)  		b = (byte)(b | (byte)Math.Pow (2' mBit));  	// Bit setzen  	else  		b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  	// Bit rücksetzen  	return Write (DataType.DataBlock' mDB' mByte' (byte)b);  case "DBS":  	// DB-String  	return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  default:  	throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (dbType) {  case "DBB":  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  case "DBW":  	if (value is short) {  		objValue = ((short)value).ConvertToUshort ();  	} else {  		objValue = Convert.ChangeType (value' typeof(UInt16));  	}  	return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  case "DBD":  	if (value is int) {  		return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  	} else {  		objValue = Convert.ChangeType (value' typeof(UInt32));  	}  	return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  case "DBX":  	mByte = dbIndex;  	mBit = int.Parse (strings [2]);  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  	if (Convert.ToInt32 (value) == 1)  		b = (byte)(b | (byte)Math.Pow (2' mBit));  	// Bit setzen  	else  		b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  	// Bit rücksetzen  	return Write (DataType.DataBlock' mDB' mByte' (byte)b);  case "DBS":  	// DB-String  	return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  default:  	throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (dbType) {  case "DBB":  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  case "DBW":  	if (value is short) {  		objValue = ((short)value).ConvertToUshort ();  	} else {  		objValue = Convert.ChangeType (value' typeof(UInt16));  	}  	return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  case "DBD":  	if (value is int) {  		return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  	} else {  		objValue = Convert.ChangeType (value' typeof(UInt32));  	}  	return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  case "DBX":  	mByte = dbIndex;  	mBit = int.Parse (strings [2]);  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  	if (Convert.ToInt32 (value) == 1)  		b = (byte)(b | (byte)Math.Pow (2' mBit));  	// Bit setzen  	else  		b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  	// Bit rücksetzen  	return Write (DataType.DataBlock' mDB' mByte' (byte)b);  case "DBS":  	// DB-String  	return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  default:  	throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: switch (dbType) {  case "DBB":  	objValue = Convert.ChangeType (value' typeof(byte));  	return Write (DataType.DataBlock' mDB' dbIndex' (byte)objValue);  case "DBW":  	if (value is short) {  		objValue = ((short)value).ConvertToUshort ();  	} else {  		objValue = Convert.ChangeType (value' typeof(UInt16));  	}  	return Write (DataType.DataBlock' mDB' dbIndex' (UInt16)objValue);  case "DBD":  	if (value is int) {  		return Write (DataType.DataBlock' mDB' dbIndex' (Int32)value);  	} else {  		objValue = Convert.ChangeType (value' typeof(UInt32));  	}  	return Write (DataType.DataBlock' mDB' dbIndex' (UInt32)objValue);  case "DBX":  	mByte = dbIndex;  	mBit = int.Parse (strings [2]);  	if (mBit > 7) {  		throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  	}  	byte b = (byte)Read (DataType.DataBlock' mDB' mByte' VarType.Byte' 1);  	if (Convert.ToInt32 (value) == 1)  		b = (byte)(b | (byte)Math.Pow (2' mBit));  	// Bit setzen  	else  		b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  	// Bit rücksetzen  	return Write (DataType.DataBlock' mDB' mByte' (byte)b);  case "DBS":  	// DB-String  	return Write (DataType.DataBlock' mDB' dbIndex' (string)value);  default:  	throw new Exception (string.Format ("Addressing Error: Unable to parse address {0}. Supported formats include DBB (byte)' DBW (word)' DBD (dword)' DBX (bitwise)' DBS (string)."' dbType));  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: mBit = int.Parse (strings [2]);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: if (mBit > 7) {  	throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: if (Convert.ToInt32 (value) == 1)  	b = (byte)(b | (byte)Math.Pow (2' mBit));  // Bit setzen  else  	b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: if (Convert.ToInt32 (value) == 1)  	b = (byte)(b | (byte)Math.Pow (2' mBit));  // Bit setzen  else  	b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: b = (byte)(b | (byte)Math.Pow (2' mBit));  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: b = (byte)(b & (b ^ (byte)Math.Pow (2' mBit)));  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (byte)objValue);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: return Write (DataType.Input' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (byte)objValue);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: return Write (DataType.Output' 0' int.Parse (txt.Substring (2))' (UInt32)objValue);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (byte)objValue);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' (UInt16)objValue);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: return Write (DataType.Memory' 0' int.Parse (txt.Substring (2))' value);  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: if (mBit > 7) {  	throw new Exception (string.Format ("Addressing Error: You can only reference bitwise locations 0-7. Address {0} is invalid"' mBit));  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: if ((int)value == 1)  	_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  // Set bit  else  	_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: if ((int)value == 1)  	_byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  // Set bit  else  	_byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: _byte = (byte)(_byte | (byte)Math.Pow (2' mBit));  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,Write,The following statement contains a magic number: _byte = (byte)(_byte & (_byte ^ (byte)Math.Pow (2' mBit)));  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadHeaderPackage,The following statement contains a magic number: package.Add ((byte)(19 + (12 * amount)));  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadHeaderPackage,The following statement contains a magic number: package.Add ((byte)(19 + (12 * amount)));  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadHeaderPackage,The following statement contains a magic number: package.Add (Types.Word.ToByteArray ((ushort)(2 + (amount * 12))));  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadHeaderPackage,The following statement contains a magic number: package.Add (Types.Word.ToByteArray ((ushort)(2 + (amount * 12))));  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,CreateReadDataRequestPackage,The following statement contains a magic number: switch (dataType) {  case DataType.Timer:  case DataType.Counter:  	package.Add (Types.Word.ToByteArray ((ushort)(startByteAdr)));  	break;  default:  	package.Add (Types.Word.ToByteArray ((ushort)((startByteAdr) * 8)));  	break;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,CreateReadDataRequestPackage,The following statement contains a magic number: package.Add (Types.Word.ToByteArray ((ushort)((startByteAdr) * 8)));  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadBytesWithASingleRequest,The following statement contains a magic number: try {  	// first create the header  	int packageSize = 31;  	Types.ByteArray package = new ByteArray (packageSize);  	package.Add (ReadHeaderPackage ());  	// package.Add(0x02);  // datenart  	package.Add (CreateReadDataRequestPackage (dataType' db' startByteAdr' count));  	_mSocket.Send (package.array' package.array.Length' SocketFlags.None);  	byte[] bReceive = new byte[512];  	int numReceived = _mSocket.Receive (bReceive' 512' SocketFlags.None);  	if (bReceive [21] != 0xff)  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	for (int cnt = 0; cnt < count; cnt++)  		bytes [cnt] = bReceive [cnt + 25];  	return bytes;  } catch (SocketException socketException) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = socketException.Message;  	return null;  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = exc.Message;  	return null;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadBytesWithASingleRequest,The following statement contains a magic number: try {  	// first create the header  	int packageSize = 31;  	Types.ByteArray package = new ByteArray (packageSize);  	package.Add (ReadHeaderPackage ());  	// package.Add(0x02);  // datenart  	package.Add (CreateReadDataRequestPackage (dataType' db' startByteAdr' count));  	_mSocket.Send (package.array' package.array.Length' SocketFlags.None);  	byte[] bReceive = new byte[512];  	int numReceived = _mSocket.Receive (bReceive' 512' SocketFlags.None);  	if (bReceive [21] != 0xff)  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	for (int cnt = 0; cnt < count; cnt++)  		bytes [cnt] = bReceive [cnt + 25];  	return bytes;  } catch (SocketException socketException) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = socketException.Message;  	return null;  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = exc.Message;  	return null;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadBytesWithASingleRequest,The following statement contains a magic number: try {  	// first create the header  	int packageSize = 31;  	Types.ByteArray package = new ByteArray (packageSize);  	package.Add (ReadHeaderPackage ());  	// package.Add(0x02);  // datenart  	package.Add (CreateReadDataRequestPackage (dataType' db' startByteAdr' count));  	_mSocket.Send (package.array' package.array.Length' SocketFlags.None);  	byte[] bReceive = new byte[512];  	int numReceived = _mSocket.Receive (bReceive' 512' SocketFlags.None);  	if (bReceive [21] != 0xff)  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	for (int cnt = 0; cnt < count; cnt++)  		bytes [cnt] = bReceive [cnt + 25];  	return bytes;  } catch (SocketException socketException) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = socketException.Message;  	return null;  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = exc.Message;  	return null;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadBytesWithASingleRequest,The following statement contains a magic number: try {  	// first create the header  	int packageSize = 31;  	Types.ByteArray package = new ByteArray (packageSize);  	package.Add (ReadHeaderPackage ());  	// package.Add(0x02);  // datenart  	package.Add (CreateReadDataRequestPackage (dataType' db' startByteAdr' count));  	_mSocket.Send (package.array' package.array.Length' SocketFlags.None);  	byte[] bReceive = new byte[512];  	int numReceived = _mSocket.Receive (bReceive' 512' SocketFlags.None);  	if (bReceive [21] != 0xff)  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	for (int cnt = 0; cnt < count; cnt++)  		bytes [cnt] = bReceive [cnt + 25];  	return bytes;  } catch (SocketException socketException) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = socketException.Message;  	return null;  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = exc.Message;  	return null;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadBytesWithASingleRequest,The following statement contains a magic number: try {  	// first create the header  	int packageSize = 31;  	Types.ByteArray package = new ByteArray (packageSize);  	package.Add (ReadHeaderPackage ());  	// package.Add(0x02);  // datenart  	package.Add (CreateReadDataRequestPackage (dataType' db' startByteAdr' count));  	_mSocket.Send (package.array' package.array.Length' SocketFlags.None);  	byte[] bReceive = new byte[512];  	int numReceived = _mSocket.Receive (bReceive' 512' SocketFlags.None);  	if (bReceive [21] != 0xff)  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	for (int cnt = 0; cnt < count; cnt++)  		bytes [cnt] = bReceive [cnt + 25];  	return bytes;  } catch (SocketException socketException) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = socketException.Message;  	return null;  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = exc.Message;  	return null;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadBytesWithASingleRequest,The following statement contains a magic number: if (bReceive [21] != 0xff)  	throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadBytesWithASingleRequest,The following statement contains a magic number: for (int cnt = 0; cnt < count; cnt++)  	bytes [cnt] = bReceive [cnt + 25];  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,ReadBytesWithASingleRequest,The following statement contains a magic number: bytes [cnt] = bReceive [cnt + 25];  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: try {  	varCount = value.Length;  	// first create the header  	int packageSize = 35 + value.Length;  	Types.ByteArray package = new Types.ByteArray (packageSize);  	package.Add (new byte[] {  		3'  		0'  		0  	});  	package.Add ((byte)packageSize);  	package.Add (new byte[] {  		2'  		0xf0'  		0x80'  		0x32'  		1'  		0'  		0  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount - 1)));  	package.Add (new byte[] {  		0'  		0x0e  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount + 4)));  	package.Add (new byte[] {  		0x05'  		0x01'  		0x12'  		0x0a'  		0x10'  		0x02  	});  	package.Add (Types.Word.ToByteArray ((ushort)varCount));  	package.Add (Types.Word.ToByteArray ((ushort)(db)));  	package.Add ((byte)dataType);  	var overflow = (int)(startByteAdr * 8 / 0xffffU);  	// handles words with address bigger than 8191  	package.Add ((byte)overflow);  	package.Add (Types.Word.ToByteArray ((ushort)(startByteAdr * 8)));  	package.Add (new byte[] {  		0'  		4  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount * 8)));  	// now join the header and the data  	package.Add (value);  	_mSocket.Send (package.array' package.array.Length' SocketFlags.None);  	int numReceived = _mSocket.Receive (bReceive' 512' SocketFlags.None);  	if (bReceive [21] != 0xff) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	return ErrorCode.NoError;  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: try {  	varCount = value.Length;  	// first create the header  	int packageSize = 35 + value.Length;  	Types.ByteArray package = new Types.ByteArray (packageSize);  	package.Add (new byte[] {  		3'  		0'  		0  	});  	package.Add ((byte)packageSize);  	package.Add (new byte[] {  		2'  		0xf0'  		0x80'  		0x32'  		1'  		0'  		0  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount - 1)));  	package.Add (new byte[] {  		0'  		0x0e  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount + 4)));  	package.Add (new byte[] {  		0x05'  		0x01'  		0x12'  		0x0a'  		0x10'  		0x02  	});  	package.Add (Types.Word.ToByteArray ((ushort)varCount));  	package.Add (Types.Word.ToByteArray ((ushort)(db)));  	package.Add ((byte)dataType);  	var overflow = (int)(startByteAdr * 8 / 0xffffU);  	// handles words with address bigger than 8191  	package.Add ((byte)overflow);  	package.Add (Types.Word.ToByteArray ((ushort)(startByteAdr * 8)));  	package.Add (new byte[] {  		0'  		4  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount * 8)));  	// now join the header and the data  	package.Add (value);  	_mSocket.Send (package.array' package.array.Length' SocketFlags.None);  	int numReceived = _mSocket.Receive (bReceive' 512' SocketFlags.None);  	if (bReceive [21] != 0xff) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	return ErrorCode.NoError;  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: try {  	varCount = value.Length;  	// first create the header  	int packageSize = 35 + value.Length;  	Types.ByteArray package = new Types.ByteArray (packageSize);  	package.Add (new byte[] {  		3'  		0'  		0  	});  	package.Add ((byte)packageSize);  	package.Add (new byte[] {  		2'  		0xf0'  		0x80'  		0x32'  		1'  		0'  		0  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount - 1)));  	package.Add (new byte[] {  		0'  		0x0e  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount + 4)));  	package.Add (new byte[] {  		0x05'  		0x01'  		0x12'  		0x0a'  		0x10'  		0x02  	});  	package.Add (Types.Word.ToByteArray ((ushort)varCount));  	package.Add (Types.Word.ToByteArray ((ushort)(db)));  	package.Add ((byte)dataType);  	var overflow = (int)(startByteAdr * 8 / 0xffffU);  	// handles words with address bigger than 8191  	package.Add ((byte)overflow);  	package.Add (Types.Word.ToByteArray ((ushort)(startByteAdr * 8)));  	package.Add (new byte[] {  		0'  		4  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount * 8)));  	// now join the header and the data  	package.Add (value);  	_mSocket.Send (package.array' package.array.Length' SocketFlags.None);  	int numReceived = _mSocket.Receive (bReceive' 512' SocketFlags.None);  	if (bReceive [21] != 0xff) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	return ErrorCode.NoError;  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: try {  	varCount = value.Length;  	// first create the header  	int packageSize = 35 + value.Length;  	Types.ByteArray package = new Types.ByteArray (packageSize);  	package.Add (new byte[] {  		3'  		0'  		0  	});  	package.Add ((byte)packageSize);  	package.Add (new byte[] {  		2'  		0xf0'  		0x80'  		0x32'  		1'  		0'  		0  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount - 1)));  	package.Add (new byte[] {  		0'  		0x0e  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount + 4)));  	package.Add (new byte[] {  		0x05'  		0x01'  		0x12'  		0x0a'  		0x10'  		0x02  	});  	package.Add (Types.Word.ToByteArray ((ushort)varCount));  	package.Add (Types.Word.ToByteArray ((ushort)(db)));  	package.Add ((byte)dataType);  	var overflow = (int)(startByteAdr * 8 / 0xffffU);  	// handles words with address bigger than 8191  	package.Add ((byte)overflow);  	package.Add (Types.Word.ToByteArray ((ushort)(startByteAdr * 8)));  	package.Add (new byte[] {  		0'  		4  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount * 8)));  	// now join the header and the data  	package.Add (value);  	_mSocket.Send (package.array' package.array.Length' SocketFlags.None);  	int numReceived = _mSocket.Receive (bReceive' 512' SocketFlags.None);  	if (bReceive [21] != 0xff) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	return ErrorCode.NoError;  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: try {  	varCount = value.Length;  	// first create the header  	int packageSize = 35 + value.Length;  	Types.ByteArray package = new Types.ByteArray (packageSize);  	package.Add (new byte[] {  		3'  		0'  		0  	});  	package.Add ((byte)packageSize);  	package.Add (new byte[] {  		2'  		0xf0'  		0x80'  		0x32'  		1'  		0'  		0  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount - 1)));  	package.Add (new byte[] {  		0'  		0x0e  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount + 4)));  	package.Add (new byte[] {  		0x05'  		0x01'  		0x12'  		0x0a'  		0x10'  		0x02  	});  	package.Add (Types.Word.ToByteArray ((ushort)varCount));  	package.Add (Types.Word.ToByteArray ((ushort)(db)));  	package.Add ((byte)dataType);  	var overflow = (int)(startByteAdr * 8 / 0xffffU);  	// handles words with address bigger than 8191  	package.Add ((byte)overflow);  	package.Add (Types.Word.ToByteArray ((ushort)(startByteAdr * 8)));  	package.Add (new byte[] {  		0'  		4  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount * 8)));  	// now join the header and the data  	package.Add (value);  	_mSocket.Send (package.array' package.array.Length' SocketFlags.None);  	int numReceived = _mSocket.Receive (bReceive' 512' SocketFlags.None);  	if (bReceive [21] != 0xff) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	return ErrorCode.NoError;  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: try {  	varCount = value.Length;  	// first create the header  	int packageSize = 35 + value.Length;  	Types.ByteArray package = new Types.ByteArray (packageSize);  	package.Add (new byte[] {  		3'  		0'  		0  	});  	package.Add ((byte)packageSize);  	package.Add (new byte[] {  		2'  		0xf0'  		0x80'  		0x32'  		1'  		0'  		0  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount - 1)));  	package.Add (new byte[] {  		0'  		0x0e  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount + 4)));  	package.Add (new byte[] {  		0x05'  		0x01'  		0x12'  		0x0a'  		0x10'  		0x02  	});  	package.Add (Types.Word.ToByteArray ((ushort)varCount));  	package.Add (Types.Word.ToByteArray ((ushort)(db)));  	package.Add ((byte)dataType);  	var overflow = (int)(startByteAdr * 8 / 0xffffU);  	// handles words with address bigger than 8191  	package.Add ((byte)overflow);  	package.Add (Types.Word.ToByteArray ((ushort)(startByteAdr * 8)));  	package.Add (new byte[] {  		0'  		4  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount * 8)));  	// now join the header and the data  	package.Add (value);  	_mSocket.Send (package.array' package.array.Length' SocketFlags.None);  	int numReceived = _mSocket.Receive (bReceive' 512' SocketFlags.None);  	if (bReceive [21] != 0xff) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	return ErrorCode.NoError;  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: try {  	varCount = value.Length;  	// first create the header  	int packageSize = 35 + value.Length;  	Types.ByteArray package = new Types.ByteArray (packageSize);  	package.Add (new byte[] {  		3'  		0'  		0  	});  	package.Add ((byte)packageSize);  	package.Add (new byte[] {  		2'  		0xf0'  		0x80'  		0x32'  		1'  		0'  		0  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount - 1)));  	package.Add (new byte[] {  		0'  		0x0e  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount + 4)));  	package.Add (new byte[] {  		0x05'  		0x01'  		0x12'  		0x0a'  		0x10'  		0x02  	});  	package.Add (Types.Word.ToByteArray ((ushort)varCount));  	package.Add (Types.Word.ToByteArray ((ushort)(db)));  	package.Add ((byte)dataType);  	var overflow = (int)(startByteAdr * 8 / 0xffffU);  	// handles words with address bigger than 8191  	package.Add ((byte)overflow);  	package.Add (Types.Word.ToByteArray ((ushort)(startByteAdr * 8)));  	package.Add (new byte[] {  		0'  		4  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount * 8)));  	// now join the header and the data  	package.Add (value);  	_mSocket.Send (package.array' package.array.Length' SocketFlags.None);  	int numReceived = _mSocket.Receive (bReceive' 512' SocketFlags.None);  	if (bReceive [21] != 0xff) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	return ErrorCode.NoError;  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: try {  	varCount = value.Length;  	// first create the header  	int packageSize = 35 + value.Length;  	Types.ByteArray package = new Types.ByteArray (packageSize);  	package.Add (new byte[] {  		3'  		0'  		0  	});  	package.Add ((byte)packageSize);  	package.Add (new byte[] {  		2'  		0xf0'  		0x80'  		0x32'  		1'  		0'  		0  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount - 1)));  	package.Add (new byte[] {  		0'  		0x0e  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount + 4)));  	package.Add (new byte[] {  		0x05'  		0x01'  		0x12'  		0x0a'  		0x10'  		0x02  	});  	package.Add (Types.Word.ToByteArray ((ushort)varCount));  	package.Add (Types.Word.ToByteArray ((ushort)(db)));  	package.Add ((byte)dataType);  	var overflow = (int)(startByteAdr * 8 / 0xffffU);  	// handles words with address bigger than 8191  	package.Add ((byte)overflow);  	package.Add (Types.Word.ToByteArray ((ushort)(startByteAdr * 8)));  	package.Add (new byte[] {  		0'  		4  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount * 8)));  	// now join the header and the data  	package.Add (value);  	_mSocket.Send (package.array' package.array.Length' SocketFlags.None);  	int numReceived = _mSocket.Receive (bReceive' 512' SocketFlags.None);  	if (bReceive [21] != 0xff) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	return ErrorCode.NoError;  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: try {  	varCount = value.Length;  	// first create the header  	int packageSize = 35 + value.Length;  	Types.ByteArray package = new Types.ByteArray (packageSize);  	package.Add (new byte[] {  		3'  		0'  		0  	});  	package.Add ((byte)packageSize);  	package.Add (new byte[] {  		2'  		0xf0'  		0x80'  		0x32'  		1'  		0'  		0  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount - 1)));  	package.Add (new byte[] {  		0'  		0x0e  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount + 4)));  	package.Add (new byte[] {  		0x05'  		0x01'  		0x12'  		0x0a'  		0x10'  		0x02  	});  	package.Add (Types.Word.ToByteArray ((ushort)varCount));  	package.Add (Types.Word.ToByteArray ((ushort)(db)));  	package.Add ((byte)dataType);  	var overflow = (int)(startByteAdr * 8 / 0xffffU);  	// handles words with address bigger than 8191  	package.Add ((byte)overflow);  	package.Add (Types.Word.ToByteArray ((ushort)(startByteAdr * 8)));  	package.Add (new byte[] {  		0'  		4  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount * 8)));  	// now join the header and the data  	package.Add (value);  	_mSocket.Send (package.array' package.array.Length' SocketFlags.None);  	int numReceived = _mSocket.Receive (bReceive' 512' SocketFlags.None);  	if (bReceive [21] != 0xff) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	return ErrorCode.NoError;  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: try {  	varCount = value.Length;  	// first create the header  	int packageSize = 35 + value.Length;  	Types.ByteArray package = new Types.ByteArray (packageSize);  	package.Add (new byte[] {  		3'  		0'  		0  	});  	package.Add ((byte)packageSize);  	package.Add (new byte[] {  		2'  		0xf0'  		0x80'  		0x32'  		1'  		0'  		0  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount - 1)));  	package.Add (new byte[] {  		0'  		0x0e  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount + 4)));  	package.Add (new byte[] {  		0x05'  		0x01'  		0x12'  		0x0a'  		0x10'  		0x02  	});  	package.Add (Types.Word.ToByteArray ((ushort)varCount));  	package.Add (Types.Word.ToByteArray ((ushort)(db)));  	package.Add ((byte)dataType);  	var overflow = (int)(startByteAdr * 8 / 0xffffU);  	// handles words with address bigger than 8191  	package.Add ((byte)overflow);  	package.Add (Types.Word.ToByteArray ((ushort)(startByteAdr * 8)));  	package.Add (new byte[] {  		0'  		4  	});  	package.Add (Types.Word.ToByteArray ((ushort)(varCount * 8)));  	// now join the header and the data  	package.Add (value);  	_mSocket.Send (package.array' package.array.Length' SocketFlags.None);  	int numReceived = _mSocket.Receive (bReceive' 512' SocketFlags.None);  	if (bReceive [21] != 0xff) {  		throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  	}  	return ErrorCode.NoError;  } catch (Exception exc) {  	LastErrorCode = ErrorCode.WriteData;  	LastErrorString = exc.Message;  	return LastErrorCode;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: package.Add (new byte[] {  	3'  	0'  	0  });  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: package.Add (new byte[] {  	2'  	0xf0'  	0x80'  	0x32'  	1'  	0'  	0  });  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: package.Add (Types.Word.ToByteArray ((ushort)(varCount + 4)));  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: package.Add (Types.Word.ToByteArray ((ushort)(startByteAdr * 8)));  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: package.Add (new byte[] {  	0'  	4  });  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: package.Add (Types.Word.ToByteArray ((ushort)(varCount * 8)));  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,WriteBytesWithASingleRequest,The following statement contains a magic number: if (bReceive [21] != 0xff) {  	throw new Exception (ErrorCode.WrongNumberReceivedBytes.ToString ());  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,VarTypeToByteLength,The following statement contains a magic number: switch (varType) {  case VarType.Bit:  	return varCount;  //TODO  case VarType.Byte:  	return (varCount < 1) ? 1 : varCount;  case VarType.String:  	return varCount;  case VarType.Word:  case VarType.Timer:  case VarType.Int:  case VarType.Counter:  	return varCount * 2;  case VarType.DWord:  case VarType.DInt:  case VarType.Real:  	return varCount * 4;  default:  	return 0;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,VarTypeToByteLength,The following statement contains a magic number: switch (varType) {  case VarType.Bit:  	return varCount;  //TODO  case VarType.Byte:  	return (varCount < 1) ? 1 : varCount;  case VarType.String:  	return varCount;  case VarType.Word:  case VarType.Timer:  case VarType.Int:  case VarType.Counter:  	return varCount * 2;  case VarType.DWord:  case VarType.DInt:  case VarType.Real:  	return varCount * 4;  default:  	return 0;  }  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,VarTypeToByteLength,The following statement contains a magic number: return varCount * 2;  
Magic Number,S7.Net,Plc,F:\newReposMay17\killnine_s7netplus\S7.Net\PLC.cs,VarTypeToByteLength,The following statement contains a magic number: return varCount * 4;  
Magic Number,S7.Net.Types,Boolean,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Boolean.cs,GetValue,The following statement contains a magic number: if ((value & (int)Math.Pow (2' bit)) != 0)  	return true;  else  	return false;  
Magic Number,S7.Net.Types,Boolean,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Boolean.cs,SetBit,The following statement contains a magic number: return (byte)(value | (byte)Math.Pow (2' bit));  
Magic Number,S7.Net.Types,Boolean,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Boolean.cs,ClearBit,The following statement contains a magic number: return (byte)(value & (byte)(~(byte)Math.Pow (2' bit)));  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		numBytes++;  		break;  	case "Int16":  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 2;  		break;  	case "Int32":  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	case "Float":  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	default:  		numBytes += GetClassSize (property.PropertyType);  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		numBytes++;  		break;  	case "Int16":  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 2;  		break;  	case "Int32":  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	case "Float":  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	default:  		numBytes += GetClassSize (property.PropertyType);  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		numBytes++;  		break;  	case "Int16":  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 2;  		break;  	case "Int32":  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	case "Float":  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	default:  		numBytes += GetClassSize (property.PropertyType);  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		numBytes++;  		break;  	case "Int16":  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 2;  		break;  	case "Int32":  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	case "Float":  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	default:  		numBytes += GetClassSize (property.PropertyType);  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		numBytes++;  		break;  	case "Int16":  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 2;  		break;  	case "Int32":  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	case "Float":  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	default:  		numBytes += GetClassSize (property.PropertyType);  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		numBytes++;  		break;  	case "Int16":  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 2;  		break;  	case "Int32":  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	case "Float":  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	default:  		numBytes += GetClassSize (property.PropertyType);  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		numBytes++;  		break;  	case "Int16":  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 2;  		break;  	case "Int32":  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	case "Float":  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	default:  		numBytes += GetClassSize (property.PropertyType);  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		numBytes++;  		break;  	case "Int16":  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 2;  		break;  	case "Int32":  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	case "Float":  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	default:  		numBytes += GetClassSize (property.PropertyType);  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		numBytes++;  		break;  	case "Int16":  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 2;  		break;  	case "Int32":  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	case "Float":  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	default:  		numBytes += GetClassSize (property.PropertyType);  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		numBytes++;  		break;  	case "Int16":  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 2;  		break;  	case "Int32":  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	case "Float":  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	default:  		numBytes += GetClassSize (property.PropertyType);  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	numBytes++;  	break;  case "Int16":  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 2;  	break;  case "Int32":  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  case "Float":  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  default:  	numBytes += GetClassSize (property.PropertyType);  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	numBytes++;  	break;  case "Int16":  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 2;  	break;  case "Int32":  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  case "Float":  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  default:  	numBytes += GetClassSize (property.PropertyType);  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	numBytes++;  	break;  case "Int16":  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 2;  	break;  case "Int32":  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  case "Float":  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  default:  	numBytes += GetClassSize (property.PropertyType);  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	numBytes++;  	break;  case "Int16":  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 2;  	break;  case "Int32":  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  case "Float":  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  default:  	numBytes += GetClassSize (property.PropertyType);  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	numBytes++;  	break;  case "Int16":  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 2;  	break;  case "Int32":  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  case "Float":  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  default:  	numBytes += GetClassSize (property.PropertyType);  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	numBytes++;  	break;  case "Int16":  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 2;  	break;  case "Int32":  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  case "Float":  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  default:  	numBytes += GetClassSize (property.PropertyType);  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	numBytes++;  	break;  case "Int16":  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 2;  	break;  case "Int32":  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  case "Float":  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  default:  	numBytes += GetClassSize (property.PropertyType);  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	numBytes++;  	break;  case "Int16":  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 2;  	break;  case "Int32":  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  case "Float":  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  default:  	numBytes += GetClassSize (property.PropertyType);  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	numBytes++;  	break;  case "Int16":  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 2;  	break;  case "Int32":  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  case "Float":  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  default:  	numBytes += GetClassSize (property.PropertyType);  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	numBytes++;  	break;  case "Int16":  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 2;  	break;  case "Int32":  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  case "Float":  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  default:  	numBytes += GetClassSize (property.PropertyType);  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: numBytes += 0.125;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: numBytes += 2;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: numBytes += 4;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,GetClassSize,The following statement contains a magic number: numBytes += 4;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			property.SetValue (sourceClass' true' null);  		else  			property.SetValue (sourceClass' false' null);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		property.SetValue (sourceClass' source.ConvertToShort ()' null);  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		})' null);  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetClassSize (property.PropertyType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		var propClass = Activator.CreateInstance (property.PropertyType);  		FromBytes (propClass' property.PropertyType' buffer);  		property.SetValue (sourceClass' propClass' null);  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			property.SetValue (sourceClass' true' null);  		else  			property.SetValue (sourceClass' false' null);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		property.SetValue (sourceClass' source.ConvertToShort ()' null);  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		})' null);  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetClassSize (property.PropertyType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		var propClass = Activator.CreateInstance (property.PropertyType);  		FromBytes (propClass' property.PropertyType' buffer);  		property.SetValue (sourceClass' propClass' null);  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			property.SetValue (sourceClass' true' null);  		else  			property.SetValue (sourceClass' false' null);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		property.SetValue (sourceClass' source.ConvertToShort ()' null);  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		})' null);  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetClassSize (property.PropertyType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		var propClass = Activator.CreateInstance (property.PropertyType);  		FromBytes (propClass' property.PropertyType' buffer);  		property.SetValue (sourceClass' propClass' null);  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			property.SetValue (sourceClass' true' null);  		else  			property.SetValue (sourceClass' false' null);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		property.SetValue (sourceClass' source.ConvertToShort ()' null);  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		})' null);  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetClassSize (property.PropertyType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		var propClass = Activator.CreateInstance (property.PropertyType);  		FromBytes (propClass' property.PropertyType' buffer);  		property.SetValue (sourceClass' propClass' null);  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			property.SetValue (sourceClass' true' null);  		else  			property.SetValue (sourceClass' false' null);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		property.SetValue (sourceClass' source.ConvertToShort ()' null);  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		})' null);  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetClassSize (property.PropertyType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		var propClass = Activator.CreateInstance (property.PropertyType);  		FromBytes (propClass' property.PropertyType' buffer);  		property.SetValue (sourceClass' propClass' null);  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			property.SetValue (sourceClass' true' null);  		else  			property.SetValue (sourceClass' false' null);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		property.SetValue (sourceClass' source.ConvertToShort ()' null);  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		})' null);  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetClassSize (property.PropertyType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		var propClass = Activator.CreateInstance (property.PropertyType);  		FromBytes (propClass' property.PropertyType' buffer);  		property.SetValue (sourceClass' propClass' null);  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			property.SetValue (sourceClass' true' null);  		else  			property.SetValue (sourceClass' false' null);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		property.SetValue (sourceClass' source.ConvertToShort ()' null);  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		})' null);  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetClassSize (property.PropertyType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		var propClass = Activator.CreateInstance (property.PropertyType);  		FromBytes (propClass' property.PropertyType' buffer);  		property.SetValue (sourceClass' propClass' null);  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			property.SetValue (sourceClass' true' null);  		else  			property.SetValue (sourceClass' false' null);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		property.SetValue (sourceClass' source.ConvertToShort ()' null);  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		})' null);  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetClassSize (property.PropertyType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		var propClass = Activator.CreateInstance (property.PropertyType);  		FromBytes (propClass' property.PropertyType' buffer);  		property.SetValue (sourceClass' propClass' null);  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			property.SetValue (sourceClass' true' null);  		else  			property.SetValue (sourceClass' false' null);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		property.SetValue (sourceClass' source.ConvertToShort ()' null);  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		})' null);  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetClassSize (property.PropertyType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		var propClass = Activator.CreateInstance (property.PropertyType);  		FromBytes (propClass' property.PropertyType' buffer);  		property.SetValue (sourceClass' propClass' null);  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			property.SetValue (sourceClass' true' null);  		else  			property.SetValue (sourceClass' false' null);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		property.SetValue (sourceClass' source.ConvertToShort ()' null);  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		})' null);  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetClassSize (property.PropertyType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		var propClass = Activator.CreateInstance (property.PropertyType);  		FromBytes (propClass' property.PropertyType' buffer);  		property.SetValue (sourceClass' propClass' null);  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			property.SetValue (sourceClass' true' null);  		else  			property.SetValue (sourceClass' false' null);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		property.SetValue (sourceClass' source.ConvertToShort ()' null);  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		})' null);  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetClassSize (property.PropertyType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		var propClass = Activator.CreateInstance (property.PropertyType);  		FromBytes (propClass' property.PropertyType' buffer);  		property.SetValue (sourceClass' propClass' null);  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			property.SetValue (sourceClass' true' null);  		else  			property.SetValue (sourceClass' false' null);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		property.SetValue (sourceClass' source.ConvertToShort ()' null);  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		})' null);  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetClassSize (property.PropertyType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		var propClass = Activator.CreateInstance (property.PropertyType);  		FromBytes (propClass' property.PropertyType' buffer);  		property.SetValue (sourceClass' propClass' null);  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			property.SetValue (sourceClass' true' null);  		else  			property.SetValue (sourceClass' false' null);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		property.SetValue (sourceClass' source.ConvertToShort ()' null);  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		})' null);  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetClassSize (property.PropertyType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		var propClass = Activator.CreateInstance (property.PropertyType);  		FromBytes (propClass' property.PropertyType' buffer);  		property.SetValue (sourceClass' propClass' null);  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			property.SetValue (sourceClass' true' null);  		else  			property.SetValue (sourceClass' false' null);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		property.SetValue (sourceClass' source.ConvertToShort ()' null);  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		})' null);  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetClassSize (property.PropertyType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		var propClass = Activator.CreateInstance (property.PropertyType);  		FromBytes (propClass' property.PropertyType' buffer);  		property.SetValue (sourceClass' propClass' null);  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			property.SetValue (sourceClass' true' null);  		else  			property.SetValue (sourceClass' false' null);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		property.SetValue (sourceClass' source.ConvertToShort ()' null);  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		})' null);  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetClassSize (property.PropertyType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		var propClass = Activator.CreateInstance (property.PropertyType);  		FromBytes (propClass' property.PropertyType' buffer);  		property.SetValue (sourceClass' propClass' null);  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			property.SetValue (sourceClass' true' null);  		else  			property.SetValue (sourceClass' false' null);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		property.SetValue (sourceClass' source.ConvertToShort ()' null);  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		})' null);  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetClassSize (property.PropertyType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		var propClass = Activator.CreateInstance (property.PropertyType);  		FromBytes (propClass' property.PropertyType' buffer);  		property.SetValue (sourceClass' propClass' null);  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			property.SetValue (sourceClass' true' null);  		else  			property.SetValue (sourceClass' false' null);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		property.SetValue (sourceClass' source.ConvertToShort ()' null);  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		})' null);  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetClassSize (property.PropertyType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		var propClass = Activator.CreateInstance (property.PropertyType);  		FromBytes (propClass' property.PropertyType' buffer);  		property.SetValue (sourceClass' propClass' null);  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			property.SetValue (sourceClass' true' null);  		else  			property.SetValue (sourceClass' false' null);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		property.SetValue (sourceClass' source.ConvertToShort ()' null);  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		})' null);  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetClassSize (property.PropertyType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		var propClass = Activator.CreateInstance (property.PropertyType);  		FromBytes (propClass' property.PropertyType' buffer);  		property.SetValue (sourceClass' propClass' null);  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			property.SetValue (sourceClass' true' null);  		else  			property.SetValue (sourceClass' false' null);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		property.SetValue (sourceClass' source.ConvertToShort ()' null);  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		})' null);  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetClassSize (property.PropertyType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		var propClass = Activator.CreateInstance (property.PropertyType);  		FromBytes (propClass' property.PropertyType' buffer);  		property.SetValue (sourceClass' propClass' null);  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			property.SetValue (sourceClass' true' null);  		else  			property.SetValue (sourceClass' false' null);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		property.SetValue (sourceClass' source.ConvertToShort ()' null);  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		})' null);  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetClassSize (property.PropertyType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		var propClass = Activator.CreateInstance (property.PropertyType);  		FromBytes (propClass' property.PropertyType' buffer);  		property.SetValue (sourceClass' propClass' null);  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			property.SetValue (sourceClass' true' null);  		else  			property.SetValue (sourceClass' false' null);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		property.SetValue (sourceClass' source.ConvertToShort ()' null);  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		})' null);  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetClassSize (property.PropertyType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		var propClass = Activator.CreateInstance (property.PropertyType);  		FromBytes (propClass' property.PropertyType' buffer);  		property.SetValue (sourceClass' propClass' null);  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			property.SetValue (sourceClass' true' null);  		else  			property.SetValue (sourceClass' false' null);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		property.SetValue (sourceClass' source.ConvertToShort ()' null);  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		})' null);  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetClassSize (property.PropertyType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		var propClass = Activator.CreateInstance (property.PropertyType);  		FromBytes (propClass' property.PropertyType' buffer);  		property.SetValue (sourceClass' propClass' null);  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			property.SetValue (sourceClass' true' null);  		else  			property.SetValue (sourceClass' false' null);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		property.SetValue (sourceClass' source.ConvertToShort ()' null);  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		})' null);  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetClassSize (property.PropertyType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		var propClass = Activator.CreateInstance (property.PropertyType);  		FromBytes (propClass' property.PropertyType' buffer);  		property.SetValue (sourceClass' propClass' null);  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: foreach (var property in properties) {  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			property.SetValue (sourceClass' true' null);  		else  			property.SetValue (sourceClass' false' null);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		property.SetValue (sourceClass' source.ConvertToShort ()' null);  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		})' null);  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetClassSize (property.PropertyType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		var propClass = Activator.CreateInstance (property.PropertyType);  		FromBytes (propClass' property.PropertyType' buffer);  		property.SetValue (sourceClass' propClass' null);  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		property.SetValue (sourceClass' true' null);  	else  		property.SetValue (sourceClass' false' null);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	property.SetValue (sourceClass' source.ConvertToShort ()' null);  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	})' null);  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetClassSize (property.PropertyType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	var propClass = Activator.CreateInstance (property.PropertyType);  	FromBytes (propClass' property.PropertyType' buffer);  	property.SetValue (sourceClass' propClass' null);  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		property.SetValue (sourceClass' true' null);  	else  		property.SetValue (sourceClass' false' null);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	property.SetValue (sourceClass' source.ConvertToShort ()' null);  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	})' null);  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetClassSize (property.PropertyType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	var propClass = Activator.CreateInstance (property.PropertyType);  	FromBytes (propClass' property.PropertyType' buffer);  	property.SetValue (sourceClass' propClass' null);  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		property.SetValue (sourceClass' true' null);  	else  		property.SetValue (sourceClass' false' null);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	property.SetValue (sourceClass' source.ConvertToShort ()' null);  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	})' null);  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetClassSize (property.PropertyType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	var propClass = Activator.CreateInstance (property.PropertyType);  	FromBytes (propClass' property.PropertyType' buffer);  	property.SetValue (sourceClass' propClass' null);  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		property.SetValue (sourceClass' true' null);  	else  		property.SetValue (sourceClass' false' null);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	property.SetValue (sourceClass' source.ConvertToShort ()' null);  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	})' null);  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetClassSize (property.PropertyType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	var propClass = Activator.CreateInstance (property.PropertyType);  	FromBytes (propClass' property.PropertyType' buffer);  	property.SetValue (sourceClass' propClass' null);  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		property.SetValue (sourceClass' true' null);  	else  		property.SetValue (sourceClass' false' null);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	property.SetValue (sourceClass' source.ConvertToShort ()' null);  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	})' null);  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetClassSize (property.PropertyType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	var propClass = Activator.CreateInstance (property.PropertyType);  	FromBytes (propClass' property.PropertyType' buffer);  	property.SetValue (sourceClass' propClass' null);  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		property.SetValue (sourceClass' true' null);  	else  		property.SetValue (sourceClass' false' null);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	property.SetValue (sourceClass' source.ConvertToShort ()' null);  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	})' null);  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetClassSize (property.PropertyType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	var propClass = Activator.CreateInstance (property.PropertyType);  	FromBytes (propClass' property.PropertyType' buffer);  	property.SetValue (sourceClass' propClass' null);  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		property.SetValue (sourceClass' true' null);  	else  		property.SetValue (sourceClass' false' null);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	property.SetValue (sourceClass' source.ConvertToShort ()' null);  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	})' null);  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetClassSize (property.PropertyType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	var propClass = Activator.CreateInstance (property.PropertyType);  	FromBytes (propClass' property.PropertyType' buffer);  	property.SetValue (sourceClass' propClass' null);  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		property.SetValue (sourceClass' true' null);  	else  		property.SetValue (sourceClass' false' null);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	property.SetValue (sourceClass' source.ConvertToShort ()' null);  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	})' null);  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetClassSize (property.PropertyType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	var propClass = Activator.CreateInstance (property.PropertyType);  	FromBytes (propClass' property.PropertyType' buffer);  	property.SetValue (sourceClass' propClass' null);  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		property.SetValue (sourceClass' true' null);  	else  		property.SetValue (sourceClass' false' null);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	property.SetValue (sourceClass' source.ConvertToShort ()' null);  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	})' null);  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetClassSize (property.PropertyType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	var propClass = Activator.CreateInstance (property.PropertyType);  	FromBytes (propClass' property.PropertyType' buffer);  	property.SetValue (sourceClass' propClass' null);  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		property.SetValue (sourceClass' true' null);  	else  		property.SetValue (sourceClass' false' null);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	property.SetValue (sourceClass' source.ConvertToShort ()' null);  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	})' null);  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetClassSize (property.PropertyType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	var propClass = Activator.CreateInstance (property.PropertyType);  	FromBytes (propClass' property.PropertyType' buffer);  	property.SetValue (sourceClass' propClass' null);  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		property.SetValue (sourceClass' true' null);  	else  		property.SetValue (sourceClass' false' null);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	property.SetValue (sourceClass' source.ConvertToShort ()' null);  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	})' null);  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetClassSize (property.PropertyType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	var propClass = Activator.CreateInstance (property.PropertyType);  	FromBytes (propClass' property.PropertyType' buffer);  	property.SetValue (sourceClass' propClass' null);  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		property.SetValue (sourceClass' true' null);  	else  		property.SetValue (sourceClass' false' null);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	property.SetValue (sourceClass' source.ConvertToShort ()' null);  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	})' null);  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetClassSize (property.PropertyType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	var propClass = Activator.CreateInstance (property.PropertyType);  	FromBytes (propClass' property.PropertyType' buffer);  	property.SetValue (sourceClass' propClass' null);  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		property.SetValue (sourceClass' true' null);  	else  		property.SetValue (sourceClass' false' null);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	property.SetValue (sourceClass' source.ConvertToShort ()' null);  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	})' null);  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetClassSize (property.PropertyType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	var propClass = Activator.CreateInstance (property.PropertyType);  	FromBytes (propClass' property.PropertyType' buffer);  	property.SetValue (sourceClass' propClass' null);  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		property.SetValue (sourceClass' true' null);  	else  		property.SetValue (sourceClass' false' null);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	property.SetValue (sourceClass' source.ConvertToShort ()' null);  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	})' null);  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetClassSize (property.PropertyType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	var propClass = Activator.CreateInstance (property.PropertyType);  	FromBytes (propClass' property.PropertyType' buffer);  	property.SetValue (sourceClass' propClass' null);  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		property.SetValue (sourceClass' true' null);  	else  		property.SetValue (sourceClass' false' null);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	property.SetValue (sourceClass' source.ConvertToShort ()' null);  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	})' null);  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetClassSize (property.PropertyType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	var propClass = Activator.CreateInstance (property.PropertyType);  	FromBytes (propClass' property.PropertyType' buffer);  	property.SetValue (sourceClass' propClass' null);  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		property.SetValue (sourceClass' true' null);  	else  		property.SetValue (sourceClass' false' null);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	property.SetValue (sourceClass' source.ConvertToShort ()' null);  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	})' null);  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetClassSize (property.PropertyType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	var propClass = Activator.CreateInstance (property.PropertyType);  	FromBytes (propClass' property.PropertyType' buffer);  	property.SetValue (sourceClass' propClass' null);  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		property.SetValue (sourceClass' true' null);  	else  		property.SetValue (sourceClass' false' null);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	property.SetValue (sourceClass' source.ConvertToShort ()' null);  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	})' null);  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetClassSize (property.PropertyType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	var propClass = Activator.CreateInstance (property.PropertyType);  	FromBytes (propClass' property.PropertyType' buffer);  	property.SetValue (sourceClass' propClass' null);  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		property.SetValue (sourceClass' true' null);  	else  		property.SetValue (sourceClass' false' null);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	property.SetValue (sourceClass' source.ConvertToShort ()' null);  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	})' null);  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetClassSize (property.PropertyType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	var propClass = Activator.CreateInstance (property.PropertyType);  	FromBytes (propClass' property.PropertyType' buffer);  	property.SetValue (sourceClass' propClass' null);  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		property.SetValue (sourceClass' true' null);  	else  		property.SetValue (sourceClass' false' null);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	property.SetValue (sourceClass' source.ConvertToShort ()' null);  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	})' null);  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetClassSize (property.PropertyType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	var propClass = Activator.CreateInstance (property.PropertyType);  	FromBytes (propClass' property.PropertyType' buffer);  	property.SetValue (sourceClass' propClass' null);  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		property.SetValue (sourceClass' true' null);  	else  		property.SetValue (sourceClass' false' null);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	property.SetValue (sourceClass' source.ConvertToShort ()' null);  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	})' null);  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetClassSize (property.PropertyType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	var propClass = Activator.CreateInstance (property.PropertyType);  	FromBytes (propClass' property.PropertyType' buffer);  	property.SetValue (sourceClass' propClass' null);  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		property.SetValue (sourceClass' true' null);  	else  		property.SetValue (sourceClass' false' null);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	property.SetValue (sourceClass' source.ConvertToShort ()' null);  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	})' null);  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetClassSize (property.PropertyType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	var propClass = Activator.CreateInstance (property.PropertyType);  	FromBytes (propClass' property.PropertyType' buffer);  	property.SetValue (sourceClass' propClass' null);  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		property.SetValue (sourceClass' true' null);  	else  		property.SetValue (sourceClass' false' null);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	property.SetValue (sourceClass' source.ConvertToShort ()' null);  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	})' null);  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetClassSize (property.PropertyType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	var propClass = Activator.CreateInstance (property.PropertyType);  	FromBytes (propClass' property.PropertyType' buffer);  	property.SetValue (sourceClass' propClass' null);  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		property.SetValue (sourceClass' true' null);  	else  		property.SetValue (sourceClass' false' null);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	property.SetValue (sourceClass' source.ConvertToShort ()' null);  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	})' null);  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetClassSize (property.PropertyType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	var propClass = Activator.CreateInstance (property.PropertyType);  	FromBytes (propClass' property.PropertyType' buffer);  	property.SetValue (sourceClass' propClass' null);  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		property.SetValue (sourceClass' true' null);  	else  		property.SetValue (sourceClass' false' null);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	property.SetValue (sourceClass' (byte)(bytes [(int)numBytes])' null);  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	property.SetValue (sourceClass' source.ConvertToShort ()' null);  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes])' null);  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	property.SetValue (sourceClass' sourceUInt.ConvertToInt ()' null);  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	})' null);  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetClassSize (property.PropertyType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	var propClass = Activator.CreateInstance (property.PropertyType);  	FromBytes (propClass' property.PropertyType' buffer);  	property.SetValue (sourceClass' propClass' null);  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: bitPos = (int)((numBytes - (double)bytePos) / 0.125);  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  	property.SetValue (sourceClass' true' null);  else  	property.SetValue (sourceClass' false' null);  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: numBytes += 0.125;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: numBytes += 2;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: numBytes += 2;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: numBytes += 4;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: property.SetValue (sourceClass' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3])' null);  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: numBytes += 4;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  	bytes [(int)numBytes]'  	bytes [(int)numBytes + 1]'  	bytes [(int)numBytes + 2]'  	bytes [(int)numBytes + 3]  })' null);  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: property.SetValue (sourceClass' Double.FromByteArray (new byte[] {  	bytes [(int)numBytes]'  	bytes [(int)numBytes + 1]'  	bytes [(int)numBytes + 2]'  	bytes [(int)numBytes + 3]  })' null);  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,FromBytes,The following statement contains a magic number: numBytes += 4;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,ToBytes,The following statement contains a magic number: foreach (var property in properties) {  	bytes2 = null;  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bool)property.GetValue (sourceClass' null))  			bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  		// is true  		else  			bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  		// is false  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = (int)Math.Ceiling (numBytes);  		bytePos = (int)numBytes;  		bytes [bytePos] = (byte)property.GetValue (sourceClass' null);  		numBytes++;  		break;  	case "Int16":  		bytes2 = Int.ToByteArray ((Int16)property.GetValue (sourceClass' null));  		break;  	case "UInt16":  		bytes2 = Word.ToByteArray ((UInt16)property.GetValue (sourceClass' null));  		break;  	case "Int32":  		bytes2 = DInt.ToByteArray ((Int32)property.GetValue (sourceClass' null));  		break;  	case "UInt32":  		bytes2 = DWord.ToByteArray ((UInt32)property.GetValue (sourceClass' null));  		break;  	case "Double":  		bytes2 = Double.ToByteArray ((double)property.GetValue (sourceClass' null));  		break;  	}  	if (bytes2 != null) {  		// add them  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		bytePos = (int)numBytes;  		for (int bCnt = 0; bCnt < bytes2.Length; bCnt++)  			bytes [bytePos + bCnt] = bytes2 [bCnt];  		numBytes += bytes2.Length;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,ToBytes,The following statement contains a magic number: foreach (var property in properties) {  	bytes2 = null;  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bool)property.GetValue (sourceClass' null))  			bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  		// is true  		else  			bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  		// is false  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = (int)Math.Ceiling (numBytes);  		bytePos = (int)numBytes;  		bytes [bytePos] = (byte)property.GetValue (sourceClass' null);  		numBytes++;  		break;  	case "Int16":  		bytes2 = Int.ToByteArray ((Int16)property.GetValue (sourceClass' null));  		break;  	case "UInt16":  		bytes2 = Word.ToByteArray ((UInt16)property.GetValue (sourceClass' null));  		break;  	case "Int32":  		bytes2 = DInt.ToByteArray ((Int32)property.GetValue (sourceClass' null));  		break;  	case "UInt32":  		bytes2 = DWord.ToByteArray ((UInt32)property.GetValue (sourceClass' null));  		break;  	case "Double":  		bytes2 = Double.ToByteArray ((double)property.GetValue (sourceClass' null));  		break;  	}  	if (bytes2 != null) {  		// add them  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		bytePos = (int)numBytes;  		for (int bCnt = 0; bCnt < bytes2.Length; bCnt++)  			bytes [bytePos + bCnt] = bytes2 [bCnt];  		numBytes += bytes2.Length;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,ToBytes,The following statement contains a magic number: foreach (var property in properties) {  	bytes2 = null;  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bool)property.GetValue (sourceClass' null))  			bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  		// is true  		else  			bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  		// is false  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = (int)Math.Ceiling (numBytes);  		bytePos = (int)numBytes;  		bytes [bytePos] = (byte)property.GetValue (sourceClass' null);  		numBytes++;  		break;  	case "Int16":  		bytes2 = Int.ToByteArray ((Int16)property.GetValue (sourceClass' null));  		break;  	case "UInt16":  		bytes2 = Word.ToByteArray ((UInt16)property.GetValue (sourceClass' null));  		break;  	case "Int32":  		bytes2 = DInt.ToByteArray ((Int32)property.GetValue (sourceClass' null));  		break;  	case "UInt32":  		bytes2 = DWord.ToByteArray ((UInt32)property.GetValue (sourceClass' null));  		break;  	case "Double":  		bytes2 = Double.ToByteArray ((double)property.GetValue (sourceClass' null));  		break;  	}  	if (bytes2 != null) {  		// add them  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		bytePos = (int)numBytes;  		for (int bCnt = 0; bCnt < bytes2.Length; bCnt++)  			bytes [bytePos + bCnt] = bytes2 [bCnt];  		numBytes += bytes2.Length;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,ToBytes,The following statement contains a magic number: foreach (var property in properties) {  	bytes2 = null;  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bool)property.GetValue (sourceClass' null))  			bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  		// is true  		else  			bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  		// is false  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = (int)Math.Ceiling (numBytes);  		bytePos = (int)numBytes;  		bytes [bytePos] = (byte)property.GetValue (sourceClass' null);  		numBytes++;  		break;  	case "Int16":  		bytes2 = Int.ToByteArray ((Int16)property.GetValue (sourceClass' null));  		break;  	case "UInt16":  		bytes2 = Word.ToByteArray ((UInt16)property.GetValue (sourceClass' null));  		break;  	case "Int32":  		bytes2 = DInt.ToByteArray ((Int32)property.GetValue (sourceClass' null));  		break;  	case "UInt32":  		bytes2 = DWord.ToByteArray ((UInt32)property.GetValue (sourceClass' null));  		break;  	case "Double":  		bytes2 = Double.ToByteArray ((double)property.GetValue (sourceClass' null));  		break;  	}  	if (bytes2 != null) {  		// add them  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		bytePos = (int)numBytes;  		for (int bCnt = 0; bCnt < bytes2.Length; bCnt++)  			bytes [bytePos + bCnt] = bytes2 [bCnt];  		numBytes += bytes2.Length;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,ToBytes,The following statement contains a magic number: foreach (var property in properties) {  	bytes2 = null;  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bool)property.GetValue (sourceClass' null))  			bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  		// is true  		else  			bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  		// is false  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = (int)Math.Ceiling (numBytes);  		bytePos = (int)numBytes;  		bytes [bytePos] = (byte)property.GetValue (sourceClass' null);  		numBytes++;  		break;  	case "Int16":  		bytes2 = Int.ToByteArray ((Int16)property.GetValue (sourceClass' null));  		break;  	case "UInt16":  		bytes2 = Word.ToByteArray ((UInt16)property.GetValue (sourceClass' null));  		break;  	case "Int32":  		bytes2 = DInt.ToByteArray ((Int32)property.GetValue (sourceClass' null));  		break;  	case "UInt32":  		bytes2 = DWord.ToByteArray ((UInt32)property.GetValue (sourceClass' null));  		break;  	case "Double":  		bytes2 = Double.ToByteArray ((double)property.GetValue (sourceClass' null));  		break;  	}  	if (bytes2 != null) {  		// add them  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		bytePos = (int)numBytes;  		for (int bCnt = 0; bCnt < bytes2.Length; bCnt++)  			bytes [bytePos + bCnt] = bytes2 [bCnt];  		numBytes += bytes2.Length;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,ToBytes,The following statement contains a magic number: foreach (var property in properties) {  	bytes2 = null;  	switch (property.PropertyType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bool)property.GetValue (sourceClass' null))  			bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  		// is true  		else  			bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  		// is false  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = (int)Math.Ceiling (numBytes);  		bytePos = (int)numBytes;  		bytes [bytePos] = (byte)property.GetValue (sourceClass' null);  		numBytes++;  		break;  	case "Int16":  		bytes2 = Int.ToByteArray ((Int16)property.GetValue (sourceClass' null));  		break;  	case "UInt16":  		bytes2 = Word.ToByteArray ((UInt16)property.GetValue (sourceClass' null));  		break;  	case "Int32":  		bytes2 = DInt.ToByteArray ((Int32)property.GetValue (sourceClass' null));  		break;  	case "UInt32":  		bytes2 = DWord.ToByteArray ((UInt32)property.GetValue (sourceClass' null));  		break;  	case "Double":  		bytes2 = Double.ToByteArray ((double)property.GetValue (sourceClass' null));  		break;  	}  	if (bytes2 != null) {  		// add them  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		bytePos = (int)numBytes;  		for (int bCnt = 0; bCnt < bytes2.Length; bCnt++)  			bytes [bytePos + bCnt] = bytes2 [bCnt];  		numBytes += bytes2.Length;  	}  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,ToBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bool)property.GetValue (sourceClass' null))  		bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  	// is true  	else  		bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  	// is false  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = (int)Math.Ceiling (numBytes);  	bytePos = (int)numBytes;  	bytes [bytePos] = (byte)property.GetValue (sourceClass' null);  	numBytes++;  	break;  case "Int16":  	bytes2 = Int.ToByteArray ((Int16)property.GetValue (sourceClass' null));  	break;  case "UInt16":  	bytes2 = Word.ToByteArray ((UInt16)property.GetValue (sourceClass' null));  	break;  case "Int32":  	bytes2 = DInt.ToByteArray ((Int32)property.GetValue (sourceClass' null));  	break;  case "UInt32":  	bytes2 = DWord.ToByteArray ((UInt32)property.GetValue (sourceClass' null));  	break;  case "Double":  	bytes2 = Double.ToByteArray ((double)property.GetValue (sourceClass' null));  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,ToBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bool)property.GetValue (sourceClass' null))  		bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  	// is true  	else  		bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  	// is false  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = (int)Math.Ceiling (numBytes);  	bytePos = (int)numBytes;  	bytes [bytePos] = (byte)property.GetValue (sourceClass' null);  	numBytes++;  	break;  case "Int16":  	bytes2 = Int.ToByteArray ((Int16)property.GetValue (sourceClass' null));  	break;  case "UInt16":  	bytes2 = Word.ToByteArray ((UInt16)property.GetValue (sourceClass' null));  	break;  case "Int32":  	bytes2 = DInt.ToByteArray ((Int32)property.GetValue (sourceClass' null));  	break;  case "UInt32":  	bytes2 = DWord.ToByteArray ((UInt32)property.GetValue (sourceClass' null));  	break;  case "Double":  	bytes2 = Double.ToByteArray ((double)property.GetValue (sourceClass' null));  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,ToBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bool)property.GetValue (sourceClass' null))  		bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  	// is true  	else  		bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  	// is false  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = (int)Math.Ceiling (numBytes);  	bytePos = (int)numBytes;  	bytes [bytePos] = (byte)property.GetValue (sourceClass' null);  	numBytes++;  	break;  case "Int16":  	bytes2 = Int.ToByteArray ((Int16)property.GetValue (sourceClass' null));  	break;  case "UInt16":  	bytes2 = Word.ToByteArray ((UInt16)property.GetValue (sourceClass' null));  	break;  case "Int32":  	bytes2 = DInt.ToByteArray ((Int32)property.GetValue (sourceClass' null));  	break;  case "UInt32":  	bytes2 = DWord.ToByteArray ((UInt32)property.GetValue (sourceClass' null));  	break;  case "Double":  	bytes2 = Double.ToByteArray ((double)property.GetValue (sourceClass' null));  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,ToBytes,The following statement contains a magic number: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bool)property.GetValue (sourceClass' null))  		bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  	// is true  	else  		bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  	// is false  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = (int)Math.Ceiling (numBytes);  	bytePos = (int)numBytes;  	bytes [bytePos] = (byte)property.GetValue (sourceClass' null);  	numBytes++;  	break;  case "Int16":  	bytes2 = Int.ToByteArray ((Int16)property.GetValue (sourceClass' null));  	break;  case "UInt16":  	bytes2 = Word.ToByteArray ((UInt16)property.GetValue (sourceClass' null));  	break;  case "Int32":  	bytes2 = DInt.ToByteArray ((Int32)property.GetValue (sourceClass' null));  	break;  case "UInt32":  	bytes2 = DWord.ToByteArray ((UInt32)property.GetValue (sourceClass' null));  	break;  case "Double":  	bytes2 = Double.ToByteArray ((double)property.GetValue (sourceClass' null));  	break;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,ToBytes,The following statement contains a magic number: bitPos = (int)((numBytes - (double)bytePos) / 0.125);  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,ToBytes,The following statement contains a magic number: if ((bool)property.GetValue (sourceClass' null))  	bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  // is true  else  	bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,ToBytes,The following statement contains a magic number: if ((bool)property.GetValue (sourceClass' null))  	bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  // is true  else  	bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,ToBytes,The following statement contains a magic number: bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,ToBytes,The following statement contains a magic number: bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,ToBytes,The following statement contains a magic number: numBytes += 0.125;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,ToBytes,The following statement contains a magic number: if (bytes2 != null) {  	// add them  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	bytePos = (int)numBytes;  	for (int bCnt = 0; bCnt < bytes2.Length; bCnt++)  		bytes [bytePos + bCnt] = bytes2 [bCnt];  	numBytes += bytes2.Length;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,ToBytes,The following statement contains a magic number: if (bytes2 != null) {  	// add them  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	bytePos = (int)numBytes;  	for (int bCnt = 0; bCnt < bytes2.Length; bCnt++)  		bytes [bytePos + bCnt] = bytes2 [bCnt];  	numBytes += bytes2.Length;  }  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,ToBytes,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,ToBytes,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Counter,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Counter.cs,FromByteArray,The following statement contains a magic number: if (bytes.Length != 2) {  	throw new ArgumentException ("Wrong number of bytes. Bytes array must contain 2 bytes.");  }  
Magic Number,S7.Net.Types,Counter,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Counter.cs,FromBytes,The following statement contains a magic number: return (UInt16)(HiVal * 256 + LoVal);  
Magic Number,S7.Net.Types,Counter,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Counter.cs,ToByteArray,The following statement contains a magic number: for (int cnt = 0; cnt < x; cnt++) {  	Int64 x1 = (Int64)Math.Pow (256' (cnt));  	Int64 x3 = (Int64)(valLong / x1);  	bytes [x - cnt - 1] = (byte)(x3 & 255);  	valLong -= bytes [x - cnt - 1] * x1;  }  
Magic Number,S7.Net.Types,Counter,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Counter.cs,ToByteArray,The following statement contains a magic number: for (int cnt = 0; cnt < x; cnt++) {  	Int64 x1 = (Int64)Math.Pow (256' (cnt));  	Int64 x3 = (Int64)(valLong / x1);  	bytes [x - cnt - 1] = (byte)(x3 & 255);  	valLong -= bytes [x - cnt - 1] * x1;  }  
Magic Number,S7.Net.Types,Counter,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Counter.cs,ToByteArray,The following statement contains a magic number: bytes [x - cnt - 1] = (byte)(x3 & 255);  
Magic Number,S7.Net.Types,Counter,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Counter.cs,ToArray,The following statement contains a magic number: for (int cnt = 0; cnt < bytes.Length / 2; cnt++)  	values [cnt] = FromByteArray (new byte[] {  		bytes [counter++]'  		bytes [counter++]  	});  
Magic Number,S7.Net.Types,DInt,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DInt.cs,FromByteArray,The following statement contains a magic number: if (bytes.Length != 4) {  	throw new ArgumentException ("Wrong number of bytes. Bytes array must contain 4 bytes.");  }  
Magic Number,S7.Net.Types,DInt,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DInt.cs,FromByteArray,The following statement contains a magic number: return FromBytes (bytes [3]' bytes [2]' bytes [1]' bytes [0]);  
Magic Number,S7.Net.Types,DInt,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DInt.cs,FromByteArray,The following statement contains a magic number: return FromBytes (bytes [3]' bytes [2]' bytes [1]' bytes [0]);  
Magic Number,S7.Net.Types,DInt,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DInt.cs,FromBytes,The following statement contains a magic number: return (Int32)(v1 + v2 * Math.Pow (2' 8) + v3 * Math.Pow (2' 16) + v4 * Math.Pow (2' 24));  
Magic Number,S7.Net.Types,DInt,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DInt.cs,FromBytes,The following statement contains a magic number: return (Int32)(v1 + v2 * Math.Pow (2' 8) + v3 * Math.Pow (2' 16) + v4 * Math.Pow (2' 24));  
Magic Number,S7.Net.Types,DInt,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DInt.cs,FromBytes,The following statement contains a magic number: return (Int32)(v1 + v2 * Math.Pow (2' 8) + v3 * Math.Pow (2' 16) + v4 * Math.Pow (2' 24));  
Magic Number,S7.Net.Types,DInt,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DInt.cs,FromBytes,The following statement contains a magic number: return (Int32)(v1 + v2 * Math.Pow (2' 8) + v3 * Math.Pow (2' 16) + v4 * Math.Pow (2' 24));  
Magic Number,S7.Net.Types,DInt,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DInt.cs,FromBytes,The following statement contains a magic number: return (Int32)(v1 + v2 * Math.Pow (2' 8) + v3 * Math.Pow (2' 16) + v4 * Math.Pow (2' 24));  
Magic Number,S7.Net.Types,DInt,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DInt.cs,FromBytes,The following statement contains a magic number: return (Int32)(v1 + v2 * Math.Pow (2' 8) + v3 * Math.Pow (2' 16) + v4 * Math.Pow (2' 24));  
Magic Number,S7.Net.Types,DInt,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DInt.cs,ToByteArray,The following statement contains a magic number: for (int cnt = 0; cnt < x; cnt++) {  	Int64 x1 = (Int64)Math.Pow (256' (cnt));  	Int64 x3 = (Int64)(valLong / x1);  	bytes [x - cnt - 1] = (byte)(x3 & 255);  	valLong -= bytes [x - cnt - 1] * x1;  }  
Magic Number,S7.Net.Types,DInt,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DInt.cs,ToByteArray,The following statement contains a magic number: for (int cnt = 0; cnt < x; cnt++) {  	Int64 x1 = (Int64)Math.Pow (256' (cnt));  	Int64 x3 = (Int64)(valLong / x1);  	bytes [x - cnt - 1] = (byte)(x3 & 255);  	valLong -= bytes [x - cnt - 1] * x1;  }  
Magic Number,S7.Net.Types,DInt,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DInt.cs,ToByteArray,The following statement contains a magic number: bytes [x - cnt - 1] = (byte)(x3 & 255);  
Magic Number,S7.Net.Types,DInt,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DInt.cs,ToArray,The following statement contains a magic number: for (int cnt = 0; cnt < bytes.Length / 4; cnt++)  	values [cnt] = FromByteArray (new byte[] {  		bytes [counter++]'  		bytes [counter++]'  		bytes [counter++]'  		bytes [counter++]  	});  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,FromByteArray,The following statement contains a magic number: if (bytes.Length != 4) {  	throw new ArgumentException ("Wrong number of bytes. Bytes array must contain 4 bytes.");  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,FromByteArray,The following statement contains a magic number: if ((int)v1 + v2 + v3 + v4 == 0) {  	return 0.0;  } else {  	// nun String bilden  	string txt = ValToBinString (v1) + ValToBinString (v2) + ValToBinString (v3) + ValToBinString (v4);  	// erstmal das Vorzeichen  	int vz = int.Parse (txt.Substring (0' 1));  	int exd = Conversion.BinStringToInt32 (txt.Substring (1' 8));  	string ma = txt.Substring (9' 23);  	double mantisse = 1;  	double faktor = 1.0;  	//das ist die Anzahl der restlichen bit's  	for (int cnt = 0; cnt <= 22; cnt++) {  		faktor = faktor / 2.0;  		//entspricht 2^-y  		if (ma.Substring (cnt' 1) == "1") {  			mantisse = mantisse + faktor;  		}  	}  	return Math.Pow ((-1)' vz) * Math.Pow (2' (exd - 127)) * mantisse;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,FromByteArray,The following statement contains a magic number: if ((int)v1 + v2 + v3 + v4 == 0) {  	return 0.0;  } else {  	// nun String bilden  	string txt = ValToBinString (v1) + ValToBinString (v2) + ValToBinString (v3) + ValToBinString (v4);  	// erstmal das Vorzeichen  	int vz = int.Parse (txt.Substring (0' 1));  	int exd = Conversion.BinStringToInt32 (txt.Substring (1' 8));  	string ma = txt.Substring (9' 23);  	double mantisse = 1;  	double faktor = 1.0;  	//das ist die Anzahl der restlichen bit's  	for (int cnt = 0; cnt <= 22; cnt++) {  		faktor = faktor / 2.0;  		//entspricht 2^-y  		if (ma.Substring (cnt' 1) == "1") {  			mantisse = mantisse + faktor;  		}  	}  	return Math.Pow ((-1)' vz) * Math.Pow (2' (exd - 127)) * mantisse;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,FromByteArray,The following statement contains a magic number: if ((int)v1 + v2 + v3 + v4 == 0) {  	return 0.0;  } else {  	// nun String bilden  	string txt = ValToBinString (v1) + ValToBinString (v2) + ValToBinString (v3) + ValToBinString (v4);  	// erstmal das Vorzeichen  	int vz = int.Parse (txt.Substring (0' 1));  	int exd = Conversion.BinStringToInt32 (txt.Substring (1' 8));  	string ma = txt.Substring (9' 23);  	double mantisse = 1;  	double faktor = 1.0;  	//das ist die Anzahl der restlichen bit's  	for (int cnt = 0; cnt <= 22; cnt++) {  		faktor = faktor / 2.0;  		//entspricht 2^-y  		if (ma.Substring (cnt' 1) == "1") {  			mantisse = mantisse + faktor;  		}  	}  	return Math.Pow ((-1)' vz) * Math.Pow (2' (exd - 127)) * mantisse;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,FromByteArray,The following statement contains a magic number: if ((int)v1 + v2 + v3 + v4 == 0) {  	return 0.0;  } else {  	// nun String bilden  	string txt = ValToBinString (v1) + ValToBinString (v2) + ValToBinString (v3) + ValToBinString (v4);  	// erstmal das Vorzeichen  	int vz = int.Parse (txt.Substring (0' 1));  	int exd = Conversion.BinStringToInt32 (txt.Substring (1' 8));  	string ma = txt.Substring (9' 23);  	double mantisse = 1;  	double faktor = 1.0;  	//das ist die Anzahl der restlichen bit's  	for (int cnt = 0; cnt <= 22; cnt++) {  		faktor = faktor / 2.0;  		//entspricht 2^-y  		if (ma.Substring (cnt' 1) == "1") {  			mantisse = mantisse + faktor;  		}  	}  	return Math.Pow ((-1)' vz) * Math.Pow (2' (exd - 127)) * mantisse;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,FromByteArray,The following statement contains a magic number: if ((int)v1 + v2 + v3 + v4 == 0) {  	return 0.0;  } else {  	// nun String bilden  	string txt = ValToBinString (v1) + ValToBinString (v2) + ValToBinString (v3) + ValToBinString (v4);  	// erstmal das Vorzeichen  	int vz = int.Parse (txt.Substring (0' 1));  	int exd = Conversion.BinStringToInt32 (txt.Substring (1' 8));  	string ma = txt.Substring (9' 23);  	double mantisse = 1;  	double faktor = 1.0;  	//das ist die Anzahl der restlichen bit's  	for (int cnt = 0; cnt <= 22; cnt++) {  		faktor = faktor / 2.0;  		//entspricht 2^-y  		if (ma.Substring (cnt' 1) == "1") {  			mantisse = mantisse + faktor;  		}  	}  	return Math.Pow ((-1)' vz) * Math.Pow (2' (exd - 127)) * mantisse;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,FromByteArray,The following statement contains a magic number: if ((int)v1 + v2 + v3 + v4 == 0) {  	return 0.0;  } else {  	// nun String bilden  	string txt = ValToBinString (v1) + ValToBinString (v2) + ValToBinString (v3) + ValToBinString (v4);  	// erstmal das Vorzeichen  	int vz = int.Parse (txt.Substring (0' 1));  	int exd = Conversion.BinStringToInt32 (txt.Substring (1' 8));  	string ma = txt.Substring (9' 23);  	double mantisse = 1;  	double faktor = 1.0;  	//das ist die Anzahl der restlichen bit's  	for (int cnt = 0; cnt <= 22; cnt++) {  		faktor = faktor / 2.0;  		//entspricht 2^-y  		if (ma.Substring (cnt' 1) == "1") {  			mantisse = mantisse + faktor;  		}  	}  	return Math.Pow ((-1)' vz) * Math.Pow (2' (exd - 127)) * mantisse;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,FromByteArray,The following statement contains a magic number: if ((int)v1 + v2 + v3 + v4 == 0) {  	return 0.0;  } else {  	// nun String bilden  	string txt = ValToBinString (v1) + ValToBinString (v2) + ValToBinString (v3) + ValToBinString (v4);  	// erstmal das Vorzeichen  	int vz = int.Parse (txt.Substring (0' 1));  	int exd = Conversion.BinStringToInt32 (txt.Substring (1' 8));  	string ma = txt.Substring (9' 23);  	double mantisse = 1;  	double faktor = 1.0;  	//das ist die Anzahl der restlichen bit's  	for (int cnt = 0; cnt <= 22; cnt++) {  		faktor = faktor / 2.0;  		//entspricht 2^-y  		if (ma.Substring (cnt' 1) == "1") {  			mantisse = mantisse + faktor;  		}  	}  	return Math.Pow ((-1)' vz) * Math.Pow (2' (exd - 127)) * mantisse;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,FromByteArray,The following statement contains a magic number: for (int cnt = 0; cnt <= 22; cnt++) {  	faktor = faktor / 2.0;  	//entspricht 2^-y  	if (ma.Substring (cnt' 1) == "1") {  		mantisse = mantisse + faktor;  	}  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,FromByteArray,The following statement contains a magic number: for (int cnt = 0; cnt <= 22; cnt++) {  	faktor = faktor / 2.0;  	//entspricht 2^-y  	if (ma.Substring (cnt' 1) == "1") {  		mantisse = mantisse + faktor;  	}  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,FromByteArray,The following statement contains a magic number: faktor = faktor / 2.0;  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,FromByteArray,The following statement contains a magic number: return Math.Pow ((-1)' vz) * Math.Pow (2' (exd - 127)) * mantisse;  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,FromByteArray,The following statement contains a magic number: return Math.Pow ((-1)' vz) * Math.Pow (2' (exd - 127)) * mantisse;  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: if (wert != 0f) {  	if (wert < 0) {  		wert *= -1;  		binString = "1";  	} else {  		binString = "0";  	}  	int exponent = (int)Math.Floor ((double)Math.Log (wert) / Math.Log (2.0));  	wert = wert / (Math.Pow (2' exponent)) - 1;  	binString += ValToBinString ((byte)(exponent + 127));  	for (int cnt = 1; cnt <= 23; cnt++) {  		if (!(wert - System.Math.Pow (2' -cnt) < 0)) {  			wert = wert - System.Math.Pow (2' -cnt);  			binString += "1";  		} else  			binString += "0";  	}  	bytes [0] = (byte)BinStringToByte (binString.Substring (0' 8));  	bytes [1] = (byte)BinStringToByte (binString.Substring (8' 8));  	bytes [2] = (byte)BinStringToByte (binString.Substring (16' 8));  	bytes [3] = (byte)BinStringToByte (binString.Substring (24' 8));  } else {  	bytes [0] = 0;  	bytes [1] = 0;  	bytes [2] = 0;  	bytes [3] = 0;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: if (wert != 0f) {  	if (wert < 0) {  		wert *= -1;  		binString = "1";  	} else {  		binString = "0";  	}  	int exponent = (int)Math.Floor ((double)Math.Log (wert) / Math.Log (2.0));  	wert = wert / (Math.Pow (2' exponent)) - 1;  	binString += ValToBinString ((byte)(exponent + 127));  	for (int cnt = 1; cnt <= 23; cnt++) {  		if (!(wert - System.Math.Pow (2' -cnt) < 0)) {  			wert = wert - System.Math.Pow (2' -cnt);  			binString += "1";  		} else  			binString += "0";  	}  	bytes [0] = (byte)BinStringToByte (binString.Substring (0' 8));  	bytes [1] = (byte)BinStringToByte (binString.Substring (8' 8));  	bytes [2] = (byte)BinStringToByte (binString.Substring (16' 8));  	bytes [3] = (byte)BinStringToByte (binString.Substring (24' 8));  } else {  	bytes [0] = 0;  	bytes [1] = 0;  	bytes [2] = 0;  	bytes [3] = 0;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: if (wert != 0f) {  	if (wert < 0) {  		wert *= -1;  		binString = "1";  	} else {  		binString = "0";  	}  	int exponent = (int)Math.Floor ((double)Math.Log (wert) / Math.Log (2.0));  	wert = wert / (Math.Pow (2' exponent)) - 1;  	binString += ValToBinString ((byte)(exponent + 127));  	for (int cnt = 1; cnt <= 23; cnt++) {  		if (!(wert - System.Math.Pow (2' -cnt) < 0)) {  			wert = wert - System.Math.Pow (2' -cnt);  			binString += "1";  		} else  			binString += "0";  	}  	bytes [0] = (byte)BinStringToByte (binString.Substring (0' 8));  	bytes [1] = (byte)BinStringToByte (binString.Substring (8' 8));  	bytes [2] = (byte)BinStringToByte (binString.Substring (16' 8));  	bytes [3] = (byte)BinStringToByte (binString.Substring (24' 8));  } else {  	bytes [0] = 0;  	bytes [1] = 0;  	bytes [2] = 0;  	bytes [3] = 0;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: if (wert != 0f) {  	if (wert < 0) {  		wert *= -1;  		binString = "1";  	} else {  		binString = "0";  	}  	int exponent = (int)Math.Floor ((double)Math.Log (wert) / Math.Log (2.0));  	wert = wert / (Math.Pow (2' exponent)) - 1;  	binString += ValToBinString ((byte)(exponent + 127));  	for (int cnt = 1; cnt <= 23; cnt++) {  		if (!(wert - System.Math.Pow (2' -cnt) < 0)) {  			wert = wert - System.Math.Pow (2' -cnt);  			binString += "1";  		} else  			binString += "0";  	}  	bytes [0] = (byte)BinStringToByte (binString.Substring (0' 8));  	bytes [1] = (byte)BinStringToByte (binString.Substring (8' 8));  	bytes [2] = (byte)BinStringToByte (binString.Substring (16' 8));  	bytes [3] = (byte)BinStringToByte (binString.Substring (24' 8));  } else {  	bytes [0] = 0;  	bytes [1] = 0;  	bytes [2] = 0;  	bytes [3] = 0;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: if (wert != 0f) {  	if (wert < 0) {  		wert *= -1;  		binString = "1";  	} else {  		binString = "0";  	}  	int exponent = (int)Math.Floor ((double)Math.Log (wert) / Math.Log (2.0));  	wert = wert / (Math.Pow (2' exponent)) - 1;  	binString += ValToBinString ((byte)(exponent + 127));  	for (int cnt = 1; cnt <= 23; cnt++) {  		if (!(wert - System.Math.Pow (2' -cnt) < 0)) {  			wert = wert - System.Math.Pow (2' -cnt);  			binString += "1";  		} else  			binString += "0";  	}  	bytes [0] = (byte)BinStringToByte (binString.Substring (0' 8));  	bytes [1] = (byte)BinStringToByte (binString.Substring (8' 8));  	bytes [2] = (byte)BinStringToByte (binString.Substring (16' 8));  	bytes [3] = (byte)BinStringToByte (binString.Substring (24' 8));  } else {  	bytes [0] = 0;  	bytes [1] = 0;  	bytes [2] = 0;  	bytes [3] = 0;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: if (wert != 0f) {  	if (wert < 0) {  		wert *= -1;  		binString = "1";  	} else {  		binString = "0";  	}  	int exponent = (int)Math.Floor ((double)Math.Log (wert) / Math.Log (2.0));  	wert = wert / (Math.Pow (2' exponent)) - 1;  	binString += ValToBinString ((byte)(exponent + 127));  	for (int cnt = 1; cnt <= 23; cnt++) {  		if (!(wert - System.Math.Pow (2' -cnt) < 0)) {  			wert = wert - System.Math.Pow (2' -cnt);  			binString += "1";  		} else  			binString += "0";  	}  	bytes [0] = (byte)BinStringToByte (binString.Substring (0' 8));  	bytes [1] = (byte)BinStringToByte (binString.Substring (8' 8));  	bytes [2] = (byte)BinStringToByte (binString.Substring (16' 8));  	bytes [3] = (byte)BinStringToByte (binString.Substring (24' 8));  } else {  	bytes [0] = 0;  	bytes [1] = 0;  	bytes [2] = 0;  	bytes [3] = 0;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: if (wert != 0f) {  	if (wert < 0) {  		wert *= -1;  		binString = "1";  	} else {  		binString = "0";  	}  	int exponent = (int)Math.Floor ((double)Math.Log (wert) / Math.Log (2.0));  	wert = wert / (Math.Pow (2' exponent)) - 1;  	binString += ValToBinString ((byte)(exponent + 127));  	for (int cnt = 1; cnt <= 23; cnt++) {  		if (!(wert - System.Math.Pow (2' -cnt) < 0)) {  			wert = wert - System.Math.Pow (2' -cnt);  			binString += "1";  		} else  			binString += "0";  	}  	bytes [0] = (byte)BinStringToByte (binString.Substring (0' 8));  	bytes [1] = (byte)BinStringToByte (binString.Substring (8' 8));  	bytes [2] = (byte)BinStringToByte (binString.Substring (16' 8));  	bytes [3] = (byte)BinStringToByte (binString.Substring (24' 8));  } else {  	bytes [0] = 0;  	bytes [1] = 0;  	bytes [2] = 0;  	bytes [3] = 0;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: if (wert != 0f) {  	if (wert < 0) {  		wert *= -1;  		binString = "1";  	} else {  		binString = "0";  	}  	int exponent = (int)Math.Floor ((double)Math.Log (wert) / Math.Log (2.0));  	wert = wert / (Math.Pow (2' exponent)) - 1;  	binString += ValToBinString ((byte)(exponent + 127));  	for (int cnt = 1; cnt <= 23; cnt++) {  		if (!(wert - System.Math.Pow (2' -cnt) < 0)) {  			wert = wert - System.Math.Pow (2' -cnt);  			binString += "1";  		} else  			binString += "0";  	}  	bytes [0] = (byte)BinStringToByte (binString.Substring (0' 8));  	bytes [1] = (byte)BinStringToByte (binString.Substring (8' 8));  	bytes [2] = (byte)BinStringToByte (binString.Substring (16' 8));  	bytes [3] = (byte)BinStringToByte (binString.Substring (24' 8));  } else {  	bytes [0] = 0;  	bytes [1] = 0;  	bytes [2] = 0;  	bytes [3] = 0;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: if (wert != 0f) {  	if (wert < 0) {  		wert *= -1;  		binString = "1";  	} else {  		binString = "0";  	}  	int exponent = (int)Math.Floor ((double)Math.Log (wert) / Math.Log (2.0));  	wert = wert / (Math.Pow (2' exponent)) - 1;  	binString += ValToBinString ((byte)(exponent + 127));  	for (int cnt = 1; cnt <= 23; cnt++) {  		if (!(wert - System.Math.Pow (2' -cnt) < 0)) {  			wert = wert - System.Math.Pow (2' -cnt);  			binString += "1";  		} else  			binString += "0";  	}  	bytes [0] = (byte)BinStringToByte (binString.Substring (0' 8));  	bytes [1] = (byte)BinStringToByte (binString.Substring (8' 8));  	bytes [2] = (byte)BinStringToByte (binString.Substring (16' 8));  	bytes [3] = (byte)BinStringToByte (binString.Substring (24' 8));  } else {  	bytes [0] = 0;  	bytes [1] = 0;  	bytes [2] = 0;  	bytes [3] = 0;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: if (wert != 0f) {  	if (wert < 0) {  		wert *= -1;  		binString = "1";  	} else {  		binString = "0";  	}  	int exponent = (int)Math.Floor ((double)Math.Log (wert) / Math.Log (2.0));  	wert = wert / (Math.Pow (2' exponent)) - 1;  	binString += ValToBinString ((byte)(exponent + 127));  	for (int cnt = 1; cnt <= 23; cnt++) {  		if (!(wert - System.Math.Pow (2' -cnt) < 0)) {  			wert = wert - System.Math.Pow (2' -cnt);  			binString += "1";  		} else  			binString += "0";  	}  	bytes [0] = (byte)BinStringToByte (binString.Substring (0' 8));  	bytes [1] = (byte)BinStringToByte (binString.Substring (8' 8));  	bytes [2] = (byte)BinStringToByte (binString.Substring (16' 8));  	bytes [3] = (byte)BinStringToByte (binString.Substring (24' 8));  } else {  	bytes [0] = 0;  	bytes [1] = 0;  	bytes [2] = 0;  	bytes [3] = 0;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: if (wert != 0f) {  	if (wert < 0) {  		wert *= -1;  		binString = "1";  	} else {  		binString = "0";  	}  	int exponent = (int)Math.Floor ((double)Math.Log (wert) / Math.Log (2.0));  	wert = wert / (Math.Pow (2' exponent)) - 1;  	binString += ValToBinString ((byte)(exponent + 127));  	for (int cnt = 1; cnt <= 23; cnt++) {  		if (!(wert - System.Math.Pow (2' -cnt) < 0)) {  			wert = wert - System.Math.Pow (2' -cnt);  			binString += "1";  		} else  			binString += "0";  	}  	bytes [0] = (byte)BinStringToByte (binString.Substring (0' 8));  	bytes [1] = (byte)BinStringToByte (binString.Substring (8' 8));  	bytes [2] = (byte)BinStringToByte (binString.Substring (16' 8));  	bytes [3] = (byte)BinStringToByte (binString.Substring (24' 8));  } else {  	bytes [0] = 0;  	bytes [1] = 0;  	bytes [2] = 0;  	bytes [3] = 0;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: if (wert != 0f) {  	if (wert < 0) {  		wert *= -1;  		binString = "1";  	} else {  		binString = "0";  	}  	int exponent = (int)Math.Floor ((double)Math.Log (wert) / Math.Log (2.0));  	wert = wert / (Math.Pow (2' exponent)) - 1;  	binString += ValToBinString ((byte)(exponent + 127));  	for (int cnt = 1; cnt <= 23; cnt++) {  		if (!(wert - System.Math.Pow (2' -cnt) < 0)) {  			wert = wert - System.Math.Pow (2' -cnt);  			binString += "1";  		} else  			binString += "0";  	}  	bytes [0] = (byte)BinStringToByte (binString.Substring (0' 8));  	bytes [1] = (byte)BinStringToByte (binString.Substring (8' 8));  	bytes [2] = (byte)BinStringToByte (binString.Substring (16' 8));  	bytes [3] = (byte)BinStringToByte (binString.Substring (24' 8));  } else {  	bytes [0] = 0;  	bytes [1] = 0;  	bytes [2] = 0;  	bytes [3] = 0;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: if (wert != 0f) {  	if (wert < 0) {  		wert *= -1;  		binString = "1";  	} else {  		binString = "0";  	}  	int exponent = (int)Math.Floor ((double)Math.Log (wert) / Math.Log (2.0));  	wert = wert / (Math.Pow (2' exponent)) - 1;  	binString += ValToBinString ((byte)(exponent + 127));  	for (int cnt = 1; cnt <= 23; cnt++) {  		if (!(wert - System.Math.Pow (2' -cnt) < 0)) {  			wert = wert - System.Math.Pow (2' -cnt);  			binString += "1";  		} else  			binString += "0";  	}  	bytes [0] = (byte)BinStringToByte (binString.Substring (0' 8));  	bytes [1] = (byte)BinStringToByte (binString.Substring (8' 8));  	bytes [2] = (byte)BinStringToByte (binString.Substring (16' 8));  	bytes [3] = (byte)BinStringToByte (binString.Substring (24' 8));  } else {  	bytes [0] = 0;  	bytes [1] = 0;  	bytes [2] = 0;  	bytes [3] = 0;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: if (wert != 0f) {  	if (wert < 0) {  		wert *= -1;  		binString = "1";  	} else {  		binString = "0";  	}  	int exponent = (int)Math.Floor ((double)Math.Log (wert) / Math.Log (2.0));  	wert = wert / (Math.Pow (2' exponent)) - 1;  	binString += ValToBinString ((byte)(exponent + 127));  	for (int cnt = 1; cnt <= 23; cnt++) {  		if (!(wert - System.Math.Pow (2' -cnt) < 0)) {  			wert = wert - System.Math.Pow (2' -cnt);  			binString += "1";  		} else  			binString += "0";  	}  	bytes [0] = (byte)BinStringToByte (binString.Substring (0' 8));  	bytes [1] = (byte)BinStringToByte (binString.Substring (8' 8));  	bytes [2] = (byte)BinStringToByte (binString.Substring (16' 8));  	bytes [3] = (byte)BinStringToByte (binString.Substring (24' 8));  } else {  	bytes [0] = 0;  	bytes [1] = 0;  	bytes [2] = 0;  	bytes [3] = 0;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: if (wert != 0f) {  	if (wert < 0) {  		wert *= -1;  		binString = "1";  	} else {  		binString = "0";  	}  	int exponent = (int)Math.Floor ((double)Math.Log (wert) / Math.Log (2.0));  	wert = wert / (Math.Pow (2' exponent)) - 1;  	binString += ValToBinString ((byte)(exponent + 127));  	for (int cnt = 1; cnt <= 23; cnt++) {  		if (!(wert - System.Math.Pow (2' -cnt) < 0)) {  			wert = wert - System.Math.Pow (2' -cnt);  			binString += "1";  		} else  			binString += "0";  	}  	bytes [0] = (byte)BinStringToByte (binString.Substring (0' 8));  	bytes [1] = (byte)BinStringToByte (binString.Substring (8' 8));  	bytes [2] = (byte)BinStringToByte (binString.Substring (16' 8));  	bytes [3] = (byte)BinStringToByte (binString.Substring (24' 8));  } else {  	bytes [0] = 0;  	bytes [1] = 0;  	bytes [2] = 0;  	bytes [3] = 0;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: if (wert != 0f) {  	if (wert < 0) {  		wert *= -1;  		binString = "1";  	} else {  		binString = "0";  	}  	int exponent = (int)Math.Floor ((double)Math.Log (wert) / Math.Log (2.0));  	wert = wert / (Math.Pow (2' exponent)) - 1;  	binString += ValToBinString ((byte)(exponent + 127));  	for (int cnt = 1; cnt <= 23; cnt++) {  		if (!(wert - System.Math.Pow (2' -cnt) < 0)) {  			wert = wert - System.Math.Pow (2' -cnt);  			binString += "1";  		} else  			binString += "0";  	}  	bytes [0] = (byte)BinStringToByte (binString.Substring (0' 8));  	bytes [1] = (byte)BinStringToByte (binString.Substring (8' 8));  	bytes [2] = (byte)BinStringToByte (binString.Substring (16' 8));  	bytes [3] = (byte)BinStringToByte (binString.Substring (24' 8));  } else {  	bytes [0] = 0;  	bytes [1] = 0;  	bytes [2] = 0;  	bytes [3] = 0;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: if (wert != 0f) {  	if (wert < 0) {  		wert *= -1;  		binString = "1";  	} else {  		binString = "0";  	}  	int exponent = (int)Math.Floor ((double)Math.Log (wert) / Math.Log (2.0));  	wert = wert / (Math.Pow (2' exponent)) - 1;  	binString += ValToBinString ((byte)(exponent + 127));  	for (int cnt = 1; cnt <= 23; cnt++) {  		if (!(wert - System.Math.Pow (2' -cnt) < 0)) {  			wert = wert - System.Math.Pow (2' -cnt);  			binString += "1";  		} else  			binString += "0";  	}  	bytes [0] = (byte)BinStringToByte (binString.Substring (0' 8));  	bytes [1] = (byte)BinStringToByte (binString.Substring (8' 8));  	bytes [2] = (byte)BinStringToByte (binString.Substring (16' 8));  	bytes [3] = (byte)BinStringToByte (binString.Substring (24' 8));  } else {  	bytes [0] = 0;  	bytes [1] = 0;  	bytes [2] = 0;  	bytes [3] = 0;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: wert = wert / (Math.Pow (2' exponent)) - 1;  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: binString += ValToBinString ((byte)(exponent + 127));  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: for (int cnt = 1; cnt <= 23; cnt++) {  	if (!(wert - System.Math.Pow (2' -cnt) < 0)) {  		wert = wert - System.Math.Pow (2' -cnt);  		binString += "1";  	} else  		binString += "0";  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: for (int cnt = 1; cnt <= 23; cnt++) {  	if (!(wert - System.Math.Pow (2' -cnt) < 0)) {  		wert = wert - System.Math.Pow (2' -cnt);  		binString += "1";  	} else  		binString += "0";  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: for (int cnt = 1; cnt <= 23; cnt++) {  	if (!(wert - System.Math.Pow (2' -cnt) < 0)) {  		wert = wert - System.Math.Pow (2' -cnt);  		binString += "1";  	} else  		binString += "0";  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: if (!(wert - System.Math.Pow (2' -cnt) < 0)) {  	wert = wert - System.Math.Pow (2' -cnt);  	binString += "1";  } else  	binString += "0";  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: if (!(wert - System.Math.Pow (2' -cnt) < 0)) {  	wert = wert - System.Math.Pow (2' -cnt);  	binString += "1";  } else  	binString += "0";  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: wert = wert - System.Math.Pow (2' -cnt);  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: bytes [0] = (byte)BinStringToByte (binString.Substring (0' 8));  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: bytes [1] = (byte)BinStringToByte (binString.Substring (8' 8));  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: bytes [1] = (byte)BinStringToByte (binString.Substring (8' 8));  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: bytes [2] = (byte)BinStringToByte (binString.Substring (16' 8));  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: bytes [2] = (byte)BinStringToByte (binString.Substring (16' 8));  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: bytes [2] = (byte)BinStringToByte (binString.Substring (16' 8));  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: bytes [3] = (byte)BinStringToByte (binString.Substring (24' 8));  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: bytes [3] = (byte)BinStringToByte (binString.Substring (24' 8));  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: bytes [3] = (byte)BinStringToByte (binString.Substring (24' 8));  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: bytes [2] = 0;  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToByteArray,The following statement contains a magic number: bytes [3] = 0;  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ToArray,The following statement contains a magic number: for (int cnt = 0; cnt < bytes.Length / 4; cnt++)  	values [cnt] = FromByteArray (new byte[] {  		bytes [counter++]'  		bytes [counter++]'  		bytes [counter++]'  		bytes [counter++]  	});  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ValToBinString,The following statement contains a magic number: for (int cnt = 7; cnt >= 0; cnt += -1) {  	if ((value & (byte)Math.Pow (2' cnt)) > 0)  		txt += "1";  	else  		txt += "0";  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ValToBinString,The following statement contains a magic number: for (int cnt = 7; cnt >= 0; cnt += -1) {  	if ((value & (byte)Math.Pow (2' cnt)) > 0)  		txt += "1";  	else  		txt += "0";  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,ValToBinString,The following statement contains a magic number: if ((value & (byte)Math.Pow (2' cnt)) > 0)  	txt += "1";  else  	txt += "0";  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,BinStringToByte,The following statement contains a magic number: if (txt.Length == 8) {  	for (cnt = 7; cnt >= 0; cnt += -1) {  		if (int.Parse (txt.Substring (cnt' 1)) == 1) {  			ret += (int)(Math.Pow (2' (txt.Length - 1 - cnt)));  		}  	}  	return (byte)ret;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,BinStringToByte,The following statement contains a magic number: if (txt.Length == 8) {  	for (cnt = 7; cnt >= 0; cnt += -1) {  		if (int.Parse (txt.Substring (cnt' 1)) == 1) {  			ret += (int)(Math.Pow (2' (txt.Length - 1 - cnt)));  		}  	}  	return (byte)ret;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,BinStringToByte,The following statement contains a magic number: if (txt.Length == 8) {  	for (cnt = 7; cnt >= 0; cnt += -1) {  		if (int.Parse (txt.Substring (cnt' 1)) == 1) {  			ret += (int)(Math.Pow (2' (txt.Length - 1 - cnt)));  		}  	}  	return (byte)ret;  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,BinStringToByte,The following statement contains a magic number: for (cnt = 7; cnt >= 0; cnt += -1) {  	if (int.Parse (txt.Substring (cnt' 1)) == 1) {  		ret += (int)(Math.Pow (2' (txt.Length - 1 - cnt)));  	}  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,BinStringToByte,The following statement contains a magic number: for (cnt = 7; cnt >= 0; cnt += -1) {  	if (int.Parse (txt.Substring (cnt' 1)) == 1) {  		ret += (int)(Math.Pow (2' (txt.Length - 1 - cnt)));  	}  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,BinStringToByte,The following statement contains a magic number: cnt = 7
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,BinStringToByte,The following statement contains a magic number: if (int.Parse (txt.Substring (cnt' 1)) == 1) {  	ret += (int)(Math.Pow (2' (txt.Length - 1 - cnt)));  }  
Magic Number,S7.Net.Types,Double,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Double.cs,BinStringToByte,The following statement contains a magic number: ret += (int)(Math.Pow (2' (txt.Length - 1 - cnt)));  
Magic Number,S7.Net.Types,DWord,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DWord.cs,FromByteArray,The following statement contains a magic number: return FromBytes (bytes [3]' bytes [2]' bytes [1]' bytes [0]);  
Magic Number,S7.Net.Types,DWord,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DWord.cs,FromByteArray,The following statement contains a magic number: return FromBytes (bytes [3]' bytes [2]' bytes [1]' bytes [0]);  
Magic Number,S7.Net.Types,DWord,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DWord.cs,FromBytes,The following statement contains a magic number: return (UInt32)(v1 + v2 * Math.Pow (2' 8) + v3 * Math.Pow (2' 16) + v4 * Math.Pow (2' 24));  
Magic Number,S7.Net.Types,DWord,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DWord.cs,FromBytes,The following statement contains a magic number: return (UInt32)(v1 + v2 * Math.Pow (2' 8) + v3 * Math.Pow (2' 16) + v4 * Math.Pow (2' 24));  
Magic Number,S7.Net.Types,DWord,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DWord.cs,FromBytes,The following statement contains a magic number: return (UInt32)(v1 + v2 * Math.Pow (2' 8) + v3 * Math.Pow (2' 16) + v4 * Math.Pow (2' 24));  
Magic Number,S7.Net.Types,DWord,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DWord.cs,FromBytes,The following statement contains a magic number: return (UInt32)(v1 + v2 * Math.Pow (2' 8) + v3 * Math.Pow (2' 16) + v4 * Math.Pow (2' 24));  
Magic Number,S7.Net.Types,DWord,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DWord.cs,FromBytes,The following statement contains a magic number: return (UInt32)(v1 + v2 * Math.Pow (2' 8) + v3 * Math.Pow (2' 16) + v4 * Math.Pow (2' 24));  
Magic Number,S7.Net.Types,DWord,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DWord.cs,FromBytes,The following statement contains a magic number: return (UInt32)(v1 + v2 * Math.Pow (2' 8) + v3 * Math.Pow (2' 16) + v4 * Math.Pow (2' 24));  
Magic Number,S7.Net.Types,DWord,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DWord.cs,ToByteArray,The following statement contains a magic number: for (int cnt = 0; cnt < x; cnt++) {  	Int64 x1 = (Int64)Math.Pow (256' (cnt));  	Int64 x3 = (Int64)(valLong / x1);  	bytes [x - cnt - 1] = (byte)(x3 & 255);  	valLong -= bytes [x - cnt - 1] * x1;  }  
Magic Number,S7.Net.Types,DWord,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DWord.cs,ToByteArray,The following statement contains a magic number: for (int cnt = 0; cnt < x; cnt++) {  	Int64 x1 = (Int64)Math.Pow (256' (cnt));  	Int64 x3 = (Int64)(valLong / x1);  	bytes [x - cnt - 1] = (byte)(x3 & 255);  	valLong -= bytes [x - cnt - 1] * x1;  }  
Magic Number,S7.Net.Types,DWord,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DWord.cs,ToByteArray,The following statement contains a magic number: bytes [x - cnt - 1] = (byte)(x3 & 255);  
Magic Number,S7.Net.Types,DWord,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\DWord.cs,ToArray,The following statement contains a magic number: for (int cnt = 0; cnt < bytes.Length / 4; cnt++)  	values [cnt] = FromByteArray (new byte[] {  		bytes [counter++]'  		bytes [counter++]'  		bytes [counter++]'  		bytes [counter++]  	});  
Magic Number,S7.Net.Types,Int,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Int.cs,FromByteArray,The following statement contains a magic number: if (bytes.Length != 2) {  	throw new ArgumentException ("Wrong number of bytes. Bytes array must contain 2 bytes.");  }  
Magic Number,S7.Net.Types,Int,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Int.cs,FromBytes,The following statement contains a magic number: return (Int16)(HiVal * 256 + LoVal);  
Magic Number,S7.Net.Types,Int,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Int.cs,ToByteArray,The following statement contains a magic number: for (int cnt = 0; cnt < x; cnt++) {  	Int64 x1 = (Int64)Math.Pow (256' (cnt));  	Int64 x3 = (Int64)(valLong / x1);  	bytes [x - cnt - 1] = (byte)(x3 & 255);  	valLong -= bytes [x - cnt - 1] * x1;  }  
Magic Number,S7.Net.Types,Int,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Int.cs,ToByteArray,The following statement contains a magic number: for (int cnt = 0; cnt < x; cnt++) {  	Int64 x1 = (Int64)Math.Pow (256' (cnt));  	Int64 x3 = (Int64)(valLong / x1);  	bytes [x - cnt - 1] = (byte)(x3 & 255);  	valLong -= bytes [x - cnt - 1] * x1;  }  
Magic Number,S7.Net.Types,Int,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Int.cs,ToByteArray,The following statement contains a magic number: bytes [x - cnt - 1] = (byte)(x3 & 255);  
Magic Number,S7.Net.Types,Int,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Int.cs,ToArray,The following statement contains a magic number: for (int cnt = 0; cnt < bytes.Length / 2; cnt++)  	values [cnt] = FromByteArray (new byte[] {  		bytes [counter++]'  		bytes [counter++]  	});  
Magic Number,S7.Net.Types,Int,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Int.cs,CWord,The following statement contains a magic number: if (value > 32767) {  	value -= 32768;  	value = 32768 - value;  	value *= -1;  }  
Magic Number,S7.Net.Types,Int,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Int.cs,CWord,The following statement contains a magic number: if (value > 32767) {  	value -= 32768;  	value = 32768 - value;  	value *= -1;  }  
Magic Number,S7.Net.Types,Int,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Int.cs,CWord,The following statement contains a magic number: if (value > 32767) {  	value -= 32768;  	value = 32768 - value;  	value *= -1;  }  
Magic Number,S7.Net.Types,Int,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Int.cs,CWord,The following statement contains a magic number: value -= 32768;  
Magic Number,S7.Net.Types,Int,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Int.cs,CWord,The following statement contains a magic number: value = 32768 - value;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		numBytes++;  		break;  	case "Int16":  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 2;  		break;  	case "Int32":  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	case "Float":  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	default:  		numBytes += GetStructSize (info.FieldType);  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		numBytes++;  		break;  	case "Int16":  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 2;  		break;  	case "Int32":  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	case "Float":  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	default:  		numBytes += GetStructSize (info.FieldType);  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		numBytes++;  		break;  	case "Int16":  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 2;  		break;  	case "Int32":  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	case "Float":  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	default:  		numBytes += GetStructSize (info.FieldType);  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		numBytes++;  		break;  	case "Int16":  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 2;  		break;  	case "Int32":  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	case "Float":  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	default:  		numBytes += GetStructSize (info.FieldType);  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		numBytes++;  		break;  	case "Int16":  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 2;  		break;  	case "Int32":  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	case "Float":  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	default:  		numBytes += GetStructSize (info.FieldType);  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		numBytes++;  		break;  	case "Int16":  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 2;  		break;  	case "Int32":  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	case "Float":  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	default:  		numBytes += GetStructSize (info.FieldType);  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		numBytes++;  		break;  	case "Int16":  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 2;  		break;  	case "Int32":  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	case "Float":  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	default:  		numBytes += GetStructSize (info.FieldType);  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		numBytes++;  		break;  	case "Int16":  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 2;  		break;  	case "Int32":  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	case "Float":  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	default:  		numBytes += GetStructSize (info.FieldType);  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		numBytes++;  		break;  	case "Int16":  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 2;  		break;  	case "Int32":  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	case "Float":  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	default:  		numBytes += GetStructSize (info.FieldType);  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		numBytes++;  		break;  	case "Int16":  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 2;  		break;  	case "Int32":  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	case "Float":  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		numBytes += 4;  		break;  	default:  		numBytes += GetStructSize (info.FieldType);  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	numBytes++;  	break;  case "Int16":  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 2;  	break;  case "Int32":  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  case "Float":  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  default:  	numBytes += GetStructSize (info.FieldType);  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	numBytes++;  	break;  case "Int16":  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 2;  	break;  case "Int32":  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  case "Float":  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  default:  	numBytes += GetStructSize (info.FieldType);  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	numBytes++;  	break;  case "Int16":  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 2;  	break;  case "Int32":  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  case "Float":  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  default:  	numBytes += GetStructSize (info.FieldType);  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	numBytes++;  	break;  case "Int16":  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 2;  	break;  case "Int32":  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  case "Float":  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  default:  	numBytes += GetStructSize (info.FieldType);  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	numBytes++;  	break;  case "Int16":  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 2;  	break;  case "Int32":  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  case "Float":  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  default:  	numBytes += GetStructSize (info.FieldType);  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	numBytes++;  	break;  case "Int16":  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 2;  	break;  case "Int32":  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  case "Float":  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  default:  	numBytes += GetStructSize (info.FieldType);  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	numBytes++;  	break;  case "Int16":  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 2;  	break;  case "Int32":  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  case "Float":  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  default:  	numBytes += GetStructSize (info.FieldType);  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	numBytes++;  	break;  case "Int16":  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 2;  	break;  case "Int32":  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  case "Float":  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  default:  	numBytes += GetStructSize (info.FieldType);  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	numBytes++;  	break;  case "Int16":  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 2;  	break;  case "Int32":  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  case "Float":  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  default:  	numBytes += GetStructSize (info.FieldType);  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	numBytes++;  	break;  case "Int16":  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 2;  	break;  case "Int32":  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  case "Float":  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	numBytes += 4;  	break;  default:  	numBytes += GetStructSize (info.FieldType);  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: numBytes += 0.125;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: numBytes += 2;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: numBytes += 4;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,GetStructSize,The following statement contains a magic number: numBytes += 4;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			info.SetValue (structValue' true);  		else  			info.SetValue (structValue' false);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		info.SetValue (structValue' source.ConvertToShort ());  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		info.SetValue (structValue' sourceUInt.ConvertToInt ());  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		}));  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetStructSize (info.FieldType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		info.SetValue (structValue' FromBytes (info.FieldType' buffer));  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			info.SetValue (structValue' true);  		else  			info.SetValue (structValue' false);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		info.SetValue (structValue' source.ConvertToShort ());  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		info.SetValue (structValue' sourceUInt.ConvertToInt ());  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		}));  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetStructSize (info.FieldType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		info.SetValue (structValue' FromBytes (info.FieldType' buffer));  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			info.SetValue (structValue' true);  		else  			info.SetValue (structValue' false);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		info.SetValue (structValue' source.ConvertToShort ());  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		info.SetValue (structValue' sourceUInt.ConvertToInt ());  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		}));  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetStructSize (info.FieldType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		info.SetValue (structValue' FromBytes (info.FieldType' buffer));  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			info.SetValue (structValue' true);  		else  			info.SetValue (structValue' false);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		info.SetValue (structValue' source.ConvertToShort ());  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		info.SetValue (structValue' sourceUInt.ConvertToInt ());  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		}));  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetStructSize (info.FieldType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		info.SetValue (structValue' FromBytes (info.FieldType' buffer));  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			info.SetValue (structValue' true);  		else  			info.SetValue (structValue' false);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		info.SetValue (structValue' source.ConvertToShort ());  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		info.SetValue (structValue' sourceUInt.ConvertToInt ());  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		}));  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetStructSize (info.FieldType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		info.SetValue (structValue' FromBytes (info.FieldType' buffer));  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			info.SetValue (structValue' true);  		else  			info.SetValue (structValue' false);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		info.SetValue (structValue' source.ConvertToShort ());  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		info.SetValue (structValue' sourceUInt.ConvertToInt ());  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		}));  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetStructSize (info.FieldType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		info.SetValue (structValue' FromBytes (info.FieldType' buffer));  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			info.SetValue (structValue' true);  		else  			info.SetValue (structValue' false);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		info.SetValue (structValue' source.ConvertToShort ());  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		info.SetValue (structValue' sourceUInt.ConvertToInt ());  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		}));  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetStructSize (info.FieldType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		info.SetValue (structValue' FromBytes (info.FieldType' buffer));  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			info.SetValue (structValue' true);  		else  			info.SetValue (structValue' false);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		info.SetValue (structValue' source.ConvertToShort ());  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		info.SetValue (structValue' sourceUInt.ConvertToInt ());  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		}));  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetStructSize (info.FieldType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		info.SetValue (structValue' FromBytes (info.FieldType' buffer));  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			info.SetValue (structValue' true);  		else  			info.SetValue (structValue' false);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		info.SetValue (structValue' source.ConvertToShort ());  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		info.SetValue (structValue' sourceUInt.ConvertToInt ());  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		}));  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetStructSize (info.FieldType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		info.SetValue (structValue' FromBytes (info.FieldType' buffer));  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			info.SetValue (structValue' true);  		else  			info.SetValue (structValue' false);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		info.SetValue (structValue' source.ConvertToShort ());  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		info.SetValue (structValue' sourceUInt.ConvertToInt ());  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		}));  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetStructSize (info.FieldType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		info.SetValue (structValue' FromBytes (info.FieldType' buffer));  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			info.SetValue (structValue' true);  		else  			info.SetValue (structValue' false);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		info.SetValue (structValue' source.ConvertToShort ());  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		info.SetValue (structValue' sourceUInt.ConvertToInt ());  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		}));  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetStructSize (info.FieldType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		info.SetValue (structValue' FromBytes (info.FieldType' buffer));  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			info.SetValue (structValue' true);  		else  			info.SetValue (structValue' false);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		info.SetValue (structValue' source.ConvertToShort ());  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		info.SetValue (structValue' sourceUInt.ConvertToInt ());  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		}));  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetStructSize (info.FieldType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		info.SetValue (structValue' FromBytes (info.FieldType' buffer));  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			info.SetValue (structValue' true);  		else  			info.SetValue (structValue' false);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		info.SetValue (structValue' source.ConvertToShort ());  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		info.SetValue (structValue' sourceUInt.ConvertToInt ());  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		}));  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetStructSize (info.FieldType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		info.SetValue (structValue' FromBytes (info.FieldType' buffer));  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			info.SetValue (structValue' true);  		else  			info.SetValue (structValue' false);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		info.SetValue (structValue' source.ConvertToShort ());  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		info.SetValue (structValue' sourceUInt.ConvertToInt ());  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		}));  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetStructSize (info.FieldType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		info.SetValue (structValue' FromBytes (info.FieldType' buffer));  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			info.SetValue (structValue' true);  		else  			info.SetValue (structValue' false);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		info.SetValue (structValue' source.ConvertToShort ());  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		info.SetValue (structValue' sourceUInt.ConvertToInt ());  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		}));  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetStructSize (info.FieldType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		info.SetValue (structValue' FromBytes (info.FieldType' buffer));  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			info.SetValue (structValue' true);  		else  			info.SetValue (structValue' false);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		info.SetValue (structValue' source.ConvertToShort ());  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		info.SetValue (structValue' sourceUInt.ConvertToInt ());  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		}));  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetStructSize (info.FieldType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		info.SetValue (structValue' FromBytes (info.FieldType' buffer));  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			info.SetValue (structValue' true);  		else  			info.SetValue (structValue' false);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		info.SetValue (structValue' source.ConvertToShort ());  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		info.SetValue (structValue' sourceUInt.ConvertToInt ());  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		}));  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetStructSize (info.FieldType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		info.SetValue (structValue' FromBytes (info.FieldType' buffer));  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			info.SetValue (structValue' true);  		else  			info.SetValue (structValue' false);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		info.SetValue (structValue' source.ConvertToShort ());  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		info.SetValue (structValue' sourceUInt.ConvertToInt ());  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		}));  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetStructSize (info.FieldType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		info.SetValue (structValue' FromBytes (info.FieldType' buffer));  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			info.SetValue (structValue' true);  		else  			info.SetValue (structValue' false);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		info.SetValue (structValue' source.ConvertToShort ());  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		info.SetValue (structValue' sourceUInt.ConvertToInt ());  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		}));  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetStructSize (info.FieldType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		info.SetValue (structValue' FromBytes (info.FieldType' buffer));  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			info.SetValue (structValue' true);  		else  			info.SetValue (structValue' false);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		info.SetValue (structValue' source.ConvertToShort ());  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		info.SetValue (structValue' sourceUInt.ConvertToInt ());  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		}));  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetStructSize (info.FieldType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		info.SetValue (structValue' FromBytes (info.FieldType' buffer));  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			info.SetValue (structValue' true);  		else  			info.SetValue (structValue' false);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		info.SetValue (structValue' source.ConvertToShort ());  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		info.SetValue (structValue' sourceUInt.ConvertToInt ());  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		}));  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetStructSize (info.FieldType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		info.SetValue (structValue' FromBytes (info.FieldType' buffer));  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			info.SetValue (structValue' true);  		else  			info.SetValue (structValue' false);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		info.SetValue (structValue' source.ConvertToShort ());  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		info.SetValue (structValue' sourceUInt.ConvertToInt ());  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		}));  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetStructSize (info.FieldType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		info.SetValue (structValue' FromBytes (info.FieldType' buffer));  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			info.SetValue (structValue' true);  		else  			info.SetValue (structValue' false);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		info.SetValue (structValue' source.ConvertToShort ());  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		info.SetValue (structValue' sourceUInt.ConvertToInt ());  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		}));  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetStructSize (info.FieldType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		info.SetValue (structValue' FromBytes (info.FieldType' buffer));  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  			info.SetValue (structValue' true);  		else  			info.SetValue (structValue' false);  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = Math.Ceiling (numBytes);  		info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  		numBytes++;  		break;  	case "Int16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  		info.SetValue (structValue' source.ConvertToShort ());  		numBytes += 2;  		break;  	case "UInt16":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  		numBytes += 2;  		break;  	case "Int32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  		info.SetValue (structValue' sourceUInt.ConvertToInt ());  		numBytes += 4;  		break;  	case "UInt32":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  		numBytes += 4;  		break;  	case "Double":  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		// hier auswerten  		info.SetValue (structValue' Double.FromByteArray (new byte[] {  			bytes [(int)numBytes]'  			bytes [(int)numBytes + 1]'  			bytes [(int)numBytes + 2]'  			bytes [(int)numBytes + 3]  		}));  		numBytes += 4;  		break;  	default:  		var buffer = new byte[GetStructSize (info.FieldType)];  		if (buffer.Length == 0)  			continue;  		Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  		info.SetValue (structValue' FromBytes (info.FieldType' buffer));  		numBytes += buffer.Length;  		break;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		info.SetValue (structValue' true);  	else  		info.SetValue (structValue' false);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	info.SetValue (structValue' source.ConvertToShort ());  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	info.SetValue (structValue' sourceUInt.ConvertToInt ());  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	}));  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetStructSize (info.FieldType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	info.SetValue (structValue' FromBytes (info.FieldType' buffer));  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		info.SetValue (structValue' true);  	else  		info.SetValue (structValue' false);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	info.SetValue (structValue' source.ConvertToShort ());  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	info.SetValue (structValue' sourceUInt.ConvertToInt ());  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	}));  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetStructSize (info.FieldType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	info.SetValue (structValue' FromBytes (info.FieldType' buffer));  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		info.SetValue (structValue' true);  	else  		info.SetValue (structValue' false);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	info.SetValue (structValue' source.ConvertToShort ());  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	info.SetValue (structValue' sourceUInt.ConvertToInt ());  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	}));  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetStructSize (info.FieldType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	info.SetValue (structValue' FromBytes (info.FieldType' buffer));  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		info.SetValue (structValue' true);  	else  		info.SetValue (structValue' false);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	info.SetValue (structValue' source.ConvertToShort ());  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	info.SetValue (structValue' sourceUInt.ConvertToInt ());  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	}));  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetStructSize (info.FieldType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	info.SetValue (structValue' FromBytes (info.FieldType' buffer));  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		info.SetValue (structValue' true);  	else  		info.SetValue (structValue' false);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	info.SetValue (structValue' source.ConvertToShort ());  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	info.SetValue (structValue' sourceUInt.ConvertToInt ());  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	}));  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetStructSize (info.FieldType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	info.SetValue (structValue' FromBytes (info.FieldType' buffer));  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		info.SetValue (structValue' true);  	else  		info.SetValue (structValue' false);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	info.SetValue (structValue' source.ConvertToShort ());  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	info.SetValue (structValue' sourceUInt.ConvertToInt ());  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	}));  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetStructSize (info.FieldType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	info.SetValue (structValue' FromBytes (info.FieldType' buffer));  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		info.SetValue (structValue' true);  	else  		info.SetValue (structValue' false);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	info.SetValue (structValue' source.ConvertToShort ());  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	info.SetValue (structValue' sourceUInt.ConvertToInt ());  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	}));  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetStructSize (info.FieldType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	info.SetValue (structValue' FromBytes (info.FieldType' buffer));  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		info.SetValue (structValue' true);  	else  		info.SetValue (structValue' false);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	info.SetValue (structValue' source.ConvertToShort ());  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	info.SetValue (structValue' sourceUInt.ConvertToInt ());  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	}));  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetStructSize (info.FieldType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	info.SetValue (structValue' FromBytes (info.FieldType' buffer));  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		info.SetValue (structValue' true);  	else  		info.SetValue (structValue' false);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	info.SetValue (structValue' source.ConvertToShort ());  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	info.SetValue (structValue' sourceUInt.ConvertToInt ());  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	}));  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetStructSize (info.FieldType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	info.SetValue (structValue' FromBytes (info.FieldType' buffer));  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		info.SetValue (structValue' true);  	else  		info.SetValue (structValue' false);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	info.SetValue (structValue' source.ConvertToShort ());  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	info.SetValue (structValue' sourceUInt.ConvertToInt ());  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	}));  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetStructSize (info.FieldType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	info.SetValue (structValue' FromBytes (info.FieldType' buffer));  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		info.SetValue (structValue' true);  	else  		info.SetValue (structValue' false);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	info.SetValue (structValue' source.ConvertToShort ());  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	info.SetValue (structValue' sourceUInt.ConvertToInt ());  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	}));  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetStructSize (info.FieldType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	info.SetValue (structValue' FromBytes (info.FieldType' buffer));  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		info.SetValue (structValue' true);  	else  		info.SetValue (structValue' false);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	info.SetValue (structValue' source.ConvertToShort ());  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	info.SetValue (structValue' sourceUInt.ConvertToInt ());  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	}));  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetStructSize (info.FieldType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	info.SetValue (structValue' FromBytes (info.FieldType' buffer));  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		info.SetValue (structValue' true);  	else  		info.SetValue (structValue' false);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	info.SetValue (structValue' source.ConvertToShort ());  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	info.SetValue (structValue' sourceUInt.ConvertToInt ());  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	}));  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetStructSize (info.FieldType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	info.SetValue (structValue' FromBytes (info.FieldType' buffer));  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		info.SetValue (structValue' true);  	else  		info.SetValue (structValue' false);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	info.SetValue (structValue' source.ConvertToShort ());  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	info.SetValue (structValue' sourceUInt.ConvertToInt ());  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	}));  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetStructSize (info.FieldType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	info.SetValue (structValue' FromBytes (info.FieldType' buffer));  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		info.SetValue (structValue' true);  	else  		info.SetValue (structValue' false);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	info.SetValue (structValue' source.ConvertToShort ());  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	info.SetValue (structValue' sourceUInt.ConvertToInt ());  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	}));  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetStructSize (info.FieldType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	info.SetValue (structValue' FromBytes (info.FieldType' buffer));  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		info.SetValue (structValue' true);  	else  		info.SetValue (structValue' false);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	info.SetValue (structValue' source.ConvertToShort ());  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	info.SetValue (structValue' sourceUInt.ConvertToInt ());  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	}));  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetStructSize (info.FieldType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	info.SetValue (structValue' FromBytes (info.FieldType' buffer));  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		info.SetValue (structValue' true);  	else  		info.SetValue (structValue' false);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	info.SetValue (structValue' source.ConvertToShort ());  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	info.SetValue (structValue' sourceUInt.ConvertToInt ());  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	}));  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetStructSize (info.FieldType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	info.SetValue (structValue' FromBytes (info.FieldType' buffer));  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		info.SetValue (structValue' true);  	else  		info.SetValue (structValue' false);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	info.SetValue (structValue' source.ConvertToShort ());  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	info.SetValue (structValue' sourceUInt.ConvertToInt ());  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	}));  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetStructSize (info.FieldType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	info.SetValue (structValue' FromBytes (info.FieldType' buffer));  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		info.SetValue (structValue' true);  	else  		info.SetValue (structValue' false);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	info.SetValue (structValue' source.ConvertToShort ());  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	info.SetValue (structValue' sourceUInt.ConvertToInt ());  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	}));  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetStructSize (info.FieldType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	info.SetValue (structValue' FromBytes (info.FieldType' buffer));  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		info.SetValue (structValue' true);  	else  		info.SetValue (structValue' false);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	info.SetValue (structValue' source.ConvertToShort ());  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	info.SetValue (structValue' sourceUInt.ConvertToInt ());  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	}));  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetStructSize (info.FieldType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	info.SetValue (structValue' FromBytes (info.FieldType' buffer));  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		info.SetValue (structValue' true);  	else  		info.SetValue (structValue' false);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	info.SetValue (structValue' source.ConvertToShort ());  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	info.SetValue (structValue' sourceUInt.ConvertToInt ());  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	}));  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetStructSize (info.FieldType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	info.SetValue (structValue' FromBytes (info.FieldType' buffer));  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		info.SetValue (structValue' true);  	else  		info.SetValue (structValue' false);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	info.SetValue (structValue' source.ConvertToShort ());  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	info.SetValue (structValue' sourceUInt.ConvertToInt ());  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	}));  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetStructSize (info.FieldType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	info.SetValue (structValue' FromBytes (info.FieldType' buffer));  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		info.SetValue (structValue' true);  	else  		info.SetValue (structValue' false);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	info.SetValue (structValue' source.ConvertToShort ());  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	info.SetValue (structValue' sourceUInt.ConvertToInt ());  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	}));  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetStructSize (info.FieldType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	info.SetValue (structValue' FromBytes (info.FieldType' buffer));  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  		info.SetValue (structValue' true);  	else  		info.SetValue (structValue' false);  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = Math.Ceiling (numBytes);  	info.SetValue (structValue' (byte)(bytes [(int)numBytes]));  	numBytes++;  	break;  case "Int16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	ushort source = Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]);  	info.SetValue (structValue' source.ConvertToShort ());  	numBytes += 2;  	break;  case "UInt16":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Word.FromBytes (bytes [(int)numBytes + 1]' bytes [(int)numBytes]));  	numBytes += 2;  	break;  case "Int32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	uint sourceUInt = DWord.FromBytes (bytes [(int)numBytes + 3]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 0]);  	info.SetValue (structValue' sourceUInt.ConvertToInt ());  	numBytes += 4;  	break;  case "UInt32":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  	numBytes += 4;  	break;  case "Double":  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	// hier auswerten  	info.SetValue (structValue' Double.FromByteArray (new byte[] {  		bytes [(int)numBytes]'  		bytes [(int)numBytes + 1]'  		bytes [(int)numBytes + 2]'  		bytes [(int)numBytes + 3]  	}));  	numBytes += 4;  	break;  default:  	var buffer = new byte[GetStructSize (info.FieldType)];  	if (buffer.Length == 0)  		continue;  	Buffer.BlockCopy (bytes' (int)Math.Ceiling (numBytes)' buffer' 0' buffer.Length);  	info.SetValue (structValue' FromBytes (info.FieldType' buffer));  	numBytes += buffer.Length;  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: bitPos = (int)((numBytes - (double)bytePos) / 0.125);  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: if ((bytes [bytePos] & (int)Math.Pow (2' bitPos)) != 0)  	info.SetValue (structValue' true);  else  	info.SetValue (structValue' false);  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: numBytes += 0.125;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: numBytes += 2;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: numBytes += 2;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: numBytes += 4;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: info.SetValue (structValue' DWord.FromBytes (bytes [(int)numBytes]' bytes [(int)numBytes + 1]' bytes [(int)numBytes + 2]' bytes [(int)numBytes + 3]));  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: numBytes += 4;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: info.SetValue (structValue' Double.FromByteArray (new byte[] {  	bytes [(int)numBytes]'  	bytes [(int)numBytes + 1]'  	bytes [(int)numBytes + 2]'  	bytes [(int)numBytes + 3]  }));  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: info.SetValue (structValue' Double.FromByteArray (new byte[] {  	bytes [(int)numBytes]'  	bytes [(int)numBytes + 1]'  	bytes [(int)numBytes + 2]'  	bytes [(int)numBytes + 3]  }));  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,FromBytes,The following statement contains a magic number: numBytes += 4;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	bytes2 = null;  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bool)info.GetValue (structValue))  			bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  		// is true  		else  			bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  		// is false  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = (int)Math.Ceiling (numBytes);  		bytePos = (int)numBytes;  		bytes [bytePos] = (byte)info.GetValue (structValue);  		numBytes++;  		break;  	case "Int16":  		bytes2 = Int.ToByteArray ((Int16)info.GetValue (structValue));  		break;  	case "UInt16":  		bytes2 = Word.ToByteArray ((UInt16)info.GetValue (structValue));  		break;  	case "Int32":  		bytes2 = DInt.ToByteArray ((Int32)info.GetValue (structValue));  		break;  	case "UInt32":  		bytes2 = DWord.ToByteArray ((UInt32)info.GetValue (structValue));  		break;  	case "Double":  		bytes2 = Double.ToByteArray ((double)info.GetValue (structValue));  		break;  	}  	if (bytes2 != null) {  		// add them  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		bytePos = (int)numBytes;  		for (int bCnt = 0; bCnt < bytes2.Length; bCnt++)  			bytes [bytePos + bCnt] = bytes2 [bCnt];  		numBytes += bytes2.Length;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	bytes2 = null;  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bool)info.GetValue (structValue))  			bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  		// is true  		else  			bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  		// is false  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = (int)Math.Ceiling (numBytes);  		bytePos = (int)numBytes;  		bytes [bytePos] = (byte)info.GetValue (structValue);  		numBytes++;  		break;  	case "Int16":  		bytes2 = Int.ToByteArray ((Int16)info.GetValue (structValue));  		break;  	case "UInt16":  		bytes2 = Word.ToByteArray ((UInt16)info.GetValue (structValue));  		break;  	case "Int32":  		bytes2 = DInt.ToByteArray ((Int32)info.GetValue (structValue));  		break;  	case "UInt32":  		bytes2 = DWord.ToByteArray ((UInt32)info.GetValue (structValue));  		break;  	case "Double":  		bytes2 = Double.ToByteArray ((double)info.GetValue (structValue));  		break;  	}  	if (bytes2 != null) {  		// add them  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		bytePos = (int)numBytes;  		for (int bCnt = 0; bCnt < bytes2.Length; bCnt++)  			bytes [bytePos + bCnt] = bytes2 [bCnt];  		numBytes += bytes2.Length;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	bytes2 = null;  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bool)info.GetValue (structValue))  			bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  		// is true  		else  			bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  		// is false  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = (int)Math.Ceiling (numBytes);  		bytePos = (int)numBytes;  		bytes [bytePos] = (byte)info.GetValue (structValue);  		numBytes++;  		break;  	case "Int16":  		bytes2 = Int.ToByteArray ((Int16)info.GetValue (structValue));  		break;  	case "UInt16":  		bytes2 = Word.ToByteArray ((UInt16)info.GetValue (structValue));  		break;  	case "Int32":  		bytes2 = DInt.ToByteArray ((Int32)info.GetValue (structValue));  		break;  	case "UInt32":  		bytes2 = DWord.ToByteArray ((UInt32)info.GetValue (structValue));  		break;  	case "Double":  		bytes2 = Double.ToByteArray ((double)info.GetValue (structValue));  		break;  	}  	if (bytes2 != null) {  		// add them  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		bytePos = (int)numBytes;  		for (int bCnt = 0; bCnt < bytes2.Length; bCnt++)  			bytes [bytePos + bCnt] = bytes2 [bCnt];  		numBytes += bytes2.Length;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	bytes2 = null;  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bool)info.GetValue (structValue))  			bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  		// is true  		else  			bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  		// is false  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = (int)Math.Ceiling (numBytes);  		bytePos = (int)numBytes;  		bytes [bytePos] = (byte)info.GetValue (structValue);  		numBytes++;  		break;  	case "Int16":  		bytes2 = Int.ToByteArray ((Int16)info.GetValue (structValue));  		break;  	case "UInt16":  		bytes2 = Word.ToByteArray ((UInt16)info.GetValue (structValue));  		break;  	case "Int32":  		bytes2 = DInt.ToByteArray ((Int32)info.GetValue (structValue));  		break;  	case "UInt32":  		bytes2 = DWord.ToByteArray ((UInt32)info.GetValue (structValue));  		break;  	case "Double":  		bytes2 = Double.ToByteArray ((double)info.GetValue (structValue));  		break;  	}  	if (bytes2 != null) {  		// add them  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		bytePos = (int)numBytes;  		for (int bCnt = 0; bCnt < bytes2.Length; bCnt++)  			bytes [bytePos + bCnt] = bytes2 [bCnt];  		numBytes += bytes2.Length;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	bytes2 = null;  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bool)info.GetValue (structValue))  			bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  		// is true  		else  			bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  		// is false  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = (int)Math.Ceiling (numBytes);  		bytePos = (int)numBytes;  		bytes [bytePos] = (byte)info.GetValue (structValue);  		numBytes++;  		break;  	case "Int16":  		bytes2 = Int.ToByteArray ((Int16)info.GetValue (structValue));  		break;  	case "UInt16":  		bytes2 = Word.ToByteArray ((UInt16)info.GetValue (structValue));  		break;  	case "Int32":  		bytes2 = DInt.ToByteArray ((Int32)info.GetValue (structValue));  		break;  	case "UInt32":  		bytes2 = DWord.ToByteArray ((UInt32)info.GetValue (structValue));  		break;  	case "Double":  		bytes2 = Double.ToByteArray ((double)info.GetValue (structValue));  		break;  	}  	if (bytes2 != null) {  		// add them  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		bytePos = (int)numBytes;  		for (int bCnt = 0; bCnt < bytes2.Length; bCnt++)  			bytes [bytePos + bCnt] = bytes2 [bCnt];  		numBytes += bytes2.Length;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: foreach (System.Reflection.FieldInfo info in infos) {  	bytes2 = null;  	switch (info.FieldType.Name) {  	case "Boolean":  		// get the value  		bytePos = (int)Math.Floor (numBytes);  		bitPos = (int)((numBytes - (double)bytePos) / 0.125);  		if ((bool)info.GetValue (structValue))  			bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  		// is true  		else  			bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  		// is false  		numBytes += 0.125;  		break;  	case "Byte":  		numBytes = (int)Math.Ceiling (numBytes);  		bytePos = (int)numBytes;  		bytes [bytePos] = (byte)info.GetValue (structValue);  		numBytes++;  		break;  	case "Int16":  		bytes2 = Int.ToByteArray ((Int16)info.GetValue (structValue));  		break;  	case "UInt16":  		bytes2 = Word.ToByteArray ((UInt16)info.GetValue (structValue));  		break;  	case "Int32":  		bytes2 = DInt.ToByteArray ((Int32)info.GetValue (structValue));  		break;  	case "UInt32":  		bytes2 = DWord.ToByteArray ((UInt32)info.GetValue (structValue));  		break;  	case "Double":  		bytes2 = Double.ToByteArray ((double)info.GetValue (structValue));  		break;  	}  	if (bytes2 != null) {  		// add them  		numBytes = Math.Ceiling (numBytes);  		if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  			numBytes++;  		bytePos = (int)numBytes;  		for (int bCnt = 0; bCnt < bytes2.Length; bCnt++)  			bytes [bytePos + bCnt] = bytes2 [bCnt];  		numBytes += bytes2.Length;  	}  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bool)info.GetValue (structValue))  		bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  	// is true  	else  		bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  	// is false  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = (int)Math.Ceiling (numBytes);  	bytePos = (int)numBytes;  	bytes [bytePos] = (byte)info.GetValue (structValue);  	numBytes++;  	break;  case "Int16":  	bytes2 = Int.ToByteArray ((Int16)info.GetValue (structValue));  	break;  case "UInt16":  	bytes2 = Word.ToByteArray ((UInt16)info.GetValue (structValue));  	break;  case "Int32":  	bytes2 = DInt.ToByteArray ((Int32)info.GetValue (structValue));  	break;  case "UInt32":  	bytes2 = DWord.ToByteArray ((UInt32)info.GetValue (structValue));  	break;  case "Double":  	bytes2 = Double.ToByteArray ((double)info.GetValue (structValue));  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bool)info.GetValue (structValue))  		bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  	// is true  	else  		bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  	// is false  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = (int)Math.Ceiling (numBytes);  	bytePos = (int)numBytes;  	bytes [bytePos] = (byte)info.GetValue (structValue);  	numBytes++;  	break;  case "Int16":  	bytes2 = Int.ToByteArray ((Int16)info.GetValue (structValue));  	break;  case "UInt16":  	bytes2 = Word.ToByteArray ((UInt16)info.GetValue (structValue));  	break;  case "Int32":  	bytes2 = DInt.ToByteArray ((Int32)info.GetValue (structValue));  	break;  case "UInt32":  	bytes2 = DWord.ToByteArray ((UInt32)info.GetValue (structValue));  	break;  case "Double":  	bytes2 = Double.ToByteArray ((double)info.GetValue (structValue));  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bool)info.GetValue (structValue))  		bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  	// is true  	else  		bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  	// is false  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = (int)Math.Ceiling (numBytes);  	bytePos = (int)numBytes;  	bytes [bytePos] = (byte)info.GetValue (structValue);  	numBytes++;  	break;  case "Int16":  	bytes2 = Int.ToByteArray ((Int16)info.GetValue (structValue));  	break;  case "UInt16":  	bytes2 = Word.ToByteArray ((UInt16)info.GetValue (structValue));  	break;  case "Int32":  	bytes2 = DInt.ToByteArray ((Int32)info.GetValue (structValue));  	break;  case "UInt32":  	bytes2 = DWord.ToByteArray ((UInt32)info.GetValue (structValue));  	break;  case "Double":  	bytes2 = Double.ToByteArray ((double)info.GetValue (structValue));  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bool)info.GetValue (structValue))  		bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  	// is true  	else  		bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  	// is false  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = (int)Math.Ceiling (numBytes);  	bytePos = (int)numBytes;  	bytes [bytePos] = (byte)info.GetValue (structValue);  	numBytes++;  	break;  case "Int16":  	bytes2 = Int.ToByteArray ((Int16)info.GetValue (structValue));  	break;  case "UInt16":  	bytes2 = Word.ToByteArray ((UInt16)info.GetValue (structValue));  	break;  case "Int32":  	bytes2 = DInt.ToByteArray ((Int32)info.GetValue (structValue));  	break;  case "UInt32":  	bytes2 = DWord.ToByteArray ((UInt32)info.GetValue (structValue));  	break;  case "Double":  	bytes2 = Double.ToByteArray ((double)info.GetValue (structValue));  	break;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: bitPos = (int)((numBytes - (double)bytePos) / 0.125);  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: if ((bool)info.GetValue (structValue))  	bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  // is true  else  	bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: if ((bool)info.GetValue (structValue))  	bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  // is true  else  	bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: numBytes += 0.125;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: if (bytes2 != null) {  	// add them  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	bytePos = (int)numBytes;  	for (int bCnt = 0; bCnt < bytes2.Length; bCnt++)  		bytes [bytePos + bCnt] = bytes2 [bCnt];  	numBytes += bytes2.Length;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: if (bytes2 != null) {  	// add them  	numBytes = Math.Ceiling (numBytes);  	if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  		numBytes++;  	bytePos = (int)numBytes;  	for (int bCnt = 0; bCnt < bytes2.Length; bCnt++)  		bytes [bytePos + bCnt] = bytes2 [bCnt];  	numBytes += bytes2.Length;  }  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following statement contains a magic number: if ((numBytes / 2 - Math.Floor (numBytes / 2.0)) > 0)  	numBytes++;  
Magic Number,S7.Net.Types,Timer,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: wert = Conversion.BinStringToInt32 (txt.Substring (4' 4)) * 100.0;  
Magic Number,S7.Net.Types,Timer,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: wert = Conversion.BinStringToInt32 (txt.Substring (4' 4)) * 100.0;  
Magic Number,S7.Net.Types,Timer,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: wert = Conversion.BinStringToInt32 (txt.Substring (4' 4)) * 100.0;  
Magic Number,S7.Net.Types,Timer,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: wert += Conversion.BinStringToInt32 (txt.Substring (8' 4)) * 10.0;  
Magic Number,S7.Net.Types,Timer,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: wert += Conversion.BinStringToInt32 (txt.Substring (8' 4)) * 10.0;  
Magic Number,S7.Net.Types,Timer,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: wert += Conversion.BinStringToInt32 (txt.Substring (8' 4)) * 10.0;  
Magic Number,S7.Net.Types,Timer,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: wert += Conversion.BinStringToInt32 (txt.Substring (12' 4));  
Magic Number,S7.Net.Types,Timer,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: wert += Conversion.BinStringToInt32 (txt.Substring (12' 4));  
Magic Number,S7.Net.Types,Timer,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: switch (txt.Substring (2' 2)) {  case "00":  	wert *= 0.01;  	break;  case "01":  	wert *= 0.1;  	break;  case "10":  	wert *= 1.0;  	break;  case "11":  	wert *= 10.0;  	break;  }  
Magic Number,S7.Net.Types,Timer,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: switch (txt.Substring (2' 2)) {  case "00":  	wert *= 0.01;  	break;  case "01":  	wert *= 0.1;  	break;  case "10":  	wert *= 1.0;  	break;  case "11":  	wert *= 10.0;  	break;  }  
Magic Number,S7.Net.Types,Timer,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: switch (txt.Substring (2' 2)) {  case "00":  	wert *= 0.01;  	break;  case "01":  	wert *= 0.1;  	break;  case "10":  	wert *= 1.0;  	break;  case "11":  	wert *= 10.0;  	break;  }  
Magic Number,S7.Net.Types,Timer,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: switch (txt.Substring (2' 2)) {  case "00":  	wert *= 0.01;  	break;  case "01":  	wert *= 0.1;  	break;  case "10":  	wert *= 1.0;  	break;  case "11":  	wert *= 10.0;  	break;  }  
Magic Number,S7.Net.Types,Timer,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: switch (txt.Substring (2' 2)) {  case "00":  	wert *= 0.01;  	break;  case "01":  	wert *= 0.1;  	break;  case "10":  	wert *= 1.0;  	break;  case "11":  	wert *= 10.0;  	break;  }  
Magic Number,S7.Net.Types,Timer,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: wert *= 0.01;  
Magic Number,S7.Net.Types,Timer,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: wert *= 0.1;  
Magic Number,S7.Net.Types,Timer,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following statement contains a magic number: wert *= 10.0;  
Magic Number,S7.Net.Types,Timer,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Timer.cs,ToByteArray,The following statement contains a magic number: for (int cnt = 0; cnt < x; cnt++) {  	Int64 x1 = (Int64)Math.Pow (256' (cnt));  	Int64 x3 = (Int64)(valLong / x1);  	bytes [x - cnt - 1] = (byte)(x3 & 255);  	valLong -= bytes [x - cnt - 1] * x1;  }  
Magic Number,S7.Net.Types,Timer,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Timer.cs,ToByteArray,The following statement contains a magic number: for (int cnt = 0; cnt < x; cnt++) {  	Int64 x1 = (Int64)Math.Pow (256' (cnt));  	Int64 x3 = (Int64)(valLong / x1);  	bytes [x - cnt - 1] = (byte)(x3 & 255);  	valLong -= bytes [x - cnt - 1] * x1;  }  
Magic Number,S7.Net.Types,Timer,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Timer.cs,ToByteArray,The following statement contains a magic number: bytes [x - cnt - 1] = (byte)(x3 & 255);  
Magic Number,S7.Net.Types,Timer,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Timer.cs,ToArray,The following statement contains a magic number: for (int cnt = 0; cnt < bytes.Length / 2; cnt++)  	values [cnt] = FromByteArray (new byte[] {  		bytes [counter++]'  		bytes [counter++]  	});  
Magic Number,S7.Net.Types,Word,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Word.cs,FromByteArray,The following statement contains a magic number: if (bytes.Length != 2) {  	throw new ArgumentException ("Wrong number of bytes. Bytes array must contain 2 bytes.");  }  
Magic Number,S7.Net.Types,Word,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Word.cs,FromBytes,The following statement contains a magic number: return (UInt16)(HiVal * 256 + LoVal);  
Magic Number,S7.Net.Types,Word,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Word.cs,ToByteArray,The following statement contains a magic number: for (int cnt = 0; cnt < x; cnt++) {  	Int64 x1 = (Int64)Math.Pow (256' (cnt));  	Int64 x3 = (Int64)(valLong / x1);  	bytes [x - cnt - 1] = (byte)(x3 & 255);  	valLong -= bytes [x - cnt - 1] * x1;  }  
Magic Number,S7.Net.Types,Word,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Word.cs,ToByteArray,The following statement contains a magic number: for (int cnt = 0; cnt < x; cnt++) {  	Int64 x1 = (Int64)Math.Pow (256' (cnt));  	Int64 x3 = (Int64)(valLong / x1);  	bytes [x - cnt - 1] = (byte)(x3 & 255);  	valLong -= bytes [x - cnt - 1] * x1;  }  
Magic Number,S7.Net.Types,Word,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Word.cs,ToByteArray,The following statement contains a magic number: bytes [x - cnt - 1] = (byte)(x3 & 255);  
Magic Number,S7.Net.Types,Word,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Word.cs,ToArray,The following statement contains a magic number: for (int cnt = 0; cnt < bytes.Length / 2; cnt++)  	values [cnt] = FromByteArray (new byte[] {  		bytes [counter++]'  		bytes [counter++]  	});  
Missing Default,S7.Net.Types,Class,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Class.cs,ToBytes,The following switch statement is missing a default case: switch (property.PropertyType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bool)property.GetValue (sourceClass' null))  		bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  	// is true  	else  		bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  	// is false  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = (int)Math.Ceiling (numBytes);  	bytePos = (int)numBytes;  	bytes [bytePos] = (byte)property.GetValue (sourceClass' null);  	numBytes++;  	break;  case "Int16":  	bytes2 = Int.ToByteArray ((Int16)property.GetValue (sourceClass' null));  	break;  case "UInt16":  	bytes2 = Word.ToByteArray ((UInt16)property.GetValue (sourceClass' null));  	break;  case "Int32":  	bytes2 = DInt.ToByteArray ((Int32)property.GetValue (sourceClass' null));  	break;  case "UInt32":  	bytes2 = DWord.ToByteArray ((UInt32)property.GetValue (sourceClass' null));  	break;  case "Double":  	bytes2 = Double.ToByteArray ((double)property.GetValue (sourceClass' null));  	break;  }  
Missing Default,S7.Net.Types,Struct,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Struct.cs,ToBytes,The following switch statement is missing a default case: switch (info.FieldType.Name) {  case "Boolean":  	// get the value  	bytePos = (int)Math.Floor (numBytes);  	bitPos = (int)((numBytes - (double)bytePos) / 0.125);  	if ((bool)info.GetValue (structValue))  		bytes [bytePos] |= (byte)Math.Pow (2' bitPos);  	// is true  	else  		bytes [bytePos] &= (byte)(~(byte)Math.Pow (2' bitPos));  	// is false  	numBytes += 0.125;  	break;  case "Byte":  	numBytes = (int)Math.Ceiling (numBytes);  	bytePos = (int)numBytes;  	bytes [bytePos] = (byte)info.GetValue (structValue);  	numBytes++;  	break;  case "Int16":  	bytes2 = Int.ToByteArray ((Int16)info.GetValue (structValue));  	break;  case "UInt16":  	bytes2 = Word.ToByteArray ((UInt16)info.GetValue (structValue));  	break;  case "Int32":  	bytes2 = DInt.ToByteArray ((Int32)info.GetValue (structValue));  	break;  case "UInt32":  	bytes2 = DWord.ToByteArray ((UInt32)info.GetValue (structValue));  	break;  case "Double":  	bytes2 = Double.ToByteArray ((double)info.GetValue (structValue));  	break;  }  
Missing Default,S7.Net.Types,Timer,F:\newReposMay17\killnine_s7netplus\S7.Net\Types\Timer.cs,FromByteArray,The following switch statement is missing a default case: switch (txt.Substring (2' 2)) {  case "00":  	wert *= 0.01;  	break;  case "01":  	wert *= 0.1;  	break;  case "10":  	wert *= 1.0;  	break;  case "11":  	wert *= 10.0;  	break;  }  
