Implementation smell,Namespace,Class,File,Method,Description
Complex Method,YAMP.Sensors.Devices,Camera,C:\repos\FlorianRappl_YAMP\YAMP.Sensors\Devices\Camera.cs,Capture,Cyclomatic complexity of the method is 12
Empty Catch Block,YAMP.Sensors.Devices,Gps,C:\repos\FlorianRappl_YAMP\YAMP.Sensors\Devices\Gps.cs,InitialPosition,The method has an empty catch block.
Empty Catch Block,YAMP.Sensors.Devices,Microphone,C:\repos\FlorianRappl_YAMP\YAMP.Sensors\Devices\Microphone.cs,Microphone,The method has an empty catch block.
Magic Number,YAMP.Sensors.Devices,Microphone,C:\repos\FlorianRappl_YAMP\YAMP.Sensors\Devices\Microphone.cs,Record,The following statement contains a magic number: if (_wasapiCapture != null)              {                  _wasapiCapture.StartRecording();                    _measured = -1;                  _measuring = true;                    while (_measured < bufferFills)                  {                      await Task.Delay(50);                  }                    _measuring = false;                  _wasapiCapture.StopRecording();                  var lengths = _measurements.Take(bufferFills).Select(a => a.Length).ToArray();                  var result = new Double[lengths.Sum() / 4];                  var k = 1;                    for (var j = 0; j < bufferFills; j++)                  {                      for (var i = 0; i < lengths[j]; i += 4' k++)                      {                          var value = BitConverter.ToSingle(_measurements[j]' i);                          result[k] = value;                      }                  }                    return result;              }
Magic Number,YAMP.Sensors.Devices,Microphone,C:\repos\FlorianRappl_YAMP\YAMP.Sensors\Devices\Microphone.cs,Record,The following statement contains a magic number: if (_wasapiCapture != null)              {                  _wasapiCapture.StartRecording();                    _measured = -1;                  _measuring = true;                    while (_measured < bufferFills)                  {                      await Task.Delay(50);                  }                    _measuring = false;                  _wasapiCapture.StopRecording();                  var lengths = _measurements.Take(bufferFills).Select(a => a.Length).ToArray();                  var result = new Double[lengths.Sum() / 4];                  var k = 1;                    for (var j = 0; j < bufferFills; j++)                  {                      for (var i = 0; i < lengths[j]; i += 4' k++)                      {                          var value = BitConverter.ToSingle(_measurements[j]' i);                          result[k] = value;                      }                  }                    return result;              }
Magic Number,YAMP.Sensors.Devices,Microphone,C:\repos\FlorianRappl_YAMP\YAMP.Sensors\Devices\Microphone.cs,Record,The following statement contains a magic number: if (_wasapiCapture != null)              {                  _wasapiCapture.StartRecording();                    _measured = -1;                  _measuring = true;                    while (_measured < bufferFills)                  {                      await Task.Delay(50);                  }                    _measuring = false;                  _wasapiCapture.StopRecording();                  var lengths = _measurements.Take(bufferFills).Select(a => a.Length).ToArray();                  var result = new Double[lengths.Sum() / 4];                  var k = 1;                    for (var j = 0; j < bufferFills; j++)                  {                      for (var i = 0; i < lengths[j]; i += 4' k++)                      {                          var value = BitConverter.ToSingle(_measurements[j]' i);                          result[k] = value;                      }                  }                    return result;              }
Magic Number,YAMP.Sensors.Devices,Camera,C:\repos\FlorianRappl_YAMP\YAMP.Sensors\Devices\Camera.cs,Capture,The following statement contains a magic number: if (_mediaCapture != null)              {                  if (coarsening < 1.0)                  {                      throw new YAMPRuntimeException("Video: coarsening must be larger than or equal to 1.0.");                  }                    var imageProperties = ImageEncodingProperties.CreatePng();                  var stream = new InMemoryRandomAccessStream();                    await _mediaCapture.CapturePhotoToStreamAsync(imageProperties' stream);                    var decoder = await BitmapDecoder.CreateAsync(stream);                  var pixelData = await decoder.GetPixelDataAsync();                  var rgbValues = pixelData.DetachPixelData();                  var width = (Int32)decoder.PixelWidth;                  var height = (Int32)decoder.PixelHeight;                    var inverseCoarsening = 1.0 / coarsening;                  var finalWidth = (Int32)(width * inverseCoarsening);                  var finalHeight = (Int32)(height * inverseCoarsening);                    var count = new Byte[finalHeight' finalWidth];                  var rvalues = new Double[finalHeight' finalWidth];                  var gvalues = new Double[finalHeight' finalWidth];                  var bvalues = new Double[finalHeight' finalWidth];                    for (var i = 0; i < width; i++)                  {                      var idx = (Int32)(i * inverseCoarsening);                        if (idx >= finalWidth)                      {                          idx = finalWidth - 1;                      }                        for (int j = 0; j < height; j++)                      {                          var jdx = (Int32)(j * inverseCoarsening);                            if (jdx >= finalHeight)                          {                              jdx = finalHeight - 1;                          }                            rvalues[jdx' idx] += rgbValues[(j * width + i) * 4 + 2];                          gvalues[jdx' idx] += rgbValues[(j * width + i) * 4 + 1];                          bvalues[jdx' idx] += rgbValues[(j * width + i) * 4 + 0];                          count[jdx' idx]++;                      }                  }                    for (var i = 0; i < finalHeight; i++)                  {                      for (var j = 0; j < finalWidth; j++)                      {                          var cinv = 1.0 / count[i' j];                          rvalues[i' j] *= cinv;                          gvalues[i' j] *= cinv;                          bvalues[i' j] *= cinv;                      }                  }                    if (fused)                  {                      for (var i = 0; i < finalHeight; i++)                      {                          for (var j = 0; j < finalWidth; j++)                          {                              rvalues[i' j] = (Int32)rvalues[i' j];                              gvalues[i' j] = (Int32)gvalues[i' j];                              bvalues[i' j] = (Int32)bvalues[i' j];                                rvalues[i' j] *= rfactor;                              gvalues[i' j] *= gfactor;                              bvalues[i' j] *= bfactor;                                rvalues[i' j] += gvalues[i' j] + bvalues[i' j];                          }                      }                        return new FrameData                      {                          Blue = rvalues'                          Green = rvalues'                          Red = rvalues'                          IsFused = true                      };                  }                    return new FrameData                  {                      Blue = bvalues'                      Green = gvalues'                      Red = rvalues'                      IsFused = false                  };              }
Magic Number,YAMP.Sensors.Devices,Camera,C:\repos\FlorianRappl_YAMP\YAMP.Sensors\Devices\Camera.cs,Capture,The following statement contains a magic number: if (_mediaCapture != null)              {                  if (coarsening < 1.0)                  {                      throw new YAMPRuntimeException("Video: coarsening must be larger than or equal to 1.0.");                  }                    var imageProperties = ImageEncodingProperties.CreatePng();                  var stream = new InMemoryRandomAccessStream();                    await _mediaCapture.CapturePhotoToStreamAsync(imageProperties' stream);                    var decoder = await BitmapDecoder.CreateAsync(stream);                  var pixelData = await decoder.GetPixelDataAsync();                  var rgbValues = pixelData.DetachPixelData();                  var width = (Int32)decoder.PixelWidth;                  var height = (Int32)decoder.PixelHeight;                    var inverseCoarsening = 1.0 / coarsening;                  var finalWidth = (Int32)(width * inverseCoarsening);                  var finalHeight = (Int32)(height * inverseCoarsening);                    var count = new Byte[finalHeight' finalWidth];                  var rvalues = new Double[finalHeight' finalWidth];                  var gvalues = new Double[finalHeight' finalWidth];                  var bvalues = new Double[finalHeight' finalWidth];                    for (var i = 0; i < width; i++)                  {                      var idx = (Int32)(i * inverseCoarsening);                        if (idx >= finalWidth)                      {                          idx = finalWidth - 1;                      }                        for (int j = 0; j < height; j++)                      {                          var jdx = (Int32)(j * inverseCoarsening);                            if (jdx >= finalHeight)                          {                              jdx = finalHeight - 1;                          }                            rvalues[jdx' idx] += rgbValues[(j * width + i) * 4 + 2];                          gvalues[jdx' idx] += rgbValues[(j * width + i) * 4 + 1];                          bvalues[jdx' idx] += rgbValues[(j * width + i) * 4 + 0];                          count[jdx' idx]++;                      }                  }                    for (var i = 0; i < finalHeight; i++)                  {                      for (var j = 0; j < finalWidth; j++)                      {                          var cinv = 1.0 / count[i' j];                          rvalues[i' j] *= cinv;                          gvalues[i' j] *= cinv;                          bvalues[i' j] *= cinv;                      }                  }                    if (fused)                  {                      for (var i = 0; i < finalHeight; i++)                      {                          for (var j = 0; j < finalWidth; j++)                          {                              rvalues[i' j] = (Int32)rvalues[i' j];                              gvalues[i' j] = (Int32)gvalues[i' j];                              bvalues[i' j] = (Int32)bvalues[i' j];                                rvalues[i' j] *= rfactor;                              gvalues[i' j] *= gfactor;                              bvalues[i' j] *= bfactor;                                rvalues[i' j] += gvalues[i' j] + bvalues[i' j];                          }                      }                        return new FrameData                      {                          Blue = rvalues'                          Green = rvalues'                          Red = rvalues'                          IsFused = true                      };                  }                    return new FrameData                  {                      Blue = bvalues'                      Green = gvalues'                      Red = rvalues'                      IsFused = false                  };              }
Magic Number,YAMP.Sensors.Devices,Camera,C:\repos\FlorianRappl_YAMP\YAMP.Sensors\Devices\Camera.cs,Capture,The following statement contains a magic number: if (_mediaCapture != null)              {                  if (coarsening < 1.0)                  {                      throw new YAMPRuntimeException("Video: coarsening must be larger than or equal to 1.0.");                  }                    var imageProperties = ImageEncodingProperties.CreatePng();                  var stream = new InMemoryRandomAccessStream();                    await _mediaCapture.CapturePhotoToStreamAsync(imageProperties' stream);                    var decoder = await BitmapDecoder.CreateAsync(stream);                  var pixelData = await decoder.GetPixelDataAsync();                  var rgbValues = pixelData.DetachPixelData();                  var width = (Int32)decoder.PixelWidth;                  var height = (Int32)decoder.PixelHeight;                    var inverseCoarsening = 1.0 / coarsening;                  var finalWidth = (Int32)(width * inverseCoarsening);                  var finalHeight = (Int32)(height * inverseCoarsening);                    var count = new Byte[finalHeight' finalWidth];                  var rvalues = new Double[finalHeight' finalWidth];                  var gvalues = new Double[finalHeight' finalWidth];                  var bvalues = new Double[finalHeight' finalWidth];                    for (var i = 0; i < width; i++)                  {                      var idx = (Int32)(i * inverseCoarsening);                        if (idx >= finalWidth)                      {                          idx = finalWidth - 1;                      }                        for (int j = 0; j < height; j++)                      {                          var jdx = (Int32)(j * inverseCoarsening);                            if (jdx >= finalHeight)                          {                              jdx = finalHeight - 1;                          }                            rvalues[jdx' idx] += rgbValues[(j * width + i) * 4 + 2];                          gvalues[jdx' idx] += rgbValues[(j * width + i) * 4 + 1];                          bvalues[jdx' idx] += rgbValues[(j * width + i) * 4 + 0];                          count[jdx' idx]++;                      }                  }                    for (var i = 0; i < finalHeight; i++)                  {                      for (var j = 0; j < finalWidth; j++)                      {                          var cinv = 1.0 / count[i' j];                          rvalues[i' j] *= cinv;                          gvalues[i' j] *= cinv;                          bvalues[i' j] *= cinv;                      }                  }                    if (fused)                  {                      for (var i = 0; i < finalHeight; i++)                      {                          for (var j = 0; j < finalWidth; j++)                          {                              rvalues[i' j] = (Int32)rvalues[i' j];                              gvalues[i' j] = (Int32)gvalues[i' j];                              bvalues[i' j] = (Int32)bvalues[i' j];                                rvalues[i' j] *= rfactor;                              gvalues[i' j] *= gfactor;                              bvalues[i' j] *= bfactor;                                rvalues[i' j] += gvalues[i' j] + bvalues[i' j];                          }                      }                        return new FrameData                      {                          Blue = rvalues'                          Green = rvalues'                          Red = rvalues'                          IsFused = true                      };                  }                    return new FrameData                  {                      Blue = bvalues'                      Green = gvalues'                      Red = rvalues'                      IsFused = false                  };              }
Magic Number,YAMP.Sensors.Devices,Camera,C:\repos\FlorianRappl_YAMP\YAMP.Sensors\Devices\Camera.cs,Capture,The following statement contains a magic number: if (_mediaCapture != null)              {                  if (coarsening < 1.0)                  {                      throw new YAMPRuntimeException("Video: coarsening must be larger than or equal to 1.0.");                  }                    var imageProperties = ImageEncodingProperties.CreatePng();                  var stream = new InMemoryRandomAccessStream();                    await _mediaCapture.CapturePhotoToStreamAsync(imageProperties' stream);                    var decoder = await BitmapDecoder.CreateAsync(stream);                  var pixelData = await decoder.GetPixelDataAsync();                  var rgbValues = pixelData.DetachPixelData();                  var width = (Int32)decoder.PixelWidth;                  var height = (Int32)decoder.PixelHeight;                    var inverseCoarsening = 1.0 / coarsening;                  var finalWidth = (Int32)(width * inverseCoarsening);                  var finalHeight = (Int32)(height * inverseCoarsening);                    var count = new Byte[finalHeight' finalWidth];                  var rvalues = new Double[finalHeight' finalWidth];                  var gvalues = new Double[finalHeight' finalWidth];                  var bvalues = new Double[finalHeight' finalWidth];                    for (var i = 0; i < width; i++)                  {                      var idx = (Int32)(i * inverseCoarsening);                        if (idx >= finalWidth)                      {                          idx = finalWidth - 1;                      }                        for (int j = 0; j < height; j++)                      {                          var jdx = (Int32)(j * inverseCoarsening);                            if (jdx >= finalHeight)                          {                              jdx = finalHeight - 1;                          }                            rvalues[jdx' idx] += rgbValues[(j * width + i) * 4 + 2];                          gvalues[jdx' idx] += rgbValues[(j * width + i) * 4 + 1];                          bvalues[jdx' idx] += rgbValues[(j * width + i) * 4 + 0];                          count[jdx' idx]++;                      }                  }                    for (var i = 0; i < finalHeight; i++)                  {                      for (var j = 0; j < finalWidth; j++)                      {                          var cinv = 1.0 / count[i' j];                          rvalues[i' j] *= cinv;                          gvalues[i' j] *= cinv;                          bvalues[i' j] *= cinv;                      }                  }                    if (fused)                  {                      for (var i = 0; i < finalHeight; i++)                      {                          for (var j = 0; j < finalWidth; j++)                          {                              rvalues[i' j] = (Int32)rvalues[i' j];                              gvalues[i' j] = (Int32)gvalues[i' j];                              bvalues[i' j] = (Int32)bvalues[i' j];                                rvalues[i' j] *= rfactor;                              gvalues[i' j] *= gfactor;                              bvalues[i' j] *= bfactor;                                rvalues[i' j] += gvalues[i' j] + bvalues[i' j];                          }                      }                        return new FrameData                      {                          Blue = rvalues'                          Green = rvalues'                          Red = rvalues'                          IsFused = true                      };                  }                    return new FrameData                  {                      Blue = bvalues'                      Green = gvalues'                      Red = rvalues'                      IsFused = false                  };              }
Magic Number,YAMP.Sensors,TimeSeriesFunction,C:\repos\FlorianRappl_YAMP\YAMP.Sensors\Functions\TimeSeriesFunction.cs,Function,The following statement contains a magic number: var timeBetweenMeasurements = (Int32)Math.Floor(dt.Value * 1000);
Magic Number,YAMP.Sensors,TimeSeriesFunction,C:\repos\FlorianRappl_YAMP\YAMP.Sensors\Functions\TimeSeriesFunction.cs,Function,The following statement contains a magic number: var results = new MatrixValue(numberOfMeasurements' 2);
Magic Number,YAMP.Sensors,TimeSeriesFunction,C:\repos\FlorianRappl_YAMP\YAMP.Sensors\Functions\TimeSeriesFunction.cs,Function,The following statement contains a magic number: for (var i = 1; i <= numberOfMeasurements; i++)              {                  Thread.Sleep(timeBetweenMeasurements);                    var result = f.Perform(context' args);                  results[i' 1] = new ScalarValue(time);                    if (result is ScalarValue)                  {                      results[i' 2] = result as ScalarValue;                  }                  else if (result is MatrixValue)                  {                      var m = result as MatrixValue;                        for (var j = 1; j <= m.Length; j++)                      {                          results[i' 1 + j] = m[j];                      }                  }                    time += dt.Value;              }
