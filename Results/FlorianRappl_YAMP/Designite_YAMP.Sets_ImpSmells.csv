Implementation smell,Namespace,Class,File,Method,Description
Long Method,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,DoRemove,The method has 140 lines of code.
Complex Method,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,SortedSet,Cyclomatic complexity of the method is 8
Complex Method,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,AddIfNotPresent,Cyclomatic complexity of the method is 8
Complex Method,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,DoRemove,Cyclomatic complexity of the method is 9
Complex Method,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,UnionWith,Cyclomatic complexity of the method is 8
Complex Method,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,ExceptWith,Cyclomatic complexity of the method is 9
Complex Method,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,IsProperSupersetOf,Cyclomatic complexity of the method is 8
Complex Method,YAMPSystem.Collections.Generic,TreeSubSet,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,InOrderTreeWalk,Cyclomatic complexity of the method is 8
Complex Method,YAMP.Sets,ValueWrap,C:\repos\FlorianRappl_YAMP\YAMP.Sets\Values\SetValue.cs,CompareTo,Cyclomatic complexity of the method is 8
Long Parameter List,YAMPSystem.Collections.Generic,TreeSubSet,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,TreeSubSet,The method has 5 parameters. Parameters: Underlying' Min' Max' lowerBoundActive' upperBoundActive
Long Identifier,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,,The length of the parameter SR_Arg_RankMultiDimNotSupported is 31.
Long Identifier,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,,The length of the parameter SR_ArgumentOutOfRange_NeedNonNegNum is 35.
Long Identifier,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,,The length of the parameter SR_SortedSet_LowerValueGreaterThanUpperValue is 44.
Long Identifier,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,,The length of the parameter SR_InvalidOperation_EnumFailedVersion is 37.
Long Identifier,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,,The length of the parameter SR_InvalidOperation_EnumOpCantHappen is 36.
Long Statement,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,ReplaceNode,The length of the statement  "                Debug.Assert((successor.Right == null && successor.IsRed) || (successor.Right.IsRed && !successor.IsRed)' "Successor must be in valid state"); " is 142.
Long Statement,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,Overlaps,The length of the statement  "            if (asSorted != null && AreComparersEqual(this' asSorted) && (_comparer.Compare(Min' asSorted.Max) > 0 || _comparer.Compare(Max' asSorted.Min) < 0)) " is 148.
Long Statement,YAMPSystem.Collections.Generic,TreeSubSet,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,InOrderTreeWalk,The length of the statement  "                Stack<Node> stack = new Stack<Node>(2 * (int)SortedSet<T>.log2(_count + 1)); //this is not exactly right if count is out of date' but the stack can grow " is 152.
Long Statement,YAMP.Sets,SetValue,C:\repos\FlorianRappl_YAMP\YAMP.Sets\Values\SetValue.cs,CreateSet,The length of the statement  "            return ordered ? (ISetValueDictionary)new SortedSetValueWrap(source) : (ISetValueDictionary)new HashSetValueWrap(source); " is 121.
Complex Conditional,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,UnionWith,The conditional expression  "s != null && t == null && AreComparersEqual(this' s) && (s.Count > this.Count / 2)"  is complex.
Complex Conditional,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,Overlaps,The conditional expression  "asSorted != null && AreComparersEqual(this' asSorted) && (_comparer.Compare(Min' asSorted.Max) > 0 || _comparer.Compare(Max' asSorted.Min) < 0)"  is complex.
Magic Number,YAMPSystem.Collections.Generic,EnumerableHelpers,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\EnumerableHelpers.cs,ToArray,The following statement contains a magic number: if (ic != null)              {                  int count = ic.Count;                  if (count != 0)                  {                      // Allocate an array of the desired size' then copy the elements into it. Note that this has the same                       // issue regarding concurrency as other existing collections like List<T>. If the collection size                       // concurrently changes between the array allocation and the CopyTo' we could end up either getting an                       // exception from overrunning the array (if the size went up) or we could end up not filling as many                       // items as 'count' suggests (if the size went down).  This is only an issue for concurrent collections                       // that implement ICollection<T>' which as of .NET 4.6 is just ConcurrentDictionary<TKey' TValue>.                      T[] arr = new T[count];                      ic.CopyTo(arr' 0);                      length = count;                      return arr;                  }              }              else              {                  using (var en = source.GetEnumerator())                  {                      if (en.MoveNext())                      {                          const int DefaultCapacity = 4;                          T[] arr = new T[DefaultCapacity];                          arr[0] = en.Current;                          int count = 1;                                                    while (en.MoveNext())                          {                              if (count == arr.Length)                              {                                  // MaxArrayLength is defined in Array.MaxArrayLength and in gchelpers in CoreCLR.                                  // It represents the maximum number of elements that can be in an array where                                  // the size of the element is greater than one byte; a separate' slightly larger constant'                                  // is used when the size of the element is one.                                  const int MaxArrayLength = 0x7FEFFFFF;                                            // This is the same growth logic as in List<T>:                                  // If the array is currently empty' we make it a default size.  Otherwise' we attempt to                                   // double the size of the array.  Doubling will overflow once the size of the array reaches                                  // 2^30' since doubling to 2^31 is 1 larger than Int32.MaxValue.  In that case' we instead                                   // constrain the length to be MaxArrayLength (this overflow check works because of the                                   // cast to uint).  Because a slightly larger constant is used when T is one byte in size' we                                   // could then end up in a situation where arr.Length is MaxArrayLength or slightly larger' such                                   // that we constrain newLength to be MaxArrayLength but the needed number of elements is actually                                   // larger than that.  For that case' we then ensure that the newLength is large enough to hold                                   // the desired capacity.  This does mean that in the very rare case where we've grown to such a                                   // large size' each new element added after MaxArrayLength will end up doing a resize.                                  int newLength = count << 1;                                  if ((uint)newLength > MaxArrayLength)                                  {                                      newLength = MaxArrayLength <= count ? count + 1 : MaxArrayLength;                                  }                                            Array.Resize(ref arr' newLength);                              }                                                            arr[count++] = en.Current;                          }                                                    length = count;                          return arr;                      }                  }              }
Magic Number,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,SortedSet,The following statement contains a magic number: if (baseSortedSet != null && baseTreeSubSet == null && AreComparersEqual(this' baseSortedSet))              {                  //breadth first traversal to recreate nodes                  if (baseSortedSet.Count == 0)                  {                      return;                  }                    //pre order way to replicate nodes                  Stack<Node> theirStack = new Stack<SortedSet<T>.Node>(2 * log2(baseSortedSet.Count) + 2);                  Stack<Node> myStack = new Stack<SortedSet<T>.Node>(2 * log2(baseSortedSet.Count) + 2);                  Node theirCurrent = baseSortedSet._root;                  Node myCurrent = (theirCurrent != null ? new SortedSet<T>.Node(theirCurrent.Item' theirCurrent.IsRed) : null);                  _root = myCurrent;                  while (theirCurrent != null)                  {                      theirStack.Push(theirCurrent);                      myStack.Push(myCurrent);                      myCurrent.Left = (theirCurrent.Left != null ? new SortedSet<T>.Node(theirCurrent.Left.Item' theirCurrent.Left.IsRed) : null);                      theirCurrent = theirCurrent.Left;                      myCurrent = myCurrent.Left;                  }                  while (theirStack.Count != 0)                  {                      theirCurrent = theirStack.Pop();                      myCurrent = myStack.Pop();                      Node theirRight = theirCurrent.Right;                      Node myRight = null;                      if (theirRight != null)                      {                          myRight = new SortedSet<T>.Node(theirRight.Item' theirRight.IsRed);                      }                      myCurrent.Right = myRight;                        while (theirRight != null)                      {                          theirStack.Push(theirRight);                          myStack.Push(myRight);                          myRight.Left = (theirRight.Left != null ? new SortedSet<T>.Node(theirRight.Left.Item' theirRight.Left.IsRed) : null);                          theirRight = theirRight.Left;                          myRight = myRight.Left;                      }                  }                  _count = baseSortedSet._count;              }              else              {                  int count;                  T[] els = EnumerableHelpers.ToArray(collection' out count);                  if (count > 0)                  {                      comparer = _comparer; // If comparer is null' sets it to Comparer<T>.Default                      Array.Sort(els' 0' count' comparer);                      int index = 1;                      for (int i = 1; i < count; i++)                      {                          if (comparer.Compare(els[i]' els[i - 1]) != 0)                          {                              els[index++] = els[i];                          }                      }                      count = index;                        _root = ConstructRootFromSortedArray(els' 0' count - 1' null);                      _count = count;                  }              }
Magic Number,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,SortedSet,The following statement contains a magic number: if (baseSortedSet != null && baseTreeSubSet == null && AreComparersEqual(this' baseSortedSet))              {                  //breadth first traversal to recreate nodes                  if (baseSortedSet.Count == 0)                  {                      return;                  }                    //pre order way to replicate nodes                  Stack<Node> theirStack = new Stack<SortedSet<T>.Node>(2 * log2(baseSortedSet.Count) + 2);                  Stack<Node> myStack = new Stack<SortedSet<T>.Node>(2 * log2(baseSortedSet.Count) + 2);                  Node theirCurrent = baseSortedSet._root;                  Node myCurrent = (theirCurrent != null ? new SortedSet<T>.Node(theirCurrent.Item' theirCurrent.IsRed) : null);                  _root = myCurrent;                  while (theirCurrent != null)                  {                      theirStack.Push(theirCurrent);                      myStack.Push(myCurrent);                      myCurrent.Left = (theirCurrent.Left != null ? new SortedSet<T>.Node(theirCurrent.Left.Item' theirCurrent.Left.IsRed) : null);                      theirCurrent = theirCurrent.Left;                      myCurrent = myCurrent.Left;                  }                  while (theirStack.Count != 0)                  {                      theirCurrent = theirStack.Pop();                      myCurrent = myStack.Pop();                      Node theirRight = theirCurrent.Right;                      Node myRight = null;                      if (theirRight != null)                      {                          myRight = new SortedSet<T>.Node(theirRight.Item' theirRight.IsRed);                      }                      myCurrent.Right = myRight;                        while (theirRight != null)                      {                          theirStack.Push(theirRight);                          myStack.Push(myRight);                          myRight.Left = (theirRight.Left != null ? new SortedSet<T>.Node(theirRight.Left.Item' theirRight.Left.IsRed) : null);                          theirRight = theirRight.Left;                          myRight = myRight.Left;                      }                  }                  _count = baseSortedSet._count;              }              else              {                  int count;                  T[] els = EnumerableHelpers.ToArray(collection' out count);                  if (count > 0)                  {                      comparer = _comparer; // If comparer is null' sets it to Comparer<T>.Default                      Array.Sort(els' 0' count' comparer);                      int index = 1;                      for (int i = 1; i < count; i++)                      {                          if (comparer.Compare(els[i]' els[i - 1]) != 0)                          {                              els[index++] = els[i];                          }                      }                      count = index;                        _root = ConstructRootFromSortedArray(els' 0' count - 1' null);                      _count = count;                  }              }
Magic Number,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,SortedSet,The following statement contains a magic number: if (baseSortedSet != null && baseTreeSubSet == null && AreComparersEqual(this' baseSortedSet))              {                  //breadth first traversal to recreate nodes                  if (baseSortedSet.Count == 0)                  {                      return;                  }                    //pre order way to replicate nodes                  Stack<Node> theirStack = new Stack<SortedSet<T>.Node>(2 * log2(baseSortedSet.Count) + 2);                  Stack<Node> myStack = new Stack<SortedSet<T>.Node>(2 * log2(baseSortedSet.Count) + 2);                  Node theirCurrent = baseSortedSet._root;                  Node myCurrent = (theirCurrent != null ? new SortedSet<T>.Node(theirCurrent.Item' theirCurrent.IsRed) : null);                  _root = myCurrent;                  while (theirCurrent != null)                  {                      theirStack.Push(theirCurrent);                      myStack.Push(myCurrent);                      myCurrent.Left = (theirCurrent.Left != null ? new SortedSet<T>.Node(theirCurrent.Left.Item' theirCurrent.Left.IsRed) : null);                      theirCurrent = theirCurrent.Left;                      myCurrent = myCurrent.Left;                  }                  while (theirStack.Count != 0)                  {                      theirCurrent = theirStack.Pop();                      myCurrent = myStack.Pop();                      Node theirRight = theirCurrent.Right;                      Node myRight = null;                      if (theirRight != null)                      {                          myRight = new SortedSet<T>.Node(theirRight.Item' theirRight.IsRed);                      }                      myCurrent.Right = myRight;                        while (theirRight != null)                      {                          theirStack.Push(theirRight);                          myStack.Push(myRight);                          myRight.Left = (theirRight.Left != null ? new SortedSet<T>.Node(theirRight.Left.Item' theirRight.Left.IsRed) : null);                          theirRight = theirRight.Left;                          myRight = myRight.Left;                      }                  }                  _count = baseSortedSet._count;              }              else              {                  int count;                  T[] els = EnumerableHelpers.ToArray(collection' out count);                  if (count > 0)                  {                      comparer = _comparer; // If comparer is null' sets it to Comparer<T>.Default                      Array.Sort(els' 0' count' comparer);                      int index = 1;                      for (int i = 1; i < count; i++)                      {                          if (comparer.Compare(els[i]' els[i - 1]) != 0)                          {                              els[index++] = els[i];                          }                      }                      count = index;                        _root = ConstructRootFromSortedArray(els' 0' count - 1' null);                      _count = count;                  }              }
Magic Number,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,SortedSet,The following statement contains a magic number: if (baseSortedSet != null && baseTreeSubSet == null && AreComparersEqual(this' baseSortedSet))              {                  //breadth first traversal to recreate nodes                  if (baseSortedSet.Count == 0)                  {                      return;                  }                    //pre order way to replicate nodes                  Stack<Node> theirStack = new Stack<SortedSet<T>.Node>(2 * log2(baseSortedSet.Count) + 2);                  Stack<Node> myStack = new Stack<SortedSet<T>.Node>(2 * log2(baseSortedSet.Count) + 2);                  Node theirCurrent = baseSortedSet._root;                  Node myCurrent = (theirCurrent != null ? new SortedSet<T>.Node(theirCurrent.Item' theirCurrent.IsRed) : null);                  _root = myCurrent;                  while (theirCurrent != null)                  {                      theirStack.Push(theirCurrent);                      myStack.Push(myCurrent);                      myCurrent.Left = (theirCurrent.Left != null ? new SortedSet<T>.Node(theirCurrent.Left.Item' theirCurrent.Left.IsRed) : null);                      theirCurrent = theirCurrent.Left;                      myCurrent = myCurrent.Left;                  }                  while (theirStack.Count != 0)                  {                      theirCurrent = theirStack.Pop();                      myCurrent = myStack.Pop();                      Node theirRight = theirCurrent.Right;                      Node myRight = null;                      if (theirRight != null)                      {                          myRight = new SortedSet<T>.Node(theirRight.Item' theirRight.IsRed);                      }                      myCurrent.Right = myRight;                        while (theirRight != null)                      {                          theirStack.Push(theirRight);                          myStack.Push(myRight);                          myRight.Left = (theirRight.Left != null ? new SortedSet<T>.Node(theirRight.Left.Item' theirRight.Left.IsRed) : null);                          theirRight = theirRight.Left;                          myRight = myRight.Left;                      }                  }                  _count = baseSortedSet._count;              }              else              {                  int count;                  T[] els = EnumerableHelpers.ToArray(collection' out count);                  if (count > 0)                  {                      comparer = _comparer; // If comparer is null' sets it to Comparer<T>.Default                      Array.Sort(els' 0' count' comparer);                      int index = 1;                      for (int i = 1; i < count; i++)                      {                          if (comparer.Compare(els[i]' els[i - 1]) != 0)                          {                              els[index++] = els[i];                          }                      }                      count = index;                        _root = ConstructRootFromSortedArray(els' 0' count - 1' null);                      _count = count;                  }              }
Magic Number,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,InOrderTreeWalk,The following statement contains a magic number: Stack<Node> stack = new Stack<Node>(2 * (int)(SortedSet<T>.log2(Count + 1)));
Magic Number,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,InternalIndexOf,The following statement contains a magic number: while (current != null)              {                  int order = _comparer.Compare(item' current.Item);                  if (order == 0)                  {                      return count;                  }                  else                  {                      current = (order < 0) ? current.Left : current.Right;                      count = (order < 0) ? (2 * count + 1) : (2 * count + 2);                  }              }
Magic Number,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,InternalIndexOf,The following statement contains a magic number: while (current != null)              {                  int order = _comparer.Compare(item' current.Item);                  if (order == 0)                  {                      return count;                  }                  else                  {                      current = (order < 0) ? current.Left : current.Right;                      count = (order < 0) ? (2 * count + 1) : (2 * count + 2);                  }              }
Magic Number,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,InternalIndexOf,The following statement contains a magic number: while (current != null)              {                  int order = _comparer.Compare(item' current.Item);                  if (order == 0)                  {                      return count;                  }                  else                  {                      current = (order < 0) ? current.Left : current.Right;                      count = (order < 0) ? (2 * count + 1) : (2 * count + 2);                  }              }
Magic Number,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,UnionWith,The following statement contains a magic number: if (s != null && t == null && AreComparersEqual(this' s) && (s.Count > this.Count / 2))              { //this actually hurts if N is much greater than M the /2 is arbitrary                  //first do a merge sort to an array.                  T[] merged = new T[s.Count + this.Count];                  int c = 0;                  Enumerator mine = this.GetEnumerator();                  Enumerator theirs = s.GetEnumerator();                  bool mineEnded = !mine.MoveNext()' theirsEnded = !theirs.MoveNext();                  while (!mineEnded && !theirsEnded)                  {                      int comp = Comparer.Compare(mine.Current' theirs.Current);                      if (comp < 0)                      {                          merged[c++] = mine.Current;                          mineEnded = !mine.MoveNext();                      }                      else if (comp == 0)                      {                          merged[c++] = theirs.Current;                          mineEnded = !mine.MoveNext();                          theirsEnded = !theirs.MoveNext();                      }                      else                      {                          merged[c++] = theirs.Current;                          theirsEnded = !theirs.MoveNext();                      }                  }                    if (!mineEnded || !theirsEnded)                  {                      Enumerator remaining = (mineEnded ? theirs : mine);                      do                      {                          merged[c++] = remaining.Current;                      } while (remaining.MoveNext());                  }                    //now merged has all c elements                    //safe to gc the root' we  have all the elements                  _root = null;                      _root = SortedSet<T>.ConstructRootFromSortedArray(merged' 0' c - 1' null);                  _count = c;                  _version++;              }              else              {                  AddAllElements(other);              }
Magic Number,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,ConstructRootFromSortedArray,The following statement contains a magic number: if (size == 1)              {                  root = new Node(arr[startIndex]' false);                  if (redNode != null)                  {                      root.Left = redNode;                  }              }              else if (size == 2)              {                  root = new Node(arr[startIndex]' false);                  root.Right = new Node(arr[endIndex]' false);                  root.Right.IsRed = true;                  if (redNode != null)                  {                      root.Left = redNode;                  }              }              else if (size == 3)              {                  root = new Node(arr[startIndex + 1]' false);                  root.Left = new Node(arr[startIndex]' false);                  root.Right = new Node(arr[endIndex]' false);                  if (redNode != null)                  {                      root.Left.Left = redNode;                  }              }              else              {                  int midpt = ((startIndex + endIndex) / 2);                  root = new Node(arr[midpt]' false);                  root.Left = ConstructRootFromSortedArray(arr' startIndex' midpt - 1' redNode);                  if (size % 2 == 0)                  {                      root.Right = ConstructRootFromSortedArray(arr' midpt + 2' endIndex' new Node(arr[midpt + 1]' true));                  }                  else                  {                      root.Right = ConstructRootFromSortedArray(arr' midpt + 1' endIndex' null);                  }              }
Magic Number,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,ConstructRootFromSortedArray,The following statement contains a magic number: if (size == 1)              {                  root = new Node(arr[startIndex]' false);                  if (redNode != null)                  {                      root.Left = redNode;                  }              }              else if (size == 2)              {                  root = new Node(arr[startIndex]' false);                  root.Right = new Node(arr[endIndex]' false);                  root.Right.IsRed = true;                  if (redNode != null)                  {                      root.Left = redNode;                  }              }              else if (size == 3)              {                  root = new Node(arr[startIndex + 1]' false);                  root.Left = new Node(arr[startIndex]' false);                  root.Right = new Node(arr[endIndex]' false);                  if (redNode != null)                  {                      root.Left.Left = redNode;                  }              }              else              {                  int midpt = ((startIndex + endIndex) / 2);                  root = new Node(arr[midpt]' false);                  root.Left = ConstructRootFromSortedArray(arr' startIndex' midpt - 1' redNode);                  if (size % 2 == 0)                  {                      root.Right = ConstructRootFromSortedArray(arr' midpt + 2' endIndex' new Node(arr[midpt + 1]' true));                  }                  else                  {                      root.Right = ConstructRootFromSortedArray(arr' midpt + 1' endIndex' null);                  }              }
Magic Number,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,ConstructRootFromSortedArray,The following statement contains a magic number: if (size == 1)              {                  root = new Node(arr[startIndex]' false);                  if (redNode != null)                  {                      root.Left = redNode;                  }              }              else if (size == 2)              {                  root = new Node(arr[startIndex]' false);                  root.Right = new Node(arr[endIndex]' false);                  root.Right.IsRed = true;                  if (redNode != null)                  {                      root.Left = redNode;                  }              }              else if (size == 3)              {                  root = new Node(arr[startIndex + 1]' false);                  root.Left = new Node(arr[startIndex]' false);                  root.Right = new Node(arr[endIndex]' false);                  if (redNode != null)                  {                      root.Left.Left = redNode;                  }              }              else              {                  int midpt = ((startIndex + endIndex) / 2);                  root = new Node(arr[midpt]' false);                  root.Left = ConstructRootFromSortedArray(arr' startIndex' midpt - 1' redNode);                  if (size % 2 == 0)                  {                      root.Right = ConstructRootFromSortedArray(arr' midpt + 2' endIndex' new Node(arr[midpt + 1]' true));                  }                  else                  {                      root.Right = ConstructRootFromSortedArray(arr' midpt + 1' endIndex' null);                  }              }
Magic Number,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,ConstructRootFromSortedArray,The following statement contains a magic number: if (size == 1)              {                  root = new Node(arr[startIndex]' false);                  if (redNode != null)                  {                      root.Left = redNode;                  }              }              else if (size == 2)              {                  root = new Node(arr[startIndex]' false);                  root.Right = new Node(arr[endIndex]' false);                  root.Right.IsRed = true;                  if (redNode != null)                  {                      root.Left = redNode;                  }              }              else if (size == 3)              {                  root = new Node(arr[startIndex + 1]' false);                  root.Left = new Node(arr[startIndex]' false);                  root.Right = new Node(arr[endIndex]' false);                  if (redNode != null)                  {                      root.Left.Left = redNode;                  }              }              else              {                  int midpt = ((startIndex + endIndex) / 2);                  root = new Node(arr[midpt]' false);                  root.Left = ConstructRootFromSortedArray(arr' startIndex' midpt - 1' redNode);                  if (size % 2 == 0)                  {                      root.Right = ConstructRootFromSortedArray(arr' midpt + 2' endIndex' new Node(arr[midpt + 1]' true));                  }                  else                  {                      root.Right = ConstructRootFromSortedArray(arr' midpt + 1' endIndex' null);                  }              }
Magic Number,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,ConstructRootFromSortedArray,The following statement contains a magic number: if (size == 1)              {                  root = new Node(arr[startIndex]' false);                  if (redNode != null)                  {                      root.Left = redNode;                  }              }              else if (size == 2)              {                  root = new Node(arr[startIndex]' false);                  root.Right = new Node(arr[endIndex]' false);                  root.Right.IsRed = true;                  if (redNode != null)                  {                      root.Left = redNode;                  }              }              else if (size == 3)              {                  root = new Node(arr[startIndex + 1]' false);                  root.Left = new Node(arr[startIndex]' false);                  root.Right = new Node(arr[endIndex]' false);                  if (redNode != null)                  {                      root.Left.Left = redNode;                  }              }              else              {                  int midpt = ((startIndex + endIndex) / 2);                  root = new Node(arr[midpt]' false);                  root.Left = ConstructRootFromSortedArray(arr' startIndex' midpt - 1' redNode);                  if (size % 2 == 0)                  {                      root.Right = ConstructRootFromSortedArray(arr' midpt + 2' endIndex' new Node(arr[midpt + 1]' true));                  }                  else                  {                      root.Right = ConstructRootFromSortedArray(arr' midpt + 1' endIndex' null);                  }              }
Magic Number,YAMPSystem.Collections.Generic,TreeSubSet,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,InOrderTreeWalk,The following statement contains a magic number: Stack<Node> stack = new Stack<Node>(2 * (int)SortedSet<T>.log2(_count + 1));
Magic Number,YAMPSystem.Collections.Generic,Enumerator,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,Enumerator,The following statement contains a magic number: _stack = new Stack<SortedSet<T>.Node>(2 * (int)SortedSet<T>.log2(set.Count + 1));
Magic Number,YAMPSystem.Collections.Generic,Enumerator,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,Enumerator,The following statement contains a magic number: _stack = new Stack<SortedSet<T>.Node>(2 * (int)SortedSet<T>.log2(set.Count + 1));
Magic Number,YAMP.Sets,SetValue,C:\repos\FlorianRappl_YAMP\YAMP.Sets\Values\SetValue.cs,DeserializeString,The following statement contains a magic number: var buffer = new Byte[4];
Missing Default,YAMPSystem.Collections.Generic,SortedSet<T>,C:\repos\FlorianRappl_YAMP\YAMP.Sets\External\CoreFX\SortedSet.cs,DoRemove,The following switch statement is missing a default case: switch (rotation)                              {                                  case TreeRotation.RightRotation:                                      Debug.Assert(parent.Left == sibling' "sibling must be left child of parent!");                                      Debug.Assert(sibling.Left.IsRed' "Left child of sibling must be red!");                                      sibling.Left.IsRed = false;                                      newGrandParent = RotateRight(parent);                                      break;                                  case TreeRotation.LeftRotation:                                      Debug.Assert(parent.Right == sibling' "sibling must be left child of parent!");                                      Debug.Assert(sibling.Right.IsRed' "Right child of sibling must be red!");                                      sibling.Right.IsRed = false;                                      newGrandParent = RotateLeft(parent);                                      break;                                    case TreeRotation.RightLeftRotation:                                      Debug.Assert(parent.Right == sibling' "sibling must be left child of parent!");                                      Debug.Assert(sibling.Left.IsRed' "Left child of sibling must be red!");                                      newGrandParent = RotateRightLeft(parent);                                      break;                                    case TreeRotation.LeftRightRotation:                                      Debug.Assert(parent.Left == sibling' "sibling must be left child of parent!");                                      Debug.Assert(sibling.Right.IsRed' "Right child of sibling must be red!");                                      newGrandParent = RotateLeftRight(parent);                                      break;                              }
