Implementation smell,Namespace,Class,File,Method,Description
Long Method,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,GetToken,The method has 189 lines of code.
Long Method,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The method has 159 lines of code.
Long Method,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The method has 517 lines of code.
Complex Method,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,GetToken,Cyclomatic complexity of the method is 32
Complex Method,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,ValueSatisfiesCriteria,Cyclomatic complexity of the method is 8
Complex Method,CalcEngine,Tally,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Tally.cs,AddValue,Cyclomatic complexity of the method is 9
Complex Method,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Factor,Cyclomatic complexity of the method is 9
Complex Method,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Evaluate,Cyclomatic complexity of the method is 8
Complex Method,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,Cyclomatic complexity of the method is 14
Complex Method,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,EvaluateFunction,Cyclomatic complexity of the method is 11
Complex Method,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,Cyclomatic complexity of the method is 90
Complex Method,MathParserNet,SimplificationReturnValue,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\SimplificationReturnValue.cs,ToFraction,Cyclomatic complexity of the method is 8
Complex Method,MathParserTK_NET,MathParserTK,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,ConvertToRPN,Cyclomatic complexity of the method is 8
Long Identifier,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,,The length of the parameter _sizeOfPolishPostfixExpression is 30.
Long Identifier,MathFunctions,MathParser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathFormula\MathFormula.cs,Calculate,The length of the parameter firstClosePhrantesisIndexAfterLastOpened is 40.
Long Statement,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The length of the statement  "            Test("1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1))))))))))"' 1 / (1 + 1 / (1 + 1 / (1 + 1 / (1 + 1 / (1 + 1 / (1 + 1 / (1 + 1 / (1 + 1 / (1 + 1 / (1 + 1.0))))))))))); " is 175.
Long Statement,CalcEngine,Statistical,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Statistical.cs,Register,The length of the statement  "            //CRITBINOM	Returns the smallest value for which the cumulative binomial distribution is less than or equal to a criterion value " is 128.
Long Statement,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The length of the statement  "            //ce.RegisterFunction("ASC	Changes full-width (double-byte) English letters or katakana within a character string to half-width (single-byte) characters " is 152.
Long Statement,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The length of the statement  "            //ce.RegisterFunction("JIS	Changes half-width (single-byte) English letters or katakana within a character string to full-width (double-byte) characters " is 152.
Long Statement,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The length of the statement  "            ce.RegisterFunction("MID"' 3' Mid); // Returns a specific number of characters from a text string starting at the position you specify " is 134.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,ExpressionToTermW,The length of the statement  "                throw new MathParserException("Wrong input string. Expecting for: 'variable'' math function' '+'''-'' at input[" + _indexOfChar.ToString() + "]"); " is 146.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,ExpressionToTermW,The length of the statement  "                throw new MathParserException("Wrong input string. Expecting for: 'variable'' math function' '+'''-'' at input[" + _indexOfChar.ToString() + "]"); " is 146.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,WtoXWorEps,The length of the statement  "                    throw new MathParserException("Wrong input string. Expecting for: '-'''+''')'' end of input' at input[" + _indexOfChar.ToString() + "]"); " is 137.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,TermToPowerK,The length of the statement  "                throw new MathParserException("Wrong input string. Expecting for: 'variable'' math function' '+'''-'''('' number [0..9]' at input[" + _indexOfChar.ToString() + "]"); " is 165.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,TermToPowerK,The length of the statement  "                throw new MathParserException("Wrong input string. Expecting for: 'variable'' math function' '+'''-'''('' number [0..9]' at input[" + _indexOfChar.ToString() + "]"); " is 165.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,KtoYKorKtoEps,The length of the statement  "                    throw new MathParserException("Wrong input string. Expecting for: '*'''/'''+'''-''')'' end of input' at input[" + _indexOfChar.ToString() + "]"); " is 145.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,PowerToFactoV,The length of the statement  "                throw new MathParserException("Wrong input string. Expecting for: 'variable'' math function''('''+'''-''number [0..9] at input[" + _indexOfChar.ToString() + "]"); " is 162.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,PowerToFactoV,The length of the statement  "                throw new MathParserException("Wrong input string. Expecting for: 'variable'' math function''('''+'''-''number [0..9] at input[" + _indexOfChar.ToString() + "]"); " is 162.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,VtoZVorVtoEps,The length of the statement  "                    throw new MathParserException("Wrong input string. Expecting for: '^'''+'''-'''*'''/''')'' end of input' at input[" + _indexOfChar.ToString() + "]"); " is 149.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Factor,The length of the statement  "            if (Char.IsDigit(this._mathInput[this._indexOfChar]) || this._mathInput[this._indexOfChar] == '.')  //check if next character is digit " is 134.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Factor,The length of the statement  "                _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,End,The length of the statement  "                throw new MathParserException("Wrong input string. Expecting for end of input stream' at input[" + _indexOfChar.ToString() + "]"); " is 130.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Sin,The length of the statement  "            _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Sqrt,The length of the statement  "                _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Sec,The length of the statement  "            _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Cos,The length of the statement  "            _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Cot,The length of the statement  "            _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Tan,The length of the statement  "            _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Csc,The length of the statement  "            _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Asin,The length of the statement  "                _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Acos,The length of the statement  "                _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Atan,The length of the statement  "                _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Acot,The length of the statement  "                _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Exp,The length of the statement  "            _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Log,The length of the statement  "            _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Evaluate,The length of the statement  "                    throw new ArgumentException("vars and varsValues arrays length are not equal");    // for each variable should be define the coresponding value " is 143.
Long Statement,MathFunctions,MathParser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathFormula\MathFormula.cs,Calculate,The length of the statement  "                    decimal result = ProcessOperation(Formula.Substring(lastOpenPhrantesisIndex + 1' firstClosePhrantesisIndexAfterLastOpened - lastOpenPhrantesisIndex - 1)); " is 154.
Long Statement,MathFunctions,MathParser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathFormula\MathFormula.cs,Calculate,The length of the statement  "                        if (Formula.Substring(lastOpenPhrantesisIndex - 1' 1) != "(" && !OperationOrder.Contains(Formula.Substring(lastOpenPhrantesisIndex - 1' 1))) " is 140.
Long Statement,MathFunctions,MathParser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathFormula\MathFormula.cs,Calculate,The length of the statement  "                    Formula = Formula.Substring(0' lastOpenPhrantesisIndex) + (AppendAsterix ? "*" : "") + result.ToString() + Formula.Substring(firstClosePhrantesisIndexAfterLastOpened + 1); " is 171.
Long Statement,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Evaluate,The length of the statement  "				Regex regEx = new Regex( @"(?<=[\d\)])(?=[a-df-z\(])|(?<=pi)(?=[^\+\-\*\/\\^!)])|(?<=\))(?=\d)|(?<=[^\/\*\+\-])(?=exp)"' RegexOptions.IgnoreCase ); " is 147.
Long Statement,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Evaluate,The length of the statement  "					if( m.Groups[3].Value.Length > 0 ) Expression = Expression.Replace( m.Value' "{" + m.Groups[1].Value + this.Solve( m.Groups[2].Value ) + "}" + m.Groups[3].Value ); " is 163.
Long Statement,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() ); " is 131.
Long Statement,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() ); " is 131.
Long Statement,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() ); " is 131.
Long Statement,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() ); " is 130.
Long Statement,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() ); " is 120.
Long Statement,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() ); " is 131.
Long Statement,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() ); " is 131.
Long Statement,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() ); " is 130.
Long Statement,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() ); " is 131.
Long Statement,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() ); " is 130.
Long Statement,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() ); " is 131.
Long Statement,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "				Expression = Expression.Replace( m.Value' Math.Pow( Convert.ToDouble( m.Groups[1].Value )' Convert.ToDouble( m.Groups[2].Value ) ).ToString() ); " is 144.
Long Statement,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "			regEx = new Regex( @"(\d+'*\d*e[\+-]?\d+|\d+'*\d*)\^(-?\d+'*\d*[eE][\+-]?\d+|-?\d+'*\d*)" ); // Search for patterns like 5^-1 " is 125.
Long Statement,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "				Expression = regEx.Replace( Expression' Math.Pow( Convert.ToDouble( m.Groups[1].Value )' Convert.ToDouble( m.Groups[2].Value ) ).ToString()' 1 ); " is 145.
Long Statement,MathParserNet,OrderedDictionary<TKey;TValue>,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\OrderedDictionary.cs,RemoveAt,The length of the statement  "                throw new ArgumentOutOfRangeException("index"' @"'index' must be non-negative and less than the size of the collection"); " is 121.
Long Statement,MathParserTK_NET,MathParserTK,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,Parse,The length of the statement  "            //convert all symbols in input string to lower case and remove whitespaces in string to get rid of the various input errors " is 123.
Complex Conditional,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,GetToken,The conditional expression  "!isLetter && c != '_' && (_idChars == null || _idChars.IndexOf(c) < 0)"  is complex.
Complex Conditional,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,GetToken,The conditional expression  "!isLetter && !isDigit && c != '_' && (_idChars == null || _idChars.IndexOf(c) < 0)"  is complex.
Complex Conditional,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,ExpressionToTermW,The conditional expression  "Char.IsDigit(this._mathInput[_indexOfChar]) ||                   this._varsAndValues.ContainsKey(this._mathInput[_indexOfChar]) ||                  this._mathInput[_indexOfChar] == '.' ||                  this._mathInput[_indexOfChar] == 's' ||                  this._mathInput[_indexOfChar] == 'l' ||                   this._mathInput[_indexOfChar] == 'c' ||                  this._mathInput[_indexOfChar] == 'e' ||                  this._mathInput[_indexOfChar] == 't' ||                   this._mathInput[_indexOfChar] == 'a' ||                  this._mathInput[_indexOfChar] == '-' ||                  this._mathInput[_indexOfChar] == '+' ||                   this._mathInput[_indexOfChar] == '('"  is complex.
Complex Conditional,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,TermToPowerK,The conditional expression  "Char.IsDigit(this._mathInput[_indexOfChar]) ||                  this._varsAndValues.ContainsKey(this._mathInput[_indexOfChar]) ||                  this._mathInput[_indexOfChar] == '.' ||                  this._mathInput[_indexOfChar] == 's' ||                  this._mathInput[_indexOfChar] == 'l' ||                  this._mathInput[_indexOfChar] == 'c' ||                  this._mathInput[_indexOfChar] == 'e' ||                  this._mathInput[_indexOfChar] == 't' ||                  this._mathInput[_indexOfChar] == 'a' ||                  this._mathInput[_indexOfChar] == '-' ||                  this._mathInput[_indexOfChar] == '+' ||                  this._mathInput[_indexOfChar] == '('"  is complex.
Complex Conditional,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,PowerToFactoV,The conditional expression  "Char.IsDigit(this._mathInput[_indexOfChar]) ||                  this._varsAndValues.ContainsKey(this._mathInput[_indexOfChar]) ||                  this._mathInput[_indexOfChar] == '.' ||                  this._mathInput[_indexOfChar] == 's' ||                  this._mathInput[_indexOfChar] == 'l' ||                  this._mathInput[_indexOfChar] == 'c' ||                  this._mathInput[_indexOfChar] == 'e' ||                  this._mathInput[_indexOfChar] == 't' ||                  this._mathInput[_indexOfChar] == 'a' ||                  this._mathInput[_indexOfChar] == '-' ||                  this._mathInput[_indexOfChar] == '+' ||                  this._mathInput[_indexOfChar] == '('"  is complex.
Complex Conditional,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,VtoZVorVtoEps,The conditional expression  "this._mathInput[this._indexOfChar] != '+' && this._mathInput[this._indexOfChar] != '-' &&                      this._mathInput[this._indexOfChar] != '*' && this._mathInput[this._indexOfChar] != '/' &&                      this._mathInput[this._indexOfChar] != ')'"  is complex.
Complex Conditional,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The conditional expression  "(GetPrecedence(token.TokenName) <= GetPrecedence(op) &&                                   IsLeftAssociative(token.TokenValue)) ||                                  !IsLeftAssociative(token.TokenValue) &&                                  GetPrecedence(token.TokenName) < GetPrecedence(op)"  is complex.
Complex Conditional,MathParserTK_NET,MathParserTK,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,LexicalAnalyze,The conditional expression  "char.IsDigit(preToken[0]) || char.IsDigit(infixExp[pos + 1])                                              || (infixExp[pos + 1] == '+') || (infixExp[pos + 1] == '-')"  is complex.
Empty Catch Block,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,EvaluateFunction,The method has an empty catch block.
Empty Catch Block,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,EvaluateFunction,The method has an empty catch block.
Empty Catch Block,MathParserTK_NET,MathParserTK,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,LexicalAnalyze,The method has an empty catch block.
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,GetToken,The following statement contains a magic number: if (!isLetter && !isDigit)  			{  				// if this is a number starting with a decimal' don't parse as operator                  var nxt = _ptr + 1 < _len ? _expr[_ptr + 1] : 0;                  bool isNumber = c == _decimal && nxt >= '0' && nxt <= '9';  				if (!isNumber)  				{                      // look up localized list separator                      if (c == _listSep)                      {                          _token = new Token(c' TKID.COMMA' TKTYPE.GROUP);                          _ptr++;                          return;                      }                                            // look up single-char tokens on table                      Token tk;                      if (_tkTbl.TryGetValue(c' out tk))  					{  						// save token we found  						_token = tk;  						_ptr++;    						// look for double-char tokens (special case)  						if (_ptr < _len && (c == '>' || c == '<'))  						{                              if (_tkTbl.TryGetValue(_expr.Substring(_ptr - 1' 2)' out tk))  							{  								_token = tk;  								_ptr++;  							}  						}                            // found token on the table  						return;  					}  				}  			}
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,GetToken,The following statement contains a magic number: if (isDigit || c == _decimal)  			{  				var sci = false;                  var pct = false;                  var div = -1.0; // use double' not int (this may get really big)                  var val = 0.0;                  for (i = 0; i + _ptr < _len; i++)  				{  					c = _expr[_ptr + i];                        // digits always OK                      if (c >= '0' && c <= '9')                      {                          val = val * 10 + (c - '0');                          if (div > -1)                          {                              div *= 10;                          }                          continue;                      }    					// one decimal is OK                      if (c == _decimal && div < 0)  					{  						div = 1;  						continue;  					}                        					// scientific notation?  					if ((c == 'E' || c == 'e') && !sci)   					{  						sci = true;  						c = _expr[_ptr + i + 1];  						if (c == '+' || c == '-') i++;  						continue;  					}                        // percentage?                      if (c == _percent)                      {                          pct = true;                          i++;                          break;                      }    					// end of literal  					break;  				}                    // end of number' get value                  if (!sci)                  {                      // much faster than ParseDouble                      if (div > 1)                      {                          val /= div;                      }                      if (pct)                      {                          val /= 100.0;                      }                  }                  else                  {                      var lit = _expr.Substring(_ptr' i);                      val = ParseDouble(lit' _ci);                  }                    // build token                  _token = new Token(val' TKID.ATOM' TKTYPE.LITERAL);                    // advance pointer and return                  _ptr += i;                  return;  			}
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,GetToken,The following statement contains a magic number: if (isDigit || c == _decimal)  			{  				var sci = false;                  var pct = false;                  var div = -1.0; // use double' not int (this may get really big)                  var val = 0.0;                  for (i = 0; i + _ptr < _len; i++)  				{  					c = _expr[_ptr + i];                        // digits always OK                      if (c >= '0' && c <= '9')                      {                          val = val * 10 + (c - '0');                          if (div > -1)                          {                              div *= 10;                          }                          continue;                      }    					// one decimal is OK                      if (c == _decimal && div < 0)  					{  						div = 1;  						continue;  					}                        					// scientific notation?  					if ((c == 'E' || c == 'e') && !sci)   					{  						sci = true;  						c = _expr[_ptr + i + 1];  						if (c == '+' || c == '-') i++;  						continue;  					}                        // percentage?                      if (c == _percent)                      {                          pct = true;                          i++;                          break;                      }    					// end of literal  					break;  				}                    // end of number' get value                  if (!sci)                  {                      // much faster than ParseDouble                      if (div > 1)                      {                          val /= div;                      }                      if (pct)                      {                          val /= 100.0;                      }                  }                  else                  {                      var lit = _expr.Substring(_ptr' i);                      val = ParseDouble(lit' _ci);                  }                    // build token                  _token = new Token(val' TKID.ATOM' TKTYPE.LITERAL);                    // advance pointer and return                  _ptr += i;                  return;  			}
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,GetToken,The following statement contains a magic number: if (isDigit || c == _decimal)  			{  				var sci = false;                  var pct = false;                  var div = -1.0; // use double' not int (this may get really big)                  var val = 0.0;                  for (i = 0; i + _ptr < _len; i++)  				{  					c = _expr[_ptr + i];                        // digits always OK                      if (c >= '0' && c <= '9')                      {                          val = val * 10 + (c - '0');                          if (div > -1)                          {                              div *= 10;                          }                          continue;                      }    					// one decimal is OK                      if (c == _decimal && div < 0)  					{  						div = 1;  						continue;  					}                        					// scientific notation?  					if ((c == 'E' || c == 'e') && !sci)   					{  						sci = true;  						c = _expr[_ptr + i + 1];  						if (c == '+' || c == '-') i++;  						continue;  					}                        // percentage?                      if (c == _percent)                      {                          pct = true;                          i++;                          break;                      }    					// end of literal  					break;  				}                    // end of number' get value                  if (!sci)                  {                      // much faster than ParseDouble                      if (div > 1)                      {                          val /= div;                      }                      if (pct)                      {                          val /= 100.0;                      }                  }                  else                  {                      var lit = _expr.Substring(_ptr' i);                      val = ParseDouble(lit' _ci);                  }                    // build token                  _token = new Token(val' TKID.ATOM' TKTYPE.LITERAL);                    // advance pointer and return                  _ptr += i;                  return;  			}
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,ParseDouble,The following statement contains a magic number: if (str.Length > 0 && str[str.Length - 1] == ci.NumberFormat.PercentSymbol[0])              {                  str = str.Substring(0' str.Length - 1);                  return double.Parse(str' NumberStyles.Any' ci) / 100.0;              }
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("1*2*3*4*5*6*7*8*9"' 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9.0);
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("1*2*3*4*5*6*7*8*9"' 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9.0);
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("1*2*3*4*5*6*7*8*9"' 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9.0);
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("1*2*3*4*5*6*7*8*9"' 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9.0);
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("1*2*3*4*5*6*7*8*9"' 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9.0);
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("1*2*3*4*5*6*7*8*9"' 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9.0);
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("1*2*3*4*5*6*7*8*9"' 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9.0);
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("1*2*3*4*5*6*7*8*9"' 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9.0);
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("((1+2)*(2+3)/(4+5))^0.123"' Math.Pow((1 + 2) * (2 + 3) / (4 + 5.0)' 0.123));
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("((1+2)*(2+3)/(4+5))^0.123"' Math.Pow((1 + 2) * (2 + 3) / (4 + 5.0)' 0.123));
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("((1+2)*(2+3)/(4+5))^0.123"' Math.Pow((1 + 2) * (2 + 3) / (4 + 5.0)' 0.123));
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("((1+2)*(2+3)/(4+5))^0.123"' Math.Pow((1 + 2) * (2 + 3) / (4 + 5.0)' 0.123));
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("((1+2)*(2+3)/(4+5))^0.123"' Math.Pow((1 + 2) * (2 + 3) / (4 + 5.0)' 0.123));
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("((1+2)*(2+3)/(4+5))^0.123"' Math.Pow((1 + 2) * (2 + 3) / (4 + 5.0)' 0.123));
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("10%"' 0.1);
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("1e+3"' 1000.0);
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Variables.Add("two"' 2);
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("one + two"' 3);
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("(two + two)^2"' 16);
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("Name.Length * 2"' p.Name.Length * 2);
Magic Number,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("Children(2).Name"' p.Children[2].Name);
Magic Number,CalcEngine,BinaryExpression,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Expression.cs,Evaluate,The following statement contains a magic number: switch (_token.ID)  			{  				case TKID.ADD:                       return (double)_lft + (double)_rgt;  				case TKID.SUB:                       return (double)_lft - (double)_rgt;  				case TKID.MUL:                       return (double)_lft * (double)_rgt;  				case TKID.DIV:                       return (double)_lft / (double)_rgt;  				case TKID.DIVINT:                       return (double)(int)((double)_lft / (double)_rgt);  				case TKID.MOD:                       return (double)(int)((double)_lft % (double)_rgt);  				case TKID.POWER:                      var a = (double)_lft;                      var b = (double)_rgt;                      if (b == 0.0) return 1.0;                      if (b == 0.5) return Math.Sqrt(a);                      if (b == 1.0) return a;                      if (b == 2.0) return a * a;                      if (b == 3.0) return a * a * a;                      if (b == 4.0) return a * a * a * a;                      return Math.Pow((double)_lft' (double)_rgt);  			}
Magic Number,CalcEngine,BinaryExpression,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Expression.cs,Evaluate,The following statement contains a magic number: switch (_token.ID)  			{  				case TKID.ADD:                       return (double)_lft + (double)_rgt;  				case TKID.SUB:                       return (double)_lft - (double)_rgt;  				case TKID.MUL:                       return (double)_lft * (double)_rgt;  				case TKID.DIV:                       return (double)_lft / (double)_rgt;  				case TKID.DIVINT:                       return (double)(int)((double)_lft / (double)_rgt);  				case TKID.MOD:                       return (double)(int)((double)_lft % (double)_rgt);  				case TKID.POWER:                      var a = (double)_lft;                      var b = (double)_rgt;                      if (b == 0.0) return 1.0;                      if (b == 0.5) return Math.Sqrt(a);                      if (b == 1.0) return a;                      if (b == 2.0) return a * a;                      if (b == 3.0) return a * a * a;                      if (b == 4.0) return a * a * a * a;                      return Math.Pow((double)_lft' (double)_rgt);  			}
Magic Number,CalcEngine,BinaryExpression,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Expression.cs,Evaluate,The following statement contains a magic number: switch (_token.ID)  			{  				case TKID.ADD:                       return (double)_lft + (double)_rgt;  				case TKID.SUB:                       return (double)_lft - (double)_rgt;  				case TKID.MUL:                       return (double)_lft * (double)_rgt;  				case TKID.DIV:                       return (double)_lft / (double)_rgt;  				case TKID.DIVINT:                       return (double)(int)((double)_lft / (double)_rgt);  				case TKID.MOD:                       return (double)(int)((double)_lft % (double)_rgt);  				case TKID.POWER:                      var a = (double)_lft;                      var b = (double)_rgt;                      if (b == 0.0) return 1.0;                      if (b == 0.5) return Math.Sqrt(a);                      if (b == 1.0) return a;                      if (b == 2.0) return a * a;                      if (b == 3.0) return a * a * a;                      if (b == 4.0) return a * a * a * a;                      return Math.Pow((double)_lft' (double)_rgt);  			}
Magic Number,CalcEngine,BinaryExpression,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Expression.cs,Evaluate,The following statement contains a magic number: switch (_token.ID)  			{  				case TKID.ADD:                       return (double)_lft + (double)_rgt;  				case TKID.SUB:                       return (double)_lft - (double)_rgt;  				case TKID.MUL:                       return (double)_lft * (double)_rgt;  				case TKID.DIV:                       return (double)_lft / (double)_rgt;  				case TKID.DIVINT:                       return (double)(int)((double)_lft / (double)_rgt);  				case TKID.MOD:                       return (double)(int)((double)_lft % (double)_rgt);  				case TKID.POWER:                      var a = (double)_lft;                      var b = (double)_rgt;                      if (b == 0.0) return 1.0;                      if (b == 0.5) return Math.Sqrt(a);                      if (b == 1.0) return a;                      if (b == 2.0) return a * a;                      if (b == 3.0) return a * a * a;                      if (b == 4.0) return a * a * a * a;                      return Math.Pow((double)_lft' (double)_rgt);  			}
Magic Number,CalcEngine,Logical,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Logical.cs,Register,The following statement contains a magic number: ce.RegisterFunction("IF"' 3' If);
Magic Number,CalcEngine,Logical,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Logical.cs,If,The following statement contains a magic number: return (bool)p[0]                   ? p[1].Evaluate()                   : p[2].Evaluate();
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Register,The following statement contains a magic number: ce.RegisterFunction("ATAN2"' 2' Atan2);
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Register,The following statement contains a magic number: ce.RegisterFunction("LOG"' 1' 2' Log);
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Register,The following statement contains a magic number: ce.RegisterFunction("POWER"' 2' Power);
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Register,The following statement contains a magic number: ce.RegisterFunction("RANDBETWEEN"' 2' RandBetween);
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Register,The following statement contains a magic number: ce.RegisterFunction("SUMIF"' 2' 3' SumIf);
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Register,The following statement contains a magic number: ce.RegisterFunction("SUMIF"' 2' 3' SumIf);
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("ABS(-12)"' 12.0);
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("ABS(+12)"' 12.0);
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("ACOS(.23)"' Math.Acos(.23));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("ASIN(.23)"' Math.Asin(.23));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("ATAN(.23)"' Math.Atan(.23));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("ATAN2(1'2)"' Math.Atan2(1' 2));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("CEILING(1.8)"' Math.Ceiling(1.8));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("COS(1.23)"' Math.Cos(1.23));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("COSH(1.23)"' Math.Cosh(1.23));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("FLOOR(1.8)"' Math.Floor(1.8));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("LOG(1.8)"' Math.Log(1.8' 10));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("LOG(1.8)"' Math.Log(1.8' 10));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("LOG(1.8' 4)"' Math.Log(1.8' 4));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("LOG(1.8' 4)"' Math.Log(1.8' 4));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("LN(1.8)"' Math.Log(1.8));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("LOG10(1.8)"' Math.Log10(1.8));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("POWER(2'4)"' Math.Pow(2' 4));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("POWER(2'4)"' Math.Pow(2' 4));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("SIN(1.23)"' Math.Sin(1.23));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("SINH(1.23)"' Math.Sinh(1.23));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("SQRT(144)"' Math.Sqrt(144));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("SUM(1' 2' 3' 4)"' 1 + 2 + 3 + 4.0);
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("SUM(1' 2' 3' 4)"' 1 + 2 + 3 + 4.0);
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("SUM(1' 2' 3' 4)"' 1 + 2 + 3 + 4.0);
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("TAN(1.23)"' Math.Tan(1.23));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("TANH(1.23)"' Math.Tanh(1.23));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("LN(10)"' Math.Log(10));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("LOG(10)"' Math.Log10(10));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("EXP(10)"' Math.Exp(10));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("SIN(PI()/4)"' Math.Sin(Math.PI / 4));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("ASIN(PI()/4)"' Math.Asin(Math.PI / 4));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("SINH(PI()/4)"' Math.Sinh(Math.PI / 4));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("COS(PI()/4)"' Math.Cos(Math.PI / 4));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("ACOS(PI()/4)"' Math.Acos(Math.PI / 4));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("COSH(PI()/4)"' Math.Cosh(Math.PI / 4));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("TAN(PI()/4)"' Math.Tan(Math.PI / 4));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("ATAN(PI()/4)"' Math.Atan(Math.PI / 4));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("ATAN2(1'2)"' Math.Atan2(1' 2));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("TANH(PI()/4)"' Math.Tanh(Math.PI / 4));
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Log,The following statement contains a magic number: var lbase = p.Count > 1 ? (double)p[1] : 10;
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,SumIf,The following statement contains a magic number: IEnumerable sumRange = p.Count < 3 ? range : p[2] as IEnumerable;
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,SumIf,The following statement contains a magic number: IEnumerable sumRange = p.Count < 3 ? range : p[2] as IEnumerable;
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,ValueSatisfiesCriteria,The following statement contains a magic number: if (!string.IsNullOrEmpty(cs))              {                  // if criteria is an expression (e.g. ">20")' use calc engine                  if (cs[0] == '=' || cs[0] == '<' || cs[0] == '>')                  {                      // build expression                      var expression = string.Format("{0}{1}"' value' cs);                        // add quotes if necessary                      var pattern = @"(\w+)(\W+)(\w+)";                      var m = Regex.Match(expression' pattern);                      if (m.Groups.Count == 4)                      {                          double d;                          if (!double.TryParse(m.Groups[1].Value' out d) ||                              !double.TryParse(m.Groups[3].Value' out d))                          {                              expression = string.Format("\"{0}\"{1}\"{2}\""'                                  m.Groups[1].Value'                                  m.Groups[2].Value'                                  m.Groups[3].Value);                          }                      }                        // evaluate                      return (bool)ce.Evaluate(expression);                  }                    // if criteria is a regular expression' use regex                  if (cs.IndexOf('*') > -1)                  {                      var pattern = cs.Replace(@"\"' @"\\");                      pattern = pattern.Replace("."' @"\");                      pattern = pattern.Replace("*"' ".*");                      return Regex.IsMatch(value.ToString()' pattern' RegexOptions.IgnoreCase);                  }                    // straight string comparison                   return string.Equals(value.ToString()' cs' StringComparison.OrdinalIgnoreCase);              }
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,ValueSatisfiesCriteria,The following statement contains a magic number: if (!string.IsNullOrEmpty(cs))              {                  // if criteria is an expression (e.g. ">20")' use calc engine                  if (cs[0] == '=' || cs[0] == '<' || cs[0] == '>')                  {                      // build expression                      var expression = string.Format("{0}{1}"' value' cs);                        // add quotes if necessary                      var pattern = @"(\w+)(\W+)(\w+)";                      var m = Regex.Match(expression' pattern);                      if (m.Groups.Count == 4)                      {                          double d;                          if (!double.TryParse(m.Groups[1].Value' out d) ||                              !double.TryParse(m.Groups[3].Value' out d))                          {                              expression = string.Format("\"{0}\"{1}\"{2}\""'                                  m.Groups[1].Value'                                  m.Groups[2].Value'                                  m.Groups[3].Value);                          }                      }                        // evaluate                      return (bool)ce.Evaluate(expression);                  }                    // if criteria is a regular expression' use regex                  if (cs.IndexOf('*') > -1)                  {                      var pattern = cs.Replace(@"\"' @"\\");                      pattern = pattern.Replace("."' @"\");                      pattern = pattern.Replace("*"' ".*");                      return Regex.IsMatch(value.ToString()' pattern' RegexOptions.IgnoreCase);                  }                    // straight string comparison                   return string.Equals(value.ToString()' cs' StringComparison.OrdinalIgnoreCase);              }
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,ValueSatisfiesCriteria,The following statement contains a magic number: if (!string.IsNullOrEmpty(cs))              {                  // if criteria is an expression (e.g. ">20")' use calc engine                  if (cs[0] == '=' || cs[0] == '<' || cs[0] == '>')                  {                      // build expression                      var expression = string.Format("{0}{1}"' value' cs);                        // add quotes if necessary                      var pattern = @"(\w+)(\W+)(\w+)";                      var m = Regex.Match(expression' pattern);                      if (m.Groups.Count == 4)                      {                          double d;                          if (!double.TryParse(m.Groups[1].Value' out d) ||                              !double.TryParse(m.Groups[3].Value' out d))                          {                              expression = string.Format("\"{0}\"{1}\"{2}\""'                                  m.Groups[1].Value'                                  m.Groups[2].Value'                                  m.Groups[3].Value);                          }                      }                        // evaluate                      return (bool)ce.Evaluate(expression);                  }                    // if criteria is a regular expression' use regex                  if (cs.IndexOf('*') > -1)                  {                      var pattern = cs.Replace(@"\"' @"\\");                      pattern = pattern.Replace("."' @"\");                      pattern = pattern.Replace("*"' ".*");                      return Regex.IsMatch(value.ToString()' pattern' RegexOptions.IgnoreCase);                  }                    // straight string comparison                   return string.Equals(value.ToString()' cs' StringComparison.OrdinalIgnoreCase);              }
Magic Number,CalcEngine,MathTrig,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,ValueSatisfiesCriteria,The following statement contains a magic number: if (!string.IsNullOrEmpty(cs))              {                  // if criteria is an expression (e.g. ">20")' use calc engine                  if (cs[0] == '=' || cs[0] == '<' || cs[0] == '>')                  {                      // build expression                      var expression = string.Format("{0}{1}"' value' cs);                        // add quotes if necessary                      var pattern = @"(\w+)(\W+)(\w+)";                      var m = Regex.Match(expression' pattern);                      if (m.Groups.Count == 4)                      {                          double d;                          if (!double.TryParse(m.Groups[1].Value' out d) ||                              !double.TryParse(m.Groups[3].Value' out d))                          {                              expression = string.Format("\"{0}\"{1}\"{2}\""'                                  m.Groups[1].Value'                                  m.Groups[2].Value'                                  m.Groups[3].Value);                          }                      }                        // evaluate                      return (bool)ce.Evaluate(expression);                  }                    // if criteria is a regular expression' use regex                  if (cs.IndexOf('*') > -1)                  {                      var pattern = cs.Replace(@"\"' @"\\");                      pattern = pattern.Replace("."' @"\");                      pattern = pattern.Replace("*"' ".*");                      return Regex.IsMatch(value.ToString()' pattern' RegexOptions.IgnoreCase);                  }                    // straight string comparison                   return string.Equals(value.ToString()' cs' StringComparison.OrdinalIgnoreCase);              }
Magic Number,CalcEngine,Statistical,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Statistical.cs,Register,The following statement contains a magic number: ce.RegisterFunction("COUNTIF"' 2' CountIf);
Magic Number,CalcEngine,Statistical,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Statistical.cs,Test,The following statement contains a magic number: ce.Test("Average(1' 3' 3' 1' true' false' \"hello\")"' 2.0);
Magic Number,CalcEngine,Statistical,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Statistical.cs,Test,The following statement contains a magic number: ce.Test("AverageA(1' 3' 3' 1' true' false' \"hello\")"' (1 + 3 + 3 + 1 + 1 + 0 + 0) / 7.0);
Magic Number,CalcEngine,Statistical,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Statistical.cs,Test,The following statement contains a magic number: ce.Test("AverageA(1' 3' 3' 1' true' false' \"hello\")"' (1 + 3 + 3 + 1 + 1 + 0 + 0) / 7.0);
Magic Number,CalcEngine,Statistical,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Statistical.cs,Test,The following statement contains a magic number: ce.Test("AverageA(1' 3' 3' 1' true' false' \"hello\")"' (1 + 3 + 3 + 1 + 1 + 0 + 0) / 7.0);
Magic Number,CalcEngine,Statistical,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Statistical.cs,Test,The following statement contains a magic number: ce.Test("Count(1' 3' 3' 1' true' false' \"hello\")"' 4.0);
Magic Number,CalcEngine,Statistical,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Statistical.cs,Test,The following statement contains a magic number: ce.Test("CountA(1' 3' 3' 1' true' false' \"hello\")"' 7.0);
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction("FIND"' 2' 3' Find);
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction("FIND"' 2' 3' Find);
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction("LEFT"' 1' 2' Left);
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction("MID"' 3' Mid);
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction("REPLACE"' 4' Replace);
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction("REPT"' 2' Rept);
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction("RIGHT"' 1' 2' Right);
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction("SEARCH"' 2' Search);
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction("SUBSTITUTE"' 3' 4' Substitute);
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction("SUBSTITUTE"' 3' 4' Substitute);
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction("TEXT"' 2' _Text);
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Test,The following statement contains a magic number: ce.Test("CODE(\"A\")"' 65);
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Test,The following statement contains a magic number: ce.Test("FIND(\"bra\"' \"abracadabra\")"' 2);
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Test,The following statement contains a magic number: ce.Test("LEN(\"abracadabra\")"' 11);
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Test,The following statement contains a magic number: ce.Test("SEARCH(\"bra\"' \"abracadabra\")"' 2);
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Test,The following statement contains a magic number: ce.Test("SEARCH(\"BRA\"' \"abracadabra\")"' 2);
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Test,The following statement contains a magic number: ce.Test("VALUE(\"1234\")"' 1234.0);
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,IndexOf,The following statement contains a magic number: if (p.Count > 2)              {                  start = (int)p[2] - 1;              }
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,IndexOf,The following statement contains a magic number: if (p.Count > 2)              {                  start = (int)p[2] - 1;              }
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Mid,The following statement contains a magic number: return ((string)p[0]).Substring((int)p[1] - 1' (int)p[2]);
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Replace,The following statement contains a magic number: var len = (int)p[2];
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Replace,The following statement contains a magic number: var rep = (string)p[3];
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Substitute,The following statement contains a magic number: var newText = (string)p[2];
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Substitute,The following statement contains a magic number: if (p.Count == 3)              {                  return text.Replace(oldText' newText);              }
Magic Number,CalcEngine,Text,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Substitute,The following statement contains a magic number: int index = (int)p[3];
Magic Number,CalcEngine,Person,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Tester.cs,CreateTestPerson,The following statement contains a magic number: p.Birth = DateTime.Today.AddYears(-30);
Magic Number,CalcEngine,Person,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Tester.cs,CreateTestPerson,The following statement contains a magic number: for (int i = 0; i < 5; i++)                  {                      var c = new Person();                      c.Name = "Test Child " + i.ToString();                      c.Birth = DateTime.Today.AddYears(-i);                      c.Male = i % 2 == 0;                      p.Children.Add(c);                      p.ChildrenDct.Add(c.Name' c);                  }
Magic Number,CalcEngine,Person,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Tester.cs,CreateTestPerson,The following statement contains a magic number: for (int i = 0; i < 5; i++)                  {                      var c = new Person();                      c.Name = "Test Child " + i.ToString();                      c.Birth = DateTime.Today.AddYears(-i);                      c.Male = i % 2 == 0;                      p.Children.Add(c);                      p.ChildrenDct.Add(c.Name' c);                  }
Magic Number,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Factor,The following statement contains a magic number: if (this._mathInput[this._indexOfChar] == '+')   //check if unary plus              {                  _traverseNode.Operation = Operation.Plus;                  _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.AnyValue)' new MathParserTreeNode(Nonterminal.Factor));                  _traverseNode.Left.Operation = Operation.UnaryPlus;                  this._sizeOfPolishPostfixExpression += 2;                  stack.Push(_traverseNode.Right);                  this._indexOfChar++;                  return;              }
Magic Number,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Factor,The following statement contains a magic number: if (this._mathInput[this._indexOfChar] == '-')   //check if unary minus              {                  _traverseNode.Operation = Operation.Minus;                  _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.AnyValue)' new MathParserTreeNode(Nonterminal.Factor));                  _traverseNode.Left.Operation = Operation.UnaryMinus;                  this._sizeOfPolishPostfixExpression += 2;                  stack.Push(_traverseNode.Right);                  this._indexOfChar++;                  return;              }
Magic Number,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Factor,The following statement contains a magic number: if (this._mathInput.Length > this._indexOfChar + 4)              {                  temp = this._mathInput.Substring(this._indexOfChar' 4);                  if (_mathFuncDecision.ContainsKey(temp))               //check if the next item is math function                  {                      try                      {                          _mathFuncDecision[temp].Invoke(stack);                          return;                      }                      catch (MathParserException)                      {                          throw;                      }                  }              }
Magic Number,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Factor,The following statement contains a magic number: if (this._mathInput.Length > this._indexOfChar + 4)              {                  temp = this._mathInput.Substring(this._indexOfChar' 4);                  if (_mathFuncDecision.ContainsKey(temp))               //check if the next item is math function                  {                      try                      {                          _mathFuncDecision[temp].Invoke(stack);                          return;                      }                      catch (MathParserException)                      {                          throw;                      }                  }              }
Magic Number,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Sin,The following statement contains a magic number: this._indexOfChar += 4;
Magic Number,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Sqrt,The following statement contains a magic number: if (this._mathInput[this._indexOfChar + 4] == '(')              {                  _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose));                  _traverseNode.Left.Operation = Operation.Sqrt;                  this._sizeOfPolishPostfixExpression++;                  this._indexOfChar += 5;                  stack.Push(_traverseNode.Right);                  stack.Push(_traverseNode.Left);              }              else                  throw new MathParserException("Wrong input string. Expecting for end '('' at input[" + _indexOfChar.ToString() + "]");
Magic Number,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Sqrt,The following statement contains a magic number: if (this._mathInput[this._indexOfChar + 4] == '(')              {                  _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose));                  _traverseNode.Left.Operation = Operation.Sqrt;                  this._sizeOfPolishPostfixExpression++;                  this._indexOfChar += 5;                  stack.Push(_traverseNode.Right);                  stack.Push(_traverseNode.Left);              }              else                  throw new MathParserException("Wrong input string. Expecting for end '('' at input[" + _indexOfChar.ToString() + "]");
Magic Number,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Sec,The following statement contains a magic number: this._indexOfChar += 4;
Magic Number,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Cos,The following statement contains a magic number: this._indexOfChar += 4;
Magic Number,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Cot,The following statement contains a magic number: this._indexOfChar += 4;
Magic Number,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Tan,The following statement contains a magic number: this._indexOfChar += 4;
Magic Number,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Csc,The following statement contains a magic number: this._indexOfChar += 4;
Magic Number,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Asin,The following statement contains a magic number: if (this._mathInput[this._indexOfChar + 4] == '(')              {                  _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose));                  _traverseNode.Left.Operation = Operation.Asin;                  this._sizeOfPolishPostfixExpression++;                  this._indexOfChar += 5;                  stack.Push(_traverseNode.Right);                  stack.Push(_traverseNode.Left);              }              else                  throw new MathParserException("Wrong input string. Expecting for end '('' at input[" + _indexOfChar.ToString() + "]");
Magic Number,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Asin,The following statement contains a magic number: if (this._mathInput[this._indexOfChar + 4] == '(')              {                  _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose));                  _traverseNode.Left.Operation = Operation.Asin;                  this._sizeOfPolishPostfixExpression++;                  this._indexOfChar += 5;                  stack.Push(_traverseNode.Right);                  stack.Push(_traverseNode.Left);              }              else                  throw new MathParserException("Wrong input string. Expecting for end '('' at input[" + _indexOfChar.ToString() + "]");
Magic Number,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Acos,The following statement contains a magic number: if (this._mathInput[this._indexOfChar + 4] == '(')              {                  _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose));                  _traverseNode.Left.Operation = Operation.Acos;                  this._sizeOfPolishPostfixExpression++;                  this._indexOfChar += 5;                  stack.Push(_traverseNode.Right);                  stack.Push(_traverseNode.Left);              }              else                  throw new MathParserException("Wrong input string. Expecting for end '('' at input[" + _indexOfChar.ToString() + "]");
Magic Number,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Acos,The following statement contains a magic number: if (this._mathInput[this._indexOfChar + 4] == '(')              {                  _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose));                  _traverseNode.Left.Operation = Operation.Acos;                  this._sizeOfPolishPostfixExpression++;                  this._indexOfChar += 5;                  stack.Push(_traverseNode.Right);                  stack.Push(_traverseNode.Left);              }              else                  throw new MathParserException("Wrong input string. Expecting for end '('' at input[" + _indexOfChar.ToString() + "]");
Magic Number,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Atan,The following statement contains a magic number: if (this._mathInput[this._indexOfChar + 4] == '(')              {                  _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose));                  _traverseNode.Left.Operation = Operation.Atan;                  this._sizeOfPolishPostfixExpression++;                  this._indexOfChar += 5;                  stack.Push(_traverseNode.Right);                  stack.Push(_traverseNode.Left);              }              else                  throw new MathParserException("Wrong input string. Expecting for end '('' at input[" + _indexOfChar.ToString() + "]");
Magic Number,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Atan,The following statement contains a magic number: if (this._mathInput[this._indexOfChar + 4] == '(')              {                  _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose));                  _traverseNode.Left.Operation = Operation.Atan;                  this._sizeOfPolishPostfixExpression++;                  this._indexOfChar += 5;                  stack.Push(_traverseNode.Right);                  stack.Push(_traverseNode.Left);              }              else                  throw new MathParserException("Wrong input string. Expecting for end '('' at input[" + _indexOfChar.ToString() + "]");
Magic Number,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Acot,The following statement contains a magic number: if (this._mathInput[this._indexOfChar + 4] == '(')              {                  _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose));                  _traverseNode.Left.Operation = Operation.Acot;                  this._sizeOfPolishPostfixExpression++;                  this._indexOfChar += 5;                  stack.Push(_traverseNode.Right);                  stack.Push(_traverseNode.Left);              }              else                  throw new MathParserException("Wrong input string. Expecting for end '('' at input[" + _indexOfChar.ToString() + "]");
Magic Number,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Acot,The following statement contains a magic number: if (this._mathInput[this._indexOfChar + 4] == '(')              {                  _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose));                  _traverseNode.Left.Operation = Operation.Acot;                  this._sizeOfPolishPostfixExpression++;                  this._indexOfChar += 5;                  stack.Push(_traverseNode.Right);                  stack.Push(_traverseNode.Left);              }              else                  throw new MathParserException("Wrong input string. Expecting for end '('' at input[" + _indexOfChar.ToString() + "]");
Magic Number,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Exp,The following statement contains a magic number: this._indexOfChar += 4;
Magic Number,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Log,The following statement contains a magic number: this._indexOfChar += 4;
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Evaluate,The following statement contains a magic number: try   			{  				// ****************************************************************************************  				// ** MathParser in action:                                                              **  				// ** Expression = "-(5 - 10)^(-1)  ( 3 + 2(    cos( 3 Pi )+( 2+ ln( exp(1) ) )    ^3))" **  				// ****************************************************************************************  				//  				//  				// ----------  				// - Step 1 -  				// ----------  				// Remove blank.  				//  				// -(5 - 10)^(-1)  ( 3 + 2(    cos( 3 Pi )+( 2+ ln( exp(1) ) )    ^3)) -> -(5-10)^(-1)(3+2(cos(3Pi)+(2+ln(exp(1)))^3))  				//  				Expression = Expression.Replace( " "' "" );  				//  				// ----------  				// - Step 2 -  				// ----------  				// Insert '*' if necessary.  				//  				//                                                             _    _      _  				// -(5-10)^(-1)(3+2(cos(3Pi)+(2+ln(exp(1)))^3)) -> -(5-10)^(-1)*(3+2*(cos(3*Pi)+(2+ln(exp(1)))^3))  				//             |   |     |  				//  				Regex regEx = new Regex( @"(?<=[\d\)])(?=[a-df-z\(])|(?<=pi)(?=[^\+\-\*\/\\^!)])|(?<=\))(?=\d)|(?<=[^\/\*\+\-])(?=exp)"' RegexOptions.IgnoreCase );  				Expression = regEx.Replace( Expression' "*" );  				//  				// ----------  				// - Step 3 -  				// ----------  				// Replace constants: Pi -> 3'14...  				//  				//                                                                        ____  				// -(5-10)^(-1)*(3+2*(cos(3*Pi)+(2+ln(e))^3)) -> -(5-10)^(-1)*(3+2*(cos(3*3'14)+(2+ln(exp(1)))^3))  				//                          --  				//  				regEx = new Regex( "pi"' RegexOptions.IgnoreCase );  				Expression = regEx.Replace( Expression' Math.PI.ToString() );  				//  				// ----------  				// - Step 4 -  				// ----------  				// Search for parentheses an solve the expression between it.  				//  				//                                                       _____  				// -(5-10)^(-1)*(3+2*(cos(3*3'14)+(2+ln(exp(1)))^3)) -> -{-5}^(-1)*(3+2*(cos(3*3'14)+(2+ln(exp(1)))^3))  				//  |_____|  				//                                                          __  				// -{-5}^(-1)*(3+2*(cos(3*3'14)+(2+ln(exp(1)))^3)) -> -{-5}^-1*(3+2*(cos(3*3'14)+(2+ln(exp(1)))^3))  				//       |__|  				//                                                                    ____  				// -{-5}^-1*(3+2*(cos(3*3'14)+(2+ln(exp(1)))^3)) -> -{-5}^-1*(3+2*(cos9'42+(2+ln(exp(1)))^3))  				//                   |______|  				//                                                                              _  				// -{-5}^-1*(3+2*(cos9'72+(2+ln(exp(1)))^3)) -> -{-5}^-1*(3+2*(cos9'72+(2+ln(exp1))^3))  				//                                 |_|  				//                                                                        ____  				// -{-5}^-1*(3+2*(cos9'72+(2+ln(exp1))^3)) -> -{-5}^-1*(3+2*(cos9'72+(2+ln2'71)^3))  				//                             |____|  				//                                                                 ____  				// -{-5}^-1*(3+2*(cos9'72+(2+ln2'71)^3)) -> -{-5}^-1*(3+2*(cos9'72+{3}^3))  				//                        |_________|  				//                                                 __  				// -{-5}^-1*(3+2*(cos9'72+{3}^3)) -> -{-5}^-1*(3+2*26)  				//               |_____________|  				//                               __  				// -{-5}^-1*(3+2*26) -> -{-5}^-1*55  				//          |______|  				//  				regEx = new Regex( @"([a-z]*)\(([^\(\)]+)\)(\^|!?)"' RegexOptions.IgnoreCase );  				Match m = regEx.Match( Expression );  				while( m.Success )  				{  					if( m.Groups[3].Value.Length > 0 ) Expression = Expression.Replace( m.Value' "{" + m.Groups[1].Value + this.Solve( m.Groups[2].Value ) + "}" + m.Groups[3].Value );  					else Expression = Expression.Replace( m.Value' m.Groups[1].Value + this.Solve( m.Groups[2].Value ) );  					m = regEx.Match( Expression );  				}  				//  				// ----------  				// - Step 5 -  				// ----------  				// There are no more parentheses. Solve the expression and convert it to double.  				//                __  				// -{-5}^-1*55 => 11  				// |_________|  				//  				this.Value = Convert.ToDouble( this.Solve( Expression ) );  				return true;  			}  			catch  			{  				// Shit!  				return false;  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Evaluate,The following statement contains a magic number: try   			{  				// ****************************************************************************************  				// ** MathParser in action:                                                              **  				// ** Expression = "-(5 - 10)^(-1)  ( 3 + 2(    cos( 3 Pi )+( 2+ ln( exp(1) ) )    ^3))" **  				// ****************************************************************************************  				//  				//  				// ----------  				// - Step 1 -  				// ----------  				// Remove blank.  				//  				// -(5 - 10)^(-1)  ( 3 + 2(    cos( 3 Pi )+( 2+ ln( exp(1) ) )    ^3)) -> -(5-10)^(-1)(3+2(cos(3Pi)+(2+ln(exp(1)))^3))  				//  				Expression = Expression.Replace( " "' "" );  				//  				// ----------  				// - Step 2 -  				// ----------  				// Insert '*' if necessary.  				//  				//                                                             _    _      _  				// -(5-10)^(-1)(3+2(cos(3Pi)+(2+ln(exp(1)))^3)) -> -(5-10)^(-1)*(3+2*(cos(3*Pi)+(2+ln(exp(1)))^3))  				//             |   |     |  				//  				Regex regEx = new Regex( @"(?<=[\d\)])(?=[a-df-z\(])|(?<=pi)(?=[^\+\-\*\/\\^!)])|(?<=\))(?=\d)|(?<=[^\/\*\+\-])(?=exp)"' RegexOptions.IgnoreCase );  				Expression = regEx.Replace( Expression' "*" );  				//  				// ----------  				// - Step 3 -  				// ----------  				// Replace constants: Pi -> 3'14...  				//  				//                                                                        ____  				// -(5-10)^(-1)*(3+2*(cos(3*Pi)+(2+ln(e))^3)) -> -(5-10)^(-1)*(3+2*(cos(3*3'14)+(2+ln(exp(1)))^3))  				//                          --  				//  				regEx = new Regex( "pi"' RegexOptions.IgnoreCase );  				Expression = regEx.Replace( Expression' Math.PI.ToString() );  				//  				// ----------  				// - Step 4 -  				// ----------  				// Search for parentheses an solve the expression between it.  				//  				//                                                       _____  				// -(5-10)^(-1)*(3+2*(cos(3*3'14)+(2+ln(exp(1)))^3)) -> -{-5}^(-1)*(3+2*(cos(3*3'14)+(2+ln(exp(1)))^3))  				//  |_____|  				//                                                          __  				// -{-5}^(-1)*(3+2*(cos(3*3'14)+(2+ln(exp(1)))^3)) -> -{-5}^-1*(3+2*(cos(3*3'14)+(2+ln(exp(1)))^3))  				//       |__|  				//                                                                    ____  				// -{-5}^-1*(3+2*(cos(3*3'14)+(2+ln(exp(1)))^3)) -> -{-5}^-1*(3+2*(cos9'42+(2+ln(exp(1)))^3))  				//                   |______|  				//                                                                              _  				// -{-5}^-1*(3+2*(cos9'72+(2+ln(exp(1)))^3)) -> -{-5}^-1*(3+2*(cos9'72+(2+ln(exp1))^3))  				//                                 |_|  				//                                                                        ____  				// -{-5}^-1*(3+2*(cos9'72+(2+ln(exp1))^3)) -> -{-5}^-1*(3+2*(cos9'72+(2+ln2'71)^3))  				//                             |____|  				//                                                                 ____  				// -{-5}^-1*(3+2*(cos9'72+(2+ln2'71)^3)) -> -{-5}^-1*(3+2*(cos9'72+{3}^3))  				//                        |_________|  				//                                                 __  				// -{-5}^-1*(3+2*(cos9'72+{3}^3)) -> -{-5}^-1*(3+2*26)  				//               |_____________|  				//                               __  				// -{-5}^-1*(3+2*26) -> -{-5}^-1*55  				//          |______|  				//  				regEx = new Regex( @"([a-z]*)\(([^\(\)]+)\)(\^|!?)"' RegexOptions.IgnoreCase );  				Match m = regEx.Match( Expression );  				while( m.Success )  				{  					if( m.Groups[3].Value.Length > 0 ) Expression = Expression.Replace( m.Value' "{" + m.Groups[1].Value + this.Solve( m.Groups[2].Value ) + "}" + m.Groups[3].Value );  					else Expression = Expression.Replace( m.Value' m.Groups[1].Value + this.Solve( m.Groups[2].Value ) );  					m = regEx.Match( Expression );  				}  				//  				// ----------  				// - Step 5 -  				// ----------  				// There are no more parentheses. Solve the expression and convert it to double.  				//                __  				// -{-5}^-1*55 => 11  				// |_________|  				//  				this.Value = Convert.ToDouble( this.Solve( Expression ) );  				return true;  			}  			catch  			{  				// Shit!  				return false;  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Evaluate,The following statement contains a magic number: try   			{  				// ****************************************************************************************  				// ** MathParser in action:                                                              **  				// ** Expression = "-(5 - 10)^(-1)  ( 3 + 2(    cos( 3 Pi )+( 2+ ln( exp(1) ) )    ^3))" **  				// ****************************************************************************************  				//  				//  				// ----------  				// - Step 1 -  				// ----------  				// Remove blank.  				//  				// -(5 - 10)^(-1)  ( 3 + 2(    cos( 3 Pi )+( 2+ ln( exp(1) ) )    ^3)) -> -(5-10)^(-1)(3+2(cos(3Pi)+(2+ln(exp(1)))^3))  				//  				Expression = Expression.Replace( " "' "" );  				//  				// ----------  				// - Step 2 -  				// ----------  				// Insert '*' if necessary.  				//  				//                                                             _    _      _  				// -(5-10)^(-1)(3+2(cos(3Pi)+(2+ln(exp(1)))^3)) -> -(5-10)^(-1)*(3+2*(cos(3*Pi)+(2+ln(exp(1)))^3))  				//             |   |     |  				//  				Regex regEx = new Regex( @"(?<=[\d\)])(?=[a-df-z\(])|(?<=pi)(?=[^\+\-\*\/\\^!)])|(?<=\))(?=\d)|(?<=[^\/\*\+\-])(?=exp)"' RegexOptions.IgnoreCase );  				Expression = regEx.Replace( Expression' "*" );  				//  				// ----------  				// - Step 3 -  				// ----------  				// Replace constants: Pi -> 3'14...  				//  				//                                                                        ____  				// -(5-10)^(-1)*(3+2*(cos(3*Pi)+(2+ln(e))^3)) -> -(5-10)^(-1)*(3+2*(cos(3*3'14)+(2+ln(exp(1)))^3))  				//                          --  				//  				regEx = new Regex( "pi"' RegexOptions.IgnoreCase );  				Expression = regEx.Replace( Expression' Math.PI.ToString() );  				//  				// ----------  				// - Step 4 -  				// ----------  				// Search for parentheses an solve the expression between it.  				//  				//                                                       _____  				// -(5-10)^(-1)*(3+2*(cos(3*3'14)+(2+ln(exp(1)))^3)) -> -{-5}^(-1)*(3+2*(cos(3*3'14)+(2+ln(exp(1)))^3))  				//  |_____|  				//                                                          __  				// -{-5}^(-1)*(3+2*(cos(3*3'14)+(2+ln(exp(1)))^3)) -> -{-5}^-1*(3+2*(cos(3*3'14)+(2+ln(exp(1)))^3))  				//       |__|  				//                                                                    ____  				// -{-5}^-1*(3+2*(cos(3*3'14)+(2+ln(exp(1)))^3)) -> -{-5}^-1*(3+2*(cos9'42+(2+ln(exp(1)))^3))  				//                   |______|  				//                                                                              _  				// -{-5}^-1*(3+2*(cos9'72+(2+ln(exp(1)))^3)) -> -{-5}^-1*(3+2*(cos9'72+(2+ln(exp1))^3))  				//                                 |_|  				//                                                                        ____  				// -{-5}^-1*(3+2*(cos9'72+(2+ln(exp1))^3)) -> -{-5}^-1*(3+2*(cos9'72+(2+ln2'71)^3))  				//                             |____|  				//                                                                 ____  				// -{-5}^-1*(3+2*(cos9'72+(2+ln2'71)^3)) -> -{-5}^-1*(3+2*(cos9'72+{3}^3))  				//                        |_________|  				//                                                 __  				// -{-5}^-1*(3+2*(cos9'72+{3}^3)) -> -{-5}^-1*(3+2*26)  				//               |_____________|  				//                               __  				// -{-5}^-1*(3+2*26) -> -{-5}^-1*55  				//          |______|  				//  				regEx = new Regex( @"([a-z]*)\(([^\(\)]+)\)(\^|!?)"' RegexOptions.IgnoreCase );  				Match m = regEx.Match( Expression );  				while( m.Success )  				{  					if( m.Groups[3].Value.Length > 0 ) Expression = Expression.Replace( m.Value' "{" + m.Groups[1].Value + this.Solve( m.Groups[2].Value ) + "}" + m.Groups[3].Value );  					else Expression = Expression.Replace( m.Value' m.Groups[1].Value + this.Solve( m.Groups[2].Value ) );  					m = regEx.Match( Expression );  				}  				//  				// ----------  				// - Step 5 -  				// ----------  				// There are no more parentheses. Solve the expression and convert it to double.  				//                __  				// -{-5}^-1*55 => 11  				// |_________|  				//  				this.Value = Convert.ToDouble( this.Solve( Expression ) );  				return true;  			}  			catch  			{  				// Shit!  				return false;  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Evaluate,The following statement contains a magic number: try   			{  				// ****************************************************************************************  				// ** MathParser in action:                                                              **  				// ** Expression = "-(5 - 10)^(-1)  ( 3 + 2(    cos( 3 Pi )+( 2+ ln( exp(1) ) )    ^3))" **  				// ****************************************************************************************  				//  				//  				// ----------  				// - Step 1 -  				// ----------  				// Remove blank.  				//  				// -(5 - 10)^(-1)  ( 3 + 2(    cos( 3 Pi )+( 2+ ln( exp(1) ) )    ^3)) -> -(5-10)^(-1)(3+2(cos(3Pi)+(2+ln(exp(1)))^3))  				//  				Expression = Expression.Replace( " "' "" );  				//  				// ----------  				// - Step 2 -  				// ----------  				// Insert '*' if necessary.  				//  				//                                                             _    _      _  				// -(5-10)^(-1)(3+2(cos(3Pi)+(2+ln(exp(1)))^3)) -> -(5-10)^(-1)*(3+2*(cos(3*Pi)+(2+ln(exp(1)))^3))  				//             |   |     |  				//  				Regex regEx = new Regex( @"(?<=[\d\)])(?=[a-df-z\(])|(?<=pi)(?=[^\+\-\*\/\\^!)])|(?<=\))(?=\d)|(?<=[^\/\*\+\-])(?=exp)"' RegexOptions.IgnoreCase );  				Expression = regEx.Replace( Expression' "*" );  				//  				// ----------  				// - Step 3 -  				// ----------  				// Replace constants: Pi -> 3'14...  				//  				//                                                                        ____  				// -(5-10)^(-1)*(3+2*(cos(3*Pi)+(2+ln(e))^3)) -> -(5-10)^(-1)*(3+2*(cos(3*3'14)+(2+ln(exp(1)))^3))  				//                          --  				//  				regEx = new Regex( "pi"' RegexOptions.IgnoreCase );  				Expression = regEx.Replace( Expression' Math.PI.ToString() );  				//  				// ----------  				// - Step 4 -  				// ----------  				// Search for parentheses an solve the expression between it.  				//  				//                                                       _____  				// -(5-10)^(-1)*(3+2*(cos(3*3'14)+(2+ln(exp(1)))^3)) -> -{-5}^(-1)*(3+2*(cos(3*3'14)+(2+ln(exp(1)))^3))  				//  |_____|  				//                                                          __  				// -{-5}^(-1)*(3+2*(cos(3*3'14)+(2+ln(exp(1)))^3)) -> -{-5}^-1*(3+2*(cos(3*3'14)+(2+ln(exp(1)))^3))  				//       |__|  				//                                                                    ____  				// -{-5}^-1*(3+2*(cos(3*3'14)+(2+ln(exp(1)))^3)) -> -{-5}^-1*(3+2*(cos9'42+(2+ln(exp(1)))^3))  				//                   |______|  				//                                                                              _  				// -{-5}^-1*(3+2*(cos9'72+(2+ln(exp(1)))^3)) -> -{-5}^-1*(3+2*(cos9'72+(2+ln(exp1))^3))  				//                                 |_|  				//                                                                        ____  				// -{-5}^-1*(3+2*(cos9'72+(2+ln(exp1))^3)) -> -{-5}^-1*(3+2*(cos9'72+(2+ln2'71)^3))  				//                             |____|  				//                                                                 ____  				// -{-5}^-1*(3+2*(cos9'72+(2+ln2'71)^3)) -> -{-5}^-1*(3+2*(cos9'72+{3}^3))  				//                        |_________|  				//                                                 __  				// -{-5}^-1*(3+2*(cos9'72+{3}^3)) -> -{-5}^-1*(3+2*26)  				//               |_____________|  				//                               __  				// -{-5}^-1*(3+2*26) -> -{-5}^-1*55  				//          |______|  				//  				regEx = new Regex( @"([a-z]*)\(([^\(\)]+)\)(\^|!?)"' RegexOptions.IgnoreCase );  				Match m = regEx.Match( Expression );  				while( m.Success )  				{  					if( m.Groups[3].Value.Length > 0 ) Expression = Expression.Replace( m.Value' "{" + m.Groups[1].Value + this.Solve( m.Groups[2].Value ) + "}" + m.Groups[3].Value );  					else Expression = Expression.Replace( m.Value' m.Groups[1].Value + this.Solve( m.Groups[2].Value ) );  					m = regEx.Match( Expression );  				}  				//  				// ----------  				// - Step 5 -  				// ----------  				// There are no more parentheses. Solve the expression and convert it to double.  				//                __  				// -{-5}^-1*55 => 11  				// |_________|  				//  				this.Value = Convert.ToDouble( this.Solve( Expression ) );  				return true;  			}  			catch  			{  				// Shit!  				return false;  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success && this.FunctionList.IndexOf(m.Groups[1].Value.ToLower() ) > -1  )  			{  				switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success && this.FunctionList.IndexOf(m.Groups[1].Value.ToLower() ) > -1  )  			{  				switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success && this.FunctionList.IndexOf(m.Groups[1].Value.ToLower() ) > -1  )  			{  				switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success && this.FunctionList.IndexOf(m.Groups[1].Value.ToLower() ) > -1  )  			{  				switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success && this.FunctionList.IndexOf(m.Groups[1].Value.ToLower() ) > -1  )  			{  				switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success && this.FunctionList.IndexOf(m.Groups[1].Value.ToLower() ) > -1  )  			{  				switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success && this.FunctionList.IndexOf(m.Groups[1].Value.ToLower() ) > -1  )  			{  				switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success && this.FunctionList.IndexOf(m.Groups[1].Value.ToLower() ) > -1  )  			{  				switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success && this.FunctionList.IndexOf(m.Groups[1].Value.ToLower() ) > -1  )  			{  				switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success && this.FunctionList.IndexOf(m.Groups[1].Value.ToLower() ) > -1  )  			{  				switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success && this.FunctionList.IndexOf(m.Groups[1].Value.ToLower() ) > -1  )  			{  				switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success && this.FunctionList.IndexOf(m.Groups[1].Value.ToLower() ) > -1  )  			{  				switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success && this.FunctionList.IndexOf(m.Groups[1].Value.ToLower() ) > -1  )  			{  				switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success && this.FunctionList.IndexOf(m.Groups[1].Value.ToLower() ) > -1  )  			{  				switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success && this.FunctionList.IndexOf(m.Groups[1].Value.ToLower() ) > -1  )  			{  				switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success && this.FunctionList.IndexOf(m.Groups[1].Value.ToLower() ) > -1  )  			{  				switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success && this.FunctionList.IndexOf(m.Groups[1].Value.ToLower() ) > -1  )  			{  				switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success )  			{  				Expression = Expression.Replace( m.Value' Math.Pow( Convert.ToDouble( m.Groups[1].Value )' Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  				m = regEx.Match( Expression );  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success )  			{  				Expression = regEx.Replace( Expression' Math.Pow( Convert.ToDouble( m.Groups[1].Value )' Convert.ToDouble( m.Groups[2].Value ) ).ToString()' 1 );  				m = regEx.Match( Expression );  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success )  			{  				double result;  				switch( m.Groups[2].Value )  				{  					case "*" :  						result = Convert.ToDouble( m.Groups[1].Value ) * Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = Expression.Replace( m.Value' "+" + result );  						m = regEx.Match( Expression );  						continue;  					case "/" :  						result = Convert.ToDouble( m.Groups[1].Value ) / Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = regEx.Replace( Expression' "+" + result' 1 );  						m = regEx.Match( Expression );  						continue;  				}  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success )  			{  				double result;  				switch( m.Groups[2].Value )  				{  					case "*" :  						result = Convert.ToDouble( m.Groups[1].Value ) * Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = Expression.Replace( m.Value' "+" + result );  						m = regEx.Match( Expression );  						continue;  					case "/" :  						result = Convert.ToDouble( m.Groups[1].Value ) / Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = regEx.Replace( Expression' "+" + result' 1 );  						m = regEx.Match( Expression );  						continue;  				}  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success )  			{  				double result;  				switch( m.Groups[2].Value )  				{  					case "*" :  						result = Convert.ToDouble( m.Groups[1].Value ) * Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = Expression.Replace( m.Value' "+" + result );  						m = regEx.Match( Expression );  						continue;  					case "/" :  						result = Convert.ToDouble( m.Groups[1].Value ) / Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = regEx.Replace( Expression' "+" + result' 1 );  						m = regEx.Match( Expression );  						continue;  				}  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success )  			{  				double result;  				switch( m.Groups[2].Value )  				{  					case "+" :  						result = Convert.ToDouble( m.Groups[1].Value ) + Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = regEx.Replace( Expression' "+" + result' 1 );  						m = regEx.Match( Expression );  						continue;  					case "-" :  						result = Convert.ToDouble( m.Groups[1].Value ) - Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = regEx.Replace( Expression' "+" + result' 1 );  						m = regEx.Match( Expression );  						continue;  				}  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success )  			{  				double result;  				switch( m.Groups[2].Value )  				{  					case "+" :  						result = Convert.ToDouble( m.Groups[1].Value ) + Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = regEx.Replace( Expression' "+" + result' 1 );  						m = regEx.Match( Expression );  						continue;  					case "-" :  						result = Convert.ToDouble( m.Groups[1].Value ) - Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = regEx.Replace( Expression' "+" + result' 1 );  						m = regEx.Match( Expression );  						continue;  				}  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: while( m.Success )  			{  				double result;  				switch( m.Groups[2].Value )  				{  					case "+" :  						result = Convert.ToDouble( m.Groups[1].Value ) + Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = regEx.Replace( Expression' "+" + result' 1 );  						m = regEx.Match( Expression );  						continue;  					case "-" :  						result = Convert.ToDouble( m.Groups[1].Value ) - Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = regEx.Replace( Expression' "+" + result' 1 );  						m = regEx.Match( Expression );  						continue;  				}  			}
Magic Number,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: if( Expression.StartsWith( "--" ) ) Expression = Expression.Substring(2);
Magic Number,MathParserNet,TokenParser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Lexer.cs,TokenParser,The following statement contains a magic number: _customFunctionIndex = 100;
Magic Number,MathParserNet,TokenParser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Lexer.cs,RegisterCustomFunction,The following statement contains a magic number: _tokens.Insert(4' (Tokens)_customFunctionIndex' sb.ToString());
Magic Number,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: while (token != null)              {                  if (token.TokenName == TokenParser.Tokens.Sqrt)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv = EvaluateExpression(new NumberClass                                                                            {                                                                                Expression = expression'                                                                                NumberType = NumberClass.NumberTypes.Expression                                                                            });                          token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sqrt(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sqrt(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Sin)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sin(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sin(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Log)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue' 10).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue' 10).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.LogN)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Tan)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Tan(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Tan(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Abs)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Abs(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Abs(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Cos)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Cos(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Cos(rv.DoubleValue).ToString();                              break;                      }                  }                  if ((int)token.TokenName >= 100)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;  					  					foreach(var _f in _customFunctions)  					{  						if(_f.Key.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _customFunctions)                          {                              if (ff.Key.Equals(fn))                              {                                  var p = new Parser();                                  foreach (var cfr in _customFunctions)                                      p.AddCustomFunction(cfr.Key' cfr.Value);                                  foreach (var vr in _variables)                                      p.AddVariable(vr.Key' vr.Value);                                  foreach (var vf in _functions)                                      p.AddFunction(vf.Name' vf.Arguments' vf.Expression);                                    var ex = new SimplificationReturnValue[expressions.Length];   								  								for(var i = 0; i < expressions.Length; i++)  								{  									ex[i] = p.Simplify(expressions[i]);  								}                                    object funcRetval = null;                                    if (ff.Value.Method.ReturnType == typeof(int))                                  {                                      var intParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              intParams[ndx] = (int)pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              intParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(intParams);                                  }                                  if (ff.Value.Method.ReturnType == typeof(double))                                  {                                      var floatParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              floatParams[ndx] = pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              floatParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(floatParams);                                  }                                  if (ff.Value.Method.ReturnType==typeof(object))                                  {  									var ex2 = new SimplificationReturnValue[expressions.Length];  									  									for(var i = 0; i < ex2.Length; i++)  										ex2[i] = p.Simplify(expressions[i]);  									                                      funcRetval = ff.Value.DynamicInvoke(ex2);                                  }                                    //object funcRetval = ff.Value.DynamicInvoke(expressions.Select(p.Simplify).ToArray());                                    if (funcRetval is double)                                  {                                      token.TokenValue = ((double)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Float;                                  }                                  if (funcRetval is int)                                  {                                      token.TokenValue = ((int)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Integer;                                  }                                  if (funcRetval is SimplificationReturnValue)                                  {                                      var srv = (SimplificationReturnValue)funcRetval;                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                      {                                          token.TokenValue = srv.IntValue.ToString();                                          token.TokenName = TokenParser.Tokens.Integer;                                      }                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                      {                                          token.TokenValue = srv.DoubleValue.ToString();                                          token.TokenName = TokenParser.Tokens.Float;                                      }                                  }                                  break;                              }                          }                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Function)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1).Remove(0' 4);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;                      FunctionClass fun = null;  					  					foreach(var _f in _functions)  					{  						if(_f.Name.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _functions)                              if (ff.Name.Equals(fn))                                  fun = ff;                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                        var parser = new Parser();                      foreach (var cfh in _customFunctions)                          parser.AddCustomFunction(cfh.Key' cfh.Value);                        foreach (var v in _variables)                      {                          if (v.Value.NumberType == NumberClass.NumberTypes.Float)                          {                              parser.AddVariable(v.Key' v.Value.FloatNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Integer)                          {                              parser.AddVariable(v.Key' v.Value.IntNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Expression)                          {                              parser.AddVariable(v.Key' v.Value.Expression);                          }                      }                        foreach (var f in _functions)                      {                          parser.AddFunction(f.Name' f.Arguments' f.Expression);                      }                      var expressionList = new List<NumberClass>();                        foreach (var expression in expressions)                      {                          SimplificationReturnValue simRetval = parser.Simplify(expression);                            var numClass = new NumberClass();                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              numClass.FloatNumber = simRetval.DoubleValue;                              numClass.NumberType = NumberClass.NumberTypes.Float;                          }                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              numClass.IntNumber = simRetval.IntValue;                              numClass.NumberType = NumberClass.NumberTypes.Integer;                          }                          expressionList.Add(numClass);                      }                        if (fun != null)                      {                          var numClass = new NumberClass { NumberType = NumberClass.NumberTypes.Expression' Expression = fun.Expression };                            SimplificationReturnValue sretval = parser.EvaluateFunction(numClass' fun' expressionList);                            if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = sretval.IntValue.ToString();                          }                          if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = sretval.DoubleValue.ToString();                          }                      }                  }                    if (token.TokenName == TokenParser.Tokens.Variable)                  {                      if (_variables.ContainsKey(token.TokenValue))                      {                          var z = _variables[token.TokenValue];                            if (z.NumberType == NumberClass.NumberTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = z.FloatNumber.ToString();                          }                          else if (z.NumberType == NumberClass.NumberTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = z.IntNumber.ToString();                          }                      }                      else                      {                          throw new NoSuchVariableException(StringResources.Undefined_Variable + ": " + token.TokenValue);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Whitespace || token.TokenName == TokenParser.Tokens.Newline)                  {                      token = tp.GetToken();                      continue;                  }                  if (token.TokenName == TokenParser.Tokens.Integer || token.TokenName == TokenParser.Tokens.Float)                  {                      var nc = new NumberClass();                        switch (token.TokenName)                      {                          case TokenParser.Tokens.Float:                              nc.NumberType = NumberClass.NumberTypes.Float;                              nc.FloatNumber = double.Parse(token.TokenValue);                              break;                          case TokenParser.Tokens.Integer:                              nc.NumberType = NumberClass.NumberTypes.Integer;                              nc.IntNumber = int.Parse(token.TokenValue);                              break;                      }                      _outputQueue.Enqueue(nc);                  }                  if (IsOperator(token.TokenName))                  {                      if (_operatorStack.Count > 0)                      {                          while (_operatorStack.Count > 0)                          {                              var op = _operatorStack.Peek(); //o2                                    if (op == "(" || op == ")")                                  break;                              if ((GetPrecedence(token.TokenName) <= GetPrecedence(op) &&                                   IsLeftAssociative(token.TokenValue)) ||                                  !IsLeftAssociative(token.TokenValue) &&                                  GetPrecedence(token.TokenName) < GetPrecedence(op))                              {                                  op = _operatorStack.Pop();                                  var nc = new NumberClass { NumberType = NumberClass.NumberTypes.Operator' Operator = op };                                    _outputQueue.Enqueue(nc);                              }                              else break;                          }                      }                      _operatorStack.Push(token.TokenValue);                  }                  if (token.TokenName == TokenParser.Tokens.Lparen)                      _operatorStack.Push(token.TokenValue);                  if (token.TokenName == TokenParser.Tokens.Rparen)                  {                      if (_operatorStack.Count > 0)                      {                          var op = _operatorStack.Pop();                            while (op != "(")                          {                              var nc = new NumberClass { Operator = op' NumberType = NumberClass.NumberTypes.Operator };                                _outputQueue.Enqueue(nc);                                if (_operatorStack.Count > 0)                                  op = _operatorStack.Pop();                              else                              {                                  throw new MismatchedParenthesisException();                              }                          }                      }                      else                      {                          throw new MismatchedParenthesisException();                      }                  }                  token = tp.GetToken();              }
Magic Number,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: while (token != null)              {                  if (token.TokenName == TokenParser.Tokens.Sqrt)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv = EvaluateExpression(new NumberClass                                                                            {                                                                                Expression = expression'                                                                                NumberType = NumberClass.NumberTypes.Expression                                                                            });                          token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sqrt(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sqrt(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Sin)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sin(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sin(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Log)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue' 10).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue' 10).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.LogN)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Tan)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Tan(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Tan(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Abs)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Abs(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Abs(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Cos)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Cos(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Cos(rv.DoubleValue).ToString();                              break;                      }                  }                  if ((int)token.TokenName >= 100)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;  					  					foreach(var _f in _customFunctions)  					{  						if(_f.Key.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _customFunctions)                          {                              if (ff.Key.Equals(fn))                              {                                  var p = new Parser();                                  foreach (var cfr in _customFunctions)                                      p.AddCustomFunction(cfr.Key' cfr.Value);                                  foreach (var vr in _variables)                                      p.AddVariable(vr.Key' vr.Value);                                  foreach (var vf in _functions)                                      p.AddFunction(vf.Name' vf.Arguments' vf.Expression);                                    var ex = new SimplificationReturnValue[expressions.Length];   								  								for(var i = 0; i < expressions.Length; i++)  								{  									ex[i] = p.Simplify(expressions[i]);  								}                                    object funcRetval = null;                                    if (ff.Value.Method.ReturnType == typeof(int))                                  {                                      var intParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              intParams[ndx] = (int)pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              intParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(intParams);                                  }                                  if (ff.Value.Method.ReturnType == typeof(double))                                  {                                      var floatParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              floatParams[ndx] = pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              floatParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(floatParams);                                  }                                  if (ff.Value.Method.ReturnType==typeof(object))                                  {  									var ex2 = new SimplificationReturnValue[expressions.Length];  									  									for(var i = 0; i < ex2.Length; i++)  										ex2[i] = p.Simplify(expressions[i]);  									                                      funcRetval = ff.Value.DynamicInvoke(ex2);                                  }                                    //object funcRetval = ff.Value.DynamicInvoke(expressions.Select(p.Simplify).ToArray());                                    if (funcRetval is double)                                  {                                      token.TokenValue = ((double)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Float;                                  }                                  if (funcRetval is int)                                  {                                      token.TokenValue = ((int)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Integer;                                  }                                  if (funcRetval is SimplificationReturnValue)                                  {                                      var srv = (SimplificationReturnValue)funcRetval;                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                      {                                          token.TokenValue = srv.IntValue.ToString();                                          token.TokenName = TokenParser.Tokens.Integer;                                      }                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                      {                                          token.TokenValue = srv.DoubleValue.ToString();                                          token.TokenName = TokenParser.Tokens.Float;                                      }                                  }                                  break;                              }                          }                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Function)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1).Remove(0' 4);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;                      FunctionClass fun = null;  					  					foreach(var _f in _functions)  					{  						if(_f.Name.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _functions)                              if (ff.Name.Equals(fn))                                  fun = ff;                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                        var parser = new Parser();                      foreach (var cfh in _customFunctions)                          parser.AddCustomFunction(cfh.Key' cfh.Value);                        foreach (var v in _variables)                      {                          if (v.Value.NumberType == NumberClass.NumberTypes.Float)                          {                              parser.AddVariable(v.Key' v.Value.FloatNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Integer)                          {                              parser.AddVariable(v.Key' v.Value.IntNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Expression)                          {                              parser.AddVariable(v.Key' v.Value.Expression);                          }                      }                        foreach (var f in _functions)                      {                          parser.AddFunction(f.Name' f.Arguments' f.Expression);                      }                      var expressionList = new List<NumberClass>();                        foreach (var expression in expressions)                      {                          SimplificationReturnValue simRetval = parser.Simplify(expression);                            var numClass = new NumberClass();                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              numClass.FloatNumber = simRetval.DoubleValue;                              numClass.NumberType = NumberClass.NumberTypes.Float;                          }                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              numClass.IntNumber = simRetval.IntValue;                              numClass.NumberType = NumberClass.NumberTypes.Integer;                          }                          expressionList.Add(numClass);                      }                        if (fun != null)                      {                          var numClass = new NumberClass { NumberType = NumberClass.NumberTypes.Expression' Expression = fun.Expression };                            SimplificationReturnValue sretval = parser.EvaluateFunction(numClass' fun' expressionList);                            if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = sretval.IntValue.ToString();                          }                          if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = sretval.DoubleValue.ToString();                          }                      }                  }                    if (token.TokenName == TokenParser.Tokens.Variable)                  {                      if (_variables.ContainsKey(token.TokenValue))                      {                          var z = _variables[token.TokenValue];                            if (z.NumberType == NumberClass.NumberTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = z.FloatNumber.ToString();                          }                          else if (z.NumberType == NumberClass.NumberTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = z.IntNumber.ToString();                          }                      }                      else                      {                          throw new NoSuchVariableException(StringResources.Undefined_Variable + ": " + token.TokenValue);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Whitespace || token.TokenName == TokenParser.Tokens.Newline)                  {                      token = tp.GetToken();                      continue;                  }                  if (token.TokenName == TokenParser.Tokens.Integer || token.TokenName == TokenParser.Tokens.Float)                  {                      var nc = new NumberClass();                        switch (token.TokenName)                      {                          case TokenParser.Tokens.Float:                              nc.NumberType = NumberClass.NumberTypes.Float;                              nc.FloatNumber = double.Parse(token.TokenValue);                              break;                          case TokenParser.Tokens.Integer:                              nc.NumberType = NumberClass.NumberTypes.Integer;                              nc.IntNumber = int.Parse(token.TokenValue);                              break;                      }                      _outputQueue.Enqueue(nc);                  }                  if (IsOperator(token.TokenName))                  {                      if (_operatorStack.Count > 0)                      {                          while (_operatorStack.Count > 0)                          {                              var op = _operatorStack.Peek(); //o2                                    if (op == "(" || op == ")")                                  break;                              if ((GetPrecedence(token.TokenName) <= GetPrecedence(op) &&                                   IsLeftAssociative(token.TokenValue)) ||                                  !IsLeftAssociative(token.TokenValue) &&                                  GetPrecedence(token.TokenName) < GetPrecedence(op))                              {                                  op = _operatorStack.Pop();                                  var nc = new NumberClass { NumberType = NumberClass.NumberTypes.Operator' Operator = op };                                    _outputQueue.Enqueue(nc);                              }                              else break;                          }                      }                      _operatorStack.Push(token.TokenValue);                  }                  if (token.TokenName == TokenParser.Tokens.Lparen)                      _operatorStack.Push(token.TokenValue);                  if (token.TokenName == TokenParser.Tokens.Rparen)                  {                      if (_operatorStack.Count > 0)                      {                          var op = _operatorStack.Pop();                            while (op != "(")                          {                              var nc = new NumberClass { Operator = op' NumberType = NumberClass.NumberTypes.Operator };                                _outputQueue.Enqueue(nc);                                if (_operatorStack.Count > 0)                                  op = _operatorStack.Pop();                              else                              {                                  throw new MismatchedParenthesisException();                              }                          }                      }                      else                      {                          throw new MismatchedParenthesisException();                      }                  }                  token = tp.GetToken();              }
Magic Number,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: while (token != null)              {                  if (token.TokenName == TokenParser.Tokens.Sqrt)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv = EvaluateExpression(new NumberClass                                                                            {                                                                                Expression = expression'                                                                                NumberType = NumberClass.NumberTypes.Expression                                                                            });                          token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sqrt(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sqrt(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Sin)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sin(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sin(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Log)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue' 10).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue' 10).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.LogN)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Tan)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Tan(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Tan(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Abs)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Abs(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Abs(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Cos)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Cos(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Cos(rv.DoubleValue).ToString();                              break;                      }                  }                  if ((int)token.TokenName >= 100)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;  					  					foreach(var _f in _customFunctions)  					{  						if(_f.Key.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _customFunctions)                          {                              if (ff.Key.Equals(fn))                              {                                  var p = new Parser();                                  foreach (var cfr in _customFunctions)                                      p.AddCustomFunction(cfr.Key' cfr.Value);                                  foreach (var vr in _variables)                                      p.AddVariable(vr.Key' vr.Value);                                  foreach (var vf in _functions)                                      p.AddFunction(vf.Name' vf.Arguments' vf.Expression);                                    var ex = new SimplificationReturnValue[expressions.Length];   								  								for(var i = 0; i < expressions.Length; i++)  								{  									ex[i] = p.Simplify(expressions[i]);  								}                                    object funcRetval = null;                                    if (ff.Value.Method.ReturnType == typeof(int))                                  {                                      var intParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              intParams[ndx] = (int)pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              intParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(intParams);                                  }                                  if (ff.Value.Method.ReturnType == typeof(double))                                  {                                      var floatParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              floatParams[ndx] = pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              floatParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(floatParams);                                  }                                  if (ff.Value.Method.ReturnType==typeof(object))                                  {  									var ex2 = new SimplificationReturnValue[expressions.Length];  									  									for(var i = 0; i < ex2.Length; i++)  										ex2[i] = p.Simplify(expressions[i]);  									                                      funcRetval = ff.Value.DynamicInvoke(ex2);                                  }                                    //object funcRetval = ff.Value.DynamicInvoke(expressions.Select(p.Simplify).ToArray());                                    if (funcRetval is double)                                  {                                      token.TokenValue = ((double)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Float;                                  }                                  if (funcRetval is int)                                  {                                      token.TokenValue = ((int)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Integer;                                  }                                  if (funcRetval is SimplificationReturnValue)                                  {                                      var srv = (SimplificationReturnValue)funcRetval;                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                      {                                          token.TokenValue = srv.IntValue.ToString();                                          token.TokenName = TokenParser.Tokens.Integer;                                      }                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                      {                                          token.TokenValue = srv.DoubleValue.ToString();                                          token.TokenName = TokenParser.Tokens.Float;                                      }                                  }                                  break;                              }                          }                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Function)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1).Remove(0' 4);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;                      FunctionClass fun = null;  					  					foreach(var _f in _functions)  					{  						if(_f.Name.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _functions)                              if (ff.Name.Equals(fn))                                  fun = ff;                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                        var parser = new Parser();                      foreach (var cfh in _customFunctions)                          parser.AddCustomFunction(cfh.Key' cfh.Value);                        foreach (var v in _variables)                      {                          if (v.Value.NumberType == NumberClass.NumberTypes.Float)                          {                              parser.AddVariable(v.Key' v.Value.FloatNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Integer)                          {                              parser.AddVariable(v.Key' v.Value.IntNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Expression)                          {                              parser.AddVariable(v.Key' v.Value.Expression);                          }                      }                        foreach (var f in _functions)                      {                          parser.AddFunction(f.Name' f.Arguments' f.Expression);                      }                      var expressionList = new List<NumberClass>();                        foreach (var expression in expressions)                      {                          SimplificationReturnValue simRetval = parser.Simplify(expression);                            var numClass = new NumberClass();                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              numClass.FloatNumber = simRetval.DoubleValue;                              numClass.NumberType = NumberClass.NumberTypes.Float;                          }                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              numClass.IntNumber = simRetval.IntValue;                              numClass.NumberType = NumberClass.NumberTypes.Integer;                          }                          expressionList.Add(numClass);                      }                        if (fun != null)                      {                          var numClass = new NumberClass { NumberType = NumberClass.NumberTypes.Expression' Expression = fun.Expression };                            SimplificationReturnValue sretval = parser.EvaluateFunction(numClass' fun' expressionList);                            if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = sretval.IntValue.ToString();                          }                          if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = sretval.DoubleValue.ToString();                          }                      }                  }                    if (token.TokenName == TokenParser.Tokens.Variable)                  {                      if (_variables.ContainsKey(token.TokenValue))                      {                          var z = _variables[token.TokenValue];                            if (z.NumberType == NumberClass.NumberTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = z.FloatNumber.ToString();                          }                          else if (z.NumberType == NumberClass.NumberTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = z.IntNumber.ToString();                          }                      }                      else                      {                          throw new NoSuchVariableException(StringResources.Undefined_Variable + ": " + token.TokenValue);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Whitespace || token.TokenName == TokenParser.Tokens.Newline)                  {                      token = tp.GetToken();                      continue;                  }                  if (token.TokenName == TokenParser.Tokens.Integer || token.TokenName == TokenParser.Tokens.Float)                  {                      var nc = new NumberClass();                        switch (token.TokenName)                      {                          case TokenParser.Tokens.Float:                              nc.NumberType = NumberClass.NumberTypes.Float;                              nc.FloatNumber = double.Parse(token.TokenValue);                              break;                          case TokenParser.Tokens.Integer:                              nc.NumberType = NumberClass.NumberTypes.Integer;                              nc.IntNumber = int.Parse(token.TokenValue);                              break;                      }                      _outputQueue.Enqueue(nc);                  }                  if (IsOperator(token.TokenName))                  {                      if (_operatorStack.Count > 0)                      {                          while (_operatorStack.Count > 0)                          {                              var op = _operatorStack.Peek(); //o2                                    if (op == "(" || op == ")")                                  break;                              if ((GetPrecedence(token.TokenName) <= GetPrecedence(op) &&                                   IsLeftAssociative(token.TokenValue)) ||                                  !IsLeftAssociative(token.TokenValue) &&                                  GetPrecedence(token.TokenName) < GetPrecedence(op))                              {                                  op = _operatorStack.Pop();                                  var nc = new NumberClass { NumberType = NumberClass.NumberTypes.Operator' Operator = op };                                    _outputQueue.Enqueue(nc);                              }                              else break;                          }                      }                      _operatorStack.Push(token.TokenValue);                  }                  if (token.TokenName == TokenParser.Tokens.Lparen)                      _operatorStack.Push(token.TokenValue);                  if (token.TokenName == TokenParser.Tokens.Rparen)                  {                      if (_operatorStack.Count > 0)                      {                          var op = _operatorStack.Pop();                            while (op != "(")                          {                              var nc = new NumberClass { Operator = op' NumberType = NumberClass.NumberTypes.Operator };                                _outputQueue.Enqueue(nc);                                if (_operatorStack.Count > 0)                                  op = _operatorStack.Pop();                              else                              {                                  throw new MismatchedParenthesisException();                              }                          }                      }                      else                      {                          throw new MismatchedParenthesisException();                      }                  }                  token = tp.GetToken();              }
Magic Number,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: while (token != null)              {                  if (token.TokenName == TokenParser.Tokens.Sqrt)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv = EvaluateExpression(new NumberClass                                                                            {                                                                                Expression = expression'                                                                                NumberType = NumberClass.NumberTypes.Expression                                                                            });                          token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sqrt(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sqrt(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Sin)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sin(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sin(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Log)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue' 10).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue' 10).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.LogN)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Tan)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Tan(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Tan(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Abs)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Abs(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Abs(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Cos)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Cos(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Cos(rv.DoubleValue).ToString();                              break;                      }                  }                  if ((int)token.TokenName >= 100)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;  					  					foreach(var _f in _customFunctions)  					{  						if(_f.Key.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _customFunctions)                          {                              if (ff.Key.Equals(fn))                              {                                  var p = new Parser();                                  foreach (var cfr in _customFunctions)                                      p.AddCustomFunction(cfr.Key' cfr.Value);                                  foreach (var vr in _variables)                                      p.AddVariable(vr.Key' vr.Value);                                  foreach (var vf in _functions)                                      p.AddFunction(vf.Name' vf.Arguments' vf.Expression);                                    var ex = new SimplificationReturnValue[expressions.Length];   								  								for(var i = 0; i < expressions.Length; i++)  								{  									ex[i] = p.Simplify(expressions[i]);  								}                                    object funcRetval = null;                                    if (ff.Value.Method.ReturnType == typeof(int))                                  {                                      var intParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              intParams[ndx] = (int)pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              intParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(intParams);                                  }                                  if (ff.Value.Method.ReturnType == typeof(double))                                  {                                      var floatParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              floatParams[ndx] = pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              floatParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(floatParams);                                  }                                  if (ff.Value.Method.ReturnType==typeof(object))                                  {  									var ex2 = new SimplificationReturnValue[expressions.Length];  									  									for(var i = 0; i < ex2.Length; i++)  										ex2[i] = p.Simplify(expressions[i]);  									                                      funcRetval = ff.Value.DynamicInvoke(ex2);                                  }                                    //object funcRetval = ff.Value.DynamicInvoke(expressions.Select(p.Simplify).ToArray());                                    if (funcRetval is double)                                  {                                      token.TokenValue = ((double)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Float;                                  }                                  if (funcRetval is int)                                  {                                      token.TokenValue = ((int)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Integer;                                  }                                  if (funcRetval is SimplificationReturnValue)                                  {                                      var srv = (SimplificationReturnValue)funcRetval;                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                      {                                          token.TokenValue = srv.IntValue.ToString();                                          token.TokenName = TokenParser.Tokens.Integer;                                      }                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                      {                                          token.TokenValue = srv.DoubleValue.ToString();                                          token.TokenName = TokenParser.Tokens.Float;                                      }                                  }                                  break;                              }                          }                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Function)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1).Remove(0' 4);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;                      FunctionClass fun = null;  					  					foreach(var _f in _functions)  					{  						if(_f.Name.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _functions)                              if (ff.Name.Equals(fn))                                  fun = ff;                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                        var parser = new Parser();                      foreach (var cfh in _customFunctions)                          parser.AddCustomFunction(cfh.Key' cfh.Value);                        foreach (var v in _variables)                      {                          if (v.Value.NumberType == NumberClass.NumberTypes.Float)                          {                              parser.AddVariable(v.Key' v.Value.FloatNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Integer)                          {                              parser.AddVariable(v.Key' v.Value.IntNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Expression)                          {                              parser.AddVariable(v.Key' v.Value.Expression);                          }                      }                        foreach (var f in _functions)                      {                          parser.AddFunction(f.Name' f.Arguments' f.Expression);                      }                      var expressionList = new List<NumberClass>();                        foreach (var expression in expressions)                      {                          SimplificationReturnValue simRetval = parser.Simplify(expression);                            var numClass = new NumberClass();                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              numClass.FloatNumber = simRetval.DoubleValue;                              numClass.NumberType = NumberClass.NumberTypes.Float;                          }                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              numClass.IntNumber = simRetval.IntValue;                              numClass.NumberType = NumberClass.NumberTypes.Integer;                          }                          expressionList.Add(numClass);                      }                        if (fun != null)                      {                          var numClass = new NumberClass { NumberType = NumberClass.NumberTypes.Expression' Expression = fun.Expression };                            SimplificationReturnValue sretval = parser.EvaluateFunction(numClass' fun' expressionList);                            if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = sretval.IntValue.ToString();                          }                          if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = sretval.DoubleValue.ToString();                          }                      }                  }                    if (token.TokenName == TokenParser.Tokens.Variable)                  {                      if (_variables.ContainsKey(token.TokenValue))                      {                          var z = _variables[token.TokenValue];                            if (z.NumberType == NumberClass.NumberTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = z.FloatNumber.ToString();                          }                          else if (z.NumberType == NumberClass.NumberTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = z.IntNumber.ToString();                          }                      }                      else                      {                          throw new NoSuchVariableException(StringResources.Undefined_Variable + ": " + token.TokenValue);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Whitespace || token.TokenName == TokenParser.Tokens.Newline)                  {                      token = tp.GetToken();                      continue;                  }                  if (token.TokenName == TokenParser.Tokens.Integer || token.TokenName == TokenParser.Tokens.Float)                  {                      var nc = new NumberClass();                        switch (token.TokenName)                      {                          case TokenParser.Tokens.Float:                              nc.NumberType = NumberClass.NumberTypes.Float;                              nc.FloatNumber = double.Parse(token.TokenValue);                              break;                          case TokenParser.Tokens.Integer:                              nc.NumberType = NumberClass.NumberTypes.Integer;                              nc.IntNumber = int.Parse(token.TokenValue);                              break;                      }                      _outputQueue.Enqueue(nc);                  }                  if (IsOperator(token.TokenName))                  {                      if (_operatorStack.Count > 0)                      {                          while (_operatorStack.Count > 0)                          {                              var op = _operatorStack.Peek(); //o2                                    if (op == "(" || op == ")")                                  break;                              if ((GetPrecedence(token.TokenName) <= GetPrecedence(op) &&                                   IsLeftAssociative(token.TokenValue)) ||                                  !IsLeftAssociative(token.TokenValue) &&                                  GetPrecedence(token.TokenName) < GetPrecedence(op))                              {                                  op = _operatorStack.Pop();                                  var nc = new NumberClass { NumberType = NumberClass.NumberTypes.Operator' Operator = op };                                    _outputQueue.Enqueue(nc);                              }                              else break;                          }                      }                      _operatorStack.Push(token.TokenValue);                  }                  if (token.TokenName == TokenParser.Tokens.Lparen)                      _operatorStack.Push(token.TokenValue);                  if (token.TokenName == TokenParser.Tokens.Rparen)                  {                      if (_operatorStack.Count > 0)                      {                          var op = _operatorStack.Pop();                            while (op != "(")                          {                              var nc = new NumberClass { Operator = op' NumberType = NumberClass.NumberTypes.Operator };                                _outputQueue.Enqueue(nc);                                if (_operatorStack.Count > 0)                                  op = _operatorStack.Pop();                              else                              {                                  throw new MismatchedParenthesisException();                              }                          }                      }                      else                      {                          throw new MismatchedParenthesisException();                      }                  }                  token = tp.GetToken();              }
Magic Number,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: while (token != null)              {                  if (token.TokenName == TokenParser.Tokens.Sqrt)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv = EvaluateExpression(new NumberClass                                                                            {                                                                                Expression = expression'                                                                                NumberType = NumberClass.NumberTypes.Expression                                                                            });                          token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sqrt(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sqrt(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Sin)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sin(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sin(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Log)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue' 10).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue' 10).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.LogN)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Tan)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Tan(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Tan(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Abs)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Abs(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Abs(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Cos)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Cos(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Cos(rv.DoubleValue).ToString();                              break;                      }                  }                  if ((int)token.TokenName >= 100)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;  					  					foreach(var _f in _customFunctions)  					{  						if(_f.Key.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _customFunctions)                          {                              if (ff.Key.Equals(fn))                              {                                  var p = new Parser();                                  foreach (var cfr in _customFunctions)                                      p.AddCustomFunction(cfr.Key' cfr.Value);                                  foreach (var vr in _variables)                                      p.AddVariable(vr.Key' vr.Value);                                  foreach (var vf in _functions)                                      p.AddFunction(vf.Name' vf.Arguments' vf.Expression);                                    var ex = new SimplificationReturnValue[expressions.Length];   								  								for(var i = 0; i < expressions.Length; i++)  								{  									ex[i] = p.Simplify(expressions[i]);  								}                                    object funcRetval = null;                                    if (ff.Value.Method.ReturnType == typeof(int))                                  {                                      var intParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              intParams[ndx] = (int)pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              intParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(intParams);                                  }                                  if (ff.Value.Method.ReturnType == typeof(double))                                  {                                      var floatParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              floatParams[ndx] = pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              floatParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(floatParams);                                  }                                  if (ff.Value.Method.ReturnType==typeof(object))                                  {  									var ex2 = new SimplificationReturnValue[expressions.Length];  									  									for(var i = 0; i < ex2.Length; i++)  										ex2[i] = p.Simplify(expressions[i]);  									                                      funcRetval = ff.Value.DynamicInvoke(ex2);                                  }                                    //object funcRetval = ff.Value.DynamicInvoke(expressions.Select(p.Simplify).ToArray());                                    if (funcRetval is double)                                  {                                      token.TokenValue = ((double)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Float;                                  }                                  if (funcRetval is int)                                  {                                      token.TokenValue = ((int)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Integer;                                  }                                  if (funcRetval is SimplificationReturnValue)                                  {                                      var srv = (SimplificationReturnValue)funcRetval;                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                      {                                          token.TokenValue = srv.IntValue.ToString();                                          token.TokenName = TokenParser.Tokens.Integer;                                      }                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                      {                                          token.TokenValue = srv.DoubleValue.ToString();                                          token.TokenName = TokenParser.Tokens.Float;                                      }                                  }                                  break;                              }                          }                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Function)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1).Remove(0' 4);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;                      FunctionClass fun = null;  					  					foreach(var _f in _functions)  					{  						if(_f.Name.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _functions)                              if (ff.Name.Equals(fn))                                  fun = ff;                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                        var parser = new Parser();                      foreach (var cfh in _customFunctions)                          parser.AddCustomFunction(cfh.Key' cfh.Value);                        foreach (var v in _variables)                      {                          if (v.Value.NumberType == NumberClass.NumberTypes.Float)                          {                              parser.AddVariable(v.Key' v.Value.FloatNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Integer)                          {                              parser.AddVariable(v.Key' v.Value.IntNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Expression)                          {                              parser.AddVariable(v.Key' v.Value.Expression);                          }                      }                        foreach (var f in _functions)                      {                          parser.AddFunction(f.Name' f.Arguments' f.Expression);                      }                      var expressionList = new List<NumberClass>();                        foreach (var expression in expressions)                      {                          SimplificationReturnValue simRetval = parser.Simplify(expression);                            var numClass = new NumberClass();                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              numClass.FloatNumber = simRetval.DoubleValue;                              numClass.NumberType = NumberClass.NumberTypes.Float;                          }                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              numClass.IntNumber = simRetval.IntValue;                              numClass.NumberType = NumberClass.NumberTypes.Integer;                          }                          expressionList.Add(numClass);                      }                        if (fun != null)                      {                          var numClass = new NumberClass { NumberType = NumberClass.NumberTypes.Expression' Expression = fun.Expression };                            SimplificationReturnValue sretval = parser.EvaluateFunction(numClass' fun' expressionList);                            if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = sretval.IntValue.ToString();                          }                          if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = sretval.DoubleValue.ToString();                          }                      }                  }                    if (token.TokenName == TokenParser.Tokens.Variable)                  {                      if (_variables.ContainsKey(token.TokenValue))                      {                          var z = _variables[token.TokenValue];                            if (z.NumberType == NumberClass.NumberTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = z.FloatNumber.ToString();                          }                          else if (z.NumberType == NumberClass.NumberTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = z.IntNumber.ToString();                          }                      }                      else                      {                          throw new NoSuchVariableException(StringResources.Undefined_Variable + ": " + token.TokenValue);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Whitespace || token.TokenName == TokenParser.Tokens.Newline)                  {                      token = tp.GetToken();                      continue;                  }                  if (token.TokenName == TokenParser.Tokens.Integer || token.TokenName == TokenParser.Tokens.Float)                  {                      var nc = new NumberClass();                        switch (token.TokenName)                      {                          case TokenParser.Tokens.Float:                              nc.NumberType = NumberClass.NumberTypes.Float;                              nc.FloatNumber = double.Parse(token.TokenValue);                              break;                          case TokenParser.Tokens.Integer:                              nc.NumberType = NumberClass.NumberTypes.Integer;                              nc.IntNumber = int.Parse(token.TokenValue);                              break;                      }                      _outputQueue.Enqueue(nc);                  }                  if (IsOperator(token.TokenName))                  {                      if (_operatorStack.Count > 0)                      {                          while (_operatorStack.Count > 0)                          {                              var op = _operatorStack.Peek(); //o2                                    if (op == "(" || op == ")")                                  break;                              if ((GetPrecedence(token.TokenName) <= GetPrecedence(op) &&                                   IsLeftAssociative(token.TokenValue)) ||                                  !IsLeftAssociative(token.TokenValue) &&                                  GetPrecedence(token.TokenName) < GetPrecedence(op))                              {                                  op = _operatorStack.Pop();                                  var nc = new NumberClass { NumberType = NumberClass.NumberTypes.Operator' Operator = op };                                    _outputQueue.Enqueue(nc);                              }                              else break;                          }                      }                      _operatorStack.Push(token.TokenValue);                  }                  if (token.TokenName == TokenParser.Tokens.Lparen)                      _operatorStack.Push(token.TokenValue);                  if (token.TokenName == TokenParser.Tokens.Rparen)                  {                      if (_operatorStack.Count > 0)                      {                          var op = _operatorStack.Pop();                            while (op != "(")                          {                              var nc = new NumberClass { Operator = op' NumberType = NumberClass.NumberTypes.Operator };                                _outputQueue.Enqueue(nc);                                if (_operatorStack.Count > 0)                                  op = _operatorStack.Pop();                              else                              {                                  throw new MismatchedParenthesisException();                              }                          }                      }                      else                      {                          throw new MismatchedParenthesisException();                      }                  }                  token = tp.GetToken();              }
Magic Number,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: while (token != null)              {                  if (token.TokenName == TokenParser.Tokens.Sqrt)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv = EvaluateExpression(new NumberClass                                                                            {                                                                                Expression = expression'                                                                                NumberType = NumberClass.NumberTypes.Expression                                                                            });                          token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sqrt(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sqrt(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Sin)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sin(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sin(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Log)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue' 10).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue' 10).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.LogN)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Tan)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Tan(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Tan(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Abs)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Abs(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Abs(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Cos)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Cos(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Cos(rv.DoubleValue).ToString();                              break;                      }                  }                  if ((int)token.TokenName >= 100)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;  					  					foreach(var _f in _customFunctions)  					{  						if(_f.Key.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _customFunctions)                          {                              if (ff.Key.Equals(fn))                              {                                  var p = new Parser();                                  foreach (var cfr in _customFunctions)                                      p.AddCustomFunction(cfr.Key' cfr.Value);                                  foreach (var vr in _variables)                                      p.AddVariable(vr.Key' vr.Value);                                  foreach (var vf in _functions)                                      p.AddFunction(vf.Name' vf.Arguments' vf.Expression);                                    var ex = new SimplificationReturnValue[expressions.Length];   								  								for(var i = 0; i < expressions.Length; i++)  								{  									ex[i] = p.Simplify(expressions[i]);  								}                                    object funcRetval = null;                                    if (ff.Value.Method.ReturnType == typeof(int))                                  {                                      var intParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              intParams[ndx] = (int)pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              intParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(intParams);                                  }                                  if (ff.Value.Method.ReturnType == typeof(double))                                  {                                      var floatParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              floatParams[ndx] = pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              floatParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(floatParams);                                  }                                  if (ff.Value.Method.ReturnType==typeof(object))                                  {  									var ex2 = new SimplificationReturnValue[expressions.Length];  									  									for(var i = 0; i < ex2.Length; i++)  										ex2[i] = p.Simplify(expressions[i]);  									                                      funcRetval = ff.Value.DynamicInvoke(ex2);                                  }                                    //object funcRetval = ff.Value.DynamicInvoke(expressions.Select(p.Simplify).ToArray());                                    if (funcRetval is double)                                  {                                      token.TokenValue = ((double)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Float;                                  }                                  if (funcRetval is int)                                  {                                      token.TokenValue = ((int)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Integer;                                  }                                  if (funcRetval is SimplificationReturnValue)                                  {                                      var srv = (SimplificationReturnValue)funcRetval;                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                      {                                          token.TokenValue = srv.IntValue.ToString();                                          token.TokenName = TokenParser.Tokens.Integer;                                      }                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                      {                                          token.TokenValue = srv.DoubleValue.ToString();                                          token.TokenName = TokenParser.Tokens.Float;                                      }                                  }                                  break;                              }                          }                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Function)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1).Remove(0' 4);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;                      FunctionClass fun = null;  					  					foreach(var _f in _functions)  					{  						if(_f.Name.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _functions)                              if (ff.Name.Equals(fn))                                  fun = ff;                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                        var parser = new Parser();                      foreach (var cfh in _customFunctions)                          parser.AddCustomFunction(cfh.Key' cfh.Value);                        foreach (var v in _variables)                      {                          if (v.Value.NumberType == NumberClass.NumberTypes.Float)                          {                              parser.AddVariable(v.Key' v.Value.FloatNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Integer)                          {                              parser.AddVariable(v.Key' v.Value.IntNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Expression)                          {                              parser.AddVariable(v.Key' v.Value.Expression);                          }                      }                        foreach (var f in _functions)                      {                          parser.AddFunction(f.Name' f.Arguments' f.Expression);                      }                      var expressionList = new List<NumberClass>();                        foreach (var expression in expressions)                      {                          SimplificationReturnValue simRetval = parser.Simplify(expression);                            var numClass = new NumberClass();                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              numClass.FloatNumber = simRetval.DoubleValue;                              numClass.NumberType = NumberClass.NumberTypes.Float;                          }                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              numClass.IntNumber = simRetval.IntValue;                              numClass.NumberType = NumberClass.NumberTypes.Integer;                          }                          expressionList.Add(numClass);                      }                        if (fun != null)                      {                          var numClass = new NumberClass { NumberType = NumberClass.NumberTypes.Expression' Expression = fun.Expression };                            SimplificationReturnValue sretval = parser.EvaluateFunction(numClass' fun' expressionList);                            if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = sretval.IntValue.ToString();                          }                          if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = sretval.DoubleValue.ToString();                          }                      }                  }                    if (token.TokenName == TokenParser.Tokens.Variable)                  {                      if (_variables.ContainsKey(token.TokenValue))                      {                          var z = _variables[token.TokenValue];                            if (z.NumberType == NumberClass.NumberTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = z.FloatNumber.ToString();                          }                          else if (z.NumberType == NumberClass.NumberTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = z.IntNumber.ToString();                          }                      }                      else                      {                          throw new NoSuchVariableException(StringResources.Undefined_Variable + ": " + token.TokenValue);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Whitespace || token.TokenName == TokenParser.Tokens.Newline)                  {                      token = tp.GetToken();                      continue;                  }                  if (token.TokenName == TokenParser.Tokens.Integer || token.TokenName == TokenParser.Tokens.Float)                  {                      var nc = new NumberClass();                        switch (token.TokenName)                      {                          case TokenParser.Tokens.Float:                              nc.NumberType = NumberClass.NumberTypes.Float;                              nc.FloatNumber = double.Parse(token.TokenValue);                              break;                          case TokenParser.Tokens.Integer:                              nc.NumberType = NumberClass.NumberTypes.Integer;                              nc.IntNumber = int.Parse(token.TokenValue);                              break;                      }                      _outputQueue.Enqueue(nc);                  }                  if (IsOperator(token.TokenName))                  {                      if (_operatorStack.Count > 0)                      {                          while (_operatorStack.Count > 0)                          {                              var op = _operatorStack.Peek(); //o2                                    if (op == "(" || op == ")")                                  break;                              if ((GetPrecedence(token.TokenName) <= GetPrecedence(op) &&                                   IsLeftAssociative(token.TokenValue)) ||                                  !IsLeftAssociative(token.TokenValue) &&                                  GetPrecedence(token.TokenName) < GetPrecedence(op))                              {                                  op = _operatorStack.Pop();                                  var nc = new NumberClass { NumberType = NumberClass.NumberTypes.Operator' Operator = op };                                    _outputQueue.Enqueue(nc);                              }                              else break;                          }                      }                      _operatorStack.Push(token.TokenValue);                  }                  if (token.TokenName == TokenParser.Tokens.Lparen)                      _operatorStack.Push(token.TokenValue);                  if (token.TokenName == TokenParser.Tokens.Rparen)                  {                      if (_operatorStack.Count > 0)                      {                          var op = _operatorStack.Pop();                            while (op != "(")                          {                              var nc = new NumberClass { Operator = op' NumberType = NumberClass.NumberTypes.Operator };                                _outputQueue.Enqueue(nc);                                if (_operatorStack.Count > 0)                                  op = _operatorStack.Pop();                              else                              {                                  throw new MismatchedParenthesisException();                              }                          }                      }                      else                      {                          throw new MismatchedParenthesisException();                      }                  }                  token = tp.GetToken();              }
Magic Number,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: while (token != null)              {                  if (token.TokenName == TokenParser.Tokens.Sqrt)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv = EvaluateExpression(new NumberClass                                                                            {                                                                                Expression = expression'                                                                                NumberType = NumberClass.NumberTypes.Expression                                                                            });                          token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sqrt(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sqrt(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Sin)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sin(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sin(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Log)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue' 10).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue' 10).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.LogN)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Tan)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Tan(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Tan(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Abs)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Abs(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Abs(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Cos)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Cos(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Cos(rv.DoubleValue).ToString();                              break;                      }                  }                  if ((int)token.TokenName >= 100)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;  					  					foreach(var _f in _customFunctions)  					{  						if(_f.Key.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _customFunctions)                          {                              if (ff.Key.Equals(fn))                              {                                  var p = new Parser();                                  foreach (var cfr in _customFunctions)                                      p.AddCustomFunction(cfr.Key' cfr.Value);                                  foreach (var vr in _variables)                                      p.AddVariable(vr.Key' vr.Value);                                  foreach (var vf in _functions)                                      p.AddFunction(vf.Name' vf.Arguments' vf.Expression);                                    var ex = new SimplificationReturnValue[expressions.Length];   								  								for(var i = 0; i < expressions.Length; i++)  								{  									ex[i] = p.Simplify(expressions[i]);  								}                                    object funcRetval = null;                                    if (ff.Value.Method.ReturnType == typeof(int))                                  {                                      var intParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              intParams[ndx] = (int)pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              intParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(intParams);                                  }                                  if (ff.Value.Method.ReturnType == typeof(double))                                  {                                      var floatParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              floatParams[ndx] = pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              floatParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(floatParams);                                  }                                  if (ff.Value.Method.ReturnType==typeof(object))                                  {  									var ex2 = new SimplificationReturnValue[expressions.Length];  									  									for(var i = 0; i < ex2.Length; i++)  										ex2[i] = p.Simplify(expressions[i]);  									                                      funcRetval = ff.Value.DynamicInvoke(ex2);                                  }                                    //object funcRetval = ff.Value.DynamicInvoke(expressions.Select(p.Simplify).ToArray());                                    if (funcRetval is double)                                  {                                      token.TokenValue = ((double)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Float;                                  }                                  if (funcRetval is int)                                  {                                      token.TokenValue = ((int)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Integer;                                  }                                  if (funcRetval is SimplificationReturnValue)                                  {                                      var srv = (SimplificationReturnValue)funcRetval;                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                      {                                          token.TokenValue = srv.IntValue.ToString();                                          token.TokenName = TokenParser.Tokens.Integer;                                      }                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                      {                                          token.TokenValue = srv.DoubleValue.ToString();                                          token.TokenName = TokenParser.Tokens.Float;                                      }                                  }                                  break;                              }                          }                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Function)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1).Remove(0' 4);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;                      FunctionClass fun = null;  					  					foreach(var _f in _functions)  					{  						if(_f.Name.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _functions)                              if (ff.Name.Equals(fn))                                  fun = ff;                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                        var parser = new Parser();                      foreach (var cfh in _customFunctions)                          parser.AddCustomFunction(cfh.Key' cfh.Value);                        foreach (var v in _variables)                      {                          if (v.Value.NumberType == NumberClass.NumberTypes.Float)                          {                              parser.AddVariable(v.Key' v.Value.FloatNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Integer)                          {                              parser.AddVariable(v.Key' v.Value.IntNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Expression)                          {                              parser.AddVariable(v.Key' v.Value.Expression);                          }                      }                        foreach (var f in _functions)                      {                          parser.AddFunction(f.Name' f.Arguments' f.Expression);                      }                      var expressionList = new List<NumberClass>();                        foreach (var expression in expressions)                      {                          SimplificationReturnValue simRetval = parser.Simplify(expression);                            var numClass = new NumberClass();                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              numClass.FloatNumber = simRetval.DoubleValue;                              numClass.NumberType = NumberClass.NumberTypes.Float;                          }                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              numClass.IntNumber = simRetval.IntValue;                              numClass.NumberType = NumberClass.NumberTypes.Integer;                          }                          expressionList.Add(numClass);                      }                        if (fun != null)                      {                          var numClass = new NumberClass { NumberType = NumberClass.NumberTypes.Expression' Expression = fun.Expression };                            SimplificationReturnValue sretval = parser.EvaluateFunction(numClass' fun' expressionList);                            if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = sretval.IntValue.ToString();                          }                          if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = sretval.DoubleValue.ToString();                          }                      }                  }                    if (token.TokenName == TokenParser.Tokens.Variable)                  {                      if (_variables.ContainsKey(token.TokenValue))                      {                          var z = _variables[token.TokenValue];                            if (z.NumberType == NumberClass.NumberTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = z.FloatNumber.ToString();                          }                          else if (z.NumberType == NumberClass.NumberTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = z.IntNumber.ToString();                          }                      }                      else                      {                          throw new NoSuchVariableException(StringResources.Undefined_Variable + ": " + token.TokenValue);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Whitespace || token.TokenName == TokenParser.Tokens.Newline)                  {                      token = tp.GetToken();                      continue;                  }                  if (token.TokenName == TokenParser.Tokens.Integer || token.TokenName == TokenParser.Tokens.Float)                  {                      var nc = new NumberClass();                        switch (token.TokenName)                      {                          case TokenParser.Tokens.Float:                              nc.NumberType = NumberClass.NumberTypes.Float;                              nc.FloatNumber = double.Parse(token.TokenValue);                              break;                          case TokenParser.Tokens.Integer:                              nc.NumberType = NumberClass.NumberTypes.Integer;                              nc.IntNumber = int.Parse(token.TokenValue);                              break;                      }                      _outputQueue.Enqueue(nc);                  }                  if (IsOperator(token.TokenName))                  {                      if (_operatorStack.Count > 0)                      {                          while (_operatorStack.Count > 0)                          {                              var op = _operatorStack.Peek(); //o2                                    if (op == "(" || op == ")")                                  break;                              if ((GetPrecedence(token.TokenName) <= GetPrecedence(op) &&                                   IsLeftAssociative(token.TokenValue)) ||                                  !IsLeftAssociative(token.TokenValue) &&                                  GetPrecedence(token.TokenName) < GetPrecedence(op))                              {                                  op = _operatorStack.Pop();                                  var nc = new NumberClass { NumberType = NumberClass.NumberTypes.Operator' Operator = op };                                    _outputQueue.Enqueue(nc);                              }                              else break;                          }                      }                      _operatorStack.Push(token.TokenValue);                  }                  if (token.TokenName == TokenParser.Tokens.Lparen)                      _operatorStack.Push(token.TokenValue);                  if (token.TokenName == TokenParser.Tokens.Rparen)                  {                      if (_operatorStack.Count > 0)                      {                          var op = _operatorStack.Pop();                            while (op != "(")                          {                              var nc = new NumberClass { Operator = op' NumberType = NumberClass.NumberTypes.Operator };                                _outputQueue.Enqueue(nc);                                if (_operatorStack.Count > 0)                                  op = _operatorStack.Pop();                              else                              {                                  throw new MismatchedParenthesisException();                              }                          }                      }                      else                      {                          throw new MismatchedParenthesisException();                      }                  }                  token = tp.GetToken();              }
Magic Number,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: while (token != null)              {                  if (token.TokenName == TokenParser.Tokens.Sqrt)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv = EvaluateExpression(new NumberClass                                                                            {                                                                                Expression = expression'                                                                                NumberType = NumberClass.NumberTypes.Expression                                                                            });                          token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sqrt(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sqrt(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Sin)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sin(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sin(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Log)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue' 10).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue' 10).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.LogN)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Tan)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Tan(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Tan(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Abs)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Abs(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Abs(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Cos)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Cos(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Cos(rv.DoubleValue).ToString();                              break;                      }                  }                  if ((int)token.TokenName >= 100)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;  					  					foreach(var _f in _customFunctions)  					{  						if(_f.Key.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _customFunctions)                          {                              if (ff.Key.Equals(fn))                              {                                  var p = new Parser();                                  foreach (var cfr in _customFunctions)                                      p.AddCustomFunction(cfr.Key' cfr.Value);                                  foreach (var vr in _variables)                                      p.AddVariable(vr.Key' vr.Value);                                  foreach (var vf in _functions)                                      p.AddFunction(vf.Name' vf.Arguments' vf.Expression);                                    var ex = new SimplificationReturnValue[expressions.Length];   								  								for(var i = 0; i < expressions.Length; i++)  								{  									ex[i] = p.Simplify(expressions[i]);  								}                                    object funcRetval = null;                                    if (ff.Value.Method.ReturnType == typeof(int))                                  {                                      var intParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              intParams[ndx] = (int)pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              intParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(intParams);                                  }                                  if (ff.Value.Method.ReturnType == typeof(double))                                  {                                      var floatParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              floatParams[ndx] = pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              floatParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(floatParams);                                  }                                  if (ff.Value.Method.ReturnType==typeof(object))                                  {  									var ex2 = new SimplificationReturnValue[expressions.Length];  									  									for(var i = 0; i < ex2.Length; i++)  										ex2[i] = p.Simplify(expressions[i]);  									                                      funcRetval = ff.Value.DynamicInvoke(ex2);                                  }                                    //object funcRetval = ff.Value.DynamicInvoke(expressions.Select(p.Simplify).ToArray());                                    if (funcRetval is double)                                  {                                      token.TokenValue = ((double)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Float;                                  }                                  if (funcRetval is int)                                  {                                      token.TokenValue = ((int)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Integer;                                  }                                  if (funcRetval is SimplificationReturnValue)                                  {                                      var srv = (SimplificationReturnValue)funcRetval;                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                      {                                          token.TokenValue = srv.IntValue.ToString();                                          token.TokenName = TokenParser.Tokens.Integer;                                      }                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                      {                                          token.TokenValue = srv.DoubleValue.ToString();                                          token.TokenName = TokenParser.Tokens.Float;                                      }                                  }                                  break;                              }                          }                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Function)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1).Remove(0' 4);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;                      FunctionClass fun = null;  					  					foreach(var _f in _functions)  					{  						if(_f.Name.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _functions)                              if (ff.Name.Equals(fn))                                  fun = ff;                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                        var parser = new Parser();                      foreach (var cfh in _customFunctions)                          parser.AddCustomFunction(cfh.Key' cfh.Value);                        foreach (var v in _variables)                      {                          if (v.Value.NumberType == NumberClass.NumberTypes.Float)                          {                              parser.AddVariable(v.Key' v.Value.FloatNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Integer)                          {                              parser.AddVariable(v.Key' v.Value.IntNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Expression)                          {                              parser.AddVariable(v.Key' v.Value.Expression);                          }                      }                        foreach (var f in _functions)                      {                          parser.AddFunction(f.Name' f.Arguments' f.Expression);                      }                      var expressionList = new List<NumberClass>();                        foreach (var expression in expressions)                      {                          SimplificationReturnValue simRetval = parser.Simplify(expression);                            var numClass = new NumberClass();                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              numClass.FloatNumber = simRetval.DoubleValue;                              numClass.NumberType = NumberClass.NumberTypes.Float;                          }                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              numClass.IntNumber = simRetval.IntValue;                              numClass.NumberType = NumberClass.NumberTypes.Integer;                          }                          expressionList.Add(numClass);                      }                        if (fun != null)                      {                          var numClass = new NumberClass { NumberType = NumberClass.NumberTypes.Expression' Expression = fun.Expression };                            SimplificationReturnValue sretval = parser.EvaluateFunction(numClass' fun' expressionList);                            if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = sretval.IntValue.ToString();                          }                          if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = sretval.DoubleValue.ToString();                          }                      }                  }                    if (token.TokenName == TokenParser.Tokens.Variable)                  {                      if (_variables.ContainsKey(token.TokenValue))                      {                          var z = _variables[token.TokenValue];                            if (z.NumberType == NumberClass.NumberTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = z.FloatNumber.ToString();                          }                          else if (z.NumberType == NumberClass.NumberTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = z.IntNumber.ToString();                          }                      }                      else                      {                          throw new NoSuchVariableException(StringResources.Undefined_Variable + ": " + token.TokenValue);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Whitespace || token.TokenName == TokenParser.Tokens.Newline)                  {                      token = tp.GetToken();                      continue;                  }                  if (token.TokenName == TokenParser.Tokens.Integer || token.TokenName == TokenParser.Tokens.Float)                  {                      var nc = new NumberClass();                        switch (token.TokenName)                      {                          case TokenParser.Tokens.Float:                              nc.NumberType = NumberClass.NumberTypes.Float;                              nc.FloatNumber = double.Parse(token.TokenValue);                              break;                          case TokenParser.Tokens.Integer:                              nc.NumberType = NumberClass.NumberTypes.Integer;                              nc.IntNumber = int.Parse(token.TokenValue);                              break;                      }                      _outputQueue.Enqueue(nc);                  }                  if (IsOperator(token.TokenName))                  {                      if (_operatorStack.Count > 0)                      {                          while (_operatorStack.Count > 0)                          {                              var op = _operatorStack.Peek(); //o2                                    if (op == "(" || op == ")")                                  break;                              if ((GetPrecedence(token.TokenName) <= GetPrecedence(op) &&                                   IsLeftAssociative(token.TokenValue)) ||                                  !IsLeftAssociative(token.TokenValue) &&                                  GetPrecedence(token.TokenName) < GetPrecedence(op))                              {                                  op = _operatorStack.Pop();                                  var nc = new NumberClass { NumberType = NumberClass.NumberTypes.Operator' Operator = op };                                    _outputQueue.Enqueue(nc);                              }                              else break;                          }                      }                      _operatorStack.Push(token.TokenValue);                  }                  if (token.TokenName == TokenParser.Tokens.Lparen)                      _operatorStack.Push(token.TokenValue);                  if (token.TokenName == TokenParser.Tokens.Rparen)                  {                      if (_operatorStack.Count > 0)                      {                          var op = _operatorStack.Pop();                            while (op != "(")                          {                              var nc = new NumberClass { Operator = op' NumberType = NumberClass.NumberTypes.Operator };                                _outputQueue.Enqueue(nc);                                if (_operatorStack.Count > 0)                                  op = _operatorStack.Pop();                              else                              {                                  throw new MismatchedParenthesisException();                              }                          }                      }                      else                      {                          throw new MismatchedParenthesisException();                      }                  }                  token = tp.GetToken();              }
Magic Number,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: while (token != null)              {                  if (token.TokenName == TokenParser.Tokens.Sqrt)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv = EvaluateExpression(new NumberClass                                                                            {                                                                                Expression = expression'                                                                                NumberType = NumberClass.NumberTypes.Expression                                                                            });                          token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sqrt(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sqrt(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Sin)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sin(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sin(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Log)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue' 10).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue' 10).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.LogN)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Tan)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Tan(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Tan(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Abs)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Abs(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Abs(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Cos)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Cos(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Cos(rv.DoubleValue).ToString();                              break;                      }                  }                  if ((int)token.TokenName >= 100)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;  					  					foreach(var _f in _customFunctions)  					{  						if(_f.Key.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _customFunctions)                          {                              if (ff.Key.Equals(fn))                              {                                  var p = new Parser();                                  foreach (var cfr in _customFunctions)                                      p.AddCustomFunction(cfr.Key' cfr.Value);                                  foreach (var vr in _variables)                                      p.AddVariable(vr.Key' vr.Value);                                  foreach (var vf in _functions)                                      p.AddFunction(vf.Name' vf.Arguments' vf.Expression);                                    var ex = new SimplificationReturnValue[expressions.Length];   								  								for(var i = 0; i < expressions.Length; i++)  								{  									ex[i] = p.Simplify(expressions[i]);  								}                                    object funcRetval = null;                                    if (ff.Value.Method.ReturnType == typeof(int))                                  {                                      var intParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              intParams[ndx] = (int)pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              intParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(intParams);                                  }                                  if (ff.Value.Method.ReturnType == typeof(double))                                  {                                      var floatParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              floatParams[ndx] = pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              floatParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(floatParams);                                  }                                  if (ff.Value.Method.ReturnType==typeof(object))                                  {  									var ex2 = new SimplificationReturnValue[expressions.Length];  									  									for(var i = 0; i < ex2.Length; i++)  										ex2[i] = p.Simplify(expressions[i]);  									                                      funcRetval = ff.Value.DynamicInvoke(ex2);                                  }                                    //object funcRetval = ff.Value.DynamicInvoke(expressions.Select(p.Simplify).ToArray());                                    if (funcRetval is double)                                  {                                      token.TokenValue = ((double)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Float;                                  }                                  if (funcRetval is int)                                  {                                      token.TokenValue = ((int)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Integer;                                  }                                  if (funcRetval is SimplificationReturnValue)                                  {                                      var srv = (SimplificationReturnValue)funcRetval;                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                      {                                          token.TokenValue = srv.IntValue.ToString();                                          token.TokenName = TokenParser.Tokens.Integer;                                      }                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                      {                                          token.TokenValue = srv.DoubleValue.ToString();                                          token.TokenName = TokenParser.Tokens.Float;                                      }                                  }                                  break;                              }                          }                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Function)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1).Remove(0' 4);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;                      FunctionClass fun = null;  					  					foreach(var _f in _functions)  					{  						if(_f.Name.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _functions)                              if (ff.Name.Equals(fn))                                  fun = ff;                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                        var parser = new Parser();                      foreach (var cfh in _customFunctions)                          parser.AddCustomFunction(cfh.Key' cfh.Value);                        foreach (var v in _variables)                      {                          if (v.Value.NumberType == NumberClass.NumberTypes.Float)                          {                              parser.AddVariable(v.Key' v.Value.FloatNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Integer)                          {                              parser.AddVariable(v.Key' v.Value.IntNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Expression)                          {                              parser.AddVariable(v.Key' v.Value.Expression);                          }                      }                        foreach (var f in _functions)                      {                          parser.AddFunction(f.Name' f.Arguments' f.Expression);                      }                      var expressionList = new List<NumberClass>();                        foreach (var expression in expressions)                      {                          SimplificationReturnValue simRetval = parser.Simplify(expression);                            var numClass = new NumberClass();                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              numClass.FloatNumber = simRetval.DoubleValue;                              numClass.NumberType = NumberClass.NumberTypes.Float;                          }                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              numClass.IntNumber = simRetval.IntValue;                              numClass.NumberType = NumberClass.NumberTypes.Integer;                          }                          expressionList.Add(numClass);                      }                        if (fun != null)                      {                          var numClass = new NumberClass { NumberType = NumberClass.NumberTypes.Expression' Expression = fun.Expression };                            SimplificationReturnValue sretval = parser.EvaluateFunction(numClass' fun' expressionList);                            if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = sretval.IntValue.ToString();                          }                          if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = sretval.DoubleValue.ToString();                          }                      }                  }                    if (token.TokenName == TokenParser.Tokens.Variable)                  {                      if (_variables.ContainsKey(token.TokenValue))                      {                          var z = _variables[token.TokenValue];                            if (z.NumberType == NumberClass.NumberTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = z.FloatNumber.ToString();                          }                          else if (z.NumberType == NumberClass.NumberTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = z.IntNumber.ToString();                          }                      }                      else                      {                          throw new NoSuchVariableException(StringResources.Undefined_Variable + ": " + token.TokenValue);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Whitespace || token.TokenName == TokenParser.Tokens.Newline)                  {                      token = tp.GetToken();                      continue;                  }                  if (token.TokenName == TokenParser.Tokens.Integer || token.TokenName == TokenParser.Tokens.Float)                  {                      var nc = new NumberClass();                        switch (token.TokenName)                      {                          case TokenParser.Tokens.Float:                              nc.NumberType = NumberClass.NumberTypes.Float;                              nc.FloatNumber = double.Parse(token.TokenValue);                              break;                          case TokenParser.Tokens.Integer:                              nc.NumberType = NumberClass.NumberTypes.Integer;                              nc.IntNumber = int.Parse(token.TokenValue);                              break;                      }                      _outputQueue.Enqueue(nc);                  }                  if (IsOperator(token.TokenName))                  {                      if (_operatorStack.Count > 0)                      {                          while (_operatorStack.Count > 0)                          {                              var op = _operatorStack.Peek(); //o2                                    if (op == "(" || op == ")")                                  break;                              if ((GetPrecedence(token.TokenName) <= GetPrecedence(op) &&                                   IsLeftAssociative(token.TokenValue)) ||                                  !IsLeftAssociative(token.TokenValue) &&                                  GetPrecedence(token.TokenName) < GetPrecedence(op))                              {                                  op = _operatorStack.Pop();                                  var nc = new NumberClass { NumberType = NumberClass.NumberTypes.Operator' Operator = op };                                    _outputQueue.Enqueue(nc);                              }                              else break;                          }                      }                      _operatorStack.Push(token.TokenValue);                  }                  if (token.TokenName == TokenParser.Tokens.Lparen)                      _operatorStack.Push(token.TokenValue);                  if (token.TokenName == TokenParser.Tokens.Rparen)                  {                      if (_operatorStack.Count > 0)                      {                          var op = _operatorStack.Pop();                            while (op != "(")                          {                              var nc = new NumberClass { Operator = op' NumberType = NumberClass.NumberTypes.Operator };                                _outputQueue.Enqueue(nc);                                if (_operatorStack.Count > 0)                                  op = _operatorStack.Pop();                              else                              {                                  throw new MismatchedParenthesisException();                              }                          }                      }                      else                      {                          throw new MismatchedParenthesisException();                      }                  }                  token = tp.GetToken();              }
Magic Number,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: while (token != null)              {                  if (token.TokenName == TokenParser.Tokens.Sqrt)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv = EvaluateExpression(new NumberClass                                                                            {                                                                                Expression = expression'                                                                                NumberType = NumberClass.NumberTypes.Expression                                                                            });                          token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sqrt(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sqrt(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Sin)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sin(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sin(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Log)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue' 10).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue' 10).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.LogN)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Tan)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Tan(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Tan(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Abs)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Abs(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Abs(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Cos)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Cos(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Cos(rv.DoubleValue).ToString();                              break;                      }                  }                  if ((int)token.TokenName >= 100)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;  					  					foreach(var _f in _customFunctions)  					{  						if(_f.Key.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _customFunctions)                          {                              if (ff.Key.Equals(fn))                              {                                  var p = new Parser();                                  foreach (var cfr in _customFunctions)                                      p.AddCustomFunction(cfr.Key' cfr.Value);                                  foreach (var vr in _variables)                                      p.AddVariable(vr.Key' vr.Value);                                  foreach (var vf in _functions)                                      p.AddFunction(vf.Name' vf.Arguments' vf.Expression);                                    var ex = new SimplificationReturnValue[expressions.Length];   								  								for(var i = 0; i < expressions.Length; i++)  								{  									ex[i] = p.Simplify(expressions[i]);  								}                                    object funcRetval = null;                                    if (ff.Value.Method.ReturnType == typeof(int))                                  {                                      var intParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              intParams[ndx] = (int)pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              intParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(intParams);                                  }                                  if (ff.Value.Method.ReturnType == typeof(double))                                  {                                      var floatParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              floatParams[ndx] = pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              floatParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(floatParams);                                  }                                  if (ff.Value.Method.ReturnType==typeof(object))                                  {  									var ex2 = new SimplificationReturnValue[expressions.Length];  									  									for(var i = 0; i < ex2.Length; i++)  										ex2[i] = p.Simplify(expressions[i]);  									                                      funcRetval = ff.Value.DynamicInvoke(ex2);                                  }                                    //object funcRetval = ff.Value.DynamicInvoke(expressions.Select(p.Simplify).ToArray());                                    if (funcRetval is double)                                  {                                      token.TokenValue = ((double)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Float;                                  }                                  if (funcRetval is int)                                  {                                      token.TokenValue = ((int)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Integer;                                  }                                  if (funcRetval is SimplificationReturnValue)                                  {                                      var srv = (SimplificationReturnValue)funcRetval;                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                      {                                          token.TokenValue = srv.IntValue.ToString();                                          token.TokenName = TokenParser.Tokens.Integer;                                      }                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                      {                                          token.TokenValue = srv.DoubleValue.ToString();                                          token.TokenName = TokenParser.Tokens.Float;                                      }                                  }                                  break;                              }                          }                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Function)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1).Remove(0' 4);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;                      FunctionClass fun = null;  					  					foreach(var _f in _functions)  					{  						if(_f.Name.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _functions)                              if (ff.Name.Equals(fn))                                  fun = ff;                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                        var parser = new Parser();                      foreach (var cfh in _customFunctions)                          parser.AddCustomFunction(cfh.Key' cfh.Value);                        foreach (var v in _variables)                      {                          if (v.Value.NumberType == NumberClass.NumberTypes.Float)                          {                              parser.AddVariable(v.Key' v.Value.FloatNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Integer)                          {                              parser.AddVariable(v.Key' v.Value.IntNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Expression)                          {                              parser.AddVariable(v.Key' v.Value.Expression);                          }                      }                        foreach (var f in _functions)                      {                          parser.AddFunction(f.Name' f.Arguments' f.Expression);                      }                      var expressionList = new List<NumberClass>();                        foreach (var expression in expressions)                      {                          SimplificationReturnValue simRetval = parser.Simplify(expression);                            var numClass = new NumberClass();                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              numClass.FloatNumber = simRetval.DoubleValue;                              numClass.NumberType = NumberClass.NumberTypes.Float;                          }                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              numClass.IntNumber = simRetval.IntValue;                              numClass.NumberType = NumberClass.NumberTypes.Integer;                          }                          expressionList.Add(numClass);                      }                        if (fun != null)                      {                          var numClass = new NumberClass { NumberType = NumberClass.NumberTypes.Expression' Expression = fun.Expression };                            SimplificationReturnValue sretval = parser.EvaluateFunction(numClass' fun' expressionList);                            if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = sretval.IntValue.ToString();                          }                          if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = sretval.DoubleValue.ToString();                          }                      }                  }                    if (token.TokenName == TokenParser.Tokens.Variable)                  {                      if (_variables.ContainsKey(token.TokenValue))                      {                          var z = _variables[token.TokenValue];                            if (z.NumberType == NumberClass.NumberTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = z.FloatNumber.ToString();                          }                          else if (z.NumberType == NumberClass.NumberTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = z.IntNumber.ToString();                          }                      }                      else                      {                          throw new NoSuchVariableException(StringResources.Undefined_Variable + ": " + token.TokenValue);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Whitespace || token.TokenName == TokenParser.Tokens.Newline)                  {                      token = tp.GetToken();                      continue;                  }                  if (token.TokenName == TokenParser.Tokens.Integer || token.TokenName == TokenParser.Tokens.Float)                  {                      var nc = new NumberClass();                        switch (token.TokenName)                      {                          case TokenParser.Tokens.Float:                              nc.NumberType = NumberClass.NumberTypes.Float;                              nc.FloatNumber = double.Parse(token.TokenValue);                              break;                          case TokenParser.Tokens.Integer:                              nc.NumberType = NumberClass.NumberTypes.Integer;                              nc.IntNumber = int.Parse(token.TokenValue);                              break;                      }                      _outputQueue.Enqueue(nc);                  }                  if (IsOperator(token.TokenName))                  {                      if (_operatorStack.Count > 0)                      {                          while (_operatorStack.Count > 0)                          {                              var op = _operatorStack.Peek(); //o2                                    if (op == "(" || op == ")")                                  break;                              if ((GetPrecedence(token.TokenName) <= GetPrecedence(op) &&                                   IsLeftAssociative(token.TokenValue)) ||                                  !IsLeftAssociative(token.TokenValue) &&                                  GetPrecedence(token.TokenName) < GetPrecedence(op))                              {                                  op = _operatorStack.Pop();                                  var nc = new NumberClass { NumberType = NumberClass.NumberTypes.Operator' Operator = op };                                    _outputQueue.Enqueue(nc);                              }                              else break;                          }                      }                      _operatorStack.Push(token.TokenValue);                  }                  if (token.TokenName == TokenParser.Tokens.Lparen)                      _operatorStack.Push(token.TokenValue);                  if (token.TokenName == TokenParser.Tokens.Rparen)                  {                      if (_operatorStack.Count > 0)                      {                          var op = _operatorStack.Pop();                            while (op != "(")                          {                              var nc = new NumberClass { Operator = op' NumberType = NumberClass.NumberTypes.Operator };                                _outputQueue.Enqueue(nc);                                if (_operatorStack.Count > 0)                                  op = _operatorStack.Pop();                              else                              {                                  throw new MismatchedParenthesisException();                              }                          }                      }                      else                      {                          throw new MismatchedParenthesisException();                      }                  }                  token = tp.GetToken();              }
Magic Number,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: while (token != null)              {                  if (token.TokenName == TokenParser.Tokens.Sqrt)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv = EvaluateExpression(new NumberClass                                                                            {                                                                                Expression = expression'                                                                                NumberType = NumberClass.NumberTypes.Expression                                                                            });                          token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sqrt(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sqrt(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Sin)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sin(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sin(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Log)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue' 10).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue' 10).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.LogN)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Tan)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Tan(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Tan(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Abs)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Abs(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Abs(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Cos)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Cos(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Cos(rv.DoubleValue).ToString();                              break;                      }                  }                  if ((int)token.TokenName >= 100)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;  					  					foreach(var _f in _customFunctions)  					{  						if(_f.Key.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _customFunctions)                          {                              if (ff.Key.Equals(fn))                              {                                  var p = new Parser();                                  foreach (var cfr in _customFunctions)                                      p.AddCustomFunction(cfr.Key' cfr.Value);                                  foreach (var vr in _variables)                                      p.AddVariable(vr.Key' vr.Value);                                  foreach (var vf in _functions)                                      p.AddFunction(vf.Name' vf.Arguments' vf.Expression);                                    var ex = new SimplificationReturnValue[expressions.Length];   								  								for(var i = 0; i < expressions.Length; i++)  								{  									ex[i] = p.Simplify(expressions[i]);  								}                                    object funcRetval = null;                                    if (ff.Value.Method.ReturnType == typeof(int))                                  {                                      var intParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              intParams[ndx] = (int)pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              intParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(intParams);                                  }                                  if (ff.Value.Method.ReturnType == typeof(double))                                  {                                      var floatParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              floatParams[ndx] = pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              floatParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(floatParams);                                  }                                  if (ff.Value.Method.ReturnType==typeof(object))                                  {  									var ex2 = new SimplificationReturnValue[expressions.Length];  									  									for(var i = 0; i < ex2.Length; i++)  										ex2[i] = p.Simplify(expressions[i]);  									                                      funcRetval = ff.Value.DynamicInvoke(ex2);                                  }                                    //object funcRetval = ff.Value.DynamicInvoke(expressions.Select(p.Simplify).ToArray());                                    if (funcRetval is double)                                  {                                      token.TokenValue = ((double)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Float;                                  }                                  if (funcRetval is int)                                  {                                      token.TokenValue = ((int)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Integer;                                  }                                  if (funcRetval is SimplificationReturnValue)                                  {                                      var srv = (SimplificationReturnValue)funcRetval;                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                      {                                          token.TokenValue = srv.IntValue.ToString();                                          token.TokenName = TokenParser.Tokens.Integer;                                      }                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                      {                                          token.TokenValue = srv.DoubleValue.ToString();                                          token.TokenName = TokenParser.Tokens.Float;                                      }                                  }                                  break;                              }                          }                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Function)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1).Remove(0' 4);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;                      FunctionClass fun = null;  					  					foreach(var _f in _functions)  					{  						if(_f.Name.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _functions)                              if (ff.Name.Equals(fn))                                  fun = ff;                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                        var parser = new Parser();                      foreach (var cfh in _customFunctions)                          parser.AddCustomFunction(cfh.Key' cfh.Value);                        foreach (var v in _variables)                      {                          if (v.Value.NumberType == NumberClass.NumberTypes.Float)                          {                              parser.AddVariable(v.Key' v.Value.FloatNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Integer)                          {                              parser.AddVariable(v.Key' v.Value.IntNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Expression)                          {                              parser.AddVariable(v.Key' v.Value.Expression);                          }                      }                        foreach (var f in _functions)                      {                          parser.AddFunction(f.Name' f.Arguments' f.Expression);                      }                      var expressionList = new List<NumberClass>();                        foreach (var expression in expressions)                      {                          SimplificationReturnValue simRetval = parser.Simplify(expression);                            var numClass = new NumberClass();                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              numClass.FloatNumber = simRetval.DoubleValue;                              numClass.NumberType = NumberClass.NumberTypes.Float;                          }                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              numClass.IntNumber = simRetval.IntValue;                              numClass.NumberType = NumberClass.NumberTypes.Integer;                          }                          expressionList.Add(numClass);                      }                        if (fun != null)                      {                          var numClass = new NumberClass { NumberType = NumberClass.NumberTypes.Expression' Expression = fun.Expression };                            SimplificationReturnValue sretval = parser.EvaluateFunction(numClass' fun' expressionList);                            if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = sretval.IntValue.ToString();                          }                          if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = sretval.DoubleValue.ToString();                          }                      }                  }                    if (token.TokenName == TokenParser.Tokens.Variable)                  {                      if (_variables.ContainsKey(token.TokenValue))                      {                          var z = _variables[token.TokenValue];                            if (z.NumberType == NumberClass.NumberTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = z.FloatNumber.ToString();                          }                          else if (z.NumberType == NumberClass.NumberTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = z.IntNumber.ToString();                          }                      }                      else                      {                          throw new NoSuchVariableException(StringResources.Undefined_Variable + ": " + token.TokenValue);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Whitespace || token.TokenName == TokenParser.Tokens.Newline)                  {                      token = tp.GetToken();                      continue;                  }                  if (token.TokenName == TokenParser.Tokens.Integer || token.TokenName == TokenParser.Tokens.Float)                  {                      var nc = new NumberClass();                        switch (token.TokenName)                      {                          case TokenParser.Tokens.Float:                              nc.NumberType = NumberClass.NumberTypes.Float;                              nc.FloatNumber = double.Parse(token.TokenValue);                              break;                          case TokenParser.Tokens.Integer:                              nc.NumberType = NumberClass.NumberTypes.Integer;                              nc.IntNumber = int.Parse(token.TokenValue);                              break;                      }                      _outputQueue.Enqueue(nc);                  }                  if (IsOperator(token.TokenName))                  {                      if (_operatorStack.Count > 0)                      {                          while (_operatorStack.Count > 0)                          {                              var op = _operatorStack.Peek(); //o2                                    if (op == "(" || op == ")")                                  break;                              if ((GetPrecedence(token.TokenName) <= GetPrecedence(op) &&                                   IsLeftAssociative(token.TokenValue)) ||                                  !IsLeftAssociative(token.TokenValue) &&                                  GetPrecedence(token.TokenName) < GetPrecedence(op))                              {                                  op = _operatorStack.Pop();                                  var nc = new NumberClass { NumberType = NumberClass.NumberTypes.Operator' Operator = op };                                    _outputQueue.Enqueue(nc);                              }                              else break;                          }                      }                      _operatorStack.Push(token.TokenValue);                  }                  if (token.TokenName == TokenParser.Tokens.Lparen)                      _operatorStack.Push(token.TokenValue);                  if (token.TokenName == TokenParser.Tokens.Rparen)                  {                      if (_operatorStack.Count > 0)                      {                          var op = _operatorStack.Pop();                            while (op != "(")                          {                              var nc = new NumberClass { Operator = op' NumberType = NumberClass.NumberTypes.Operator };                                _outputQueue.Enqueue(nc);                                if (_operatorStack.Count > 0)                                  op = _operatorStack.Pop();                              else                              {                                  throw new MismatchedParenthesisException();                              }                          }                      }                      else                      {                          throw new MismatchedParenthesisException();                      }                  }                  token = tp.GetToken();              }
Magic Number,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: while (token != null)              {                  if (token.TokenName == TokenParser.Tokens.Sqrt)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv = EvaluateExpression(new NumberClass                                                                            {                                                                                Expression = expression'                                                                                NumberType = NumberClass.NumberTypes.Expression                                                                            });                          token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sqrt(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sqrt(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Sin)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sin(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sin(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Log)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue' 10).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue' 10).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.LogN)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Tan)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Tan(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Tan(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Abs)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Abs(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Abs(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Cos)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Cos(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Cos(rv.DoubleValue).ToString();                              break;                      }                  }                  if ((int)token.TokenName >= 100)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;  					  					foreach(var _f in _customFunctions)  					{  						if(_f.Key.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _customFunctions)                          {                              if (ff.Key.Equals(fn))                              {                                  var p = new Parser();                                  foreach (var cfr in _customFunctions)                                      p.AddCustomFunction(cfr.Key' cfr.Value);                                  foreach (var vr in _variables)                                      p.AddVariable(vr.Key' vr.Value);                                  foreach (var vf in _functions)                                      p.AddFunction(vf.Name' vf.Arguments' vf.Expression);                                    var ex = new SimplificationReturnValue[expressions.Length];   								  								for(var i = 0; i < expressions.Length; i++)  								{  									ex[i] = p.Simplify(expressions[i]);  								}                                    object funcRetval = null;                                    if (ff.Value.Method.ReturnType == typeof(int))                                  {                                      var intParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              intParams[ndx] = (int)pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              intParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(intParams);                                  }                                  if (ff.Value.Method.ReturnType == typeof(double))                                  {                                      var floatParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              floatParams[ndx] = pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              floatParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(floatParams);                                  }                                  if (ff.Value.Method.ReturnType==typeof(object))                                  {  									var ex2 = new SimplificationReturnValue[expressions.Length];  									  									for(var i = 0; i < ex2.Length; i++)  										ex2[i] = p.Simplify(expressions[i]);  									                                      funcRetval = ff.Value.DynamicInvoke(ex2);                                  }                                    //object funcRetval = ff.Value.DynamicInvoke(expressions.Select(p.Simplify).ToArray());                                    if (funcRetval is double)                                  {                                      token.TokenValue = ((double)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Float;                                  }                                  if (funcRetval is int)                                  {                                      token.TokenValue = ((int)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Integer;                                  }                                  if (funcRetval is SimplificationReturnValue)                                  {                                      var srv = (SimplificationReturnValue)funcRetval;                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                      {                                          token.TokenValue = srv.IntValue.ToString();                                          token.TokenName = TokenParser.Tokens.Integer;                                      }                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                      {                                          token.TokenValue = srv.DoubleValue.ToString();                                          token.TokenName = TokenParser.Tokens.Float;                                      }                                  }                                  break;                              }                          }                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Function)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1).Remove(0' 4);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;                      FunctionClass fun = null;  					  					foreach(var _f in _functions)  					{  						if(_f.Name.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _functions)                              if (ff.Name.Equals(fn))                                  fun = ff;                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                        var parser = new Parser();                      foreach (var cfh in _customFunctions)                          parser.AddCustomFunction(cfh.Key' cfh.Value);                        foreach (var v in _variables)                      {                          if (v.Value.NumberType == NumberClass.NumberTypes.Float)                          {                              parser.AddVariable(v.Key' v.Value.FloatNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Integer)                          {                              parser.AddVariable(v.Key' v.Value.IntNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Expression)                          {                              parser.AddVariable(v.Key' v.Value.Expression);                          }                      }                        foreach (var f in _functions)                      {                          parser.AddFunction(f.Name' f.Arguments' f.Expression);                      }                      var expressionList = new List<NumberClass>();                        foreach (var expression in expressions)                      {                          SimplificationReturnValue simRetval = parser.Simplify(expression);                            var numClass = new NumberClass();                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              numClass.FloatNumber = simRetval.DoubleValue;                              numClass.NumberType = NumberClass.NumberTypes.Float;                          }                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              numClass.IntNumber = simRetval.IntValue;                              numClass.NumberType = NumberClass.NumberTypes.Integer;                          }                          expressionList.Add(numClass);                      }                        if (fun != null)                      {                          var numClass = new NumberClass { NumberType = NumberClass.NumberTypes.Expression' Expression = fun.Expression };                            SimplificationReturnValue sretval = parser.EvaluateFunction(numClass' fun' expressionList);                            if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = sretval.IntValue.ToString();                          }                          if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = sretval.DoubleValue.ToString();                          }                      }                  }                    if (token.TokenName == TokenParser.Tokens.Variable)                  {                      if (_variables.ContainsKey(token.TokenValue))                      {                          var z = _variables[token.TokenValue];                            if (z.NumberType == NumberClass.NumberTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = z.FloatNumber.ToString();                          }                          else if (z.NumberType == NumberClass.NumberTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = z.IntNumber.ToString();                          }                      }                      else                      {                          throw new NoSuchVariableException(StringResources.Undefined_Variable + ": " + token.TokenValue);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Whitespace || token.TokenName == TokenParser.Tokens.Newline)                  {                      token = tp.GetToken();                      continue;                  }                  if (token.TokenName == TokenParser.Tokens.Integer || token.TokenName == TokenParser.Tokens.Float)                  {                      var nc = new NumberClass();                        switch (token.TokenName)                      {                          case TokenParser.Tokens.Float:                              nc.NumberType = NumberClass.NumberTypes.Float;                              nc.FloatNumber = double.Parse(token.TokenValue);                              break;                          case TokenParser.Tokens.Integer:                              nc.NumberType = NumberClass.NumberTypes.Integer;                              nc.IntNumber = int.Parse(token.TokenValue);                              break;                      }                      _outputQueue.Enqueue(nc);                  }                  if (IsOperator(token.TokenName))                  {                      if (_operatorStack.Count > 0)                      {                          while (_operatorStack.Count > 0)                          {                              var op = _operatorStack.Peek(); //o2                                    if (op == "(" || op == ")")                                  break;                              if ((GetPrecedence(token.TokenName) <= GetPrecedence(op) &&                                   IsLeftAssociative(token.TokenValue)) ||                                  !IsLeftAssociative(token.TokenValue) &&                                  GetPrecedence(token.TokenName) < GetPrecedence(op))                              {                                  op = _operatorStack.Pop();                                  var nc = new NumberClass { NumberType = NumberClass.NumberTypes.Operator' Operator = op };                                    _outputQueue.Enqueue(nc);                              }                              else break;                          }                      }                      _operatorStack.Push(token.TokenValue);                  }                  if (token.TokenName == TokenParser.Tokens.Lparen)                      _operatorStack.Push(token.TokenValue);                  if (token.TokenName == TokenParser.Tokens.Rparen)                  {                      if (_operatorStack.Count > 0)                      {                          var op = _operatorStack.Pop();                            while (op != "(")                          {                              var nc = new NumberClass { Operator = op' NumberType = NumberClass.NumberTypes.Operator };                                _outputQueue.Enqueue(nc);                                if (_operatorStack.Count > 0)                                  op = _operatorStack.Pop();                              else                              {                                  throw new MismatchedParenthesisException();                              }                          }                      }                      else                      {                          throw new MismatchedParenthesisException();                      }                  }                  token = tp.GetToken();              }
Magic Number,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: while (token != null)              {                  if (token.TokenName == TokenParser.Tokens.Sqrt)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv = EvaluateExpression(new NumberClass                                                                            {                                                                                Expression = expression'                                                                                NumberType = NumberClass.NumberTypes.Expression                                                                            });                          token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sqrt(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sqrt(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Sin)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sin(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sin(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Log)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue' 10).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue' 10).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.LogN)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Tan)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Tan(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Tan(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Abs)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Abs(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Abs(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Cos)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Cos(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Cos(rv.DoubleValue).ToString();                              break;                      }                  }                  if ((int)token.TokenName >= 100)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;  					  					foreach(var _f in _customFunctions)  					{  						if(_f.Key.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _customFunctions)                          {                              if (ff.Key.Equals(fn))                              {                                  var p = new Parser();                                  foreach (var cfr in _customFunctions)                                      p.AddCustomFunction(cfr.Key' cfr.Value);                                  foreach (var vr in _variables)                                      p.AddVariable(vr.Key' vr.Value);                                  foreach (var vf in _functions)                                      p.AddFunction(vf.Name' vf.Arguments' vf.Expression);                                    var ex = new SimplificationReturnValue[expressions.Length];   								  								for(var i = 0; i < expressions.Length; i++)  								{  									ex[i] = p.Simplify(expressions[i]);  								}                                    object funcRetval = null;                                    if (ff.Value.Method.ReturnType == typeof(int))                                  {                                      var intParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              intParams[ndx] = (int)pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              intParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(intParams);                                  }                                  if (ff.Value.Method.ReturnType == typeof(double))                                  {                                      var floatParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              floatParams[ndx] = pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              floatParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(floatParams);                                  }                                  if (ff.Value.Method.ReturnType==typeof(object))                                  {  									var ex2 = new SimplificationReturnValue[expressions.Length];  									  									for(var i = 0; i < ex2.Length; i++)  										ex2[i] = p.Simplify(expressions[i]);  									                                      funcRetval = ff.Value.DynamicInvoke(ex2);                                  }                                    //object funcRetval = ff.Value.DynamicInvoke(expressions.Select(p.Simplify).ToArray());                                    if (funcRetval is double)                                  {                                      token.TokenValue = ((double)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Float;                                  }                                  if (funcRetval is int)                                  {                                      token.TokenValue = ((int)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Integer;                                  }                                  if (funcRetval is SimplificationReturnValue)                                  {                                      var srv = (SimplificationReturnValue)funcRetval;                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                      {                                          token.TokenValue = srv.IntValue.ToString();                                          token.TokenName = TokenParser.Tokens.Integer;                                      }                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                      {                                          token.TokenValue = srv.DoubleValue.ToString();                                          token.TokenName = TokenParser.Tokens.Float;                                      }                                  }                                  break;                              }                          }                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Function)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1).Remove(0' 4);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;                      FunctionClass fun = null;  					  					foreach(var _f in _functions)  					{  						if(_f.Name.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _functions)                              if (ff.Name.Equals(fn))                                  fun = ff;                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                        var parser = new Parser();                      foreach (var cfh in _customFunctions)                          parser.AddCustomFunction(cfh.Key' cfh.Value);                        foreach (var v in _variables)                      {                          if (v.Value.NumberType == NumberClass.NumberTypes.Float)                          {                              parser.AddVariable(v.Key' v.Value.FloatNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Integer)                          {                              parser.AddVariable(v.Key' v.Value.IntNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Expression)                          {                              parser.AddVariable(v.Key' v.Value.Expression);                          }                      }                        foreach (var f in _functions)                      {                          parser.AddFunction(f.Name' f.Arguments' f.Expression);                      }                      var expressionList = new List<NumberClass>();                        foreach (var expression in expressions)                      {                          SimplificationReturnValue simRetval = parser.Simplify(expression);                            var numClass = new NumberClass();                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              numClass.FloatNumber = simRetval.DoubleValue;                              numClass.NumberType = NumberClass.NumberTypes.Float;                          }                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              numClass.IntNumber = simRetval.IntValue;                              numClass.NumberType = NumberClass.NumberTypes.Integer;                          }                          expressionList.Add(numClass);                      }                        if (fun != null)                      {                          var numClass = new NumberClass { NumberType = NumberClass.NumberTypes.Expression' Expression = fun.Expression };                            SimplificationReturnValue sretval = parser.EvaluateFunction(numClass' fun' expressionList);                            if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = sretval.IntValue.ToString();                          }                          if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = sretval.DoubleValue.ToString();                          }                      }                  }                    if (token.TokenName == TokenParser.Tokens.Variable)                  {                      if (_variables.ContainsKey(token.TokenValue))                      {                          var z = _variables[token.TokenValue];                            if (z.NumberType == NumberClass.NumberTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = z.FloatNumber.ToString();                          }                          else if (z.NumberType == NumberClass.NumberTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = z.IntNumber.ToString();                          }                      }                      else                      {                          throw new NoSuchVariableException(StringResources.Undefined_Variable + ": " + token.TokenValue);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Whitespace || token.TokenName == TokenParser.Tokens.Newline)                  {                      token = tp.GetToken();                      continue;                  }                  if (token.TokenName == TokenParser.Tokens.Integer || token.TokenName == TokenParser.Tokens.Float)                  {                      var nc = new NumberClass();                        switch (token.TokenName)                      {                          case TokenParser.Tokens.Float:                              nc.NumberType = NumberClass.NumberTypes.Float;                              nc.FloatNumber = double.Parse(token.TokenValue);                              break;                          case TokenParser.Tokens.Integer:                              nc.NumberType = NumberClass.NumberTypes.Integer;                              nc.IntNumber = int.Parse(token.TokenValue);                              break;                      }                      _outputQueue.Enqueue(nc);                  }                  if (IsOperator(token.TokenName))                  {                      if (_operatorStack.Count > 0)                      {                          while (_operatorStack.Count > 0)                          {                              var op = _operatorStack.Peek(); //o2                                    if (op == "(" || op == ")")                                  break;                              if ((GetPrecedence(token.TokenName) <= GetPrecedence(op) &&                                   IsLeftAssociative(token.TokenValue)) ||                                  !IsLeftAssociative(token.TokenValue) &&                                  GetPrecedence(token.TokenName) < GetPrecedence(op))                              {                                  op = _operatorStack.Pop();                                  var nc = new NumberClass { NumberType = NumberClass.NumberTypes.Operator' Operator = op };                                    _outputQueue.Enqueue(nc);                              }                              else break;                          }                      }                      _operatorStack.Push(token.TokenValue);                  }                  if (token.TokenName == TokenParser.Tokens.Lparen)                      _operatorStack.Push(token.TokenValue);                  if (token.TokenName == TokenParser.Tokens.Rparen)                  {                      if (_operatorStack.Count > 0)                      {                          var op = _operatorStack.Pop();                            while (op != "(")                          {                              var nc = new NumberClass { Operator = op' NumberType = NumberClass.NumberTypes.Operator };                                _outputQueue.Enqueue(nc);                                if (_operatorStack.Count > 0)                                  op = _operatorStack.Pop();                              else                              {                                  throw new MismatchedParenthesisException();                              }                          }                      }                      else                      {                          throw new MismatchedParenthesisException();                      }                  }                  token = tp.GetToken();              }
Magic Number,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: while (token != null)              {                  if (token.TokenName == TokenParser.Tokens.Sqrt)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv = EvaluateExpression(new NumberClass                                                                            {                                                                                Expression = expression'                                                                                NumberType = NumberClass.NumberTypes.Expression                                                                            });                          token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sqrt(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sqrt(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Sin)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sin(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sin(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Log)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue' 10).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue' 10).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.LogN)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Tan)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Tan(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Tan(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Abs)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Abs(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Abs(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Cos)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Cos(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Cos(rv.DoubleValue).ToString();                              break;                      }                  }                  if ((int)token.TokenName >= 100)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;  					  					foreach(var _f in _customFunctions)  					{  						if(_f.Key.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _customFunctions)                          {                              if (ff.Key.Equals(fn))                              {                                  var p = new Parser();                                  foreach (var cfr in _customFunctions)                                      p.AddCustomFunction(cfr.Key' cfr.Value);                                  foreach (var vr in _variables)                                      p.AddVariable(vr.Key' vr.Value);                                  foreach (var vf in _functions)                                      p.AddFunction(vf.Name' vf.Arguments' vf.Expression);                                    var ex = new SimplificationReturnValue[expressions.Length];   								  								for(var i = 0; i < expressions.Length; i++)  								{  									ex[i] = p.Simplify(expressions[i]);  								}                                    object funcRetval = null;                                    if (ff.Value.Method.ReturnType == typeof(int))                                  {                                      var intParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              intParams[ndx] = (int)pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              intParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(intParams);                                  }                                  if (ff.Value.Method.ReturnType == typeof(double))                                  {                                      var floatParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              floatParams[ndx] = pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              floatParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(floatParams);                                  }                                  if (ff.Value.Method.ReturnType==typeof(object))                                  {  									var ex2 = new SimplificationReturnValue[expressions.Length];  									  									for(var i = 0; i < ex2.Length; i++)  										ex2[i] = p.Simplify(expressions[i]);  									                                      funcRetval = ff.Value.DynamicInvoke(ex2);                                  }                                    //object funcRetval = ff.Value.DynamicInvoke(expressions.Select(p.Simplify).ToArray());                                    if (funcRetval is double)                                  {                                      token.TokenValue = ((double)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Float;                                  }                                  if (funcRetval is int)                                  {                                      token.TokenValue = ((int)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Integer;                                  }                                  if (funcRetval is SimplificationReturnValue)                                  {                                      var srv = (SimplificationReturnValue)funcRetval;                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                      {                                          token.TokenValue = srv.IntValue.ToString();                                          token.TokenName = TokenParser.Tokens.Integer;                                      }                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                      {                                          token.TokenValue = srv.DoubleValue.ToString();                                          token.TokenName = TokenParser.Tokens.Float;                                      }                                  }                                  break;                              }                          }                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Function)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1).Remove(0' 4);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;                      FunctionClass fun = null;  					  					foreach(var _f in _functions)  					{  						if(_f.Name.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _functions)                              if (ff.Name.Equals(fn))                                  fun = ff;                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                        var parser = new Parser();                      foreach (var cfh in _customFunctions)                          parser.AddCustomFunction(cfh.Key' cfh.Value);                        foreach (var v in _variables)                      {                          if (v.Value.NumberType == NumberClass.NumberTypes.Float)                          {                              parser.AddVariable(v.Key' v.Value.FloatNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Integer)                          {                              parser.AddVariable(v.Key' v.Value.IntNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Expression)                          {                              parser.AddVariable(v.Key' v.Value.Expression);                          }                      }                        foreach (var f in _functions)                      {                          parser.AddFunction(f.Name' f.Arguments' f.Expression);                      }                      var expressionList = new List<NumberClass>();                        foreach (var expression in expressions)                      {                          SimplificationReturnValue simRetval = parser.Simplify(expression);                            var numClass = new NumberClass();                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              numClass.FloatNumber = simRetval.DoubleValue;                              numClass.NumberType = NumberClass.NumberTypes.Float;                          }                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              numClass.IntNumber = simRetval.IntValue;                              numClass.NumberType = NumberClass.NumberTypes.Integer;                          }                          expressionList.Add(numClass);                      }                        if (fun != null)                      {                          var numClass = new NumberClass { NumberType = NumberClass.NumberTypes.Expression' Expression = fun.Expression };                            SimplificationReturnValue sretval = parser.EvaluateFunction(numClass' fun' expressionList);                            if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = sretval.IntValue.ToString();                          }                          if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = sretval.DoubleValue.ToString();                          }                      }                  }                    if (token.TokenName == TokenParser.Tokens.Variable)                  {                      if (_variables.ContainsKey(token.TokenValue))                      {                          var z = _variables[token.TokenValue];                            if (z.NumberType == NumberClass.NumberTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = z.FloatNumber.ToString();                          }                          else if (z.NumberType == NumberClass.NumberTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = z.IntNumber.ToString();                          }                      }                      else                      {                          throw new NoSuchVariableException(StringResources.Undefined_Variable + ": " + token.TokenValue);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Whitespace || token.TokenName == TokenParser.Tokens.Newline)                  {                      token = tp.GetToken();                      continue;                  }                  if (token.TokenName == TokenParser.Tokens.Integer || token.TokenName == TokenParser.Tokens.Float)                  {                      var nc = new NumberClass();                        switch (token.TokenName)                      {                          case TokenParser.Tokens.Float:                              nc.NumberType = NumberClass.NumberTypes.Float;                              nc.FloatNumber = double.Parse(token.TokenValue);                              break;                          case TokenParser.Tokens.Integer:                              nc.NumberType = NumberClass.NumberTypes.Integer;                              nc.IntNumber = int.Parse(token.TokenValue);                              break;                      }                      _outputQueue.Enqueue(nc);                  }                  if (IsOperator(token.TokenName))                  {                      if (_operatorStack.Count > 0)                      {                          while (_operatorStack.Count > 0)                          {                              var op = _operatorStack.Peek(); //o2                                    if (op == "(" || op == ")")                                  break;                              if ((GetPrecedence(token.TokenName) <= GetPrecedence(op) &&                                   IsLeftAssociative(token.TokenValue)) ||                                  !IsLeftAssociative(token.TokenValue) &&                                  GetPrecedence(token.TokenName) < GetPrecedence(op))                              {                                  op = _operatorStack.Pop();                                  var nc = new NumberClass { NumberType = NumberClass.NumberTypes.Operator' Operator = op };                                    _outputQueue.Enqueue(nc);                              }                              else break;                          }                      }                      _operatorStack.Push(token.TokenValue);                  }                  if (token.TokenName == TokenParser.Tokens.Lparen)                      _operatorStack.Push(token.TokenValue);                  if (token.TokenName == TokenParser.Tokens.Rparen)                  {                      if (_operatorStack.Count > 0)                      {                          var op = _operatorStack.Pop();                            while (op != "(")                          {                              var nc = new NumberClass { Operator = op' NumberType = NumberClass.NumberTypes.Operator };                                _outputQueue.Enqueue(nc);                                if (_operatorStack.Count > 0)                                  op = _operatorStack.Pop();                              else                              {                                  throw new MismatchedParenthesisException();                              }                          }                      }                      else                      {                          throw new MismatchedParenthesisException();                      }                  }                  token = tp.GetToken();              }
Magic Number,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: while (token != null)              {                  if (token.TokenName == TokenParser.Tokens.Sqrt)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv = EvaluateExpression(new NumberClass                                                                            {                                                                                Expression = expression'                                                                                NumberType = NumberClass.NumberTypes.Expression                                                                            });                          token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sqrt(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sqrt(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Sin)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sin(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sin(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Log)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue' 10).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue' 10).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.LogN)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Tan)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Tan(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Tan(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Abs)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Abs(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Abs(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Cos)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Cos(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Cos(rv.DoubleValue).ToString();                              break;                      }                  }                  if ((int)token.TokenName >= 100)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;  					  					foreach(var _f in _customFunctions)  					{  						if(_f.Key.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _customFunctions)                          {                              if (ff.Key.Equals(fn))                              {                                  var p = new Parser();                                  foreach (var cfr in _customFunctions)                                      p.AddCustomFunction(cfr.Key' cfr.Value);                                  foreach (var vr in _variables)                                      p.AddVariable(vr.Key' vr.Value);                                  foreach (var vf in _functions)                                      p.AddFunction(vf.Name' vf.Arguments' vf.Expression);                                    var ex = new SimplificationReturnValue[expressions.Length];   								  								for(var i = 0; i < expressions.Length; i++)  								{  									ex[i] = p.Simplify(expressions[i]);  								}                                    object funcRetval = null;                                    if (ff.Value.Method.ReturnType == typeof(int))                                  {                                      var intParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              intParams[ndx] = (int)pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              intParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(intParams);                                  }                                  if (ff.Value.Method.ReturnType == typeof(double))                                  {                                      var floatParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              floatParams[ndx] = pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              floatParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(floatParams);                                  }                                  if (ff.Value.Method.ReturnType==typeof(object))                                  {  									var ex2 = new SimplificationReturnValue[expressions.Length];  									  									for(var i = 0; i < ex2.Length; i++)  										ex2[i] = p.Simplify(expressions[i]);  									                                      funcRetval = ff.Value.DynamicInvoke(ex2);                                  }                                    //object funcRetval = ff.Value.DynamicInvoke(expressions.Select(p.Simplify).ToArray());                                    if (funcRetval is double)                                  {                                      token.TokenValue = ((double)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Float;                                  }                                  if (funcRetval is int)                                  {                                      token.TokenValue = ((int)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Integer;                                  }                                  if (funcRetval is SimplificationReturnValue)                                  {                                      var srv = (SimplificationReturnValue)funcRetval;                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                      {                                          token.TokenValue = srv.IntValue.ToString();                                          token.TokenName = TokenParser.Tokens.Integer;                                      }                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                      {                                          token.TokenValue = srv.DoubleValue.ToString();                                          token.TokenName = TokenParser.Tokens.Float;                                      }                                  }                                  break;                              }                          }                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Function)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1).Remove(0' 4);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;                      FunctionClass fun = null;  					  					foreach(var _f in _functions)  					{  						if(_f.Name.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _functions)                              if (ff.Name.Equals(fn))                                  fun = ff;                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                        var parser = new Parser();                      foreach (var cfh in _customFunctions)                          parser.AddCustomFunction(cfh.Key' cfh.Value);                        foreach (var v in _variables)                      {                          if (v.Value.NumberType == NumberClass.NumberTypes.Float)                          {                              parser.AddVariable(v.Key' v.Value.FloatNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Integer)                          {                              parser.AddVariable(v.Key' v.Value.IntNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Expression)                          {                              parser.AddVariable(v.Key' v.Value.Expression);                          }                      }                        foreach (var f in _functions)                      {                          parser.AddFunction(f.Name' f.Arguments' f.Expression);                      }                      var expressionList = new List<NumberClass>();                        foreach (var expression in expressions)                      {                          SimplificationReturnValue simRetval = parser.Simplify(expression);                            var numClass = new NumberClass();                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              numClass.FloatNumber = simRetval.DoubleValue;                              numClass.NumberType = NumberClass.NumberTypes.Float;                          }                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              numClass.IntNumber = simRetval.IntValue;                              numClass.NumberType = NumberClass.NumberTypes.Integer;                          }                          expressionList.Add(numClass);                      }                        if (fun != null)                      {                          var numClass = new NumberClass { NumberType = NumberClass.NumberTypes.Expression' Expression = fun.Expression };                            SimplificationReturnValue sretval = parser.EvaluateFunction(numClass' fun' expressionList);                            if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = sretval.IntValue.ToString();                          }                          if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = sretval.DoubleValue.ToString();                          }                      }                  }                    if (token.TokenName == TokenParser.Tokens.Variable)                  {                      if (_variables.ContainsKey(token.TokenValue))                      {                          var z = _variables[token.TokenValue];                            if (z.NumberType == NumberClass.NumberTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = z.FloatNumber.ToString();                          }                          else if (z.NumberType == NumberClass.NumberTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = z.IntNumber.ToString();                          }                      }                      else                      {                          throw new NoSuchVariableException(StringResources.Undefined_Variable + ": " + token.TokenValue);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Whitespace || token.TokenName == TokenParser.Tokens.Newline)                  {                      token = tp.GetToken();                      continue;                  }                  if (token.TokenName == TokenParser.Tokens.Integer || token.TokenName == TokenParser.Tokens.Float)                  {                      var nc = new NumberClass();                        switch (token.TokenName)                      {                          case TokenParser.Tokens.Float:                              nc.NumberType = NumberClass.NumberTypes.Float;                              nc.FloatNumber = double.Parse(token.TokenValue);                              break;                          case TokenParser.Tokens.Integer:                              nc.NumberType = NumberClass.NumberTypes.Integer;                              nc.IntNumber = int.Parse(token.TokenValue);                              break;                      }                      _outputQueue.Enqueue(nc);                  }                  if (IsOperator(token.TokenName))                  {                      if (_operatorStack.Count > 0)                      {                          while (_operatorStack.Count > 0)                          {                              var op = _operatorStack.Peek(); //o2                                    if (op == "(" || op == ")")                                  break;                              if ((GetPrecedence(token.TokenName) <= GetPrecedence(op) &&                                   IsLeftAssociative(token.TokenValue)) ||                                  !IsLeftAssociative(token.TokenValue) &&                                  GetPrecedence(token.TokenName) < GetPrecedence(op))                              {                                  op = _operatorStack.Pop();                                  var nc = new NumberClass { NumberType = NumberClass.NumberTypes.Operator' Operator = op };                                    _outputQueue.Enqueue(nc);                              }                              else break;                          }                      }                      _operatorStack.Push(token.TokenValue);                  }                  if (token.TokenName == TokenParser.Tokens.Lparen)                      _operatorStack.Push(token.TokenValue);                  if (token.TokenName == TokenParser.Tokens.Rparen)                  {                      if (_operatorStack.Count > 0)                      {                          var op = _operatorStack.Pop();                            while (op != "(")                          {                              var nc = new NumberClass { Operator = op' NumberType = NumberClass.NumberTypes.Operator };                                _outputQueue.Enqueue(nc);                                if (_operatorStack.Count > 0)                                  op = _operatorStack.Pop();                              else                              {                                  throw new MismatchedParenthesisException();                              }                          }                      }                      else                      {                          throw new MismatchedParenthesisException();                      }                  }                  token = tp.GetToken();              }
Magic Number,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: while (token != null)              {                  if (token.TokenName == TokenParser.Tokens.Sqrt)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv = EvaluateExpression(new NumberClass                                                                            {                                                                                Expression = expression'                                                                                NumberType = NumberClass.NumberTypes.Expression                                                                            });                          token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sqrt(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sqrt(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Sin)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sin(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sin(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Log)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue' 10).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue' 10).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.LogN)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Tan)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Tan(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Tan(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Abs)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Abs(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Abs(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Cos)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Cos(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Cos(rv.DoubleValue).ToString();                              break;                      }                  }                  if ((int)token.TokenName >= 100)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;  					  					foreach(var _f in _customFunctions)  					{  						if(_f.Key.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _customFunctions)                          {                              if (ff.Key.Equals(fn))                              {                                  var p = new Parser();                                  foreach (var cfr in _customFunctions)                                      p.AddCustomFunction(cfr.Key' cfr.Value);                                  foreach (var vr in _variables)                                      p.AddVariable(vr.Key' vr.Value);                                  foreach (var vf in _functions)                                      p.AddFunction(vf.Name' vf.Arguments' vf.Expression);                                    var ex = new SimplificationReturnValue[expressions.Length];   								  								for(var i = 0; i < expressions.Length; i++)  								{  									ex[i] = p.Simplify(expressions[i]);  								}                                    object funcRetval = null;                                    if (ff.Value.Method.ReturnType == typeof(int))                                  {                                      var intParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              intParams[ndx] = (int)pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              intParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(intParams);                                  }                                  if (ff.Value.Method.ReturnType == typeof(double))                                  {                                      var floatParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              floatParams[ndx] = pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              floatParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(floatParams);                                  }                                  if (ff.Value.Method.ReturnType==typeof(object))                                  {  									var ex2 = new SimplificationReturnValue[expressions.Length];  									  									for(var i = 0; i < ex2.Length; i++)  										ex2[i] = p.Simplify(expressions[i]);  									                                      funcRetval = ff.Value.DynamicInvoke(ex2);                                  }                                    //object funcRetval = ff.Value.DynamicInvoke(expressions.Select(p.Simplify).ToArray());                                    if (funcRetval is double)                                  {                                      token.TokenValue = ((double)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Float;                                  }                                  if (funcRetval is int)                                  {                                      token.TokenValue = ((int)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Integer;                                  }                                  if (funcRetval is SimplificationReturnValue)                                  {                                      var srv = (SimplificationReturnValue)funcRetval;                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                      {                                          token.TokenValue = srv.IntValue.ToString();                                          token.TokenName = TokenParser.Tokens.Integer;                                      }                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                      {                                          token.TokenValue = srv.DoubleValue.ToString();                                          token.TokenName = TokenParser.Tokens.Float;                                      }                                  }                                  break;                              }                          }                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Function)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1).Remove(0' 4);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;                      FunctionClass fun = null;  					  					foreach(var _f in _functions)  					{  						if(_f.Name.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _functions)                              if (ff.Name.Equals(fn))                                  fun = ff;                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                        var parser = new Parser();                      foreach (var cfh in _customFunctions)                          parser.AddCustomFunction(cfh.Key' cfh.Value);                        foreach (var v in _variables)                      {                          if (v.Value.NumberType == NumberClass.NumberTypes.Float)                          {                              parser.AddVariable(v.Key' v.Value.FloatNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Integer)                          {                              parser.AddVariable(v.Key' v.Value.IntNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Expression)                          {                              parser.AddVariable(v.Key' v.Value.Expression);                          }                      }                        foreach (var f in _functions)                      {                          parser.AddFunction(f.Name' f.Arguments' f.Expression);                      }                      var expressionList = new List<NumberClass>();                        foreach (var expression in expressions)                      {                          SimplificationReturnValue simRetval = parser.Simplify(expression);                            var numClass = new NumberClass();                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              numClass.FloatNumber = simRetval.DoubleValue;                              numClass.NumberType = NumberClass.NumberTypes.Float;                          }                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              numClass.IntNumber = simRetval.IntValue;                              numClass.NumberType = NumberClass.NumberTypes.Integer;                          }                          expressionList.Add(numClass);                      }                        if (fun != null)                      {                          var numClass = new NumberClass { NumberType = NumberClass.NumberTypes.Expression' Expression = fun.Expression };                            SimplificationReturnValue sretval = parser.EvaluateFunction(numClass' fun' expressionList);                            if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = sretval.IntValue.ToString();                          }                          if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = sretval.DoubleValue.ToString();                          }                      }                  }                    if (token.TokenName == TokenParser.Tokens.Variable)                  {                      if (_variables.ContainsKey(token.TokenValue))                      {                          var z = _variables[token.TokenValue];                            if (z.NumberType == NumberClass.NumberTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = z.FloatNumber.ToString();                          }                          else if (z.NumberType == NumberClass.NumberTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = z.IntNumber.ToString();                          }                      }                      else                      {                          throw new NoSuchVariableException(StringResources.Undefined_Variable + ": " + token.TokenValue);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Whitespace || token.TokenName == TokenParser.Tokens.Newline)                  {                      token = tp.GetToken();                      continue;                  }                  if (token.TokenName == TokenParser.Tokens.Integer || token.TokenName == TokenParser.Tokens.Float)                  {                      var nc = new NumberClass();                        switch (token.TokenName)                      {                          case TokenParser.Tokens.Float:                              nc.NumberType = NumberClass.NumberTypes.Float;                              nc.FloatNumber = double.Parse(token.TokenValue);                              break;                          case TokenParser.Tokens.Integer:                              nc.NumberType = NumberClass.NumberTypes.Integer;                              nc.IntNumber = int.Parse(token.TokenValue);                              break;                      }                      _outputQueue.Enqueue(nc);                  }                  if (IsOperator(token.TokenName))                  {                      if (_operatorStack.Count > 0)                      {                          while (_operatorStack.Count > 0)                          {                              var op = _operatorStack.Peek(); //o2                                    if (op == "(" || op == ")")                                  break;                              if ((GetPrecedence(token.TokenName) <= GetPrecedence(op) &&                                   IsLeftAssociative(token.TokenValue)) ||                                  !IsLeftAssociative(token.TokenValue) &&                                  GetPrecedence(token.TokenName) < GetPrecedence(op))                              {                                  op = _operatorStack.Pop();                                  var nc = new NumberClass { NumberType = NumberClass.NumberTypes.Operator' Operator = op };                                    _outputQueue.Enqueue(nc);                              }                              else break;                          }                      }                      _operatorStack.Push(token.TokenValue);                  }                  if (token.TokenName == TokenParser.Tokens.Lparen)                      _operatorStack.Push(token.TokenValue);                  if (token.TokenName == TokenParser.Tokens.Rparen)                  {                      if (_operatorStack.Count > 0)                      {                          var op = _operatorStack.Pop();                            while (op != "(")                          {                              var nc = new NumberClass { Operator = op' NumberType = NumberClass.NumberTypes.Operator };                                _outputQueue.Enqueue(nc);                                if (_operatorStack.Count > 0)                                  op = _operatorStack.Pop();                              else                              {                                  throw new MismatchedParenthesisException();                              }                          }                      }                      else                      {                          throw new MismatchedParenthesisException();                      }                  }                  token = tp.GetToken();              }
Magic Number,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: while (token != null)              {                  if (token.TokenName == TokenParser.Tokens.Sqrt)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv = EvaluateExpression(new NumberClass                                                                            {                                                                                Expression = expression'                                                                                NumberType = NumberClass.NumberTypes.Expression                                                                            });                          token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sqrt(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sqrt(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Sin)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sin(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sin(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Log)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue' 10).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue' 10).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.LogN)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Tan)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Tan(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Tan(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Abs)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Abs(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Abs(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Cos)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Cos(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Cos(rv.DoubleValue).ToString();                              break;                      }                  }                  if ((int)token.TokenName >= 100)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;  					  					foreach(var _f in _customFunctions)  					{  						if(_f.Key.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _customFunctions)                          {                              if (ff.Key.Equals(fn))                              {                                  var p = new Parser();                                  foreach (var cfr in _customFunctions)                                      p.AddCustomFunction(cfr.Key' cfr.Value);                                  foreach (var vr in _variables)                                      p.AddVariable(vr.Key' vr.Value);                                  foreach (var vf in _functions)                                      p.AddFunction(vf.Name' vf.Arguments' vf.Expression);                                    var ex = new SimplificationReturnValue[expressions.Length];   								  								for(var i = 0; i < expressions.Length; i++)  								{  									ex[i] = p.Simplify(expressions[i]);  								}                                    object funcRetval = null;                                    if (ff.Value.Method.ReturnType == typeof(int))                                  {                                      var intParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              intParams[ndx] = (int)pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              intParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(intParams);                                  }                                  if (ff.Value.Method.ReturnType == typeof(double))                                  {                                      var floatParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              floatParams[ndx] = pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              floatParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(floatParams);                                  }                                  if (ff.Value.Method.ReturnType==typeof(object))                                  {  									var ex2 = new SimplificationReturnValue[expressions.Length];  									  									for(var i = 0; i < ex2.Length; i++)  										ex2[i] = p.Simplify(expressions[i]);  									                                      funcRetval = ff.Value.DynamicInvoke(ex2);                                  }                                    //object funcRetval = ff.Value.DynamicInvoke(expressions.Select(p.Simplify).ToArray());                                    if (funcRetval is double)                                  {                                      token.TokenValue = ((double)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Float;                                  }                                  if (funcRetval is int)                                  {                                      token.TokenValue = ((int)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Integer;                                  }                                  if (funcRetval is SimplificationReturnValue)                                  {                                      var srv = (SimplificationReturnValue)funcRetval;                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                      {                                          token.TokenValue = srv.IntValue.ToString();                                          token.TokenName = TokenParser.Tokens.Integer;                                      }                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                      {                                          token.TokenValue = srv.DoubleValue.ToString();                                          token.TokenName = TokenParser.Tokens.Float;                                      }                                  }                                  break;                              }                          }                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Function)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1).Remove(0' 4);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;                      FunctionClass fun = null;  					  					foreach(var _f in _functions)  					{  						if(_f.Name.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _functions)                              if (ff.Name.Equals(fn))                                  fun = ff;                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                        var parser = new Parser();                      foreach (var cfh in _customFunctions)                          parser.AddCustomFunction(cfh.Key' cfh.Value);                        foreach (var v in _variables)                      {                          if (v.Value.NumberType == NumberClass.NumberTypes.Float)                          {                              parser.AddVariable(v.Key' v.Value.FloatNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Integer)                          {                              parser.AddVariable(v.Key' v.Value.IntNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Expression)                          {                              parser.AddVariable(v.Key' v.Value.Expression);                          }                      }                        foreach (var f in _functions)                      {                          parser.AddFunction(f.Name' f.Arguments' f.Expression);                      }                      var expressionList = new List<NumberClass>();                        foreach (var expression in expressions)                      {                          SimplificationReturnValue simRetval = parser.Simplify(expression);                            var numClass = new NumberClass();                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              numClass.FloatNumber = simRetval.DoubleValue;                              numClass.NumberType = NumberClass.NumberTypes.Float;                          }                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              numClass.IntNumber = simRetval.IntValue;                              numClass.NumberType = NumberClass.NumberTypes.Integer;                          }                          expressionList.Add(numClass);                      }                        if (fun != null)                      {                          var numClass = new NumberClass { NumberType = NumberClass.NumberTypes.Expression' Expression = fun.Expression };                            SimplificationReturnValue sretval = parser.EvaluateFunction(numClass' fun' expressionList);                            if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = sretval.IntValue.ToString();                          }                          if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = sretval.DoubleValue.ToString();                          }                      }                  }                    if (token.TokenName == TokenParser.Tokens.Variable)                  {                      if (_variables.ContainsKey(token.TokenValue))                      {                          var z = _variables[token.TokenValue];                            if (z.NumberType == NumberClass.NumberTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = z.FloatNumber.ToString();                          }                          else if (z.NumberType == NumberClass.NumberTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = z.IntNumber.ToString();                          }                      }                      else                      {                          throw new NoSuchVariableException(StringResources.Undefined_Variable + ": " + token.TokenValue);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Whitespace || token.TokenName == TokenParser.Tokens.Newline)                  {                      token = tp.GetToken();                      continue;                  }                  if (token.TokenName == TokenParser.Tokens.Integer || token.TokenName == TokenParser.Tokens.Float)                  {                      var nc = new NumberClass();                        switch (token.TokenName)                      {                          case TokenParser.Tokens.Float:                              nc.NumberType = NumberClass.NumberTypes.Float;                              nc.FloatNumber = double.Parse(token.TokenValue);                              break;                          case TokenParser.Tokens.Integer:                              nc.NumberType = NumberClass.NumberTypes.Integer;                              nc.IntNumber = int.Parse(token.TokenValue);                              break;                      }                      _outputQueue.Enqueue(nc);                  }                  if (IsOperator(token.TokenName))                  {                      if (_operatorStack.Count > 0)                      {                          while (_operatorStack.Count > 0)                          {                              var op = _operatorStack.Peek(); //o2                                    if (op == "(" || op == ")")                                  break;                              if ((GetPrecedence(token.TokenName) <= GetPrecedence(op) &&                                   IsLeftAssociative(token.TokenValue)) ||                                  !IsLeftAssociative(token.TokenValue) &&                                  GetPrecedence(token.TokenName) < GetPrecedence(op))                              {                                  op = _operatorStack.Pop();                                  var nc = new NumberClass { NumberType = NumberClass.NumberTypes.Operator' Operator = op };                                    _outputQueue.Enqueue(nc);                              }                              else break;                          }                      }                      _operatorStack.Push(token.TokenValue);                  }                  if (token.TokenName == TokenParser.Tokens.Lparen)                      _operatorStack.Push(token.TokenValue);                  if (token.TokenName == TokenParser.Tokens.Rparen)                  {                      if (_operatorStack.Count > 0)                      {                          var op = _operatorStack.Pop();                            while (op != "(")                          {                              var nc = new NumberClass { Operator = op' NumberType = NumberClass.NumberTypes.Operator };                                _outputQueue.Enqueue(nc);                                if (_operatorStack.Count > 0)                                  op = _operatorStack.Pop();                              else                              {                                  throw new MismatchedParenthesisException();                              }                          }                      }                      else                      {                          throw new MismatchedParenthesisException();                      }                  }                  token = tp.GetToken();              }
Magic Number,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: while (token != null)              {                  if (token.TokenName == TokenParser.Tokens.Sqrt)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv = EvaluateExpression(new NumberClass                                                                            {                                                                                Expression = expression'                                                                                NumberType = NumberClass.NumberTypes.Expression                                                                            });                          token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sqrt(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sqrt(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Sin)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sin(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sin(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Log)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue' 10).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue' 10).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.LogN)                  {                      string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);                        SimplificationReturnValue rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Tan)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Tan(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Tan(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Abs)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Abs(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Abs(rv.DoubleValue).ToString();                              break;                      }                  }                  if (token.TokenName == TokenParser.Tokens.Cos)                  {                      string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);                        var rv =                          EvaluateExpression(new NumberClass                          {                              Expression = expression'                              NumberType = NumberClass.NumberTypes.Expression                          });                        token.TokenName = TokenParser.Tokens.Float;                        switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Cos(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Cos(rv.DoubleValue).ToString();                              break;                      }                  }                  if ((int)token.TokenName >= 100)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;  					  					foreach(var _f in _customFunctions)  					{  						if(_f.Key.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _customFunctions)                          {                              if (ff.Key.Equals(fn))                              {                                  var p = new Parser();                                  foreach (var cfr in _customFunctions)                                      p.AddCustomFunction(cfr.Key' cfr.Value);                                  foreach (var vr in _variables)                                      p.AddVariable(vr.Key' vr.Value);                                  foreach (var vf in _functions)                                      p.AddFunction(vf.Name' vf.Arguments' vf.Expression);                                    var ex = new SimplificationReturnValue[expressions.Length];   								  								for(var i = 0; i < expressions.Length; i++)  								{  									ex[i] = p.Simplify(expressions[i]);  								}                                    object funcRetval = null;                                    if (ff.Value.Method.ReturnType == typeof(int))                                  {                                      var intParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              intParams[ndx] = (int)pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              intParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(intParams);                                  }                                  if (ff.Value.Method.ReturnType == typeof(double))                                  {                                      var floatParams = new object[ex.Length];                                      int ndx = 0;                                        foreach (var pp in ex)                                      {                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                              floatParams[ndx] = pp.DoubleValue;                                          if (pp.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                              floatParams[ndx] = pp.IntValue;                                          ndx++;                                      }                                      funcRetval = ff.Value.DynamicInvoke(floatParams);                                  }                                  if (ff.Value.Method.ReturnType==typeof(object))                                  {  									var ex2 = new SimplificationReturnValue[expressions.Length];  									  									for(var i = 0; i < ex2.Length; i++)  										ex2[i] = p.Simplify(expressions[i]);  									                                      funcRetval = ff.Value.DynamicInvoke(ex2);                                  }                                    //object funcRetval = ff.Value.DynamicInvoke(expressions.Select(p.Simplify).ToArray());                                    if (funcRetval is double)                                  {                                      token.TokenValue = ((double)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Float;                                  }                                  if (funcRetval is int)                                  {                                      token.TokenValue = ((int)funcRetval).ToString();                                      token.TokenName = TokenParser.Tokens.Integer;                                  }                                  if (funcRetval is SimplificationReturnValue)                                  {                                      var srv = (SimplificationReturnValue)funcRetval;                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                                      {                                          token.TokenValue = srv.IntValue.ToString();                                          token.TokenName = TokenParser.Tokens.Integer;                                      }                                      if (srv.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                                      {                                          token.TokenValue = srv.DoubleValue.ToString();                                          token.TokenName = TokenParser.Tokens.Float;                                      }                                  }                                  break;                              }                          }                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Function)                  {                      int ndx1 = token.TokenValue.IndexOf("(");                      string fn = token.TokenValue.Substring(0' ndx1).Remove(0' 4);                      string origExpression = token.TokenValue.Substring(ndx1);                      string[] expressions = origExpression.Replace("'"' ")'(").Split(''');                      bool found = false;                      FunctionClass fun = null;  					  					foreach(var _f in _functions)  					{  						if(_f.Name.Equals(fn))  						{  							found = true;  							break;  						}  					}                        if (found)                      {                          foreach (var ff in _functions)                              if (ff.Name.Equals(fn))                                  fun = ff;                      }                        if (!found)                      {                          throw new NoSuchFunctionException(StringResources.No_such_function_defined + ": " + fn);                      }                        var parser = new Parser();                      foreach (var cfh in _customFunctions)                          parser.AddCustomFunction(cfh.Key' cfh.Value);                        foreach (var v in _variables)                      {                          if (v.Value.NumberType == NumberClass.NumberTypes.Float)                          {                              parser.AddVariable(v.Key' v.Value.FloatNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Integer)                          {                              parser.AddVariable(v.Key' v.Value.IntNumber);                          }                          if (v.Value.NumberType == NumberClass.NumberTypes.Expression)                          {                              parser.AddVariable(v.Key' v.Value.Expression);                          }                      }                        foreach (var f in _functions)                      {                          parser.AddFunction(f.Name' f.Arguments' f.Expression);                      }                      var expressionList = new List<NumberClass>();                        foreach (var expression in expressions)                      {                          SimplificationReturnValue simRetval = parser.Simplify(expression);                            var numClass = new NumberClass();                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              numClass.FloatNumber = simRetval.DoubleValue;                              numClass.NumberType = NumberClass.NumberTypes.Float;                          }                          if (simRetval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              numClass.IntNumber = simRetval.IntValue;                              numClass.NumberType = NumberClass.NumberTypes.Integer;                          }                          expressionList.Add(numClass);                      }                        if (fun != null)                      {                          var numClass = new NumberClass { NumberType = NumberClass.NumberTypes.Expression' Expression = fun.Expression };                            SimplificationReturnValue sretval = parser.EvaluateFunction(numClass' fun' expressionList);                            if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = sretval.IntValue.ToString();                          }                          if (sretval != null && sretval.ReturnType == SimplificationReturnValue.ReturnTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = sretval.DoubleValue.ToString();                          }                      }                  }                    if (token.TokenName == TokenParser.Tokens.Variable)                  {                      if (_variables.ContainsKey(token.TokenValue))                      {                          var z = _variables[token.TokenValue];                            if (z.NumberType == NumberClass.NumberTypes.Float)                          {                              token.TokenName = TokenParser.Tokens.Float;                              token.TokenValue = z.FloatNumber.ToString();                          }                          else if (z.NumberType == NumberClass.NumberTypes.Integer)                          {                              token.TokenName = TokenParser.Tokens.Integer;                              token.TokenValue = z.IntNumber.ToString();                          }                      }                      else                      {                          throw new NoSuchVariableException(StringResources.Undefined_Variable + ": " + token.TokenValue);                      }                  }                    if (token.TokenName == TokenParser.Tokens.Whitespace || token.TokenName == TokenParser.Tokens.Newline)                  {                      token = tp.GetToken();                      continue;                  }                  if (token.TokenName == TokenParser.Tokens.Integer || token.TokenName == TokenParser.Tokens.Float)                  {                      var nc = new NumberClass();                        switch (token.TokenName)                      {                          case TokenParser.Tokens.Float:                              nc.NumberType = NumberClass.NumberTypes.Float;                              nc.FloatNumber = double.Parse(token.TokenValue);                              break;                          case TokenParser.Tokens.Integer:                              nc.NumberType = NumberClass.NumberTypes.Integer;                              nc.IntNumber = int.Parse(token.TokenValue);                              break;                      }                      _outputQueue.Enqueue(nc);                  }                  if (IsOperator(token.TokenName))                  {                      if (_operatorStack.Count > 0)                      {                          while (_operatorStack.Count > 0)                          {                              var op = _operatorStack.Peek(); //o2                                    if (op == "(" || op == ")")                                  break;                              if ((GetPrecedence(token.TokenName) <= GetPrecedence(op) &&                                   IsLeftAssociative(token.TokenValue)) ||                                  !IsLeftAssociative(token.TokenValue) &&                                  GetPrecedence(token.TokenName) < GetPrecedence(op))                              {                                  op = _operatorStack.Pop();                                  var nc = new NumberClass { NumberType = NumberClass.NumberTypes.Operator' Operator = op };                                    _outputQueue.Enqueue(nc);                              }                              else break;                          }                      }                      _operatorStack.Push(token.TokenValue);                  }                  if (token.TokenName == TokenParser.Tokens.Lparen)                      _operatorStack.Push(token.TokenValue);                  if (token.TokenName == TokenParser.Tokens.Rparen)                  {                      if (_operatorStack.Count > 0)                      {                          var op = _operatorStack.Pop();                            while (op != "(")                          {                              var nc = new NumberClass { Operator = op' NumberType = NumberClass.NumberTypes.Operator };                                _outputQueue.Enqueue(nc);                                if (_operatorStack.Count > 0)                                  op = _operatorStack.Pop();                              else                              {                                  throw new MismatchedParenthesisException();                              }                          }                      }                      else                      {                          throw new MismatchedParenthesisException();                      }                  }                  token = tp.GetToken();              }
Magic Number,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,GetPrecedence,The following statement contains a magic number: if (token == TokenParser.Tokens.Multiply || token == TokenParser.Tokens.Divide || token == TokenParser.Tokens.Modulus)                  return 2;
Magic Number,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,GetPrecedence,The following statement contains a magic number: if (token == TokenParser.Tokens.Exponent)                  return 3;
Magic Number,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,GetPrecedence,The following statement contains a magic number: if (token == TokenParser.Tokens.Lparen || token == TokenParser.Tokens.Rparen)                  return 4;
Magic Number,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,GetPrecedence,The following statement contains a magic number: if (op.Equals("*") || op.Equals("/") || op.Equals("%"))                  return 2;
Magic Number,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,GetPrecedence,The following statement contains a magic number: if (op.Equals("^"))                  return 3;
Magic Number,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,GetPrecedence,The following statement contains a magic number: if (op.Equals("(") || op.Equals(")"))                  return 4;
Magic Number,MathParserNet,SimplificationReturnValue,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\SimplificationReturnValue.cs,ToFraction,The following statement contains a magic number: for (int i=2;i<=factor;i++)              {                  double error2 = Math.Abs(d - Math.Round(d*i)/i);                  if (error2<error)                  {                      error = error2;                      bestDenominator = i;                  }              }
Magic Number,MathParserTK_NET,MathParserTK,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,MathParserTK,The following statement contains a magic number: operators = new Dictionary<string' string>(50);
Magic Number,MathParserTK_NET,MathParserTK,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,MathParserTK,The following statement contains a magic number: constants = new Dictionary<string' string>(10);
Magic Number,MathParserTK_NET,MathParserTK,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,GetPrioritet,The following statement contains a magic number: switch (op)              {                  case "leftParenthesis":                      return 0;                  case "rightParenthesis":                      return 1;                  case "plus":                  case "minus":                      return 2;                  case "unPlus":                  case "unMinus":                      return 6;                  case "multiply":                  case "division":                      return 4;                  case "degree":                  case "√":                  case "sqrt":                      return 8;                  case "sin":                  case "cos":                  case "tg":                  case "ctg":                  case "sh":                  case "ch":                  case "th":                  case "log":                  case "ln":                  case "exp":                  case "abs":                      return 10;                  default:                      return 0;              }
Magic Number,MathParserTK_NET,MathParserTK,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,GetPrioritet,The following statement contains a magic number: switch (op)              {                  case "leftParenthesis":                      return 0;                  case "rightParenthesis":                      return 1;                  case "plus":                  case "minus":                      return 2;                  case "unPlus":                  case "unMinus":                      return 6;                  case "multiply":                  case "division":                      return 4;                  case "degree":                  case "√":                  case "sqrt":                      return 8;                  case "sin":                  case "cos":                  case "tg":                  case "ctg":                  case "sh":                  case "ch":                  case "th":                  case "log":                  case "ln":                  case "exp":                  case "abs":                      return 10;                  default:                      return 0;              }
Magic Number,MathParserTK_NET,MathParserTK,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,GetPrioritet,The following statement contains a magic number: switch (op)              {                  case "leftParenthesis":                      return 0;                  case "rightParenthesis":                      return 1;                  case "plus":                  case "minus":                      return 2;                  case "unPlus":                  case "unMinus":                      return 6;                  case "multiply":                  case "division":                      return 4;                  case "degree":                  case "√":                  case "sqrt":                      return 8;                  case "sin":                  case "cos":                  case "tg":                  case "ctg":                  case "sh":                  case "ch":                  case "th":                  case "log":                  case "ln":                  case "exp":                  case "abs":                      return 10;                  default:                      return 0;              }
Magic Number,MathParserTK_NET,MathParserTK,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,GetPrioritet,The following statement contains a magic number: switch (op)              {                  case "leftParenthesis":                      return 0;                  case "rightParenthesis":                      return 1;                  case "plus":                  case "minus":                      return 2;                  case "unPlus":                  case "unMinus":                      return 6;                  case "multiply":                  case "division":                      return 4;                  case "degree":                  case "√":                  case "sqrt":                      return 8;                  case "sin":                  case "cos":                  case "tg":                  case "ctg":                  case "sh":                  case "ch":                  case "th":                  case "log":                  case "ln":                  case "exp":                  case "abs":                      return 10;                  default:                      return 0;              }
Magic Number,MathParserTK_NET,MathParserTK,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,GetPrioritet,The following statement contains a magic number: switch (op)              {                  case "leftParenthesis":                      return 0;                  case "rightParenthesis":                      return 1;                  case "plus":                  case "minus":                      return 2;                  case "unPlus":                  case "unMinus":                      return 6;                  case "multiply":                  case "division":                      return 4;                  case "degree":                  case "√":                  case "sqrt":                      return 8;                  case "sin":                  case "cos":                  case "tg":                  case "ctg":                  case "sh":                  case "ch":                  case "th":                  case "log":                  case "ln":                  case "exp":                  case "abs":                      return 10;                  default:                      return 0;              }
Magic Number,MathParserTK_NET,MathParserTK,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,GetNumberArguments,The following statement contains a magic number: switch (op)              {                  case "plus":                  case "minus":                  case "multiply":                  case "division":                  case "degree":                  case "log":                                      return 2;                  case "unMinus":                  case "unPlus":                  case "√":                  case "sqrt":                  case "tg":                  case "sh":                  case "ch":                  case "th":                  case "ln":                  case "ctg":                  case "sin":                  case "cos":                  case "exp":                  case "abs":                      return 1;                  default:                      return 0;              }
Magic Number,MathParserTK_NET,MathParserTK,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,LexicalAnalyze,The following statement contains a magic number: if (Char.IsDigit(infixExp[pos]))                  for (int i = pos; i < infixExp.Length && (Char.IsDigit(infixExp[i]) || infixExp[i] == decimalSeparator); i++)                      token += infixExp[i];              else                  if (!(Char.IsDigit(infixExp[pos]) || infixExp[pos] == decimalSeparator))                      for (int i = pos; (i < infixExp.Length) && !(Char.IsDigit(infixExp[i]) || infixExp[i] == decimalSeparator); i++)                      {                          token += infixExp[i];                          pos = i;                          if (operators.ContainsValue(token) || constants.ContainsValue(token))                          {                              if (constants.ContainsValue(token))                              {                                    if (token == "e")                                  {                                      try                                      {                                          if (infixExp.Substring(pos' 3) == "exp")                                          {                                              token = "exp";                                              return token;                                          }                                      }                                      catch (Exception)                                      {                                      }                                        //throw exception if this number in scientific notation (for example 1E +10)                                      bool preC = false;                                      try                                      {                                          if (char.IsDigit(preToken[0]) || char.IsDigit(infixExp[pos + 1])                                              || (infixExp[pos + 1] == '+') || (infixExp[pos + 1] == '-'))                                          {                                              preC = true;                                              throw new Exception();                                          }                                      }                                      catch (Exception)                                      {                                          if (preC) throw new Exception();                                      }                                    }                                  //get value of constant                                  token = GetKeyInConstants(token);                              }                              else if (operators.ContainsValue(token))                              {                                  token = GetKeyInOperators(token);                                  if (unarnyi && token == "minus") token = "unMinus";                                  if (unarnyi && token == "plus") token = "unPlus";                                  // function must be with parenthesis                                  if (IsFunction(token))                                  {                                      if (infixExp[pos + 1] != '(')                                          throw new Exception();                                  }                              }                              break;                          }                      }
Magic Number,MathParserTK_NET,MathParserTK,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,Calculate,The following statement contains a magic number: while (pos < RPNExp.Length)              {                  string token = LexicalAnalyze(RPNExp); //lexical analysis                  RPNExp = RPNExp.Remove(pos' token.Length);                    if (token == " ")                  {                      continue;                  }                    if (operators.ContainsKey(token))                  {                      if (GetNumberArguments(token) == 1)                      {                          double arg = Convert.ToDouble(stack.Pop());                            switch (token)                          {                              case "unMinus": stack.Push((-1 * arg).ToString()); break;                              case "unPlus": stack.Push(arg.ToString()); break;                              case "sqrt":                              case "√": stack.Push((Math.Sqrt(arg)).ToString()); break;                              case "sin":                                  if (radians)                                      stack.Push((Math.Sin(arg)).ToString());                                  else                                      stack.Push((Math.Sin(arg * Math.PI / 180)).ToString()); break;                              case "cos":                                  if (radians)                                      stack.Push((Math.Cos(arg)).ToString());                                  else                                      stack.Push((Math.Cos(arg * Math.PI / 180)).ToString()); break;                              case "tg":                                  if (radians)                                      stack.Push((Math.Tan(arg)).ToString());                                  else                                      stack.Push((Math.Tan(arg * Math.PI / 180)).ToString()); break;                              case "ctg":                                  if (radians)                                      stack.Push((1 / Math.Tan(arg)).ToString());                                  else                                      stack.Push((1 / Math.Tan(arg * Math.PI / 180)).ToString()); break;                              case "sh": stack.Push((Math.Sinh(arg)).ToString()); break;                              case "ch": stack.Push((Math.Cosh(arg)).ToString()); break;                              case "th": stack.Push((Math.Tanh(arg)).ToString()); break;                              case "ln": stack.Push((Math.Log(arg)).ToString()); break;                              case "exp": stack.Push((Math.Exp(arg)).ToString()); break;                              case "abs": stack.Push((Math.Abs(arg)).ToString()); break;                          }                      }                      else                      {                          double arg2 = Convert.ToDouble(stack.Pop());                          double arg1 = Convert.ToDouble(stack.Pop());                            switch (token)                          {                              case "plus": stack.Push((arg1 + arg2).ToString()); break;                              case "minus": stack.Push((arg1 - arg2).ToString()); break;                              case "multiply": stack.Push((arg1 * arg2).ToString()); break;                              case "division":                                  if (arg2 == 0)                                      throw new DivideByZeroException();                                  stack.Push((arg1 / arg2).ToString()); break;                              case "degree": stack.Push((Math.Pow(arg1' arg2).ToString())); break;                              case "log": stack.Push((Math.Log(arg2) / Math.Log(arg1)).ToString()); break;                          }                      }                  }                  else                      stack.Push(token);              }
Magic Number,MathParserTK_NET,MathParserTK,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,Calculate,The following statement contains a magic number: while (pos < RPNExp.Length)              {                  string token = LexicalAnalyze(RPNExp); //lexical analysis                  RPNExp = RPNExp.Remove(pos' token.Length);                    if (token == " ")                  {                      continue;                  }                    if (operators.ContainsKey(token))                  {                      if (GetNumberArguments(token) == 1)                      {                          double arg = Convert.ToDouble(stack.Pop());                            switch (token)                          {                              case "unMinus": stack.Push((-1 * arg).ToString()); break;                              case "unPlus": stack.Push(arg.ToString()); break;                              case "sqrt":                              case "√": stack.Push((Math.Sqrt(arg)).ToString()); break;                              case "sin":                                  if (radians)                                      stack.Push((Math.Sin(arg)).ToString());                                  else                                      stack.Push((Math.Sin(arg * Math.PI / 180)).ToString()); break;                              case "cos":                                  if (radians)                                      stack.Push((Math.Cos(arg)).ToString());                                  else                                      stack.Push((Math.Cos(arg * Math.PI / 180)).ToString()); break;                              case "tg":                                  if (radians)                                      stack.Push((Math.Tan(arg)).ToString());                                  else                                      stack.Push((Math.Tan(arg * Math.PI / 180)).ToString()); break;                              case "ctg":                                  if (radians)                                      stack.Push((1 / Math.Tan(arg)).ToString());                                  else                                      stack.Push((1 / Math.Tan(arg * Math.PI / 180)).ToString()); break;                              case "sh": stack.Push((Math.Sinh(arg)).ToString()); break;                              case "ch": stack.Push((Math.Cosh(arg)).ToString()); break;                              case "th": stack.Push((Math.Tanh(arg)).ToString()); break;                              case "ln": stack.Push((Math.Log(arg)).ToString()); break;                              case "exp": stack.Push((Math.Exp(arg)).ToString()); break;                              case "abs": stack.Push((Math.Abs(arg)).ToString()); break;                          }                      }                      else                      {                          double arg2 = Convert.ToDouble(stack.Pop());                          double arg1 = Convert.ToDouble(stack.Pop());                            switch (token)                          {                              case "plus": stack.Push((arg1 + arg2).ToString()); break;                              case "minus": stack.Push((arg1 - arg2).ToString()); break;                              case "multiply": stack.Push((arg1 * arg2).ToString()); break;                              case "division":                                  if (arg2 == 0)                                      throw new DivideByZeroException();                                  stack.Push((arg1 / arg2).ToString()); break;                              case "degree": stack.Push((Math.Pow(arg1' arg2).ToString())); break;                              case "log": stack.Push((Math.Log(arg2) / Math.Log(arg1)).ToString()); break;                          }                      }                  }                  else                      stack.Push(token);              }
Magic Number,MathParserTK_NET,MathParserTK,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,Calculate,The following statement contains a magic number: while (pos < RPNExp.Length)              {                  string token = LexicalAnalyze(RPNExp); //lexical analysis                  RPNExp = RPNExp.Remove(pos' token.Length);                    if (token == " ")                  {                      continue;                  }                    if (operators.ContainsKey(token))                  {                      if (GetNumberArguments(token) == 1)                      {                          double arg = Convert.ToDouble(stack.Pop());                            switch (token)                          {                              case "unMinus": stack.Push((-1 * arg).ToString()); break;                              case "unPlus": stack.Push(arg.ToString()); break;                              case "sqrt":                              case "√": stack.Push((Math.Sqrt(arg)).ToString()); break;                              case "sin":                                  if (radians)                                      stack.Push((Math.Sin(arg)).ToString());                                  else                                      stack.Push((Math.Sin(arg * Math.PI / 180)).ToString()); break;                              case "cos":                                  if (radians)                                      stack.Push((Math.Cos(arg)).ToString());                                  else                                      stack.Push((Math.Cos(arg * Math.PI / 180)).ToString()); break;                              case "tg":                                  if (radians)                                      stack.Push((Math.Tan(arg)).ToString());                                  else                                      stack.Push((Math.Tan(arg * Math.PI / 180)).ToString()); break;                              case "ctg":                                  if (radians)                                      stack.Push((1 / Math.Tan(arg)).ToString());                                  else                                      stack.Push((1 / Math.Tan(arg * Math.PI / 180)).ToString()); break;                              case "sh": stack.Push((Math.Sinh(arg)).ToString()); break;                              case "ch": stack.Push((Math.Cosh(arg)).ToString()); break;                              case "th": stack.Push((Math.Tanh(arg)).ToString()); break;                              case "ln": stack.Push((Math.Log(arg)).ToString()); break;                              case "exp": stack.Push((Math.Exp(arg)).ToString()); break;                              case "abs": stack.Push((Math.Abs(arg)).ToString()); break;                          }                      }                      else                      {                          double arg2 = Convert.ToDouble(stack.Pop());                          double arg1 = Convert.ToDouble(stack.Pop());                            switch (token)                          {                              case "plus": stack.Push((arg1 + arg2).ToString()); break;                              case "minus": stack.Push((arg1 - arg2).ToString()); break;                              case "multiply": stack.Push((arg1 * arg2).ToString()); break;                              case "division":                                  if (arg2 == 0)                                      throw new DivideByZeroException();                                  stack.Push((arg1 / arg2).ToString()); break;                              case "degree": stack.Push((Math.Pow(arg1' arg2).ToString())); break;                              case "log": stack.Push((Math.Log(arg2) / Math.Log(arg1)).ToString()); break;                          }                      }                  }                  else                      stack.Push(token);              }
Magic Number,MathParserTK_NET,MathParserTK,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,Calculate,The following statement contains a magic number: while (pos < RPNExp.Length)              {                  string token = LexicalAnalyze(RPNExp); //lexical analysis                  RPNExp = RPNExp.Remove(pos' token.Length);                    if (token == " ")                  {                      continue;                  }                    if (operators.ContainsKey(token))                  {                      if (GetNumberArguments(token) == 1)                      {                          double arg = Convert.ToDouble(stack.Pop());                            switch (token)                          {                              case "unMinus": stack.Push((-1 * arg).ToString()); break;                              case "unPlus": stack.Push(arg.ToString()); break;                              case "sqrt":                              case "√": stack.Push((Math.Sqrt(arg)).ToString()); break;                              case "sin":                                  if (radians)                                      stack.Push((Math.Sin(arg)).ToString());                                  else                                      stack.Push((Math.Sin(arg * Math.PI / 180)).ToString()); break;                              case "cos":                                  if (radians)                                      stack.Push((Math.Cos(arg)).ToString());                                  else                                      stack.Push((Math.Cos(arg * Math.PI / 180)).ToString()); break;                              case "tg":                                  if (radians)                                      stack.Push((Math.Tan(arg)).ToString());                                  else                                      stack.Push((Math.Tan(arg * Math.PI / 180)).ToString()); break;                              case "ctg":                                  if (radians)                                      stack.Push((1 / Math.Tan(arg)).ToString());                                  else                                      stack.Push((1 / Math.Tan(arg * Math.PI / 180)).ToString()); break;                              case "sh": stack.Push((Math.Sinh(arg)).ToString()); break;                              case "ch": stack.Push((Math.Cosh(arg)).ToString()); break;                              case "th": stack.Push((Math.Tanh(arg)).ToString()); break;                              case "ln": stack.Push((Math.Log(arg)).ToString()); break;                              case "exp": stack.Push((Math.Exp(arg)).ToString()); break;                              case "abs": stack.Push((Math.Abs(arg)).ToString()); break;                          }                      }                      else                      {                          double arg2 = Convert.ToDouble(stack.Pop());                          double arg1 = Convert.ToDouble(stack.Pop());                            switch (token)                          {                              case "plus": stack.Push((arg1 + arg2).ToString()); break;                              case "minus": stack.Push((arg1 - arg2).ToString()); break;                              case "multiply": stack.Push((arg1 * arg2).ToString()); break;                              case "division":                                  if (arg2 == 0)                                      throw new DivideByZeroException();                                  stack.Push((arg1 / arg2).ToString()); break;                              case "degree": stack.Push((Math.Pow(arg1' arg2).ToString())); break;                              case "log": stack.Push((Math.Log(arg2) / Math.Log(arg1)).ToString()); break;                          }                      }                  }                  else                      stack.Push(token);              }
Missing Default,CalcEngine,CalcEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,ParseAtom,The following switch statement is missing a default case: switch (_token.Type)  			{  				// literals  				case TKTYPE.LITERAL:  					x = new Expression(_token);  					break;                    // identifiers                  case TKTYPE.IDENTIFIER:                        // get identifier                      id = (string)_token.Value;                        // look for functions                      if (_fnTbl.TryGetValue(id' out fnDef))                      {                          var p = GetParameters();                          var pCnt = p == null ? 0 : p.Count;                          if (fnDef.ParmMin != -1 && pCnt < fnDef.ParmMin)                          {                              Throw("Too few parameters.");                          }                          if (fnDef.ParmMax != -1 && pCnt > fnDef.ParmMax)                          {                              Throw("Too many parameters.");                          }                          x = new FunctionExpression(fnDef' p);                          break;                      }                        // look for simple variables (much faster than binding!)                      if (_vars.ContainsKey(id))                      {                          x = new VariableExpression(_vars' id);                          break;                      }                        // look for external objects                      var xObj = GetExternalObject(id);                      if (xObj != null)                      {                          x = new XObjectExpression(xObj);                          break;                      }                        // look for bindings                      if (DataContext != null)                      {                          var list = new List<BindingInfo>();                          for (var t = _token; t != null; t = GetMember())                          {                              list.Add(new BindingInfo((string)t.Value' GetParameters()));                          }                          x = new BindingExpression(this' list' _ci);                          break;                      }                      Throw("Unexpected identifier");                      break;    		        // sub-expressions  		        case TKTYPE.GROUP:                        // anything other than opening parenthesis is illegal here  					if (_token.ID != TKID.OPEN)  					{                          Throw("Expression expected.");                      }    					// get expression  					GetToken();  					x = ParseCompare();    					// check that the parenthesis was closed  					if (_token.ID != TKID.CLOSE)  					{  						Throw("Unbalanced parenthesis.");  					}    					break;  		    }
Missing Default,CalcEngine,UnaryExpression,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Expression.cs,Evaluate,The following switch statement is missing a default case: switch (_token.ID)  			{  				case TKID.ADD:                      return +(double)_expr;  				case TKID.SUB:                      return -(double)_expr;  			}
Missing Default,CalcEngine,BinaryExpression,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Expression.cs,Evaluate,The following switch statement is missing a default case: switch (_token.ID)                  {                      case TKID.GT: return cmp > 0;                      case TKID.LT: return cmp < 0;                      case TKID.GE: return cmp >= 0;                      case TKID.LE: return cmp <= 0;                      case TKID.EQ: return cmp == 0;                      case TKID.NE: return cmp != 0;                  }
Missing Default,CalcEngine,BinaryExpression,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Expression.cs,Evaluate,The following switch statement is missing a default case: switch (_token.ID)  			{  				case TKID.ADD:                       return (double)_lft + (double)_rgt;  				case TKID.SUB:                       return (double)_lft - (double)_rgt;  				case TKID.MUL:                       return (double)_lft * (double)_rgt;  				case TKID.DIV:                       return (double)_lft / (double)_rgt;  				case TKID.DIVINT:                       return (double)(int)((double)_lft / (double)_rgt);  				case TKID.MOD:                       return (double)(int)((double)_lft % (double)_rgt);  				case TKID.POWER:                      var a = (double)_lft;                      var b = (double)_rgt;                      if (b == 0.0) return 1.0;                      if (b == 0.5) return Math.Sqrt(a);                      if (b == 1.0) return a;                      if (b == 2.0) return a * a;                      if (b == 3.0) return a * a * a;                      if (b == 4.0) return a * a * a * a;                      return Math.Pow((double)_lft' (double)_rgt);  			}
Missing Default,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,SemanticTransform,The following switch statement is missing a default case: switch (_traverseNode.Name)                  {                       case Nonterminal.Expression:                          this.ExpressionToTermW(stack);                          break;                      case Nonterminal.W:                          this.WtoXWorEps(stack);                          break;                      case Nonterminal.X:                          this.XtoMinusTermOrXtoPlusTerm(stack);                          break;                      case Nonterminal.Term:                          this.TermToPowerK(stack);                          break;                      case Nonterminal.K:                          this.KtoYKorKtoEps(stack);                          break;                      case Nonterminal.Y:                          this.YtoMultiplyPowerOrYtoDividePower(stack);                          break;                      case Nonterminal.Power:                          this.PowerToFactoV(stack);                          break;                      case Nonterminal.V:                          this.VtoZVorVtoEps(stack);                          break;                      case Nonterminal.Z:                          this.ZtoPowerFactor(stack);                          break;                      case Nonterminal.Factor:                          this.Factor(stack);                          break;                      case Nonterminal.ParenthesisClose:                          this.ParanthesisClose(stack);                          break;                      case Nonterminal.End:                          this.End(stack);                          break;                      case Nonterminal.AnyValue:                          break;                  }
Missing Default,MathParserDataStructures,MathObj,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,CalculateValue,The following switch statement is missing a default case: switch (this._polishPostfixExpression[i])                  {                      case Operation.UnaryMinus:                          stack.Push(0);                          break;                      case Operation.UnaryPlus:                          stack.Push(0);                          break;                      case Operation.Variable:                          stack.Push(this._varsAndValues[this._listOfVariableInputs[indexVariables++]]);                          break;                      case Operation.AnyReal:                          stack.Push(this._listOfDoubleInputs[indexValues++]);                          break;                      case Operation.Sin:                          stack.Push(Math.Sin(stack.Pop()));                          break;                      case Operation.Cos:                          stack.Push(Math.Cos(stack.Pop()));                          break;                      case Operation.Cot:                          stack.Push(1 / Math.Tan(stack.Pop()));                          break;                      case Operation.Sqrt:                          stack.Push(Math.Sqrt(stack.Pop()));                          break;                      case Operation.Asin:                          stack.Push(Math.Asin(stack.Pop()));                          break;                      case Operation.Acos:                          stack.Push(Math.Acos(stack.Pop()));                          break;                      case Operation.Atan:                          stack.Push(Math.Atan(stack.Pop()));                          break;                      case Operation.Acot:                          stack.Push(Math.Atan(1 / stack.Pop()));                          break;                      case Operation.Sec:                          stack.Push(1 / Math.Cos(stack.Pop()));                          break;                      case Operation.Csc:                          stack.Push(1 / Math.Sin(stack.Pop()));                          break;                      case Operation.Tan:                          stack.Push(Math.Tan(stack.Pop()));                          break;                      case Operation.Exp:                          stack.Push(Math.Exp(stack.Pop()));                          break;                      case Operation.Log:                          stack.Push(Math.Log(stack.Pop()));                          break;                      case Operation.Power:                          b = stack.Pop();                          a = stack.Pop();                          stack.Push(Math.Pow(a' b));                          break;                      case Operation.Plus:                          stack.Push(stack.Pop() + stack.Pop());                          break;                      case Operation.Minus:                          b = stack.Pop();                          a = stack.Pop();                          stack.Push(a - b);                          break;                      case Operation.Multiply:                          stack.Push(stack.Pop() * stack.Pop());                          break;                      case Operation.Divide:                          b = stack.Pop();                          a = stack.Pop();                          stack.Push(a / b);                          break;                  }
Missing Default,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following switch statement is missing a default case: switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}
Missing Default,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following switch statement is missing a default case: switch( m.Groups[2].Value )  				{  					case "*" :  						result = Convert.ToDouble( m.Groups[1].Value ) * Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = Expression.Replace( m.Value' "+" + result );  						m = regEx.Match( Expression );  						continue;  					case "/" :  						result = Convert.ToDouble( m.Groups[1].Value ) / Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = regEx.Replace( Expression' "+" + result' 1 );  						m = regEx.Match( Expression );  						continue;  				}
Missing Default,MathParser,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following switch statement is missing a default case: switch( m.Groups[2].Value )  				{  					case "+" :  						result = Convert.ToDouble( m.Groups[1].Value ) + Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = regEx.Replace( Expression' "+" + result' 1 );  						m = regEx.Match( Expression );  						continue;  					case "-" :  						result = Convert.ToDouble( m.Groups[1].Value ) - Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = regEx.Replace( Expression' "+" + result' 1 );  						m = regEx.Match( Expression );  						continue;  				}
Missing Default,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following switch statement is missing a default case: switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sqrt(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sqrt(rv.DoubleValue).ToString();                              break;                      }
Missing Default,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following switch statement is missing a default case: switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sin(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sin(rv.DoubleValue).ToString();                              break;                      }
Missing Default,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following switch statement is missing a default case: switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue' 10).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue' 10).ToString();                              break;                      }
Missing Default,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following switch statement is missing a default case: switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue).ToString();                              break;                      }
Missing Default,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following switch statement is missing a default case: switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Tan(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Tan(rv.DoubleValue).ToString();                              break;                      }
Missing Default,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following switch statement is missing a default case: switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Abs(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Abs(rv.DoubleValue).ToString();                              break;                      }
Missing Default,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following switch statement is missing a default case: switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Cos(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Cos(rv.DoubleValue).ToString();                              break;                      }
Missing Default,MathParserNet,Parser,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following switch statement is missing a default case: switch (token.TokenName)                      {                          case TokenParser.Tokens.Float:                              nc.NumberType = NumberClass.NumberTypes.Float;                              nc.FloatNumber = double.Parse(token.TokenValue);                              break;                          case TokenParser.Tokens.Integer:                              nc.NumberType = NumberClass.NumberTypes.Integer;                              nc.IntNumber = int.Parse(token.TokenValue);                              break;                      }
Missing Default,MathParserTK_NET,MathParserTK,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,IsFunction,The following switch statement is missing a default case: switch (s)              {                  case "√":                  case "sqrt":                  case "sin":                  case "cos":                  case "tg":                  case "ctg":                  case "sh":                  case "ch":                  case "th":                  case "log":                  case "ln":                  case "exp":                  case "abs":                      return true;              }
Missing Default,MathParserTK_NET,MathParserTK,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,Calculate,The following switch statement is missing a default case: switch (token)                          {                              case "unMinus": stack.Push((-1 * arg).ToString()); break;                              case "unPlus": stack.Push(arg.ToString()); break;                              case "sqrt":                              case "√": stack.Push((Math.Sqrt(arg)).ToString()); break;                              case "sin":                                  if (radians)                                      stack.Push((Math.Sin(arg)).ToString());                                  else                                      stack.Push((Math.Sin(arg * Math.PI / 180)).ToString()); break;                              case "cos":                                  if (radians)                                      stack.Push((Math.Cos(arg)).ToString());                                  else                                      stack.Push((Math.Cos(arg * Math.PI / 180)).ToString()); break;                              case "tg":                                  if (radians)                                      stack.Push((Math.Tan(arg)).ToString());                                  else                                      stack.Push((Math.Tan(arg * Math.PI / 180)).ToString()); break;                              case "ctg":                                  if (radians)                                      stack.Push((1 / Math.Tan(arg)).ToString());                                  else                                      stack.Push((1 / Math.Tan(arg * Math.PI / 180)).ToString()); break;                              case "sh": stack.Push((Math.Sinh(arg)).ToString()); break;                              case "ch": stack.Push((Math.Cosh(arg)).ToString()); break;                              case "th": stack.Push((Math.Tanh(arg)).ToString()); break;                              case "ln": stack.Push((Math.Log(arg)).ToString()); break;                              case "exp": stack.Push((Math.Exp(arg)).ToString()); break;                              case "abs": stack.Push((Math.Abs(arg)).ToString()); break;                          }
Missing Default,MathParserTK_NET,MathParserTK,C:\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,Calculate,The following switch statement is missing a default case: switch (token)                          {                              case "plus": stack.Push((arg1 + arg2).ToString()); break;                              case "minus": stack.Push((arg1 - arg2).ToString()); break;                              case "multiply": stack.Push((arg1 * arg2).ToString()); break;                              case "division":                                  if (arg2 == 0)                                      throw new DivideByZeroException();                                  stack.Push((arg1 / arg2).ToString()); break;                              case "degree": stack.Push((Math.Pow(arg1' arg2).ToString())); break;                              case "log": stack.Push((Math.Log(arg2) / Math.Log(arg1)).ToString()); break;                          }
