Implementation smell,Namespace,Class,File,Method,Description
Long Method,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,GetToken,The method has 189 lines of code.
Long Method,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The method has 159 lines of code.
Long Method,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The method has 517 lines of code.
Complex Method,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,ParseAtom,Cyclomatic complexity of the method is 13
Complex Method,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,GetToken,Cyclomatic complexity of the method is 32
Complex Method,CalcEngine,BinaryExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Expression.cs,Evaluate,Cyclomatic complexity of the method is 19
Complex Method,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,ValueSatisfiesCriteria,Cyclomatic complexity of the method is 8
Complex Method,CalcEngine,Tally,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Tally.cs,AddValue,Cyclomatic complexity of the method is 9
Complex Method,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Factor,Cyclomatic complexity of the method is 9
Complex Method,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Evaluate,Cyclomatic complexity of the method is 8
Complex Method,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,SemanticTransform,Cyclomatic complexity of the method is 16
Complex Method,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,CalculateValue,Cyclomatic complexity of the method is 23
Complex Method,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,Cyclomatic complexity of the method is 33
Complex Method,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,EvaluateFunction,Cyclomatic complexity of the method is 11
Complex Method,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,Cyclomatic complexity of the method is 96
Complex Method,MathParserNet,SimplificationReturnValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\SimplificationReturnValue.cs,ToFraction,Cyclomatic complexity of the method is 8
Complex Method,MathParserTK_NET,MathParserTK,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,GetPrioritet,Cyclomatic complexity of the method is 8
Complex Method,MathParserTK_NET,MathParserTK,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,ConvertToRPN,Cyclomatic complexity of the method is 12
Complex Method,MathParserTK_NET,MathParserTK,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,LexicalAnalyze,Cyclomatic complexity of the method is 16
Complex Method,MathParserTK_NET,MathParserTK,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,Calculate,Cyclomatic complexity of the method is 28
Complex Method,MathParserTK_NET,MathParserTK,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,LexicalAnalyze,Cyclomatic complexity of the method is 8
Long Identifier,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,,The length of the parameter _sizeOfPolishPostfixExpression is 30.
Long Identifier,MathFunctions,MathParser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathFormula\MathFormula.cs,Calculate,The length of the parameter firstClosePhrantesisIndexAfterLastOpened is 40.
Long Statement,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The length of the statement  "            Test("1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1/(1+1))))))))))"' 1 / (1 + 1 / (1 + 1 / (1 + 1 / (1 + 1 / (1 + 1 / (1 + 1 / (1 + 1 / (1 + 1 / (1 + 1 / (1 + 1.0))))))))))); " is 175.
Long Statement,CalcEngine,Statistical,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Statistical.cs,Register,The length of the statement  "            //CRITBINOM	Returns the smallest value for which the cumulative binomial distribution is less than or equal to a criterion value " is 128.
Long Statement,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The length of the statement  "            //ce.RegisterFunction("ASC	Changes full-width (double-byte) English letters or katakana within a character string to half-width (single-byte) characters " is 152.
Long Statement,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The length of the statement  "            //ce.RegisterFunction("JIS	Changes half-width (single-byte) English letters or katakana within a character string to full-width (double-byte) characters " is 152.
Long Statement,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The length of the statement  "            ce.RegisterFunction("MID"' 3' Mid); // Returns a specific number of characters from a text string starting at the position you specify " is 134.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,ExpressionToTermW,The length of the statement  "                throw new MathParserException("Wrong input string. Expecting for: 'variable'' math function' '+'''-'' at input[" + _indexOfChar.ToString() + "]"); " is 146.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,ExpressionToTermW,The length of the statement  "                throw new MathParserException("Wrong input string. Expecting for: 'variable'' math function' '+'''-'' at input[" + _indexOfChar.ToString() + "]"); " is 146.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,WtoXWorEps,The length of the statement  "                    throw new MathParserException("Wrong input string. Expecting for: '-'''+''')'' end of input' at input[" + _indexOfChar.ToString() + "]"); " is 137.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,TermToPowerK,The length of the statement  "                throw new MathParserException("Wrong input string. Expecting for: 'variable'' math function' '+'''-'''('' number [0..9]' at input[" + _indexOfChar.ToString() + "]"); " is 165.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,TermToPowerK,The length of the statement  "                throw new MathParserException("Wrong input string. Expecting for: 'variable'' math function' '+'''-'''('' number [0..9]' at input[" + _indexOfChar.ToString() + "]"); " is 165.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,KtoYKorKtoEps,The length of the statement  "                    throw new MathParserException("Wrong input string. Expecting for: '*'''/'''+'''-''')'' end of input' at input[" + _indexOfChar.ToString() + "]"); " is 145.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,PowerToFactoV,The length of the statement  "                throw new MathParserException("Wrong input string. Expecting for: 'variable'' math function''('''+'''-''number [0..9] at input[" + _indexOfChar.ToString() + "]"); " is 162.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,PowerToFactoV,The length of the statement  "                throw new MathParserException("Wrong input string. Expecting for: 'variable'' math function''('''+'''-''number [0..9] at input[" + _indexOfChar.ToString() + "]"); " is 162.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,VtoZVorVtoEps,The length of the statement  "                    throw new MathParserException("Wrong input string. Expecting for: '^'''+'''-'''*'''/''')'' end of input' at input[" + _indexOfChar.ToString() + "]"); " is 149.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Factor,The length of the statement  "            if (Char.IsDigit(this._mathInput[this._indexOfChar]) || this._mathInput[this._indexOfChar] == '.')  //check if next character is digit " is 134.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Factor,The length of the statement  "                _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,End,The length of the statement  "                throw new MathParserException("Wrong input string. Expecting for end of input stream' at input[" + _indexOfChar.ToString() + "]"); " is 130.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Sin,The length of the statement  "            _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Sqrt,The length of the statement  "                _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Sec,The length of the statement  "            _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Cos,The length of the statement  "            _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Cot,The length of the statement  "            _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Tan,The length of the statement  "            _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Csc,The length of the statement  "            _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Asin,The length of the statement  "                _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Acos,The length of the statement  "                _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Atan,The length of the statement  "                _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Acot,The length of the statement  "                _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Exp,The length of the statement  "            _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Log,The length of the statement  "            _traverseNode.AddChildren(new MathParserTreeNode(Nonterminal.Expression)' new MathParserTreeNode(Nonterminal.ParenthesisClose)); " is 128.
Long Statement,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Evaluate,The length of the statement  "                    throw new ArgumentException("vars and varsValues arrays length are not equal");    // for each variable should be define the coresponding value " is 143.
Long Statement,MathFunctions,MathParser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathFormula\MathFormula.cs,Calculate,The length of the statement  "                    decimal result = ProcessOperation(Formula.Substring(lastOpenPhrantesisIndex + 1' firstClosePhrantesisIndexAfterLastOpened - lastOpenPhrantesisIndex - 1)); " is 154.
Long Statement,MathFunctions,MathParser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathFormula\MathFormula.cs,Calculate,The length of the statement  "                        if (Formula.Substring(lastOpenPhrantesisIndex - 1' 1) != "(" && !OperationOrder.Contains(Formula.Substring(lastOpenPhrantesisIndex - 1' 1))) " is 140.
Long Statement,MathFunctions,MathParser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathFormula\MathFormula.cs,Calculate,The length of the statement  "                    Formula = Formula.Substring(0' lastOpenPhrantesisIndex) + (AppendAsterix ? "*" : "") + result.ToString() + Formula.Substring(firstClosePhrantesisIndexAfterLastOpened + 1); " is 171.
Long Statement,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Evaluate,The length of the statement  "				Regex regEx = new Regex( @"(?<=[\d\)])(?=[a-df-z\(])|(?<=pi)(?=[^\+\-\*\/\\^!)])|(?<=\))(?=\d)|(?<=[^\/\*\+\-])(?=exp)"' RegexOptions.IgnoreCase ); " is 147.
Long Statement,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Evaluate,The length of the statement  "					if( m.Groups[3].Value.Length > 0 ) Expression = Expression.Replace( m.Value' "{" + m.Groups[1].Value + this.Solve( m.Groups[2].Value ) + "}" + m.Groups[3].Value ); " is 163.
Long Statement,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() ); " is 131.
Long Statement,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() ); " is 131.
Long Statement,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() ); " is 131.
Long Statement,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() ); " is 130.
Long Statement,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() ); " is 120.
Long Statement,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() ); " is 131.
Long Statement,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() ); " is 131.
Long Statement,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() ); " is 130.
Long Statement,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() ); " is 131.
Long Statement,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() ); " is 130.
Long Statement,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() ); " is 131.
Long Statement,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "				Expression = Expression.Replace( m.Value' Math.Pow( Convert.ToDouble( m.Groups[1].Value )' Convert.ToDouble( m.Groups[2].Value ) ).ToString() ); " is 144.
Long Statement,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "			regEx = new Regex( @"(\d+'*\d*e[\+-]?\d+|\d+'*\d*)\^(-?\d+'*\d*[eE][\+-]?\d+|-?\d+'*\d*)" ); // Search for patterns like 5^-1 " is 125.
Long Statement,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The length of the statement  "				Expression = regEx.Replace( Expression' Math.Pow( Convert.ToDouble( m.Groups[1].Value )' Convert.ToDouble( m.Groups[2].Value ) ).ToString()' 1 ); " is 145.
Long Statement,MathParserNet,OrderedDictionary<TKey;TValue>,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\OrderedDictionary.cs,RemoveAt,The length of the statement  "                throw new ArgumentOutOfRangeException("index"' @"'index' must be non-negative and less than the size of the collection"); " is 121.
Long Statement,MathParserTK_NET,MathParserTK,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,Parse,The length of the statement  "            //convert all symbols in input string to lower case and remove whitespaces in string to get rid of the various input errors " is 123.
Complex Conditional,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,GetToken,The conditional expression  "!isLetter && c != '_' && (_idChars == null || _idChars.IndexOf(c) < 0)"  is complex.
Complex Conditional,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,GetToken,The conditional expression  "!isLetter && !isDigit && c != '_' && (_idChars == null || _idChars.IndexOf(c) < 0)"  is complex.
Complex Conditional,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,ExpressionToTermW,The conditional expression  "Char.IsDigit(this._mathInput[_indexOfChar]) ||                   this._varsAndValues.ContainsKey(this._mathInput[_indexOfChar]) ||                  this._mathInput[_indexOfChar] == '.' ||                  this._mathInput[_indexOfChar] == 's' ||                  this._mathInput[_indexOfChar] == 'l' ||                   this._mathInput[_indexOfChar] == 'c' ||                  this._mathInput[_indexOfChar] == 'e' ||                  this._mathInput[_indexOfChar] == 't' ||                   this._mathInput[_indexOfChar] == 'a' ||                  this._mathInput[_indexOfChar] == '-' ||                  this._mathInput[_indexOfChar] == '+' ||                   this._mathInput[_indexOfChar] == '('"  is complex.
Complex Conditional,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,TermToPowerK,The conditional expression  "Char.IsDigit(this._mathInput[_indexOfChar]) ||                  this._varsAndValues.ContainsKey(this._mathInput[_indexOfChar]) ||                  this._mathInput[_indexOfChar] == '.' ||                  this._mathInput[_indexOfChar] == 's' ||                  this._mathInput[_indexOfChar] == 'l' ||                  this._mathInput[_indexOfChar] == 'c' ||                  this._mathInput[_indexOfChar] == 'e' ||                  this._mathInput[_indexOfChar] == 't' ||                  this._mathInput[_indexOfChar] == 'a' ||                  this._mathInput[_indexOfChar] == '-' ||                  this._mathInput[_indexOfChar] == '+' ||                  this._mathInput[_indexOfChar] == '('"  is complex.
Complex Conditional,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,PowerToFactoV,The conditional expression  "Char.IsDigit(this._mathInput[_indexOfChar]) ||                  this._varsAndValues.ContainsKey(this._mathInput[_indexOfChar]) ||                  this._mathInput[_indexOfChar] == '.' ||                  this._mathInput[_indexOfChar] == 's' ||                  this._mathInput[_indexOfChar] == 'l' ||                  this._mathInput[_indexOfChar] == 'c' ||                  this._mathInput[_indexOfChar] == 'e' ||                  this._mathInput[_indexOfChar] == 't' ||                  this._mathInput[_indexOfChar] == 'a' ||                  this._mathInput[_indexOfChar] == '-' ||                  this._mathInput[_indexOfChar] == '+' ||                  this._mathInput[_indexOfChar] == '('"  is complex.
Complex Conditional,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,VtoZVorVtoEps,The conditional expression  "this._mathInput[this._indexOfChar] != '+' && this._mathInput[this._indexOfChar] != '-' &&                      this._mathInput[this._indexOfChar] != '*' && this._mathInput[this._indexOfChar] != '/' &&                      this._mathInput[this._indexOfChar] != ')'"  is complex.
Complex Conditional,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The conditional expression  "(GetPrecedence(token.TokenName) <= GetPrecedence(op) &&                                   IsLeftAssociative(token.TokenValue)) ||                                  !IsLeftAssociative(token.TokenValue) &&                                  GetPrecedence(token.TokenName) < GetPrecedence(op)"  is complex.
Complex Conditional,MathParserTK_NET,MathParserTK,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,LexicalAnalyze,The conditional expression  "char.IsDigit(preToken[0]) || char.IsDigit(infixExp[pos + 1])                                              || (infixExp[pos + 1] == '+') || (infixExp[pos + 1] == '-')"  is complex.
Empty Catch Block,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,EvaluateFunction,The method has an empty catch block.
Empty Catch Block,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,EvaluateFunction,The method has an empty catch block.
Empty Catch Block,MathParserTK_NET,MathParserTK,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,LexicalAnalyze,The method has an empty catch block.
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,GetToken,The following statement contains a magic number: _tkTbl.TryGetValue(_expr.Substring(_ptr - 1' 2)' out tk)
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,GetToken,The following statement contains a magic number: val = val * 10 + (c - '0');
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,GetToken,The following statement contains a magic number: div *= 10;
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,GetToken,The following statement contains a magic number: val /= 100.0;
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,ParseDouble,The following statement contains a magic number: return double.Parse(str' NumberStyles.Any' ci) / 100.0;
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("1*2*3*4*5*6*7*8*9"' 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9.0);
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("1*2*3*4*5*6*7*8*9"' 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9.0);
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("1*2*3*4*5*6*7*8*9"' 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9.0);
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("1*2*3*4*5*6*7*8*9"' 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9.0);
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("1*2*3*4*5*6*7*8*9"' 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9.0);
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("1*2*3*4*5*6*7*8*9"' 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9.0);
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("1*2*3*4*5*6*7*8*9"' 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9.0);
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("1*2*3*4*5*6*7*8*9"' 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9.0);
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("((1+2)*(2+3)/(4+5))^0.123"' Math.Pow((1 + 2) * (2 + 3) / (4 + 5.0)' 0.123));
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("((1+2)*(2+3)/(4+5))^0.123"' Math.Pow((1 + 2) * (2 + 3) / (4 + 5.0)' 0.123));
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("((1+2)*(2+3)/(4+5))^0.123"' Math.Pow((1 + 2) * (2 + 3) / (4 + 5.0)' 0.123));
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("((1+2)*(2+3)/(4+5))^0.123"' Math.Pow((1 + 2) * (2 + 3) / (4 + 5.0)' 0.123));
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("((1+2)*(2+3)/(4+5))^0.123"' Math.Pow((1 + 2) * (2 + 3) / (4 + 5.0)' 0.123));
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("((1+2)*(2+3)/(4+5))^0.123"' Math.Pow((1 + 2) * (2 + 3) / (4 + 5.0)' 0.123));
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("10%"' 0.1);
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("1e+3"' 1000.0);
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Variables.Add("two"' 2);
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("one + two"' 3);
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("(two + two)^2"' 16);
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("Name.Length * 2"' p.Name.Length * 2);
Magic Number,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,Test,The following statement contains a magic number: Test("Children(2).Name"' p.Children[2].Name);
Magic Number,CalcEngine,BinaryExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Expression.cs,Evaluate,The following statement contains a magic number: switch (_token.ID)  			{  				case TKID.ADD:                       return (double)_lft + (double)_rgt;  				case TKID.SUB:                       return (double)_lft - (double)_rgt;  				case TKID.MUL:                       return (double)_lft * (double)_rgt;  				case TKID.DIV:                       return (double)_lft / (double)_rgt;  				case TKID.DIVINT:                       return (double)(int)((double)_lft / (double)_rgt);  				case TKID.MOD:                       return (double)(int)((double)_lft % (double)_rgt);  				case TKID.POWER:                      var a = (double)_lft;                      var b = (double)_rgt;                      if (b == 0.0) return 1.0;                      if (b == 0.5) return Math.Sqrt(a);                      if (b == 1.0) return a;                      if (b == 2.0) return a * a;                      if (b == 3.0) return a * a * a;                      if (b == 4.0) return a * a * a * a;                      return Math.Pow((double)_lft' (double)_rgt);  			}
Magic Number,CalcEngine,BinaryExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Expression.cs,Evaluate,The following statement contains a magic number: switch (_token.ID)  			{  				case TKID.ADD:                       return (double)_lft + (double)_rgt;  				case TKID.SUB:                       return (double)_lft - (double)_rgt;  				case TKID.MUL:                       return (double)_lft * (double)_rgt;  				case TKID.DIV:                       return (double)_lft / (double)_rgt;  				case TKID.DIVINT:                       return (double)(int)((double)_lft / (double)_rgt);  				case TKID.MOD:                       return (double)(int)((double)_lft % (double)_rgt);  				case TKID.POWER:                      var a = (double)_lft;                      var b = (double)_rgt;                      if (b == 0.0) return 1.0;                      if (b == 0.5) return Math.Sqrt(a);                      if (b == 1.0) return a;                      if (b == 2.0) return a * a;                      if (b == 3.0) return a * a * a;                      if (b == 4.0) return a * a * a * a;                      return Math.Pow((double)_lft' (double)_rgt);  			}
Magic Number,CalcEngine,BinaryExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Expression.cs,Evaluate,The following statement contains a magic number: switch (_token.ID)  			{  				case TKID.ADD:                       return (double)_lft + (double)_rgt;  				case TKID.SUB:                       return (double)_lft - (double)_rgt;  				case TKID.MUL:                       return (double)_lft * (double)_rgt;  				case TKID.DIV:                       return (double)_lft / (double)_rgt;  				case TKID.DIVINT:                       return (double)(int)((double)_lft / (double)_rgt);  				case TKID.MOD:                       return (double)(int)((double)_lft % (double)_rgt);  				case TKID.POWER:                      var a = (double)_lft;                      var b = (double)_rgt;                      if (b == 0.0) return 1.0;                      if (b == 0.5) return Math.Sqrt(a);                      if (b == 1.0) return a;                      if (b == 2.0) return a * a;                      if (b == 3.0) return a * a * a;                      if (b == 4.0) return a * a * a * a;                      return Math.Pow((double)_lft' (double)_rgt);  			}
Magic Number,CalcEngine,BinaryExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Expression.cs,Evaluate,The following statement contains a magic number: switch (_token.ID)  			{  				case TKID.ADD:                       return (double)_lft + (double)_rgt;  				case TKID.SUB:                       return (double)_lft - (double)_rgt;  				case TKID.MUL:                       return (double)_lft * (double)_rgt;  				case TKID.DIV:                       return (double)_lft / (double)_rgt;  				case TKID.DIVINT:                       return (double)(int)((double)_lft / (double)_rgt);  				case TKID.MOD:                       return (double)(int)((double)_lft % (double)_rgt);  				case TKID.POWER:                      var a = (double)_lft;                      var b = (double)_rgt;                      if (b == 0.0) return 1.0;                      if (b == 0.5) return Math.Sqrt(a);                      if (b == 1.0) return a;                      if (b == 2.0) return a * a;                      if (b == 3.0) return a * a * a;                      if (b == 4.0) return a * a * a * a;                      return Math.Pow((double)_lft' (double)_rgt);  			}
Magic Number,CalcEngine,Logical,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Logical.cs,Register,The following statement contains a magic number: ce.RegisterFunction("IF"' 3' If);
Magic Number,CalcEngine,Logical,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Logical.cs,If,The following statement contains a magic number: return (bool)p[0]                   ? p[1].Evaluate()                   : p[2].Evaluate();
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Register,The following statement contains a magic number: ce.RegisterFunction("ATAN2"' 2' Atan2);
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Register,The following statement contains a magic number: ce.RegisterFunction("LOG"' 1' 2' Log);
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Register,The following statement contains a magic number: ce.RegisterFunction("POWER"' 2' Power);
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Register,The following statement contains a magic number: ce.RegisterFunction("RANDBETWEEN"' 2' RandBetween);
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Register,The following statement contains a magic number: ce.RegisterFunction("SUMIF"' 2' 3' SumIf);
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Register,The following statement contains a magic number: ce.RegisterFunction("SUMIF"' 2' 3' SumIf);
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("ABS(-12)"' 12.0);
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("ABS(+12)"' 12.0);
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("ACOS(.23)"' Math.Acos(.23));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("ASIN(.23)"' Math.Asin(.23));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("ATAN(.23)"' Math.Atan(.23));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("ATAN2(1'2)"' Math.Atan2(1' 2));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("CEILING(1.8)"' Math.Ceiling(1.8));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("COS(1.23)"' Math.Cos(1.23));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("COSH(1.23)"' Math.Cosh(1.23));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("FLOOR(1.8)"' Math.Floor(1.8));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("LOG(1.8)"' Math.Log(1.8' 10));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("LOG(1.8)"' Math.Log(1.8' 10));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("LOG(1.8' 4)"' Math.Log(1.8' 4));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("LOG(1.8' 4)"' Math.Log(1.8' 4));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("LN(1.8)"' Math.Log(1.8));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("LOG10(1.8)"' Math.Log10(1.8));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("POWER(2'4)"' Math.Pow(2' 4));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("POWER(2'4)"' Math.Pow(2' 4));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("SIN(1.23)"' Math.Sin(1.23));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("SINH(1.23)"' Math.Sinh(1.23));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("SQRT(144)"' Math.Sqrt(144));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("SUM(1' 2' 3' 4)"' 1 + 2 + 3 + 4.0);
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("SUM(1' 2' 3' 4)"' 1 + 2 + 3 + 4.0);
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("SUM(1' 2' 3' 4)"' 1 + 2 + 3 + 4.0);
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("TAN(1.23)"' Math.Tan(1.23));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("TANH(1.23)"' Math.Tanh(1.23));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("LN(10)"' Math.Log(10));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("LOG(10)"' Math.Log10(10));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("EXP(10)"' Math.Exp(10));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("SIN(PI()/4)"' Math.Sin(Math.PI / 4));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("ASIN(PI()/4)"' Math.Asin(Math.PI / 4));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("SINH(PI()/4)"' Math.Sinh(Math.PI / 4));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("COS(PI()/4)"' Math.Cos(Math.PI / 4));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("ACOS(PI()/4)"' Math.Acos(Math.PI / 4));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("COSH(PI()/4)"' Math.Cosh(Math.PI / 4));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("TAN(PI()/4)"' Math.Tan(Math.PI / 4));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("ATAN(PI()/4)"' Math.Atan(Math.PI / 4));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("ATAN2(1'2)"' Math.Atan2(1' 2));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Test,The following statement contains a magic number: ce.Test("TANH(PI()/4)"' Math.Tanh(Math.PI / 4));
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,Log,The following statement contains a magic number: var lbase = p.Count > 1 ? (double)p[1] : 10;
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,SumIf,The following statement contains a magic number: IEnumerable sumRange = p.Count < 3 ? range : p[2] as IEnumerable;
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,SumIf,The following statement contains a magic number: IEnumerable sumRange = p.Count < 3 ? range : p[2] as IEnumerable;
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,ValueSatisfiesCriteria,The following statement contains a magic number: expression = string.Format("\"{0}\"{1}\"{2}\""'                                  m.Groups[1].Value'                                  m.Groups[2].Value'                                  m.Groups[3].Value);
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,ValueSatisfiesCriteria,The following statement contains a magic number: expression = string.Format("\"{0}\"{1}\"{2}\""'                                  m.Groups[1].Value'                                  m.Groups[2].Value'                                  m.Groups[3].Value);
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,ValueSatisfiesCriteria,The following statement contains a magic number: !double.TryParse(m.Groups[1].Value' out d) ||                              !double.TryParse(m.Groups[3].Value' out d)
Magic Number,CalcEngine,MathTrig,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\MathTrig.cs,ValueSatisfiesCriteria,The following statement contains a magic number: m.Groups.Count == 4
Magic Number,CalcEngine,Statistical,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Statistical.cs,Register,The following statement contains a magic number: ce.RegisterFunction("COUNTIF"' 2' CountIf);
Magic Number,CalcEngine,Statistical,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Statistical.cs,Test,The following statement contains a magic number: ce.Test("Average(1' 3' 3' 1' true' false' \"hello\")"' 2.0);
Magic Number,CalcEngine,Statistical,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Statistical.cs,Test,The following statement contains a magic number: ce.Test("AverageA(1' 3' 3' 1' true' false' \"hello\")"' (1 + 3 + 3 + 1 + 1 + 0 + 0) / 7.0);
Magic Number,CalcEngine,Statistical,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Statistical.cs,Test,The following statement contains a magic number: ce.Test("AverageA(1' 3' 3' 1' true' false' \"hello\")"' (1 + 3 + 3 + 1 + 1 + 0 + 0) / 7.0);
Magic Number,CalcEngine,Statistical,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Statistical.cs,Test,The following statement contains a magic number: ce.Test("AverageA(1' 3' 3' 1' true' false' \"hello\")"' (1 + 3 + 3 + 1 + 1 + 0 + 0) / 7.0);
Magic Number,CalcEngine,Statistical,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Statistical.cs,Test,The following statement contains a magic number: ce.Test("Count(1' 3' 3' 1' true' false' \"hello\")"' 4.0);
Magic Number,CalcEngine,Statistical,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Statistical.cs,Test,The following statement contains a magic number: ce.Test("CountA(1' 3' 3' 1' true' false' \"hello\")"' 7.0);
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction("FIND"' 2' 3' Find);
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction("FIND"' 2' 3' Find);
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction("LEFT"' 1' 2' Left);
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction("MID"' 3' Mid);
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction("REPLACE"' 4' Replace);
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction("REPT"' 2' Rept);
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction("RIGHT"' 1' 2' Right);
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction("SEARCH"' 2' Search);
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction("SUBSTITUTE"' 3' 4' Substitute);
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction("SUBSTITUTE"' 3' 4' Substitute);
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Register,The following statement contains a magic number: ce.RegisterFunction("TEXT"' 2' _Text);
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Test,The following statement contains a magic number: ce.Test("CODE(\"A\")"' 65);
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Test,The following statement contains a magic number: ce.Test("FIND(\"bra\"' \"abracadabra\")"' 2);
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Test,The following statement contains a magic number: ce.Test("LEN(\"abracadabra\")"' 11);
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Test,The following statement contains a magic number: ce.Test("SEARCH(\"bra\"' \"abracadabra\")"' 2);
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Test,The following statement contains a magic number: ce.Test("SEARCH(\"BRA\"' \"abracadabra\")"' 2);
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Test,The following statement contains a magic number: ce.Test("VALUE(\"1234\")"' 1234.0);
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,IndexOf,The following statement contains a magic number: start = (int)p[2] - 1;
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,IndexOf,The following statement contains a magic number: p.Count > 2
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Mid,The following statement contains a magic number: return ((string)p[0]).Substring((int)p[1] - 1' (int)p[2]);
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Replace,The following statement contains a magic number: var len = (int)p[2];
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Replace,The following statement contains a magic number: var rep = (string)p[3];
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Substitute,The following statement contains a magic number: var newText = (string)p[2];
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Substitute,The following statement contains a magic number: p.Count == 3
Magic Number,CalcEngine,Text,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Functions\Text.cs,Substitute,The following statement contains a magic number: int index = (int)p[3];
Magic Number,CalcEngine,Person,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Tester.cs,CreateTestPerson,The following statement contains a magic number: p.Birth = DateTime.Today.AddYears(-30);
Magic Number,CalcEngine,Person,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Tester.cs,CreateTestPerson,The following statement contains a magic number: c.Male = i % 2 == 0;
Magic Number,CalcEngine,Person,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Tester.cs,CreateTestPerson,The following statement contains a magic number: i < 5
Magic Number,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Factor,The following statement contains a magic number: this._sizeOfPolishPostfixExpression += 2;
Magic Number,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Factor,The following statement contains a magic number: this._sizeOfPolishPostfixExpression += 2;
Magic Number,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Factor,The following statement contains a magic number: temp = this._mathInput.Substring(this._indexOfChar' 4);
Magic Number,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Factor,The following statement contains a magic number: this._mathInput.Length > this._indexOfChar + 4
Magic Number,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Sin,The following statement contains a magic number: this._indexOfChar += 4;
Magic Number,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Sqrt,The following statement contains a magic number: this._indexOfChar += 5;
Magic Number,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Sqrt,The following statement contains a magic number: this._mathInput[this._indexOfChar + 4] == '('
Magic Number,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Sec,The following statement contains a magic number: this._indexOfChar += 4;
Magic Number,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Cos,The following statement contains a magic number: this._indexOfChar += 4;
Magic Number,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Cot,The following statement contains a magic number: this._indexOfChar += 4;
Magic Number,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Tan,The following statement contains a magic number: this._indexOfChar += 4;
Magic Number,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Csc,The following statement contains a magic number: this._indexOfChar += 4;
Magic Number,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Asin,The following statement contains a magic number: this._indexOfChar += 5;
Magic Number,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Asin,The following statement contains a magic number: this._mathInput[this._indexOfChar + 4] == '('
Magic Number,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Acos,The following statement contains a magic number: this._indexOfChar += 5;
Magic Number,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Acos,The following statement contains a magic number: this._mathInput[this._indexOfChar + 4] == '('
Magic Number,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Atan,The following statement contains a magic number: this._indexOfChar += 5;
Magic Number,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Atan,The following statement contains a magic number: this._mathInput[this._indexOfChar + 4] == '('
Magic Number,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Acot,The following statement contains a magic number: this._indexOfChar += 5;
Magic Number,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Acot,The following statement contains a magic number: this._mathInput[this._indexOfChar + 4] == '('
Magic Number,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Exp,The following statement contains a magic number: this._indexOfChar += 4;
Magic Number,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,Log,The following statement contains a magic number: this._indexOfChar += 4;
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Evaluate,The following statement contains a magic number: Expression = Expression.Replace( m.Value' "{" + m.Groups[1].Value + this.Solve( m.Groups[2].Value ) + "}" + m.Groups[3].Value );
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Evaluate,The following statement contains a magic number: Expression = Expression.Replace( m.Value' "{" + m.Groups[1].Value + this.Solve( m.Groups[2].Value ) + "}" + m.Groups[3].Value );
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Evaluate,The following statement contains a magic number: m.Groups[3].Value.Length > 0
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: Expression = Expression.Replace( m.Value' Math.Pow( Convert.ToDouble( m.Groups[1].Value )' Convert.ToDouble( m.Groups[2].Value ) ).ToString() );
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: Expression = regEx.Replace( Expression' Math.Pow( Convert.ToDouble( m.Groups[1].Value )' Convert.ToDouble( m.Groups[2].Value ) ).ToString()' 1 );
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: switch( m.Groups[2].Value )  				{  					case "*" :  						result = Convert.ToDouble( m.Groups[1].Value ) * Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = Expression.Replace( m.Value' "+" + result );  						m = regEx.Match( Expression );  						continue;  					case "/" :  						result = Convert.ToDouble( m.Groups[1].Value ) / Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = regEx.Replace( Expression' "+" + result' 1 );  						m = regEx.Match( Expression );  						continue;  				}
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: switch( m.Groups[2].Value )  				{  					case "*" :  						result = Convert.ToDouble( m.Groups[1].Value ) * Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = Expression.Replace( m.Value' "+" + result );  						m = regEx.Match( Expression );  						continue;  					case "/" :  						result = Convert.ToDouble( m.Groups[1].Value ) / Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = regEx.Replace( Expression' "+" + result' 1 );  						m = regEx.Match( Expression );  						continue;  				}
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: switch( m.Groups[2].Value )  				{  					case "*" :  						result = Convert.ToDouble( m.Groups[1].Value ) * Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = Expression.Replace( m.Value' "+" + result );  						m = regEx.Match( Expression );  						continue;  					case "/" :  						result = Convert.ToDouble( m.Groups[1].Value ) / Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = regEx.Replace( Expression' "+" + result' 1 );  						m = regEx.Match( Expression );  						continue;  				}
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: switch( m.Groups[2].Value )  				{  					case "+" :  						result = Convert.ToDouble( m.Groups[1].Value ) + Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = regEx.Replace( Expression' "+" + result' 1 );  						m = regEx.Match( Expression );  						continue;  					case "-" :  						result = Convert.ToDouble( m.Groups[1].Value ) - Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = regEx.Replace( Expression' "+" + result' 1 );  						m = regEx.Match( Expression );  						continue;  				}
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: switch( m.Groups[2].Value )  				{  					case "+" :  						result = Convert.ToDouble( m.Groups[1].Value ) + Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = regEx.Replace( Expression' "+" + result' 1 );  						m = regEx.Match( Expression );  						continue;  					case "-" :  						result = Convert.ToDouble( m.Groups[1].Value ) - Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = regEx.Replace( Expression' "+" + result' 1 );  						m = regEx.Match( Expression );  						continue;  				}
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: switch( m.Groups[2].Value )  				{  					case "+" :  						result = Convert.ToDouble( m.Groups[1].Value ) + Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = regEx.Replace( Expression' "+" + result' 1 );  						m = regEx.Match( Expression );  						continue;  					case "-" :  						result = Convert.ToDouble( m.Groups[1].Value ) - Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = regEx.Replace( Expression' "+" + result' 1 );  						m = regEx.Match( Expression );  						continue;  				}
Magic Number,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following statement contains a magic number: Expression = Expression.Substring(2);
Magic Number,MathParserNet,TokenParser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Lexer.cs,TokenParser,The following statement contains a magic number: _customFunctionIndex = 100;
Magic Number,MathParserNet,TokenParser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Lexer.cs,RegisterCustomFunction,The following statement contains a magic number: _tokens.Insert(4' (Tokens)_customFunctionIndex' sb.ToString());
Magic Number,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);
Magic Number,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);
Magic Number,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);
Magic Number,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);
Magic Number,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);
Magic Number,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);
Magic Number,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue' 10).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue' 10).ToString();                              break;                      }
Magic Number,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue' 10).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue' 10).ToString();                              break;                      }
Magic Number,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);
Magic Number,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: string expression = token.TokenValue.Substring(4' token.TokenValue.Length - 4);
Magic Number,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);
Magic Number,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);
Magic Number,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);
Magic Number,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);
Magic Number,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);
Magic Number,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: string expression = token.TokenValue.Substring(3' token.TokenValue.Length - 3);
Magic Number,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: (int)token.TokenName >= 100
Magic Number,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following statement contains a magic number: string fn = token.TokenValue.Substring(0' ndx1).Remove(0' 4);
Magic Number,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,GetPrecedence,The following statement contains a magic number: return 2;
Magic Number,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,GetPrecedence,The following statement contains a magic number: return 3;
Magic Number,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,GetPrecedence,The following statement contains a magic number: return 4;
Magic Number,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,GetPrecedence,The following statement contains a magic number: return 2;
Magic Number,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,GetPrecedence,The following statement contains a magic number: return 3;
Magic Number,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,GetPrecedence,The following statement contains a magic number: return 4;
Magic Number,MathParserTK_NET,MathParserTK,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,MathParserTK,The following statement contains a magic number: operators = new Dictionary<string' string>(50);
Magic Number,MathParserTK_NET,MathParserTK,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,MathParserTK,The following statement contains a magic number: constants = new Dictionary<string' string>(10);
Magic Number,MathParserTK_NET,MathParserTK,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,GetPrioritet,The following statement contains a magic number: switch (op)              {                  case "leftParenthesis":                      return 0;                  case "rightParenthesis":                      return 1;                  case "plus":                  case "minus":                      return 2;                  case "unPlus":                  case "unMinus":                      return 6;                  case "multiply":                  case "division":                      return 4;                  case "degree":                  case "√":                  case "sqrt":                      return 8;                  case "sin":                  case "cos":                  case "tg":                  case "ctg":                  case "sh":                  case "ch":                  case "th":                  case "log":                  case "ln":                  case "exp":                  case "abs":                      return 10;                  default:                      return 0;              }
Magic Number,MathParserTK_NET,MathParserTK,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,GetPrioritet,The following statement contains a magic number: switch (op)              {                  case "leftParenthesis":                      return 0;                  case "rightParenthesis":                      return 1;                  case "plus":                  case "minus":                      return 2;                  case "unPlus":                  case "unMinus":                      return 6;                  case "multiply":                  case "division":                      return 4;                  case "degree":                  case "√":                  case "sqrt":                      return 8;                  case "sin":                  case "cos":                  case "tg":                  case "ctg":                  case "sh":                  case "ch":                  case "th":                  case "log":                  case "ln":                  case "exp":                  case "abs":                      return 10;                  default:                      return 0;              }
Magic Number,MathParserTK_NET,MathParserTK,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,GetPrioritet,The following statement contains a magic number: switch (op)              {                  case "leftParenthesis":                      return 0;                  case "rightParenthesis":                      return 1;                  case "plus":                  case "minus":                      return 2;                  case "unPlus":                  case "unMinus":                      return 6;                  case "multiply":                  case "division":                      return 4;                  case "degree":                  case "√":                  case "sqrt":                      return 8;                  case "sin":                  case "cos":                  case "tg":                  case "ctg":                  case "sh":                  case "ch":                  case "th":                  case "log":                  case "ln":                  case "exp":                  case "abs":                      return 10;                  default:                      return 0;              }
Magic Number,MathParserTK_NET,MathParserTK,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,GetPrioritet,The following statement contains a magic number: switch (op)              {                  case "leftParenthesis":                      return 0;                  case "rightParenthesis":                      return 1;                  case "plus":                  case "minus":                      return 2;                  case "unPlus":                  case "unMinus":                      return 6;                  case "multiply":                  case "division":                      return 4;                  case "degree":                  case "√":                  case "sqrt":                      return 8;                  case "sin":                  case "cos":                  case "tg":                  case "ctg":                  case "sh":                  case "ch":                  case "th":                  case "log":                  case "ln":                  case "exp":                  case "abs":                      return 10;                  default:                      return 0;              }
Magic Number,MathParserTK_NET,MathParserTK,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,GetPrioritet,The following statement contains a magic number: switch (op)              {                  case "leftParenthesis":                      return 0;                  case "rightParenthesis":                      return 1;                  case "plus":                  case "minus":                      return 2;                  case "unPlus":                  case "unMinus":                      return 6;                  case "multiply":                  case "division":                      return 4;                  case "degree":                  case "√":                  case "sqrt":                      return 8;                  case "sin":                  case "cos":                  case "tg":                  case "ctg":                  case "sh":                  case "ch":                  case "th":                  case "log":                  case "ln":                  case "exp":                  case "abs":                      return 10;                  default:                      return 0;              }
Magic Number,MathParserTK_NET,MathParserTK,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,GetNumberArguments,The following statement contains a magic number: switch (op)              {                  case "plus":                  case "minus":                  case "multiply":                  case "division":                  case "degree":                  case "log":                                      return 2;                  case "unMinus":                  case "unPlus":                  case "√":                  case "sqrt":                  case "tg":                  case "sh":                  case "ch":                  case "th":                  case "ln":                  case "ctg":                  case "sin":                  case "cos":                  case "exp":                  case "abs":                      return 1;                  default:                      return 0;              }
Magic Number,MathParserTK_NET,MathParserTK,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,Calculate,The following statement contains a magic number: switch (token)                          {                              case "unMinus": stack.Push((-1 * arg).ToString()); break;                              case "unPlus": stack.Push(arg.ToString()); break;                              case "sqrt":                              case "√": stack.Push((Math.Sqrt(arg)).ToString()); break;                              case "sin":                                  if (radians)                                      stack.Push((Math.Sin(arg)).ToString());                                  else                                      stack.Push((Math.Sin(arg * Math.PI / 180)).ToString()); break;                              case "cos":                                  if (radians)                                      stack.Push((Math.Cos(arg)).ToString());                                  else                                      stack.Push((Math.Cos(arg * Math.PI / 180)).ToString()); break;                              case "tg":                                  if (radians)                                      stack.Push((Math.Tan(arg)).ToString());                                  else                                      stack.Push((Math.Tan(arg * Math.PI / 180)).ToString()); break;                              case "ctg":                                  if (radians)                                      stack.Push((1 / Math.Tan(arg)).ToString());                                  else                                      stack.Push((1 / Math.Tan(arg * Math.PI / 180)).ToString()); break;                              case "sh": stack.Push((Math.Sinh(arg)).ToString()); break;                              case "ch": stack.Push((Math.Cosh(arg)).ToString()); break;                              case "th": stack.Push((Math.Tanh(arg)).ToString()); break;                              case "ln": stack.Push((Math.Log(arg)).ToString()); break;                              case "exp": stack.Push((Math.Exp(arg)).ToString()); break;                              case "abs": stack.Push((Math.Abs(arg)).ToString()); break;                          }
Magic Number,MathParserTK_NET,MathParserTK,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,Calculate,The following statement contains a magic number: switch (token)                          {                              case "unMinus": stack.Push((-1 * arg).ToString()); break;                              case "unPlus": stack.Push(arg.ToString()); break;                              case "sqrt":                              case "√": stack.Push((Math.Sqrt(arg)).ToString()); break;                              case "sin":                                  if (radians)                                      stack.Push((Math.Sin(arg)).ToString());                                  else                                      stack.Push((Math.Sin(arg * Math.PI / 180)).ToString()); break;                              case "cos":                                  if (radians)                                      stack.Push((Math.Cos(arg)).ToString());                                  else                                      stack.Push((Math.Cos(arg * Math.PI / 180)).ToString()); break;                              case "tg":                                  if (radians)                                      stack.Push((Math.Tan(arg)).ToString());                                  else                                      stack.Push((Math.Tan(arg * Math.PI / 180)).ToString()); break;                              case "ctg":                                  if (radians)                                      stack.Push((1 / Math.Tan(arg)).ToString());                                  else                                      stack.Push((1 / Math.Tan(arg * Math.PI / 180)).ToString()); break;                              case "sh": stack.Push((Math.Sinh(arg)).ToString()); break;                              case "ch": stack.Push((Math.Cosh(arg)).ToString()); break;                              case "th": stack.Push((Math.Tanh(arg)).ToString()); break;                              case "ln": stack.Push((Math.Log(arg)).ToString()); break;                              case "exp": stack.Push((Math.Exp(arg)).ToString()); break;                              case "abs": stack.Push((Math.Abs(arg)).ToString()); break;                          }
Magic Number,MathParserTK_NET,MathParserTK,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,Calculate,The following statement contains a magic number: switch (token)                          {                              case "unMinus": stack.Push((-1 * arg).ToString()); break;                              case "unPlus": stack.Push(arg.ToString()); break;                              case "sqrt":                              case "√": stack.Push((Math.Sqrt(arg)).ToString()); break;                              case "sin":                                  if (radians)                                      stack.Push((Math.Sin(arg)).ToString());                                  else                                      stack.Push((Math.Sin(arg * Math.PI / 180)).ToString()); break;                              case "cos":                                  if (radians)                                      stack.Push((Math.Cos(arg)).ToString());                                  else                                      stack.Push((Math.Cos(arg * Math.PI / 180)).ToString()); break;                              case "tg":                                  if (radians)                                      stack.Push((Math.Tan(arg)).ToString());                                  else                                      stack.Push((Math.Tan(arg * Math.PI / 180)).ToString()); break;                              case "ctg":                                  if (radians)                                      stack.Push((1 / Math.Tan(arg)).ToString());                                  else                                      stack.Push((1 / Math.Tan(arg * Math.PI / 180)).ToString()); break;                              case "sh": stack.Push((Math.Sinh(arg)).ToString()); break;                              case "ch": stack.Push((Math.Cosh(arg)).ToString()); break;                              case "th": stack.Push((Math.Tanh(arg)).ToString()); break;                              case "ln": stack.Push((Math.Log(arg)).ToString()); break;                              case "exp": stack.Push((Math.Exp(arg)).ToString()); break;                              case "abs": stack.Push((Math.Abs(arg)).ToString()); break;                          }
Magic Number,MathParserTK_NET,MathParserTK,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,Calculate,The following statement contains a magic number: switch (token)                          {                              case "unMinus": stack.Push((-1 * arg).ToString()); break;                              case "unPlus": stack.Push(arg.ToString()); break;                              case "sqrt":                              case "√": stack.Push((Math.Sqrt(arg)).ToString()); break;                              case "sin":                                  if (radians)                                      stack.Push((Math.Sin(arg)).ToString());                                  else                                      stack.Push((Math.Sin(arg * Math.PI / 180)).ToString()); break;                              case "cos":                                  if (radians)                                      stack.Push((Math.Cos(arg)).ToString());                                  else                                      stack.Push((Math.Cos(arg * Math.PI / 180)).ToString()); break;                              case "tg":                                  if (radians)                                      stack.Push((Math.Tan(arg)).ToString());                                  else                                      stack.Push((Math.Tan(arg * Math.PI / 180)).ToString()); break;                              case "ctg":                                  if (radians)                                      stack.Push((1 / Math.Tan(arg)).ToString());                                  else                                      stack.Push((1 / Math.Tan(arg * Math.PI / 180)).ToString()); break;                              case "sh": stack.Push((Math.Sinh(arg)).ToString()); break;                              case "ch": stack.Push((Math.Cosh(arg)).ToString()); break;                              case "th": stack.Push((Math.Tanh(arg)).ToString()); break;                              case "ln": stack.Push((Math.Log(arg)).ToString()); break;                              case "exp": stack.Push((Math.Exp(arg)).ToString()); break;                              case "abs": stack.Push((Math.Abs(arg)).ToString()); break;                          }
Missing Default,CalcEngine,CalcEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\CalcEngine.cs,ParseAtom,The following switch statement is missing a default case: switch (_token.Type)  			{  				// literals  				case TKTYPE.LITERAL:  					x = new Expression(_token);  					break;                    // identifiers                  case TKTYPE.IDENTIFIER:                        // get identifier                      id = (string)_token.Value;                        // look for functions                      if (_fnTbl.TryGetValue(id' out fnDef))                      {                          var p = GetParameters();                          var pCnt = p == null ? 0 : p.Count;                          if (fnDef.ParmMin != -1 && pCnt < fnDef.ParmMin)                          {                              Throw("Too few parameters.");                          }                          if (fnDef.ParmMax != -1 && pCnt > fnDef.ParmMax)                          {                              Throw("Too many parameters.");                          }                          x = new FunctionExpression(fnDef' p);                          break;                      }                        // look for simple variables (much faster than binding!)                      if (_vars.ContainsKey(id))                      {                          x = new VariableExpression(_vars' id);                          break;                      }                        // look for external objects                      var xObj = GetExternalObject(id);                      if (xObj != null)                      {                          x = new XObjectExpression(xObj);                          break;                      }                        // look for bindings                      if (DataContext != null)                      {                          var list = new List<BindingInfo>();                          for (var t = _token; t != null; t = GetMember())                          {                              list.Add(new BindingInfo((string)t.Value' GetParameters()));                          }                          x = new BindingExpression(this' list' _ci);                          break;                      }                      Throw("Unexpected identifier");                      break;    		        // sub-expressions  		        case TKTYPE.GROUP:                        // anything other than opening parenthesis is illegal here  					if (_token.ID != TKID.OPEN)  					{                          Throw("Expression expected.");                      }    					// get expression  					GetToken();  					x = ParseCompare();    					// check that the parenthesis was closed  					if (_token.ID != TKID.CLOSE)  					{  						Throw("Unbalanced parenthesis.");  					}    					break;  		    }
Missing Default,CalcEngine,UnaryExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Expression.cs,Evaluate,The following switch statement is missing a default case: switch (_token.ID)  			{  				case TKID.ADD:                      return +(double)_expr;  				case TKID.SUB:                      return -(double)_expr;  			}
Missing Default,CalcEngine,BinaryExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Expression.cs,Evaluate,The following switch statement is missing a default case: switch (_token.ID)                  {                      case TKID.GT: return cmp > 0;                      case TKID.LT: return cmp < 0;                      case TKID.GE: return cmp >= 0;                      case TKID.LE: return cmp <= 0;                      case TKID.EQ: return cmp == 0;                      case TKID.NE: return cmp != 0;                  }
Missing Default,CalcEngine,BinaryExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\CalcEngine\Expression.cs,Evaluate,The following switch statement is missing a default case: switch (_token.ID)  			{  				case TKID.ADD:                       return (double)_lft + (double)_rgt;  				case TKID.SUB:                       return (double)_lft - (double)_rgt;  				case TKID.MUL:                       return (double)_lft * (double)_rgt;  				case TKID.DIV:                       return (double)_lft / (double)_rgt;  				case TKID.DIVINT:                       return (double)(int)((double)_lft / (double)_rgt);  				case TKID.MOD:                       return (double)(int)((double)_lft % (double)_rgt);  				case TKID.POWER:                      var a = (double)_lft;                      var b = (double)_rgt;                      if (b == 0.0) return 1.0;                      if (b == 0.5) return Math.Sqrt(a);                      if (b == 1.0) return a;                      if (b == 2.0) return a * a;                      if (b == 3.0) return a * a * a;                      if (b == 4.0) return a * a * a * a;                      return Math.Pow((double)_lft' (double)_rgt);  			}
Missing Default,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,SemanticTransform,The following switch statement is missing a default case: switch (_traverseNode.Name)                  {                       case Nonterminal.Expression:                          this.ExpressionToTermW(stack);                          break;                      case Nonterminal.W:                          this.WtoXWorEps(stack);                          break;                      case Nonterminal.X:                          this.XtoMinusTermOrXtoPlusTerm(stack);                          break;                      case Nonterminal.Term:                          this.TermToPowerK(stack);                          break;                      case Nonterminal.K:                          this.KtoYKorKtoEps(stack);                          break;                      case Nonterminal.Y:                          this.YtoMultiplyPowerOrYtoDividePower(stack);                          break;                      case Nonterminal.Power:                          this.PowerToFactoV(stack);                          break;                      case Nonterminal.V:                          this.VtoZVorVtoEps(stack);                          break;                      case Nonterminal.Z:                          this.ZtoPowerFactor(stack);                          break;                      case Nonterminal.Factor:                          this.Factor(stack);                          break;                      case Nonterminal.ParenthesisClose:                          this.ParanthesisClose(stack);                          break;                      case Nonterminal.End:                          this.End(stack);                          break;                      case Nonterminal.AnyValue:                          break;                  }
Missing Default,MathParserDataStructures,MathObj,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\LLMathParser\MathObj.cs,CalculateValue,The following switch statement is missing a default case: switch (this._polishPostfixExpression[i])                  {                      case Operation.UnaryMinus:                          stack.Push(0);                          break;                      case Operation.UnaryPlus:                          stack.Push(0);                          break;                      case Operation.Variable:                          stack.Push(this._varsAndValues[this._listOfVariableInputs[indexVariables++]]);                          break;                      case Operation.AnyReal:                          stack.Push(this._listOfDoubleInputs[indexValues++]);                          break;                      case Operation.Sin:                          stack.Push(Math.Sin(stack.Pop()));                          break;                      case Operation.Cos:                          stack.Push(Math.Cos(stack.Pop()));                          break;                      case Operation.Cot:                          stack.Push(1 / Math.Tan(stack.Pop()));                          break;                      case Operation.Sqrt:                          stack.Push(Math.Sqrt(stack.Pop()));                          break;                      case Operation.Asin:                          stack.Push(Math.Asin(stack.Pop()));                          break;                      case Operation.Acos:                          stack.Push(Math.Acos(stack.Pop()));                          break;                      case Operation.Atan:                          stack.Push(Math.Atan(stack.Pop()));                          break;                      case Operation.Acot:                          stack.Push(Math.Atan(1 / stack.Pop()));                          break;                      case Operation.Sec:                          stack.Push(1 / Math.Cos(stack.Pop()));                          break;                      case Operation.Csc:                          stack.Push(1 / Math.Sin(stack.Pop()));                          break;                      case Operation.Tan:                          stack.Push(Math.Tan(stack.Pop()));                          break;                      case Operation.Exp:                          stack.Push(Math.Exp(stack.Pop()));                          break;                      case Operation.Log:                          stack.Push(Math.Log(stack.Pop()));                          break;                      case Operation.Power:                          b = stack.Pop();                          a = stack.Pop();                          stack.Push(Math.Pow(a' b));                          break;                      case Operation.Plus:                          stack.Push(stack.Pop() + stack.Pop());                          break;                      case Operation.Minus:                          b = stack.Pop();                          a = stack.Pop();                          stack.Push(a - b);                          break;                      case Operation.Multiply:                          stack.Push(stack.Pop() * stack.Pop());                          break;                      case Operation.Divide:                          b = stack.Pop();                          a = stack.Pop();                          stack.Push(a / b);                          break;                  }
Missing Default,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following switch statement is missing a default case: switch( m.Groups[1].Value.ToLower() )  				{  					case "abs" :  						Expression = Expression.Replace( m.Groups[0].Value' Math.Abs( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "acos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Acos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "asin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Asin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "atan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Atan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cos" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cos( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ceil" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Ceiling( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "cosh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Cosh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "exp" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Exp( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "floor" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Floor( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "ln" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log( Convert.ToDouble( m.Groups[2].Value )' Math.Exp(1.0) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "log" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Log10( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sign" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sign( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sin" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sin( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sinh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sinh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "sqrt" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Sqrt( Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tan" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tan( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  					case "tanh" :  						Expression = Expression.Replace( m.Groups[0].Value ' Math.Tanh( this.Factor * Convert.ToDouble( m.Groups[2].Value ) ).ToString() );  						m = regEx.Match( Expression );  						continue;  				}
Missing Default,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following switch statement is missing a default case: switch( m.Groups[2].Value )  				{  					case "*" :  						result = Convert.ToDouble( m.Groups[1].Value ) * Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = Expression.Replace( m.Value' "+" + result );  						m = regEx.Match( Expression );  						continue;  					case "/" :  						result = Convert.ToDouble( m.Groups[1].Value ) / Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = regEx.Replace( Expression' "+" + result' 1 );  						m = regEx.Match( Expression );  						continue;  				}
Missing Default,MathParser,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParser\Parser.cs,Solve,The following switch statement is missing a default case: switch( m.Groups[2].Value )  				{  					case "+" :  						result = Convert.ToDouble( m.Groups[1].Value ) + Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = regEx.Replace( Expression' "+" + result' 1 );  						m = regEx.Match( Expression );  						continue;  					case "-" :  						result = Convert.ToDouble( m.Groups[1].Value ) - Convert.ToDouble( m.Groups[3].Value );  						if( (result < 0) || (m.Index == 0) ) Expression = regEx.Replace( Expression' result.ToString()' 1 );  						else Expression = regEx.Replace( Expression' "+" + result' 1 );  						m = regEx.Match( Expression );  						continue;  				}
Missing Default,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following switch statement is missing a default case: switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sqrt(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sqrt(rv.DoubleValue).ToString();                              break;                      }
Missing Default,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following switch statement is missing a default case: switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Sin(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Sin(rv.DoubleValue).ToString();                              break;                      }
Missing Default,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following switch statement is missing a default case: switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue' 10).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue' 10).ToString();                              break;                      }
Missing Default,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following switch statement is missing a default case: switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Log(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Log(rv.DoubleValue).ToString();                              break;                      }
Missing Default,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following switch statement is missing a default case: switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Tan(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Tan(rv.DoubleValue).ToString();                              break;                      }
Missing Default,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following switch statement is missing a default case: switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Abs(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Abs(rv.DoubleValue).ToString();                              break;                      }
Missing Default,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following switch statement is missing a default case: switch (rv.ReturnType)                      {                          case SimplificationReturnValue.ReturnTypes.Integer:                              token.TokenValue = Math.Cos(rv.IntValue).ToString();                              break;                          case SimplificationReturnValue.ReturnTypes.Float:                              token.TokenValue = Math.Cos(rv.DoubleValue).ToString();                              break;                      }
Missing Default,MathParserNet,Parser,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserNet\Parser.cs,Simplify,The following switch statement is missing a default case: switch (token.TokenName)                      {                          case TokenParser.Tokens.Float:                              nc.NumberType = NumberClass.NumberTypes.Float;                              nc.FloatNumber = double.Parse(token.TokenValue);                              break;                          case TokenParser.Tokens.Integer:                              nc.NumberType = NumberClass.NumberTypes.Integer;                              nc.IntNumber = int.Parse(token.TokenValue);                              break;                      }
Missing Default,MathParserTK_NET,MathParserTK,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,IsFunction,The following switch statement is missing a default case: switch (s)              {                  case "√":                  case "sqrt":                  case "sin":                  case "cos":                  case "tg":                  case "ctg":                  case "sh":                  case "ch":                  case "th":                  case "log":                  case "ln":                  case "exp":                  case "abs":                      return true;              }
Missing Default,MathParserTK_NET,MathParserTK,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,Calculate,The following switch statement is missing a default case: switch (token)                          {                              case "unMinus": stack.Push((-1 * arg).ToString()); break;                              case "unPlus": stack.Push(arg.ToString()); break;                              case "sqrt":                              case "√": stack.Push((Math.Sqrt(arg)).ToString()); break;                              case "sin":                                  if (radians)                                      stack.Push((Math.Sin(arg)).ToString());                                  else                                      stack.Push((Math.Sin(arg * Math.PI / 180)).ToString()); break;                              case "cos":                                  if (radians)                                      stack.Push((Math.Cos(arg)).ToString());                                  else                                      stack.Push((Math.Cos(arg * Math.PI / 180)).ToString()); break;                              case "tg":                                  if (radians)                                      stack.Push((Math.Tan(arg)).ToString());                                  else                                      stack.Push((Math.Tan(arg * Math.PI / 180)).ToString()); break;                              case "ctg":                                  if (radians)                                      stack.Push((1 / Math.Tan(arg)).ToString());                                  else                                      stack.Push((1 / Math.Tan(arg * Math.PI / 180)).ToString()); break;                              case "sh": stack.Push((Math.Sinh(arg)).ToString()); break;                              case "ch": stack.Push((Math.Cosh(arg)).ToString()); break;                              case "th": stack.Push((Math.Tanh(arg)).ToString()); break;                              case "ln": stack.Push((Math.Log(arg)).ToString()); break;                              case "exp": stack.Push((Math.Exp(arg)).ToString()); break;                              case "abs": stack.Push((Math.Abs(arg)).ToString()); break;                          }
Missing Default,MathParserTK_NET,MathParserTK,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core.Comparison\MathParserTK\MathParserTK.cs,Calculate,The following switch statement is missing a default case: switch (token)                          {                              case "plus": stack.Push((arg1 + arg2).ToString()); break;                              case "minus": stack.Push((arg1 - arg2).ToString()); break;                              case "multiply": stack.Push((arg1 * arg2).ToString()); break;                              case "division":                                  if (arg2 == 0)                                      throw new DivideByZeroException();                                  stack.Push((arg1 / arg2).ToString()); break;                              case "degree": stack.Push((Math.Pow(arg1' arg2).ToString())); break;                              case "log": stack.Push((Math.Log(arg2) / Math.Log(arg1)).ToString()); break;                          }
