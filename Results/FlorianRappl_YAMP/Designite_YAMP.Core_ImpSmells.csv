Implementation smell,Namespace,Class,File,Method,Description
Long Method,YAMP,BootstrapFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\BootstrapFunction.cs,Function,The method has 100 lines of code.
Long Method,YAMP,JackknifeFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\JackknifeFunction.cs,Function,The method has 150 lines of code.
Long Method,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Perform,The method has 107 lines of code.
Long Method,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,tred2,The method has 108 lines of code.
Long Method,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,tql2,The method has 110 lines of code.
Long Method,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The method has 422 lines of code.
Long Method,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The method has 416 lines of code.
Complex Method,YAMP,YMath,C:\repos\FlorianRappl_YAMP\YAMP.Core\Providers\YMath.cs,Mean,Cyclomatic complexity of the method is 8
Complex Method,YAMP,YMath,C:\repos\FlorianRappl_YAMP\YAMP.Core\Providers\YMath.cs,HarmonicMean,Cyclomatic complexity of the method is 8
Complex Method,YAMP,YMath,C:\repos\FlorianRappl_YAMP\YAMP.Core\Providers\YMath.cs,Covariance,Cyclomatic complexity of the method is 8
Complex Method,YAMP,YMath,C:\repos\FlorianRappl_YAMP\YAMP.Core\Providers\YMath.cs,Variance,Cyclomatic complexity of the method is 8
Complex Method,YAMP,Statement,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\Statement.cs,Finalize,Cyclomatic complexity of the method is 9
Complex Method,YAMP,BootstrapFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\BootstrapFunction.cs,Function,Cyclomatic complexity of the method is 12
Complex Method,YAMP,JackknifeFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\JackknifeFunction.cs,Function,Cyclomatic complexity of the method is 17
Complex Method,YAMP,ArgumentFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunction.cs,BuildArguments,Cyclomatic complexity of the method is 10
Complex Method,YAMP,QueryContext,C:\repos\FlorianRappl_YAMP\YAMP.Core\QueryContext.cs,Run,Cyclomatic complexity of the method is 9
Complex Method,YAMP,ContourPlotValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\ContourPlotValue.cs,AddValues,Cyclomatic complexity of the method is 13
Complex Method,YAMP,ErrorPlotValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\ErrorPlotValue.cs,AddValues,Cyclomatic complexity of the method is 10
Complex Method,YAMP,Plot2DValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\Plot2DValue.cs,AddValues,Cyclomatic complexity of the method is 10
Complex Method,YAMP,Plot3DValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\Plot3DValue.cs,AddValues,Cyclomatic complexity of the method is 14
Complex Method,YAMP,NumberExpression,C:\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Elementary\NumberExpression.cs,Scan,Cyclomatic complexity of the method is 10
Complex Method,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,DeleteFullRows,Cyclomatic complexity of the method is 13
Complex Method,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,DeleteFullColumns,Cyclomatic complexity of the method is 13
Complex Method,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Perform,Cyclomatic complexity of the method is 10
Complex Method,YAMP.Numerics,HouseholderDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\HouseholderDecomposition.cs,HouseholderDecomposition,Cyclomatic complexity of the method is 9
Complex Method,YAMP.Numerics,HouseholderDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\HouseholderDecomposition.cs,Solve,Cyclomatic complexity of the method is 11
Complex Method,YAMP.Numerics,Transformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Transformlet.cs,FftKernel,Cyclomatic complexity of the method is 8
Complex Method,YAMP.Numerics,CholeskyDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\CholeskyDecomposition.cs,Solve,Cyclomatic complexity of the method is 11
Complex Method,YAMP.Numerics,Pijavsky,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\Pijavsky.cs,Pijavsky,Cyclomatic complexity of the method is 9
Complex Method,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,tred2,Cyclomatic complexity of the method is 14
Complex Method,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,tql2,Cyclomatic complexity of the method is 11
Complex Method,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,orthes,Cyclomatic complexity of the method is 20
Complex Method,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,Cyclomatic complexity of the method is 21
Complex Method,YAMP.Numerics,LUDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\LUDecomposition.cs,LUDecomposition,Cyclomatic complexity of the method is 12
Complex Method,YAMP.Numerics,LUDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\LUDecomposition.cs,Solve,Cyclomatic complexity of the method is 10
Complex Method,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,Cyclomatic complexity of the method is 54
Complex Method,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,Cyclomatic complexity of the method is 8
Complex Method,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,Cyclomatic complexity of the method is 9
Long Parameter List,YAMP,NewtonFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Fractals\NewtonFunction.cs,Function,The method has 6 parameters. Parameters: x0' xn' y0' yn' xsteps' ysteps
Long Parameter List,YAMP,BracketExpression,C:\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Container\BracketExpression.cs,BracketExpression,The method has 5 parameters. Parameters: line' column' length' query' child
Long Parameter List,YAMP,MatrixExpression,C:\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Container\MatrixExpression.cs,MatrixExpression,The method has 5 parameters. Parameters: line' column' length' query' child
Long Parameter List,YAMP,MandelbrotFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Fractals\MandelbrotFunction.cs,Function,The method has 6 parameters. Parameters: x0' xn' y0' yn' xsteps' ysteps
Long Parameter List,YAMP,CplotFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Visualization\CplotFunction.cs,Function,The method has 5 parameters. Parameters: f' minX' maxX' minY' maxY
Long Parameter List,YAMP,CplotFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Visualization\CplotFunction.cs,Plot,The method has 5 parameters. Parameters: f' minx' maxx' miny' maxy
Long Parameter List,YAMP,SubPlotValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\SubPlotValue.cs,AddSubPlot,The method has 5 parameters. Parameters: row' column' plot' rowSpan' columnSpan
Long Parameter List,YAMP,SubPlotValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\SubPlotValue.cs,AddSubPlot,The method has 6 parameters. Parameters: context' row' column' plot' rowSpan' columnSpan
Long Parameter List,YAMP,Value,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,ScientificFormat,The method has 5 parameters. Parameters: context' value' sign' U' L
Long Parameter List,YAMP,Value,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,EngineeringFormat,The method has 5 parameters. Parameters: context' value' sign' U' L
Long Parameter List,YAMP,Value,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,StandardFormat,The method has 5 parameters. Parameters: context' v' sign' U' L
Long Parameter List,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,IsProbablyPrime,The method has 5 parameters. Parameters: n' m' s' d' w
Long Parameter List,YAMP,AbsExpression,C:\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Container\AbsExpression.cs,AbsExpression,The method has 5 parameters. Parameters: line' column' length' query' child
Long Parameter List,YAMP.Numerics,Fractal,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Fractal.cs,CalculateMatrix,The method has 6 parameters. Parameters: xi' xf' yi' yf' xsteps' ysteps
Long Parameter List,YAMP.Numerics,BlasL3,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Matrices\BlasL3.cs,dGemm,The method has 15 parameters. Parameters: aStore' aOffset' aRowStride' aColStride' bStore' bOffset' bRowStride' bColStride' cStore' cOffset' cRowStride' cColStride' rowsA' colsB' length
Long Parameter List,YAMP.Numerics,BlasL3,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Matrices\BlasL3.cs,cGemm,The method has 15 parameters. Parameters: aStore' aOffset' aRowStride' aColStride' bStore' bOffset' bRowStride' bColStride' cStore' cOffset' cRowStride' cColStride' rowsA' colsB' length
Long Parameter List,YAMP.Numerics,BlasL1,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Matrices\BlasL1.cs,dCopy,The method has 7 parameters. Parameters: xStore' xOffset' xStride' yStore' yOffset' yStride' count
Long Parameter List,YAMP.Numerics,BlasL1,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Matrices\BlasL1.cs,dSwap,The method has 7 parameters. Parameters: xStore' xOffset' xStride' yStore' yOffset' yStride' count
Long Parameter List,YAMP.Numerics,BlasL1,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Matrices\BlasL1.cs,dDot,The method has 7 parameters. Parameters: aStore' aOffset' aStride' bStore' bOffset' bStride' count
Long Parameter List,YAMP.Numerics,BlasL1,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Matrices\BlasL1.cs,cDot,The method has 7 parameters. Parameters: aStore' aOffset' aStride' bStore' bOffset' bStride' count
Long Parameter List,YAMP.Numerics,BlasL1,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Matrices\BlasL1.cs,dScal,The method has 5 parameters. Parameters: alpha' store' offset' stride' count
Long Parameter List,YAMP.Numerics,BlasL1,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Matrices\BlasL1.cs,cScal,The method has 5 parameters. Parameters: alpha' store' offset' stride' count
Long Parameter List,YAMP.Numerics,BlasL1,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Matrices\BlasL1.cs,dAxpy,The method has 8 parameters. Parameters: alpha' xStore' xOffset' xStride' yStore' yOffset' yStride' count
Long Parameter List,YAMP.Numerics,BlasL1,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Matrices\BlasL1.cs,cAxpy,The method has 8 parameters. Parameters: alpha' xStore' xOffset' xStride' yStore' yOffset' yStride' count
Long Parameter List,YAMP.Numerics,BlasL2,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Matrices\BlasL2.cs,dGemv,The method has 12 parameters. Parameters: aStore' aOffset' aRowStride' aColStride' xStore' xOffset' xStride' yStore' yOffset' yStride' rows' cols
Long Parameter List,YAMP.Numerics,BlasL2,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Matrices\BlasL2.cs,cGemv,The method has 12 parameters. Parameters: aStore' aOffset' aRowStride' aColStride' xStore' xOffset' xStride' yStore' yOffset' yStride' rows' cols
Long Parameter List,YAMP.Numerics,BluesteinTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\BluesteinTransformlet.cs,FftKernel,The method has 5 parameters. Parameters: x' y' y0' dy' sign
Long Parameter List,YAMP.Numerics,RadixFiveTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The method has 5 parameters. Parameters: x' y' y0' dy' sign
Long Parameter List,YAMP.Numerics,RadixFourTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFourTransformlet.cs,FftKernel,The method has 5 parameters. Parameters: x' y' y0' dy' sign
Long Parameter List,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The method has 5 parameters. Parameters: x' y' y0' dy' sign
Long Parameter List,YAMP.Numerics,RadixThreeTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixThreeTransformlet.cs,FftKernel,The method has 7 parameters. Parameters: x0' x1' x2' y0' y1' y2' sign
Long Parameter List,YAMP.Numerics,Transformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Transformlet.cs,FftKernel,The method has 5 parameters. Parameters: x' y' y0' dy' sign
Long Parameter List,YAMP.Numerics,Interpolation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\Interpolation.cs,SolveTridiag,The method has 5 parameters. Parameters: sub' diag' sup' b' n
Long Parameter List,YAMP.Numerics,Euler,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\Euler.cs,Euler,The method has 5 parameters. Parameters: f' begin' end' y0' pointsNum
Long Parameter List,YAMP.Numerics,ODEBase,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\ODEBase.cs,ODEBase,The method has 5 parameters. Parameters: f' begin' end' y0' pointsNum
Long Parameter List,YAMP.Numerics,RungeKutta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\RungeKutta.cs,RungeKutta,The method has 5 parameters. Parameters: f' begin' end' y0' pointsNum
Long Parameter List,YAMP.Numerics,Pijavsky,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\Pijavsky.cs,Pijavsky,The method has 5 parameters. Parameters: f' a' b' l' n
Long Parameter List,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,IsProbablyPrime,The method has 5 parameters. Parameters: n' m' s' d' w
Long Statement,YAMP,ObjectExtensions,C:\repos\FlorianRappl_YAMP\YAMP.Core\Extensions\ObjectExtensions.cs,ToDictionary,The length of the statement  "                        throw new ArgumentException("Cannot execute YAMP queries with a list of values that contains types' which are not of a Value' numeric (int' double' float' long) or string (char' string) type."' "values"); " is 204.
Long Statement,YAMP,LinfitFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Numerics\LinfitFunction.cs,Function,The length of the statement  "            return new FunctionValue((parseContext' variable) => ((f.Perform(parseContext' variable) as MatrixValue) * p)[1]' true); " is 120.
Long Statement,YAMP,RGBToImgFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunctions\RGBToImgFunction.cs,Function,The length of the statement  "                    rgbvalues[i' j] = new ScalarValue(rfactor * R[i' j].IntValue + gfactor * G[i' j].IntValue + bfactor * B[i' j].IntValue); " is 120.
Long Statement,YAMP,TypeExtensions,C:\repos\FlorianRappl_YAMP\YAMP.Core\Providers\Extensions.cs,IsCastableTo,The length of the statement  "                    .Where(m => m.ReturnType == to && (m.Name.Equals("op_Implicit") || m.Name.Equals("op_Explicit")) && m.GetParameters()[0].ParameterType == from); " is 144.
Long Statement,YAMP,TypeExtensions,C:\repos\FlorianRappl_YAMP\YAMP.Core\Providers\Extensions.cs,Cast,The length of the statement  "                    .Where(m => m.ReturnType == to && (m.Name == "op_Implicit" || m.Name == "op_Explicit") && m.GetParameters()[0].ParameterType == from).First(); " is 142.
Long Statement,YAMP,ObjectValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Arguments\ObjectValue.cs,RegisterOperators,The length of the statement  "            RegisterMember(typeof(ObjectValue)' typeof(StringValue)' (left' right) => ((ObjectValue)left).GetValue((StringValue)right)); " is 124.
Long Statement,YAMP,Statement,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\Statement.cs,ReduceUnary,The length of the statement  "            while (_operators.Count != 0 && _operators.Peek().Expressions == 1 && _operators.Peek().Level >= container.Operator.Level) " is 122.
Long Statement,YAMP,BracketExpression,C:\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Container\BracketExpression.cs,Scan,The length of the statement  "                var exp = new BracketExpression(line' col' engine.Pointer - start' engine.Query' container ?? new ContainerExpression()); " is 121.
Long Statement,YAMP,MatrixExpression,C:\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Container\MatrixExpression.cs,Scan,The length of the statement  "                return new MatrixExpression(line' column' engine.Pointer - start' engine.Query' container ?? new ContainerExpression()); " is 120.
Long Statement,YAMP,FormatFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\SystemFunctions\FormatFunction.cs,Function,The length of the statement  "            Context.RaiseNotification(new NotificationEventArgs(NotificationType.Information' "Display format changed to " + value + ".")); " is 127.
Long Statement,YAMP,HelpFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\SystemFunctions\HelpFunction.cs,Function,The length of the statement  "                return new StringValue(String.Format("The specified entry was not found. Did you mean {0}?"' docu.ClosestEntry(topic.Value))); " is 126.
Long Statement,YAMP,PrecisionFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\SystemFunctions\PrecisionFunction.cs,Function,The length of the statement  "            Context.RaiseNotification(new NotificationEventArgs(NotificationType.Information' "Output precision changed to " + Context.Precision + " digits.")); " is 148.
Long Statement,YAMP,SetFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Visualization\SetFunction.cs,Function,The length of the statement  "                Context.RaiseNotification(new NotificationEventArgs(NotificationType.Failure' "No plot available... Nothing changed.")); " is 120.
Long Statement,YAMP,SetFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Visualization\SetFunction.cs,Function,The length of the statement  "                Context.RaiseNotification(new NotificationEventArgs(NotificationType.Failure' "No plot available... Nothing changed.")); " is 120.
Long Statement,YAMP,SetFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Visualization\SetFunction.cs,Function,The length of the statement  "                Context.RaiseNotification(new NotificationEventArgs(NotificationType.Failure' "No plot available... Nothing changed.")); " is 120.
Long Statement,YAMP,SetFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Visualization\SetFunction.cs,Function,The length of the statement  "            Context.RaiseNotification(new NotificationEventArgs(NotificationType.Failure' "Series " + String.Join("' "' s.ToArray()) + " changed.")); " is 137.
Long Statement,YAMP,ArgsOperator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Operators\PseudoOperators\ArgsOperator.cs,Create,The length of the statement  "            if (start != 0 && !ParseEngine.IsWhiteSpace(engine.Characters[start - 1]) && !ParseEngine.IsNewLine(engine.Characters[start - 1])) " is 130.
Long Statement,YAMP,ArgumentFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunction.cs,BuildArguments,The length of the statement  "                        return new YAMPArgumentInvalidException(Name' _arguments[idx].Header' yp.ParameterTypes[idx].Name.RemoveValueConvention()' idx); " is 128.
Long Statement,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,ParseStatement,The length of the statement  "                AddError(terminationMissing != null ? terminationMissing(this) : new YAMPTerminatorMissingError(_currentLine' _currentColumn' termination)); " is 140.
Long Statement,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,DeleteFullRows,The length of the statement  "                    if (indices[j].Row == row && !cols.Contains(indices[j].Column) && indices[j].Column >= 1 && indices[j].Column <= Columns) " is 121.
Long Statement,YAMP.Help,Documentation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Help\Documentation.cs,Get,The length of the statement  "			var topic = topics.SelectMany(m => m.Where(n => n.Name.Equals(entry' StringComparison.CurrentCultureIgnoreCase)).Select(n => n)).FirstOrDefault(); " is 146.
Long Statement,YAMP.Numerics,RadixThreeTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixThreeTransformlet.cs,FftPass,The length of the statement  "                    FftKernel(x[j]' x[j + dx] * u[N - du]' x[j + 2 * dx] * u[N - 2 * du]' out y[y0]' out y[y0 + Ns]' out y[y0 + 2 * Ns]' -1); " is 121.
Long Statement,YAMP.Numerics,SplineInterpolation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,ComputeValue,The length of the statement  "                return ((-a[gap - 1] / 6 * (x2 + h[gap]) * x1 + samples[gap' 2].Re) * x2 + (-a[gap] / 6 * (x1 + h[gap]) * x2 + samples[gap + 1' 2].Re) * x1) / h[gap]; " is 150.
Long Statement,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The length of the statement  "				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456))))); " is 130.
Long Statement,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The length of the statement  "				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7))); " is 122.
Long Statement,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The length of the statement  "				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606)))))); " is 131.
Long Statement,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The length of the statement  "				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733)))); " is 126.
Long Statement,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The length of the statement  "				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7)))); " is 125.
Long Statement,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The length of the statement  "				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4))))); " is 151.
Long Statement,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The length of the statement  "				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y))))); " is 148.
Long Statement,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The length of the statement  "                        if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1])))) " is 150.
Long Statement,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Faddeeva,The length of the statement  "                return Taylor(new ScalarValue(z.Re)' Math.Exp(-z.Re * z.Re) + 2.0 * Dawson.DawsonIntegral(z.Re) / Helpers.SqrtPI * ScalarValue.I' new ScalarValue(0.0' z.Im)); " is 158.
Long Statement,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The length of the statement  "                // 31 random bits (int) will suffice which allows us to shift and cast to an int before the first multiplication and gain better performance. " is 141.
Long Statement,YAMP.Numerics,RayleighDistribution,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\RayleighDistribution.cs,NextDouble,The length of the statement  "            return Math.Sqrt(Math.Pow(this.normalDistribution1.NextDouble()' 2) + Math.Pow(this.normalDistribution2.NextDouble()' 2)); " is 122.
Complex Conditional,YAMP,ObjectExtensions,C:\repos\FlorianRappl_YAMP\YAMP.Core\Extensions\ObjectExtensions.cs,ToValue,The conditional expression  "s is Double || s is Int32 || s is Single || s is Int64"  is complex.
Complex Conditional,YAMP,SubPlotValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\SubPlotValue.cs,Perform,The conditional expression  "subplots[i].Row <= row && subplots[i].Row + subplots[i].RowSpan - 1 >= row &&                          subplots[i].Column <= column && subplots[i].Column + subplots[i].ColumnSpan - 1 >= column"  is complex.
Complex Conditional,YAMP,NumberExpression,C:\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Elementary\NumberExpression.cs,Scan,The conditional expression  "ParseEngine.IsNumber(ch) || (ch == '.' && start + 1 < chars.Length && ParseEngine.IsNumber(chars[start + 1]))"  is complex.
Complex Conditional,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,DeleteFullRows,The conditional expression  "indices[j].Row == row && !cols.Contains(indices[j].Column) && indices[j].Column >= 1 && indices[j].Column <= Columns"  is complex.
Complex Conditional,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,DeleteFullColumns,The conditional expression  "indices[j].Column == col && !rows.Contains(indices[j].Row) && indices[j].Row >= 1 && indices[j].Row <= Rows"  is complex.
Complex Conditional,YAMP,StringExpression,C:\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Elementary\StringExpression.cs,Scan,The conditional expression  "chars[start] == '"' || (chars[start] == '@' && start + 1 < chars.Length && chars[start + 1] == '"')"  is complex.
Virtual Method Call from Constructor,YAMP,FunctionValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Arguments\FunctionValue.cs,FunctionValue,The constructor "FunctionValue" calls a virtual method "ToCode".
Virtual Method Call from Constructor,YAMP,Plot2DValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\Plot2DValue.cs,Plot2DValue,The constructor "Plot2DValue" calls a virtual method "InitializeBoundaries".
Virtual Method Call from Constructor,YAMP,PolarPlotValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\PolarPlotValue.cs,PolarPlotValue,The constructor "PolarPlotValue" calls a virtual method "InitializeBoundaries".
Virtual Method Call from Constructor,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,MatrixValue,The constructor "MatrixValue" calls a virtual method "Clone".
Virtual Method Call from Constructor,YAMP.Numerics,GivensDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\GivensDecomposition.cs,GivensDecomposition,The constructor "GivensDecomposition" calls a virtual method "Clone".
Virtual Method Call from Constructor,YAMP.Numerics,ODEBase,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\ODEBase.cs,ODEBase,The constructor "ODEBase" calls a virtual method "Calculate".
Empty Catch Block,YAMP,ParseContext,C:\repos\FlorianRappl_YAMP\YAMP.Core\ParseContext.cs,ApplyPlotTemplate,The method has an empty catch block.
Empty Catch Block,YAMP,ParseContext,C:\repos\FlorianRappl_YAMP\YAMP.Core\ParseContext.cs,ApplyPlotTemplate,The method has an empty catch block.
Magic Number,YAMP,SphereFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunctions\SphereFunction.cs,Function,The following statement contains a magic number: return Function(new ScalarValue(20));
Magic Number,YAMP,SphereFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunctions\SphereFunction.cs,Function,The following statement contains a magic number: if (dim < 2)                  throw new YAMPArgumentRangeException("n"' 1.0);
Magic Number,YAMP,SphereFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunctions\SphereFunction.cs,Function,The following statement contains a magic number: var stheta = Table(0.0' 2.0 * Math.PI' dim' Math.Sin);
Magic Number,YAMP,SphereFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunctions\SphereFunction.cs,Function,The following statement contains a magic number: var ctheta = Table(0.0' 2.0 * Math.PI' dim' Math.Cos);
Magic Number,YAMP,Bin2DecFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Bin2DecFunction.cs,Function,The following statement contains a magic number: while (binary.Count != 0)              {                  var el = binary.Pop();                    if (el)                  {                      sum += weight;                  }                    weight *= 2;              }
Magic Number,YAMP,Cart2PolFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2PolFunction.cs,Function,The following statement contains a magic number: return new MatrixValue(new[] { new ScalarValue(r)' new ScalarValue(phi) }' 2' 1);
Magic Number,YAMP,Cart2PolFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2PolFunction.cs,Function,The following statement contains a magic number: if (M.DimensionX != 2 && M.DimensionY != 2)                  throw new YAMPMatrixDimensionException(2' M.DimensionX' M.DimensionY' M.DimensionX);
Magic Number,YAMP,Cart2PolFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2PolFunction.cs,Function,The following statement contains a magic number: if (M.DimensionX != 2 && M.DimensionY != 2)                  throw new YAMPMatrixDimensionException(2' M.DimensionX' M.DimensionY' M.DimensionX);
Magic Number,YAMP,Cart2PolFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2PolFunction.cs,Function,The following statement contains a magic number: if (M.DimensionX != 2 && M.DimensionY != 2)                  throw new YAMPMatrixDimensionException(2' M.DimensionX' M.DimensionY' M.DimensionX);
Magic Number,YAMP,Cart2PolFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2PolFunction.cs,Function,The following statement contains a magic number: var isTransposed = M.DimensionY != 2;
Magic Number,YAMP,Cart2PolFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2PolFunction.cs,Function,The following statement contains a magic number: var m = new MatrixValue(2' M.DimensionX);
Magic Number,YAMP,Cart2PolFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2PolFunction.cs,Function,The following statement contains a magic number: for (var i = 1; i <= M.DimensionX; i++)              {                  var x = M[1' i].Re;                  var y = M[2' i].Re;                  var phi = Math.Atan2(y' x);                  var r = x == 0.0 ? y : (y == 0.0 ? x : x / Math.Cos(phi));                  m[1' i] = new ScalarValue(r * Math.Cos(phi));                  m[2' i] = new ScalarValue(r * Math.Sin(phi));              }
Magic Number,YAMP,Cart2PolFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2PolFunction.cs,Function,The following statement contains a magic number: for (var i = 1; i <= M.DimensionX; i++)              {                  var x = M[1' i].Re;                  var y = M[2' i].Re;                  var phi = Math.Atan2(y' x);                  var r = x == 0.0 ? y : (y == 0.0 ? x : x / Math.Cos(phi));                  m[1' i] = new ScalarValue(r * Math.Cos(phi));                  m[2' i] = new ScalarValue(r * Math.Sin(phi));              }
Magic Number,YAMP,Cart2SphFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2SphFunction.cs,Function,The following statement contains a magic number: return new MatrixValue(new[] { new ScalarValue(r)' new ScalarValue(theta)' new ScalarValue(phi) }' 3' 1);
Magic Number,YAMP,Cart2SphFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2SphFunction.cs,Function,The following statement contains a magic number: if (M.DimensionX != 3 && M.DimensionY != 3)                  throw new YAMPMatrixDimensionException(3' M.DimensionX' M.DimensionY' M.DimensionX);
Magic Number,YAMP,Cart2SphFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2SphFunction.cs,Function,The following statement contains a magic number: if (M.DimensionX != 3 && M.DimensionY != 3)                  throw new YAMPMatrixDimensionException(3' M.DimensionX' M.DimensionY' M.DimensionX);
Magic Number,YAMP,Cart2SphFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2SphFunction.cs,Function,The following statement contains a magic number: if (M.DimensionX != 3 && M.DimensionY != 3)                  throw new YAMPMatrixDimensionException(3' M.DimensionX' M.DimensionY' M.DimensionX);
Magic Number,YAMP,Cart2SphFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2SphFunction.cs,Function,The following statement contains a magic number: var isTransposed = M.DimensionY != 3;
Magic Number,YAMP,Cart2SphFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2SphFunction.cs,Function,The following statement contains a magic number: var m = new MatrixValue(3' M.DimensionX);
Magic Number,YAMP,Cart2SphFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2SphFunction.cs,Function,The following statement contains a magic number: for (var i = 1; i <= M.DimensionX; i++)              {                  var x = M[1' i].Re;                  var y = M[2' i].Re;                  var z = M[3' i].Re;                  var r = Math.Sqrt(x * x + y * y + z * z);                  var phi = Math.Atan2(y' x);                  var theta = Math.Acos(z / r);                  m[1' i] = new ScalarValue(r);                  m[2' i] = new ScalarValue(theta);                  m[3' i] = new ScalarValue(phi);              }
Magic Number,YAMP,Cart2SphFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2SphFunction.cs,Function,The following statement contains a magic number: for (var i = 1; i <= M.DimensionX; i++)              {                  var x = M[1' i].Re;                  var y = M[2' i].Re;                  var z = M[3' i].Re;                  var r = Math.Sqrt(x * x + y * y + z * z);                  var phi = Math.Atan2(y' x);                  var theta = Math.Acos(z / r);                  m[1' i] = new ScalarValue(r);                  m[2' i] = new ScalarValue(theta);                  m[3' i] = new ScalarValue(phi);              }
Magic Number,YAMP,Cart2SphFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2SphFunction.cs,Function,The following statement contains a magic number: for (var i = 1; i <= M.DimensionX; i++)              {                  var x = M[1' i].Re;                  var y = M[2' i].Re;                  var z = M[3' i].Re;                  var r = Math.Sqrt(x * x + y * y + z * z);                  var phi = Math.Atan2(y' x);                  var theta = Math.Acos(z / r);                  m[1' i] = new ScalarValue(r);                  m[2' i] = new ScalarValue(theta);                  m[3' i] = new ScalarValue(phi);              }
Magic Number,YAMP,Cart2SphFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2SphFunction.cs,Function,The following statement contains a magic number: for (var i = 1; i <= M.DimensionX; i++)              {                  var x = M[1' i].Re;                  var y = M[2' i].Re;                  var z = M[3' i].Re;                  var r = Math.Sqrt(x * x + y * y + z * z);                  var phi = Math.Atan2(y' x);                  var theta = Math.Acos(z / r);                  m[1' i] = new ScalarValue(r);                  m[2' i] = new ScalarValue(theta);                  m[3' i] = new ScalarValue(phi);              }
Magic Number,YAMP,Hex2DecFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Hex2DecFunction.cs,Function,The following statement contains a magic number: for (var i = 1; i <= hexstr.Length; i++)              {                  var chr = hexstr[i];                    if (!ParseEngine.IsWhiteSpace(chr) && !ParseEngine.IsNewLine(chr))                  {                      if (chr >= '0' && chr <= '9')                      {                          hex.Push((Int32)(chr - '0'));                      }                      else if (chr >= 'A' && chr <= 'F')                      {                          hex.Push((Int32)(chr - 'A') + 10);                      }                      else if (chr >= 'a' && chr <= 'f')                      {                          hex.Push((Int32)(chr - 'a') + 10);                      }                      else                      {                          throw new YAMPRuntimeException("hex2dec can only interpret hexadecimal strings.");                      }                  }              }
Magic Number,YAMP,Hex2DecFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Hex2DecFunction.cs,Function,The following statement contains a magic number: for (var i = 1; i <= hexstr.Length; i++)              {                  var chr = hexstr[i];                    if (!ParseEngine.IsWhiteSpace(chr) && !ParseEngine.IsNewLine(chr))                  {                      if (chr >= '0' && chr <= '9')                      {                          hex.Push((Int32)(chr - '0'));                      }                      else if (chr >= 'A' && chr <= 'F')                      {                          hex.Push((Int32)(chr - 'A') + 10);                      }                      else if (chr >= 'a' && chr <= 'f')                      {                          hex.Push((Int32)(chr - 'a') + 10);                      }                      else                      {                          throw new YAMPRuntimeException("hex2dec can only interpret hexadecimal strings.");                      }                  }              }
Magic Number,YAMP,Hex2DecFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Hex2DecFunction.cs,Function,The following statement contains a magic number: while (hex.Count != 0)              {                  var el = hex.Pop();                  sum += weight * el;                  weight *= 16;              }
Magic Number,YAMP,Oct2DecFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Oct2DecFunction.cs,Function,The following statement contains a magic number: while (hex.Count != 0)              {                  var el = hex.Pop();                  sum += weight * el;                  weight *= 8;              }
Magic Number,YAMP,Pol2CartFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Pol2CartFunction.cs,Function,The following statement contains a magic number: return new MatrixValue(new[] { x' y }' 2' 1);
Magic Number,YAMP,Pol2CartFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Pol2CartFunction.cs,Function,The following statement contains a magic number: if (M.DimensionX != 2 && M.DimensionY != 2)                  throw new YAMPMatrixDimensionException(2' M.DimensionX' M.DimensionY' M.DimensionX);
Magic Number,YAMP,Pol2CartFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Pol2CartFunction.cs,Function,The following statement contains a magic number: if (M.DimensionX != 2 && M.DimensionY != 2)                  throw new YAMPMatrixDimensionException(2' M.DimensionX' M.DimensionY' M.DimensionX);
Magic Number,YAMP,Pol2CartFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Pol2CartFunction.cs,Function,The following statement contains a magic number: if (M.DimensionX != 2 && M.DimensionY != 2)                  throw new YAMPMatrixDimensionException(2' M.DimensionX' M.DimensionY' M.DimensionX);
Magic Number,YAMP,Pol2CartFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Pol2CartFunction.cs,Function,The following statement contains a magic number: var isTransposed = M.DimensionY != 2;
Magic Number,YAMP,Pol2CartFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Pol2CartFunction.cs,Function,The following statement contains a magic number: var m = new MatrixValue(2' M.DimensionX);
Magic Number,YAMP,Pol2CartFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Pol2CartFunction.cs,Function,The following statement contains a magic number: for (var i = 1; i <= M.DimensionX; i++)              {                  var r = M[1' i].Re;                  var phi = M[2' i].Re;                  m[1' i] = new ScalarValue(r * Math.Cos(phi));                  m[2' i] = new ScalarValue(r * Math.Sin(phi));              }
Magic Number,YAMP,Pol2CartFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Pol2CartFunction.cs,Function,The following statement contains a magic number: for (var i = 1; i <= M.DimensionX; i++)              {                  var r = M[1' i].Re;                  var phi = M[2' i].Re;                  m[1' i] = new ScalarValue(r * Math.Cos(phi));                  m[2' i] = new ScalarValue(r * Math.Sin(phi));              }
Magic Number,YAMP,Sph2CartFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Sph2CartFunction.cs,Function,The following statement contains a magic number: return new MatrixValue(new[] { x' y' z }' 3' 1);
Magic Number,YAMP,Sph2CartFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Sph2CartFunction.cs,Function,The following statement contains a magic number: if (M.DimensionX != 3 && M.DimensionY != 3)                  throw new YAMPMatrixDimensionException(3' M.DimensionX' M.DimensionY' M.DimensionX);
Magic Number,YAMP,Sph2CartFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Sph2CartFunction.cs,Function,The following statement contains a magic number: if (M.DimensionX != 3 && M.DimensionY != 3)                  throw new YAMPMatrixDimensionException(3' M.DimensionX' M.DimensionY' M.DimensionX);
Magic Number,YAMP,Sph2CartFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Sph2CartFunction.cs,Function,The following statement contains a magic number: if (M.DimensionX != 3 && M.DimensionY != 3)                  throw new YAMPMatrixDimensionException(3' M.DimensionX' M.DimensionY' M.DimensionX);
Magic Number,YAMP,Sph2CartFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Sph2CartFunction.cs,Function,The following statement contains a magic number: var isTransposed = M.DimensionY != 3;
Magic Number,YAMP,Sph2CartFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Sph2CartFunction.cs,Function,The following statement contains a magic number: var m = new MatrixValue(3' M.DimensionX);
Magic Number,YAMP,Sph2CartFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Sph2CartFunction.cs,Function,The following statement contains a magic number: for (var i = 1; i <= M.DimensionX; i++)              {                  var r = M[1' i].Re;                  var theta = M[2' i].Re;                  var phi = M[3' i].Re;                  var rt = r * Math.Sin(theta);                  m[1' i] = new ScalarValue(rt * Math.Cos(phi));                  m[2' i] = new ScalarValue(rt * Math.Sin(phi));                  m[3' i] = new ScalarValue(r * Math.Cos(theta));              }
Magic Number,YAMP,Sph2CartFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Sph2CartFunction.cs,Function,The following statement contains a magic number: for (var i = 1; i <= M.DimensionX; i++)              {                  var r = M[1' i].Re;                  var theta = M[2' i].Re;                  var phi = M[3' i].Re;                  var rt = r * Math.Sin(theta);                  m[1' i] = new ScalarValue(rt * Math.Cos(phi));                  m[2' i] = new ScalarValue(rt * Math.Sin(phi));                  m[3' i] = new ScalarValue(r * Math.Cos(theta));              }
Magic Number,YAMP,Sph2CartFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Sph2CartFunction.cs,Function,The following statement contains a magic number: for (var i = 1; i <= M.DimensionX; i++)              {                  var r = M[1' i].Re;                  var theta = M[2' i].Re;                  var phi = M[3' i].Re;                  var rt = r * Math.Sin(theta);                  m[1' i] = new ScalarValue(rt * Math.Cos(phi));                  m[2' i] = new ScalarValue(rt * Math.Sin(phi));                  m[3' i] = new ScalarValue(r * Math.Cos(theta));              }
Magic Number,YAMP,Sph2CartFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Sph2CartFunction.cs,Function,The following statement contains a magic number: for (var i = 1; i <= M.DimensionX; i++)              {                  var r = M[1' i].Re;                  var theta = M[2' i].Re;                  var phi = M[3' i].Re;                  var rt = r * Math.Sin(theta);                  m[1' i] = new ScalarValue(rt * Math.Cos(phi));                  m[2' i] = new ScalarValue(rt * Math.Sin(phi));                  m[3' i] = new ScalarValue(r * Math.Cos(theta));              }
Magic Number,YAMP,NewtonFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Fractals\NewtonFunction.cs,Function,The following statement contains a magic number: return m.CalculateMatrix(-1.0' 1.0' -1.0' 1.0' 150' 150);
Magic Number,YAMP,NewtonFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Fractals\NewtonFunction.cs,Function,The following statement contains a magic number: return m.CalculateMatrix(-1.0' 1.0' -1.0' 1.0' 150' 150);
Magic Number,YAMP,NewtonFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Fractals\NewtonFunction.cs,Function,The following statement contains a magic number: var xsteps = (int)Math.Abs(Math.Ceiling((xn.Re - x0.Re) / 0.1));
Magic Number,YAMP,NewtonFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Fractals\NewtonFunction.cs,Function,The following statement contains a magic number: var ysteps = (int)Math.Abs(Math.Ceiling((yn.Re - y0.Re) / 0.1));
Magic Number,YAMP,LinfitFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Numerics\LinfitFunction.cs,Function,The following statement contains a magic number: if (m < 2)                  throw new YAMPArgumentInvalidException("Linfit"' "f"' 3);
Magic Number,YAMP,LinfitFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Numerics\LinfitFunction.cs,Function,The following statement contains a magic number: if (m < 2)                  throw new YAMPArgumentInvalidException("Linfit"' "f"' 3);
Magic Number,YAMP,LinfitFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Numerics\LinfitFunction.cs,Function,The following statement contains a magic number: if (_fx is MatrixValue == false)                  throw new YAMPArgumentInvalidException("Linfit"' "f"' 3);
Magic Number,YAMP,LinfitFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Numerics\LinfitFunction.cs,Function,The following statement contains a magic number: if (m < 2)                  throw new YAMPArgumentInvalidException("Linfit"' "f"' 3);
Magic Number,YAMP,LinfitFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Numerics\LinfitFunction.cs,Function,The following statement contains a magic number: if (m < 2)                  throw new YAMPArgumentInvalidException("Linfit"' "f"' 3);
Magic Number,YAMP,PolyfitFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Numerics\PolyfitFunction.cs,Function,The following statement contains a magic number: if (m < 2)                  throw new YAMPArgumentRangeException("n"' 0.0);
Magic Number,YAMP,RandbFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\RandomNumbers\RandbFunction.cs,Function,The following statement contains a magic number: return Function(rows' cols' new ScalarValue(0.5)' new ScalarValue(1.0));
Magic Number,YAMP,RandbFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\RandomNumbers\RandbFunction.cs,Binomial,The following statement contains a magic number: return Binomial(0.5' 1);
Magic Number,YAMP,Log2Function,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\StandardFunctions\Log2Function.cs,GetValue,The following statement contains a magic number: return value.Log(2.0);
Magic Number,YAMP,SizeFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\StandardFunctions\SizeFunction.cs,Function,The following statement contains a magic number: m[1' 2] = new ScalarValue(M.DimensionX);
Magic Number,YAMP,SizeFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\StandardFunctions\SizeFunction.cs,Function,The following statement contains a magic number: m[1' 2] = new ScalarValue(1);
Magic Number,YAMP,SizeFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\StandardFunctions\SizeFunction.cs,Function,The following statement contains a magic number: m[1' 2] = new ScalarValue(str.Value.Length);
Magic Number,YAMP,HistogramFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\HistogramFunction.cs,Function,The following statement contains a magic number: return Function(Y' new ScalarValue(10));
Magic Number,YAMP,DistFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\DistFunction.cs,Function,The following statement contains a magic number: var dist = linearfit.Function(x' fx' new FunctionValue((context' argument) =>              {                  var _x = (argument as ScalarValue - median / 2) / (variance / 4);                  var _exp_x_2 = (-_x * _x).Exp();                  var result = new MatrixValue(1' nP - 1);                    for (var i = 0; i < nP - 1; i++)                  {                      result[i + 1] = _exp_x_2 * _x.Pow(new ScalarValue(i));                  }                    return result;              }' true));
Magic Number,YAMP,DistFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\DistFunction.cs,Function,The following statement contains a magic number: var dist = linearfit.Function(x' fx' new FunctionValue((context' argument) =>              {                  var _x = (argument as ScalarValue - median / 2) / (variance / 4);                  var _exp_x_2 = (-_x * _x).Exp();                  var result = new MatrixValue(1' nP - 1);                    for (var i = 0; i < nP - 1; i++)                  {                      result[i + 1] = _exp_x_2 * _x.Pow(new ScalarValue(i));                  }                    return result;              }' true));
Magic Number,YAMP,ArtanhFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Trigonometric\ArtanhFunction.cs,GetValue,The following statement contains a magic number: return 0.5 * ((1.0 + value) / (1.0 - value)).Ln();
Magic Number,YAMP,CschFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Trigonometric\CschFunction.cs,GetValue,The following statement contains a magic number: return 2.0 / (value.Exp() - (-value).Exp());
Magic Number,YAMP,SechFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Trigonometric\SechFunction.cs,GetValue,The following statement contains a magic number: return 2.0 / (value.Exp() + (-value).Exp());
Magic Number,YAMP,ImgToRGBFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunctions\ImgToRGBFunction.cs,Function,The following statement contains a magic number: for (var i = 1; i <= M.DimensionY; i++)              {                  for (var j = 1; j <= M.DimensionX; j++)                  {                      int value = M[i' j].IntValue;                        rvalues[i' j] = new ScalarValue((value / rfactor) % 256);                      gvalues[i' j] = new ScalarValue((value / gfactor) % 256);                      bvalues[i' j] = new ScalarValue((value / bfactor) % 256);                  }              }
Magic Number,YAMP,ImgToRGBFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunctions\ImgToRGBFunction.cs,Function,The following statement contains a magic number: for (var i = 1; i <= M.DimensionY; i++)              {                  for (var j = 1; j <= M.DimensionX; j++)                  {                      int value = M[i' j].IntValue;                        rvalues[i' j] = new ScalarValue((value / rfactor) % 256);                      gvalues[i' j] = new ScalarValue((value / gfactor) % 256);                      bvalues[i' j] = new ScalarValue((value / bfactor) % 256);                  }              }
Magic Number,YAMP,ImgToRGBFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunctions\ImgToRGBFunction.cs,Function,The following statement contains a magic number: for (var i = 1; i <= M.DimensionY; i++)              {                  for (var j = 1; j <= M.DimensionX; j++)                  {                      int value = M[i' j].IntValue;                        rvalues[i' j] = new ScalarValue((value / rfactor) % 256);                      gvalues[i' j] = new ScalarValue((value / gfactor) % 256);                      bvalues[i' j] = new ScalarValue((value / bfactor) % 256);                  }              }
Magic Number,YAMP,YMath,C:\repos\FlorianRappl_YAMP\YAMP.Core\Providers\YMath.cs,Histogram,The following statement contains a magic number: for (var i = 0; i < nbins; i++)              {                  D[i] = delta * (i + 0.5) + min;              }
Magic Number,YAMP,YMath,C:\repos\FlorianRappl_YAMP\YAMP.Core\Providers\YMath.cs,Median,The following statement contains a magic number: if (M.Length % 2 == 1)              {                  midPoint = M.Length / 2;                  sum = M[midPoint + 1];              }              else              {                  midPoint = (M.Length / 2);                  sum = M[midPoint] + M[midPoint + 1];                  sum /= 2.0;              }
Magic Number,YAMP,YMath,C:\repos\FlorianRappl_YAMP\YAMP.Core\Providers\YMath.cs,Median,The following statement contains a magic number: if (M.Length % 2 == 1)              {                  midPoint = M.Length / 2;                  sum = M[midPoint + 1];              }              else              {                  midPoint = (M.Length / 2);                  sum = M[midPoint] + M[midPoint + 1];                  sum /= 2.0;              }
Magic Number,YAMP,YMath,C:\repos\FlorianRappl_YAMP\YAMP.Core\Providers\YMath.cs,Median,The following statement contains a magic number: if (M.Length % 2 == 1)              {                  midPoint = M.Length / 2;                  sum = M[midPoint + 1];              }              else              {                  midPoint = (M.Length / 2);                  sum = M[midPoint] + M[midPoint + 1];                  sum /= 2.0;              }
Magic Number,YAMP,YMath,C:\repos\FlorianRappl_YAMP\YAMP.Core\Providers\YMath.cs,Median,The following statement contains a magic number: if (M.Length % 2 == 1)              {                  midPoint = M.Length / 2;                  sum = M[midPoint + 1];              }              else              {                  midPoint = (M.Length / 2);                  sum = M[midPoint] + M[midPoint + 1];                  sum /= 2.0;              }
Magic Number,YAMP,Statement,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\Statement.cs,Statement,The following statement contains a magic number: _maxLevel = -100;
Magic Number,YAMP,Statement,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\Statement.cs,Push,The following statement contains a magic number: if (!_finalized)              {                  @operator = @operator ?? Operator.Void;                    if (@operator.Expressions == 1 && @operator.IsRightToLeft)                  {                      if (_maxLevel > @operator.Level)                      {                          PopExpressions(@operator);                      }                        _expressions.Push(new ContainerExpression(_expressions.Pop()' @operator));                  }                  else                  {                      if (@operator.Expressions == 2)                      {                          if (@operator.Level >= (@operator.IsRightToLeft ? _maxLevel : _maxLevel + 1))                          {                              _maxLevel = @operator.Level;                          }                          else                          {                              PopExpressions(@operator);                          }                      }                        _operators.Push(@operator);                      _takeOperator = false;                  }              }
Magic Number,YAMP,ContainerExpression,C:\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Container\ContainerExpression.cs,ToString,The following statement contains a magic number: if (_expressions != null)              {                  if (_expressions.Length == 1 && _operator == null)                  {                      return String.Format(" [ {0} ] "' _expressions[0]);                  }                  else if (_operator != null)                  {                      if (_expressions.Length == 1)                      {                          return String.Format(" [ {0} {1} ] "' _expressions[0]' _operator);                      }                      else if (_expressions.Length == 2)                      {                          return String.Format(" [ {0} {1} {2} ] "' _expressions[0]' _operator' _expressions[1]);                      }                  }              }
Magic Number,YAMP,ContainerExpression,C:\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Container\ContainerExpression.cs,ToDebug,The following statement contains a magic number: if (_expressions != null)              {                  if (_expressions.Length == 1 && _operator == null)                  {                      return String.Format(                          "{0}[{1}(exp)" + Environment.NewLine +                          "{2}" + Environment.NewLine +                          "{0}]"'                          pad' containerType'                          _expressions[0].ToDebug(padLeft + tabsize' tabsize));                  }                  else if (_operator != null)                  {                      if (_expressions.Length == 1)                      {                          return String.Format(                              "{0}[{1}(exp'op)" + Environment.NewLine +                              "{2}" + Environment.NewLine +                              "{3}" + Environment.NewLine +                              "{0}]"'                              pad' containerType'                              _expressions[0].ToDebug(padLeft + tabsize' tabsize)'                              _operator.ToDebug(padLeft + tabsize' tabsize));                      }                      else if (_expressions.Length == 2)                      {                          return String.Format(                              "{0}[{1}(exp1'op'exp2)" + Environment.NewLine +                              "{2}" + Environment.NewLine +                              "{3}" + Environment.NewLine +                              "{4}" + Environment.NewLine +                              "{0}]"'                              pad' containerType'                              _expressions[0].ToDebug(padLeft + tabsize' tabsize)'                              _operator.ToDebug(padLeft + tabsize' tabsize)'                              _expressions[1].ToDebug(padLeft + tabsize' tabsize));                      }                  }              }
Magic Number,YAMP,MandelbrotFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Fractals\MandelbrotFunction.cs,Function,The following statement contains a magic number: return m.CalculateMatrix(-2.5' 1.0' -1.0' 1.0' 150' 150);
Magic Number,YAMP,MandelbrotFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Fractals\MandelbrotFunction.cs,Function,The following statement contains a magic number: return m.CalculateMatrix(-2.5' 1.0' -1.0' 1.0' 150' 150);
Magic Number,YAMP,MandelbrotFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Fractals\MandelbrotFunction.cs,Function,The following statement contains a magic number: return m.CalculateMatrix(-2.5' 1.0' -1.0' 1.0' 150' 150);
Magic Number,YAMP,MandelbrotFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Fractals\MandelbrotFunction.cs,Function,The following statement contains a magic number: var xsteps = (Int32)Math.Abs(Math.Ceiling((xn.Re - x0.Re) / 0.1));
Magic Number,YAMP,MandelbrotFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Fractals\MandelbrotFunction.cs,Function,The following statement contains a magic number: var ysteps = (Int32)Math.Abs(Math.Ceiling((yn.Re - y0.Re) / 0.1));
Magic Number,YAMP,GcdFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Numerics\GcdFunction.cs,Function,The following statement contains a magic number: if (values.Length != 0)              {                  var gcd = values[1].GetIntegerOrThrowException("values"' Name);                    for (var i = 2; i <= values.Length; i++)                  {                      gcd = Helpers.GCD(gcd' values[i].GetIntegerOrThrowException("values"' Name));                  }                    return new ScalarValue(gcd);              }
Magic Number,YAMP,RootFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Numerics\RootFunction.cs,Function,The following statement contains a magic number: var newton = new NewtonMethod(lambda' x.Re' 0.00001);
Magic Number,YAMP,ACorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\ACorFunction.cs,Function,The following statement contains a magic number: if (M.Length > 1)              {                  var nOffset = (Int32)(10 * Math.Log10(M.Length));                    if (nOffset < 0)                  {                      nOffset = 0;                  }                  else if (nOffset >= M.Length)                  {                      nOffset = M.Length - 1;                  }                    return YMath.CrossCorrelation(M' M' nOffset);              }
Magic Number,YAMP,BootstrapFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\BootstrapFunction.cs,Function,The following statement contains a magic number: var result = new MatrixValue(2' nResult);
Magic Number,YAMP,BootstrapFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\BootstrapFunction.cs,Function,The following statement contains a magic number: if (temp is ScalarValue)              {                  result[1] = (ScalarValue)temp;                  result[2] = (ScalarValue)error;              }              else              {                  var T = (MatrixValue)temp;                  var E = (MatrixValue)error;                    for (var k = 1; k <= nResult; k++)                  {                      result[1' k] = T[k];                      result[2' k] = E[k];                  }              }
Magic Number,YAMP,BootstrapFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\BootstrapFunction.cs,Function,The following statement contains a magic number: if (temp is ScalarValue)              {                  result[1] = (ScalarValue)temp;                  result[2] = (ScalarValue)error;              }              else              {                  var T = (MatrixValue)temp;                  var E = (MatrixValue)error;                    for (var k = 1; k <= nResult; k++)                  {                      result[1' k] = T[k];                      result[2' k] = E[k];                  }              }
Magic Number,YAMP,JackknifeFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\JackknifeFunction.cs,Function,The following statement contains a magic number: var result = new MatrixValue(2' nResult);
Magic Number,YAMP,JackknifeFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\JackknifeFunction.cs,Function,The following statement contains a magic number: if (temp is ScalarValue)              {                  result[1] = (ScalarValue)temp;                  result[2] = (ScalarValue)error;              }              else              {                  var T = (MatrixValue)temp;                  var E = (MatrixValue)error;                    for (var k = 1; k <= nResult; k++)                  {                      result[1' k] = T[k];                      result[2' k] = E[k];                  }              }
Magic Number,YAMP,JackknifeFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\JackknifeFunction.cs,Function,The following statement contains a magic number: if (temp is ScalarValue)              {                  result[1] = (ScalarValue)temp;                  result[2] = (ScalarValue)error;              }              else              {                  var T = (MatrixValue)temp;                  var E = (MatrixValue)error;                    for (var k = 1; k <= nResult; k++)                  {                      result[1' k] = T[k];                      result[2' k] = E[k];                  }              }
Magic Number,YAMP,LsqFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\LsqFunction.cs,Function,The following statement contains a magic number: if (M.DimensionX != 2 && M.DimensionY != 2)  				throw new YAMPOperationInvalidException("lsq"' "because exactly two rows or columns are required.");
Magic Number,YAMP,LsqFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\LsqFunction.cs,Function,The following statement contains a magic number: if (M.DimensionX != 2 && M.DimensionY != 2)  				throw new YAMPOperationInvalidException("lsq"' "because exactly two rows or columns are required.");
Magic Number,YAMP,LsqFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\LsqFunction.cs,Function,The following statement contains a magic number: if (M.DimensionX > M.DimensionY)  				return Function(M.GetSubMatrix(0' 1' 0' M.DimensionX)' M.GetSubMatrix(1' 2' 0' M.DimensionX));
Magic Number,YAMP,LsqFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\LsqFunction.cs,Function,The following statement contains a magic number: return Function(M.GetSubMatrix(0' M.DimensionY' 0' 1)' M.GetSubMatrix(0' M.DimensionY' 1' 2));
Magic Number,YAMP,XCorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\XCorFunction.cs,Function,The following statement contains a magic number: if (M.Length == N.Length && M.Length > 1)              {                  var nOffset = (Int32)(10 * Math.Log10(M.Length));                    if (nOffset < 0)                  {                      nOffset = 0;                  }                  else if (nOffset >= M.Length)                  {                      nOffset = M.Length - 1;                  }                    return YMath.CrossCorrelation(M' N' nOffset);              }
Magic Number,YAMP,SolveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\LinearAlgebra\SolveFunction.cs,Function,The following statement contains a magic number: if (M.IsSymmetric)  			{  				var cg = new CGSolver(M);  				return cg.Solve(phi);  			}  			else if (M.DimensionX == M.DimensionY && M.DimensionY > 64) // Is there a way to "guess" a good number for this?  			{  				var gmres = new GMRESkSolver(M);  				gmres.Restart = 30;  				return gmres.Solve(phi);  			}
Magic Number,YAMP,SolveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\LinearAlgebra\SolveFunction.cs,Function,The following statement contains a magic number: if (M.IsSymmetric)  			{  				var cg = new CGSolver(M);  				return cg.Solve(phi);  			}  			else if (M.DimensionX == M.DimensionY && M.DimensionY > 64) // Is there a way to "guess" a good number for this?  			{  				var gmres = new GMRESkSolver(M);  				gmres.Restart = 30;  				return gmres.Solve(phi);  			}
Magic Number,YAMP,SplineFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Numerics\SplineFunction.cs,Function,The following statement contains a magic number: var M = new MatrixValue(1' 2);
Magic Number,YAMP,SplineFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Numerics\SplineFunction.cs,Function,The following statement contains a magic number: M[1' 2].Re = spline.ComputeValue(x.Re);
Magic Number,YAMP,FplotFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Visualization\FplotFunction.cs,Function,The following statement contains a magic number: return Plot(f' -1.0' 1.0' 0.05);
Magic Number,YAMP,FplotFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Visualization\FplotFunction.cs,Function,The following statement contains a magic number: return Plot(f' min.Re' max.Re' 0.05);
Magic Number,YAMP,FplotFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Visualization\FplotFunction.cs,Plot,The following statement contains a magic number: var M = new MatrixValue(N' 2);
Magic Number,YAMP,FplotFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Visualization\FplotFunction.cs,Plot,The following statement contains a magic number: for (var i = 0; i < N; i++)  			{  				var row = i + 1;  				var y = f.Perform(Context' x);  				M[row' 1] = x.Clone();                    if (y is ScalarValue)                  {                      M[row' 2] = (ScalarValue)y;                  }                  else if (y is MatrixValue)                  {                      var Y = (MatrixValue)y;                        for (var j = 1; j <= Y.Length; j++)                      {                          M[row' j + 1] = Y[j];                      }                  }    				x.Re += precision;  			}
Magic Number,YAMP,HistFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Visualization\HistFunction.cs,Function,The following statement contains a magic number: return Function(Y' new ScalarValue(10));
Magic Number,YAMP,ArgsOperator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Operators\PseudoOperators\ArgsOperator.cs,ToDebug,The following statement contains a magic number: return string.Format(                  "{2}" + Environment.NewLine +                  "{0}{1}<" + Environment.NewLine +                  "{3}" + Environment.NewLine +                  "{0}{1}>"' pad' tab' baseDebug' _content.ToDebug(padLeft + 3 * tabsize' tabsize));
Magic Number,YAMP,ArcothFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Trigonometric\ArcothFunction.cs,GetValue,The following statement contains a magic number: return 0.5 * ((1.0 + value) / (value - 1.0)).Ln();
Magic Number,YAMP,ArgumentFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunction.cs,Compare,The following statement contains a magic number: return 100 * (y.Length - x.Length) + Math.Sign(y.Weight - x.Weight);
Magic Number,YAMP,CoshFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Trigonometric\CoshFunction.cs,GetValue,The following statement contains a magic number: return (value.Exp() + (-value).Exp()) / 2.0;
Magic Number,YAMP,SinhFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Trigonometric\SinhFunction.cs,GetValue,The following statement contains a magic number: return (value.Exp() - (-value).Exp()) / 2.0;
Magic Number,YAMP,ParseContext,C:\repos\FlorianRappl_YAMP\YAMP.Core\ParseContext.cs,ParseContext,The following statement contains a magic number: _precision = 6;
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,Parse,The following statement contains a magic number: var leftPad = 3;
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,Parse,The following statement contains a magic number: var tabSize = 4;
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsLetter,The following statement contains a magic number: return (ch >= 65 && ch <= 90) ||                  (ch >= 97 && ch <= 123);
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsLetter,The following statement contains a magic number: return (ch >= 65 && ch <= 90) ||                  (ch >= 97 && ch <= 123);
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsLetter,The following statement contains a magic number: return (ch >= 65 && ch <= 90) ||                  (ch >= 97 && ch <= 123);
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsLetter,The following statement contains a magic number: return (ch >= 65 && ch <= 90) ||                  (ch >= 97 && ch <= 123);
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierStart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||  // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||       // A..Z                  (ch >= 97 && ch <= 122);
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierStart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||  // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||       // A..Z                  (ch >= 97 && ch <= 122);
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierStart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||  // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||       // A..Z                  (ch >= 97 && ch <= 122);
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierStart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||  // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||       // A..Z                  (ch >= 97 && ch <= 122);
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierStart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||  // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||       // A..Z                  (ch >= 97 && ch <= 122);
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierStart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||  // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||       // A..Z                  (ch >= 97 && ch <= 122);
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierPart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||    // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||         // A..Z                  (ch >= 97 && ch <= 122) ||        // a..z                  (ch >= 48 && ch <= 57);
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierPart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||    // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||         // A..Z                  (ch >= 97 && ch <= 122) ||        // a..z                  (ch >= 48 && ch <= 57);
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierPart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||    // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||         // A..Z                  (ch >= 97 && ch <= 122) ||        // a..z                  (ch >= 48 && ch <= 57);
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierPart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||    // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||         // A..Z                  (ch >= 97 && ch <= 122) ||        // a..z                  (ch >= 48 && ch <= 57);
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierPart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||    // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||         // A..Z                  (ch >= 97 && ch <= 122) ||        // a..z                  (ch >= 48 && ch <= 57);
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierPart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||    // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||         // A..Z                  (ch >= 97 && ch <= 122) ||        // a..z                  (ch >= 48 && ch <= 57);
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierPart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||    // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||         // A..Z                  (ch >= 97 && ch <= 122) ||        // a..z                  (ch >= 48 && ch <= 57);
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierPart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||    // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||         // A..Z                  (ch >= 97 && ch <= 122) ||        // a..z                  (ch >= 48 && ch <= 57);
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsNumber,The following statement contains a magic number: return ch >= 48 && ch <= 57;
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsNumber,The following statement contains a magic number: return ch >= 48 && ch <= 57;
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsWhiteSpace,The following statement contains a magic number: return (ch == 32) ||  // space                  (ch == 9) ||      // horizontal tab                  (ch == 0xB) ||	  // vertical tab                  (ch == 0xC) ||	  // form feed / new page                  (ch == 0xA0) ||	  // non-breaking space                  (ch >= 0x1680 && unicodeWhitespaces.IndexOf(ch.ToString()) >= 0);
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsWhiteSpace,The following statement contains a magic number: return (ch == 32) ||  // space                  (ch == 9) ||      // horizontal tab                  (ch == 0xB) ||	  // vertical tab                  (ch == 0xC) ||	  // form feed / new page                  (ch == 0xA0) ||	  // non-breaking space                  (ch >= 0x1680 && unicodeWhitespaces.IndexOf(ch.ToString()) >= 0);
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsNewLine,The following statement contains a magic number: return (ch == 10) ||  // line feed                  (ch == 13) ||	  // carriage return                  (ch == 0x2028) || // line seperator                  (ch == 0x2029);
Magic Number,YAMP,ParseEngine,C:\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsNewLine,The following statement contains a magic number: return (ch == 10) ||  // line feed                  (ch == 13) ||	  // carriage return                  (ch == 0x2028) || // line seperator                  (ch == 0x2029);
Magic Number,YAMP,Deserializer,C:\repos\FlorianRappl_YAMP\YAMP.Core\Providers\Serialization\Deserializer.cs,GetSingle,The following statement contains a magic number: var c = new Byte[4];
Magic Number,YAMP,Deserializer,C:\repos\FlorianRappl_YAMP\YAMP.Core\Providers\Serialization\Deserializer.cs,GetLong,The following statement contains a magic number: var c = new Byte[8];
Magic Number,YAMP,Deserializer,C:\repos\FlorianRappl_YAMP\YAMP.Core\Providers\Serialization\Deserializer.cs,GetString,The following statement contains a magic number: var buffer = new Byte[4];
Magic Number,YAMP,Deserializer,C:\repos\FlorianRappl_YAMP\YAMP.Core\Providers\Serialization\Deserializer.cs,GetScalar,The following statement contains a magic number: var c = new Byte[16];
Magic Number,YAMP,Deserializer,C:\repos\FlorianRappl_YAMP\YAMP.Core\Providers\Serialization\Deserializer.cs,GetScalar,The following statement contains a magic number: var imag = BitConverter.ToDouble(c' 8);
Magic Number,YAMP,Deserializer,C:\repos\FlorianRappl_YAMP\YAMP.Core\Providers\Serialization\Deserializer.cs,GetDouble,The following statement contains a magic number: var c = new Byte[8];
Magic Number,YAMP,Deserializer,C:\repos\FlorianRappl_YAMP\YAMP.Core\Providers\Serialization\Deserializer.cs,GetInt,The following statement contains a magic number: var c = new Byte[4];
Magic Number,YAMP,ContourPlotValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\ContourPlotValue.cs,SetLevels,The following statement contains a magic number: if (Levels == null || Levels.Length == 0 || n < 2)  				return;
Magic Number,YAMP,ContourPlotValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\ContourPlotValue.cs,AddValues,The following statement contains a magic number: SetLevels(zmin' zmax' Math.Min(Math.Max(dx' dy)' 10));
Magic Number,YAMP,ErrorPlotValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\ErrorPlotValue.cs,AddPoints,The following statement contains a magic number: if (m.IsVector)              {                  var x = Generate(1.0' 1.0' m.Length);                  var y = Convert(m' 0' m.Length);                  AddValues(x' y' new double[0]' new double[0]);              }              else if(m.DimensionX <= m.DimensionY)              {                  var x = ConvertY(m' 0' m.DimensionY' 0);                    for (var k = 2; k <= m.DimensionX; k++)                  {                      var y = ConvertY(m' 0' m.DimensionY' k - 1);                      AddValues(x' y' new double[0]' new double[0]);                  }              }              else              {                  var x = ConvertX(m' 0' m.DimensionX' 0);                    for (var k = 2; k <= m.DimensionY; k++)                  {                      var y = ConvertX(m' 0' m.DimensionX' k - 1);                      AddValues(x' y' new double[0]' new double[0]);                  }              }
Magic Number,YAMP,ErrorPlotValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\ErrorPlotValue.cs,AddPoints,The following statement contains a magic number: if (m.IsVector)              {                  var x = Generate(1.0' 1.0' m.Length);                  var y = Convert(m' 0' m.Length);                  AddValues(x' y' new double[0]' new double[0]);              }              else if(m.DimensionX <= m.DimensionY)              {                  var x = ConvertY(m' 0' m.DimensionY' 0);                    for (var k = 2; k <= m.DimensionX; k++)                  {                      var y = ConvertY(m' 0' m.DimensionY' k - 1);                      AddValues(x' y' new double[0]' new double[0]);                  }              }              else              {                  var x = ConvertX(m' 0' m.DimensionX' 0);                    for (var k = 2; k <= m.DimensionY; k++)                  {                      var y = ConvertX(m' 0' m.DimensionX' k - 1);                      AddValues(x' y' new double[0]' new double[0]);                  }              }
Magic Number,YAMP,Plot2DValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\Plot2DValue.cs,AddPoints,The following statement contains a magic number: if (m.IsVector)  			{  				var x = Generate(1.0' 1.0' m.Length);  				var y = Convert(m' 0' m.Length);  				AddValues(x' y);  			}  			else if(m.DimensionX <= m.DimensionY)  			{  				var x = ConvertY(m' 0' m.DimensionY' 0);    				for (var k = 2; k <= m.DimensionX; k++)  				{  					var y = ConvertY(m' 0' m.DimensionY' k - 1);  					AddValues(x' y);  				}  			}  			else  			{  				var x = ConvertX(m' 0' m.DimensionX' 0);    				for (var k = 2; k <= m.DimensionY; k++)  				{  					var y = ConvertX(m' 0' m.DimensionX' k - 1);  					AddValues(x' y);  				}  			}
Magic Number,YAMP,Plot2DValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\Plot2DValue.cs,AddPoints,The following statement contains a magic number: if (m.IsVector)  			{  				var x = Generate(1.0' 1.0' m.Length);  				var y = Convert(m' 0' m.Length);  				AddValues(x' y);  			}  			else if(m.DimensionX <= m.DimensionY)  			{  				var x = ConvertY(m' 0' m.DimensionY' 0);    				for (var k = 2; k <= m.DimensionX; k++)  				{  					var y = ConvertY(m' 0' m.DimensionY' k - 1);  					AddValues(x' y);  				}  			}  			else  			{  				var x = ConvertX(m' 0' m.DimensionX' 0);    				for (var k = 2; k <= m.DimensionY; k++)  				{  					var y = ConvertX(m' 0' m.DimensionX' k - 1);  					AddValues(x' y);  				}  			}
Magic Number,YAMP,Plot3DValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\Plot3DValue.cs,AddPoints,The following statement contains a magic number: if (m.IsVector)  				return;  			else if (m.DimensionX <= m.DimensionY && m.DimensionX == 3)  			{  				var x = ConvertY(m' 0' m.DimensionY' 0);  				var y = ConvertY(m' 0' m.DimensionY' 1);  				var z = ConvertY(m' 0' m.DimensionY' 2);  				AddValues(x' y' z);  			}  			else if(m.DimensionX > m.DimensionY && m.DimensionY == 3)  			{  				var x = ConvertX(m' 0' m.DimensionX' 0);  				var y = ConvertX(m' 0' m.DimensionX' 1);  				var z = ConvertX(m' 0' m.DimensionX' 2);  				AddValues(x' y' z);  			}
Magic Number,YAMP,Plot3DValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\Plot3DValue.cs,AddPoints,The following statement contains a magic number: if (m.IsVector)  				return;  			else if (m.DimensionX <= m.DimensionY && m.DimensionX == 3)  			{  				var x = ConvertY(m' 0' m.DimensionY' 0);  				var y = ConvertY(m' 0' m.DimensionY' 1);  				var z = ConvertY(m' 0' m.DimensionY' 2);  				AddValues(x' y' z);  			}  			else if(m.DimensionX > m.DimensionY && m.DimensionY == 3)  			{  				var x = ConvertX(m' 0' m.DimensionX' 0);  				var y = ConvertX(m' 0' m.DimensionX' 1);  				var z = ConvertX(m' 0' m.DimensionX' 2);  				AddValues(x' y' z);  			}
Magic Number,YAMP,Plot3DValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\Plot3DValue.cs,AddPoints,The following statement contains a magic number: if (m.IsVector)  				return;  			else if (m.DimensionX <= m.DimensionY && m.DimensionX == 3)  			{  				var x = ConvertY(m' 0' m.DimensionY' 0);  				var y = ConvertY(m' 0' m.DimensionY' 1);  				var z = ConvertY(m' 0' m.DimensionY' 2);  				AddValues(x' y' z);  			}  			else if(m.DimensionX > m.DimensionY && m.DimensionY == 3)  			{  				var x = ConvertX(m' 0' m.DimensionX' 0);  				var y = ConvertX(m' 0' m.DimensionX' 1);  				var z = ConvertX(m' 0' m.DimensionX' 2);  				AddValues(x' y' z);  			}
Magic Number,YAMP,Plot3DValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\Plot3DValue.cs,AddPoints,The following statement contains a magic number: if (m.IsVector)  				return;  			else if (m.DimensionX <= m.DimensionY && m.DimensionX == 3)  			{  				var x = ConvertY(m' 0' m.DimensionY' 0);  				var y = ConvertY(m' 0' m.DimensionY' 1);  				var z = ConvertY(m' 0' m.DimensionY' 2);  				AddValues(x' y' z);  			}  			else if(m.DimensionX > m.DimensionY && m.DimensionY == 3)  			{  				var x = ConvertX(m' 0' m.DimensionX' 0);  				var y = ConvertX(m' 0' m.DimensionX' 1);  				var z = ConvertX(m' 0' m.DimensionX' 2);  				AddValues(x' y' z);  			}
Magic Number,YAMP,Plot3DValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\Plot3DValue.cs,AddPoints,The following statement contains a magic number: if (x.IsVector)  			{  				if (zs.Length < 2)  					return;    				vx = Convert(x' 0' x.Length);  			}  			else  			{  				AddPoints(x);    				foreach(MatrixValue z in zs)  					AddPoints(z);    				return;  			}
Magic Number,YAMP,Plot3DValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\Plot3DValue.cs,AddPoints,The following statement contains a magic number: for(int i = 0; i < zs.Length; i++)  			{  				if (zs[i].IsVector)  				{  					if (vy == null)  						vy = Convert(zs[i]' 0' zs[i].Length);  					else  					{  						vz = Convert(zs[i]' 0' zs[i].Length);  						AddValues(vx' vy' vz);  						vx = null;  						vz = null;  					}  				}  				else if (zs[i].DimensionX <= zs[i].DimensionY && zs[i].DimensionX == 2)  				{  					vy = ConvertY(zs[i]' 0' zs[i].DimensionY' 0);  					vz = ConvertY(zs[i]' 0' zs[i].DimensionY' 1);  					AddValues(vx' vy' vz);  				}  				else if (zs[i].DimensionX > zs[i].DimensionY && zs[i].DimensionY == 2)  				{  					vy = ConvertX(zs[i]' 0' zs[i].DimensionX' 0);  					vz = ConvertX(zs[i]' 0' zs[i].DimensionX' 1);  					AddValues(vx' vy' vz);  				}  			}
Magic Number,YAMP,Plot3DValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\Plot3DValue.cs,AddPoints,The following statement contains a magic number: for(int i = 0; i < zs.Length; i++)  			{  				if (zs[i].IsVector)  				{  					if (vy == null)  						vy = Convert(zs[i]' 0' zs[i].Length);  					else  					{  						vz = Convert(zs[i]' 0' zs[i].Length);  						AddValues(vx' vy' vz);  						vx = null;  						vz = null;  					}  				}  				else if (zs[i].DimensionX <= zs[i].DimensionY && zs[i].DimensionX == 2)  				{  					vy = ConvertY(zs[i]' 0' zs[i].DimensionY' 0);  					vz = ConvertY(zs[i]' 0' zs[i].DimensionY' 1);  					AddValues(vx' vy' vz);  				}  				else if (zs[i].DimensionX > zs[i].DimensionY && zs[i].DimensionY == 2)  				{  					vy = ConvertX(zs[i]' 0' zs[i].DimensionX' 0);  					vz = ConvertX(zs[i]' 0' zs[i].DimensionX' 1);  					AddValues(vx' vy' vz);  				}  			}
Magic Number,YAMP,PolarPlotValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\PolarPlotValue.cs,AddPoints,The following statement contains a magic number: if (m.IsVector)              {                  var x = Generate(0.0' 1.0' m.Length);                  Normalize(x' m.Length);                  var y = Convert(m' 0' m.Length);                  AddValues(x' y);              }              else if (m.DimensionX <= m.DimensionY)              {                  var x = ConvertY(m' 0' m.DimensionY' 0);                    for (var k = 2; k <= m.DimensionX; k++)                  {                      var y = ConvertY(m' 0' m.DimensionY' k - 1);                      AddValues(x' y);                  }              }              else              {                  var x = ConvertX(m' 0' m.DimensionX' 0);                    for (var k = 2; k <= m.DimensionY; k++)                  {                      var y = ConvertX(m' 0' m.DimensionX' k - 1);                      AddValues(x' y);                  }              }
Magic Number,YAMP,PolarPlotValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\PolarPlotValue.cs,AddPoints,The following statement contains a magic number: if (m.IsVector)              {                  var x = Generate(0.0' 1.0' m.Length);                  Normalize(x' m.Length);                  var y = Convert(m' 0' m.Length);                  AddValues(x' y);              }              else if (m.DimensionX <= m.DimensionY)              {                  var x = ConvertY(m' 0' m.DimensionY' 0);                    for (var k = 2; k <= m.DimensionX; k++)                  {                      var y = ConvertY(m' 0' m.DimensionY' k - 1);                      AddValues(x' y);                  }              }              else              {                  var x = ConvertX(m' 0' m.DimensionX' 0);                    for (var k = 2; k <= m.DimensionY; k++)                  {                      var y = ConvertX(m' 0' m.DimensionX' k - 1);                      AddValues(x' y);                  }              }
Magic Number,YAMP,PolarPlotValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\PolarPlotValue.cs,AddValues,The following statement contains a magic number: MaxX = 2.0 * Math.PI;
Magic Number,YAMP,SubPlotValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\SubPlotValue.cs,Perform,The following statement contains a magic number: if (argument is ScalarValue)              {                  var index = ((ScalarValue)argument).IntValue;                    if (index < 1 || index > subplots.Count)                      throw new YAMPIndexOutOfBoundException(index' 1' subplots.Count);                    return subplots[index - 1].Plot;              }              else if (argument is ArgumentsValue)              {                  var av = (ArgumentsValue)argument;                    if (av.Length != 2)                      throw new YAMPArgumentNumberException("SubPlot"' av.Length' 2);                    var row = 1;                  var column = 1;                    if (av[1] is ScalarValue)                      row = ((ScalarValue)av[1]).IntValue;                  else                      throw new YAMPArgumentWrongTypeException(av[1].Header' "Scalar"' "SubPlot");                    if (av[2] is ScalarValue)                      column = ((ScalarValue)av[2]).IntValue;                  else                      throw new YAMPArgumentWrongTypeException(av[2].Header' "Scalar"' "SubPlot");                    if (row < 1 || row > Rows)                      throw new YAMPIndexOutOfBoundException(row' 1' Rows);                  else if (column < 1 || column > Columns)                      throw new YAMPIndexOutOfBoundException(column' 1' Columns);                    for (var i = subplots.Count - 1; i >= 0; i--)                  {                      if (subplots[i].Row <= row && subplots[i].Row + subplots[i].RowSpan - 1 >= row &&                          subplots[i].Column <= column && subplots[i].Column + subplots[i].ColumnSpan - 1 >= column)                          return subplots[i].Plot;                  }                    return this;              }
Magic Number,YAMP,SubPlotValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\SubPlotValue.cs,Perform,The following statement contains a magic number: if (argument is ScalarValue)              {                  var index = ((ScalarValue)argument).IntValue;                    if (index < 1 || index > subplots.Count)                      throw new YAMPIndexOutOfBoundException(index' 1' subplots.Count);                    return subplots[index - 1].Plot;              }              else if (argument is ArgumentsValue)              {                  var av = (ArgumentsValue)argument;                    if (av.Length != 2)                      throw new YAMPArgumentNumberException("SubPlot"' av.Length' 2);                    var row = 1;                  var column = 1;                    if (av[1] is ScalarValue)                      row = ((ScalarValue)av[1]).IntValue;                  else                      throw new YAMPArgumentWrongTypeException(av[1].Header' "Scalar"' "SubPlot");                    if (av[2] is ScalarValue)                      column = ((ScalarValue)av[2]).IntValue;                  else                      throw new YAMPArgumentWrongTypeException(av[2].Header' "Scalar"' "SubPlot");                    if (row < 1 || row > Rows)                      throw new YAMPIndexOutOfBoundException(row' 1' Rows);                  else if (column < 1 || column > Columns)                      throw new YAMPIndexOutOfBoundException(column' 1' Columns);                    for (var i = subplots.Count - 1; i >= 0; i--)                  {                      if (subplots[i].Row <= row && subplots[i].Row + subplots[i].RowSpan - 1 >= row &&                          subplots[i].Column <= column && subplots[i].Column + subplots[i].ColumnSpan - 1 >= column)                          return subplots[i].Plot;                  }                    return this;              }
Magic Number,YAMP,SubPlotValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\SubPlotValue.cs,Perform,The following statement contains a magic number: if (argument is ScalarValue)              {                  var index = ((ScalarValue)argument).IntValue;                    if (index < 1 || index > subplots.Count)                      throw new YAMPIndexOutOfBoundException(index' 1' subplots.Count);                    return subplots[index - 1].Plot;              }              else if (argument is ArgumentsValue)              {                  var av = (ArgumentsValue)argument;                    if (av.Length != 2)                      throw new YAMPArgumentNumberException("SubPlot"' av.Length' 2);                    var row = 1;                  var column = 1;                    if (av[1] is ScalarValue)                      row = ((ScalarValue)av[1]).IntValue;                  else                      throw new YAMPArgumentWrongTypeException(av[1].Header' "Scalar"' "SubPlot");                    if (av[2] is ScalarValue)                      column = ((ScalarValue)av[2]).IntValue;                  else                      throw new YAMPArgumentWrongTypeException(av[2].Header' "Scalar"' "SubPlot");                    if (row < 1 || row > Rows)                      throw new YAMPIndexOutOfBoundException(row' 1' Rows);                  else if (column < 1 || column > Columns)                      throw new YAMPIndexOutOfBoundException(column' 1' Columns);                    for (var i = subplots.Count - 1; i >= 0; i--)                  {                      if (subplots[i].Row <= row && subplots[i].Row + subplots[i].RowSpan - 1 >= row &&                          subplots[i].Column <= column && subplots[i].Column + subplots[i].ColumnSpan - 1 >= column)                          return subplots[i].Plot;                  }                    return this;              }
Magic Number,YAMP,SubPlotValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\SubPlotValue.cs,Perform,The following statement contains a magic number: if (argument is ScalarValue)              {                  var index = ((ScalarValue)argument).IntValue;                    if (index < 1 || index > subplots.Count)                      throw new YAMPIndexOutOfBoundException(index' 1' subplots.Count);                    return subplots[index - 1].Plot;              }              else if (argument is ArgumentsValue)              {                  var av = (ArgumentsValue)argument;                    if (av.Length != 2)                      throw new YAMPArgumentNumberException("SubPlot"' av.Length' 2);                    var row = 1;                  var column = 1;                    if (av[1] is ScalarValue)                      row = ((ScalarValue)av[1]).IntValue;                  else                      throw new YAMPArgumentWrongTypeException(av[1].Header' "Scalar"' "SubPlot");                    if (av[2] is ScalarValue)                      column = ((ScalarValue)av[2]).IntValue;                  else                      throw new YAMPArgumentWrongTypeException(av[2].Header' "Scalar"' "SubPlot");                    if (row < 1 || row > Rows)                      throw new YAMPIndexOutOfBoundException(row' 1' Rows);                  else if (column < 1 || column > Columns)                      throw new YAMPIndexOutOfBoundException(column' 1' Columns);                    for (var i = subplots.Count - 1; i >= 0; i--)                  {                      if (subplots[i].Row <= row && subplots[i].Row + subplots[i].RowSpan - 1 >= row &&                          subplots[i].Column <= column && subplots[i].Column + subplots[i].ColumnSpan - 1 >= column)                          return subplots[i].Plot;                  }                    return this;              }
Magic Number,YAMP,SubPlotValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\SubPlotValue.cs,Perform,The following statement contains a magic number: if (argument is ScalarValue)              {                  var index = ((ScalarValue)argument).IntValue;                    if (index < 1 || index > subplots.Count)                      throw new YAMPIndexOutOfBoundException(index' 1' subplots.Count);                    return subplots[index - 1].Plot;              }              else if (argument is ArgumentsValue)              {                  var av = (ArgumentsValue)argument;                    if (av.Length != 2)                      throw new YAMPArgumentNumberException("SubPlot"' av.Length' 2);                    var row = 1;                  var column = 1;                    if (av[1] is ScalarValue)                      row = ((ScalarValue)av[1]).IntValue;                  else                      throw new YAMPArgumentWrongTypeException(av[1].Header' "Scalar"' "SubPlot");                    if (av[2] is ScalarValue)                      column = ((ScalarValue)av[2]).IntValue;                  else                      throw new YAMPArgumentWrongTypeException(av[2].Header' "Scalar"' "SubPlot");                    if (row < 1 || row > Rows)                      throw new YAMPIndexOutOfBoundException(row' 1' Rows);                  else if (column < 1 || column > Columns)                      throw new YAMPIndexOutOfBoundException(column' 1' Columns);                    for (var i = subplots.Count - 1; i >= 0; i--)                  {                      if (subplots[i].Row <= row && subplots[i].Row + subplots[i].RowSpan - 1 >= row &&                          subplots[i].Column <= column && subplots[i].Column + subplots[i].ColumnSpan - 1 >= column)                          return subplots[i].Plot;                  }                    return this;              }
Magic Number,YAMP,SubPlotValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\SubPlotValue.cs,Perform,The following statement contains a magic number: if (values is PlotValue)              {                  if (indices is ArgumentsValue)                  {                      var av = (ArgumentsValue)indices;                        if (av.Length != 2)                          throw new YAMPArgumentNumberException("SubPlot"' av.Length' 2);                        var rowIndex = 0;                      var rowSpan = 0;                      var colIndex = 0;                      var colSpan = 0;                        InspectIndex(av[1]' out rowIndex' out rowSpan);                      InspectIndex(av[2]' out colIndex' out colSpan);                      return AddSubPlot(context' rowIndex' colIndex' (PlotValue)values' rowSpan' colSpan);                  }                  else if (indices is ScalarValue)                  {                      var index = ((ScalarValue)indices).IntValue;                        if (index < 1 || index > Rows * Columns)                          throw new YAMPIndexOutOfBoundException(index' 1' Rows * Columns);                        var rowIndex = (index - 1) % Rows + 1;                      var colIndex = (index - 1) / Columns + 1;                      return AddSubPlot(context' rowIndex' colIndex' (PlotValue)values);                  }                    throw new YAMPWrongTypeSuppliedException(indices.Header' "Scalar");              }
Magic Number,YAMP,SubPlotValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\SubPlotValue.cs,Perform,The following statement contains a magic number: if (values is PlotValue)              {                  if (indices is ArgumentsValue)                  {                      var av = (ArgumentsValue)indices;                        if (av.Length != 2)                          throw new YAMPArgumentNumberException("SubPlot"' av.Length' 2);                        var rowIndex = 0;                      var rowSpan = 0;                      var colIndex = 0;                      var colSpan = 0;                        InspectIndex(av[1]' out rowIndex' out rowSpan);                      InspectIndex(av[2]' out colIndex' out colSpan);                      return AddSubPlot(context' rowIndex' colIndex' (PlotValue)values' rowSpan' colSpan);                  }                  else if (indices is ScalarValue)                  {                      var index = ((ScalarValue)indices).IntValue;                        if (index < 1 || index > Rows * Columns)                          throw new YAMPIndexOutOfBoundException(index' 1' Rows * Columns);                        var rowIndex = (index - 1) % Rows + 1;                      var colIndex = (index - 1) / Columns + 1;                      return AddSubPlot(context' rowIndex' colIndex' (PlotValue)values);                  }                    throw new YAMPWrongTypeSuppliedException(indices.Header' "Scalar");              }
Magic Number,YAMP,SubPlotValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\SubPlotValue.cs,Perform,The following statement contains a magic number: if (values is PlotValue)              {                  if (indices is ArgumentsValue)                  {                      var av = (ArgumentsValue)indices;                        if (av.Length != 2)                          throw new YAMPArgumentNumberException("SubPlot"' av.Length' 2);                        var rowIndex = 0;                      var rowSpan = 0;                      var colIndex = 0;                      var colSpan = 0;                        InspectIndex(av[1]' out rowIndex' out rowSpan);                      InspectIndex(av[2]' out colIndex' out colSpan);                      return AddSubPlot(context' rowIndex' colIndex' (PlotValue)values' rowSpan' colSpan);                  }                  else if (indices is ScalarValue)                  {                      var index = ((ScalarValue)indices).IntValue;                        if (index < 1 || index > Rows * Columns)                          throw new YAMPIndexOutOfBoundException(index' 1' Rows * Columns);                        var rowIndex = (index - 1) % Rows + 1;                      var colIndex = (index - 1) / Columns + 1;                      return AddSubPlot(context' rowIndex' colIndex' (PlotValue)values);                  }                    throw new YAMPWrongTypeSuppliedException(indices.Header' "Scalar");              }
Magic Number,YAMP,Value,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,Format,The following statement contains a magic number: while (Math.Floor(t) != t)              {                  t *= 10.0;                  l++;              }
Magic Number,YAMP,Value,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,ScientificFormat,The following statement contains a magic number: if (U > 1)              {                  return Compose(context' v * Math.Pow(10.0' 1 - U)' context.Precision' U - 1);              }              else if (U == 0 && L > 0)              {                  var f = 0;                    while (Math.Floor(v) == 0)                  {                      v *= 10.0;                      f++;                  }                    return Compose(context' v' context.Precision' -f);              }
Magic Number,YAMP,Value,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,ScientificFormat,The following statement contains a magic number: if (U > 1)              {                  return Compose(context' v * Math.Pow(10.0' 1 - U)' context.Precision' U - 1);              }              else if (U == 0 && L > 0)              {                  var f = 0;                    while (Math.Floor(v) == 0)                  {                      v *= 10.0;                      f++;                  }                    return Compose(context' v' context.Precision' -f);              }
Magic Number,YAMP,Value,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,EngineeringFormat,The following statement contains a magic number: if (U > 3)              {                  var pwr = 3 * ((U - 1) / 3);                  return Compose(context' v * Math.Pow(10.0' -pwr)' context.Precision' pwr);              }              else if (U == 0 && L > 0)              {                  var f = 0;                    while (Math.Floor(v) == 0)                  {                      f++;                      v *= 10.0;                  }                    var t = f / 3;                  var t3 = t * 3 - f;                    if (t3 != 0)                  {                      t++;                      v *= Math.Pow(10.0' t3 + 3);                  }                    return Compose(context' v' context.Precision' -3 * t);              }
Magic Number,YAMP,Value,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,EngineeringFormat,The following statement contains a magic number: if (U > 3)              {                  var pwr = 3 * ((U - 1) / 3);                  return Compose(context' v * Math.Pow(10.0' -pwr)' context.Precision' pwr);              }              else if (U == 0 && L > 0)              {                  var f = 0;                    while (Math.Floor(v) == 0)                  {                      f++;                      v *= 10.0;                  }                    var t = f / 3;                  var t3 = t * 3 - f;                    if (t3 != 0)                  {                      t++;                      v *= Math.Pow(10.0' t3 + 3);                  }                    return Compose(context' v' context.Precision' -3 * t);              }
Magic Number,YAMP,Value,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,EngineeringFormat,The following statement contains a magic number: if (U > 3)              {                  var pwr = 3 * ((U - 1) / 3);                  return Compose(context' v * Math.Pow(10.0' -pwr)' context.Precision' pwr);              }              else if (U == 0 && L > 0)              {                  var f = 0;                    while (Math.Floor(v) == 0)                  {                      f++;                      v *= 10.0;                  }                    var t = f / 3;                  var t3 = t * 3 - f;                    if (t3 != 0)                  {                      t++;                      v *= Math.Pow(10.0' t3 + 3);                  }                    return Compose(context' v' context.Precision' -3 * t);              }
Magic Number,YAMP,Value,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,EngineeringFormat,The following statement contains a magic number: if (U > 3)              {                  var pwr = 3 * ((U - 1) / 3);                  return Compose(context' v * Math.Pow(10.0' -pwr)' context.Precision' pwr);              }              else if (U == 0 && L > 0)              {                  var f = 0;                    while (Math.Floor(v) == 0)                  {                      f++;                      v *= 10.0;                  }                    var t = f / 3;                  var t3 = t * 3 - f;                    if (t3 != 0)                  {                      t++;                      v *= Math.Pow(10.0' t3 + 3);                  }                    return Compose(context' v' context.Precision' -3 * t);              }
Magic Number,YAMP,Value,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,EngineeringFormat,The following statement contains a magic number: if (U > 3)              {                  var pwr = 3 * ((U - 1) / 3);                  return Compose(context' v * Math.Pow(10.0' -pwr)' context.Precision' pwr);              }              else if (U == 0 && L > 0)              {                  var f = 0;                    while (Math.Floor(v) == 0)                  {                      f++;                      v *= 10.0;                  }                    var t = f / 3;                  var t3 = t * 3 - f;                    if (t3 != 0)                  {                      t++;                      v *= Math.Pow(10.0' t3 + 3);                  }                    return Compose(context' v' context.Precision' -3 * t);              }
Magic Number,YAMP,Value,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,EngineeringFormat,The following statement contains a magic number: if (U > 3)              {                  var pwr = 3 * ((U - 1) / 3);                  return Compose(context' v * Math.Pow(10.0' -pwr)' context.Precision' pwr);              }              else if (U == 0 && L > 0)              {                  var f = 0;                    while (Math.Floor(v) == 0)                  {                      f++;                      v *= 10.0;                  }                    var t = f / 3;                  var t3 = t * 3 - f;                    if (t3 != 0)                  {                      t++;                      v *= Math.Pow(10.0' t3 + 3);                  }                    return Compose(context' v' context.Precision' -3 * t);              }
Magic Number,YAMP,Value,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,EngineeringFormat,The following statement contains a magic number: if (U > 3)              {                  var pwr = 3 * ((U - 1) / 3);                  return Compose(context' v * Math.Pow(10.0' -pwr)' context.Precision' pwr);              }              else if (U == 0 && L > 0)              {                  var f = 0;                    while (Math.Floor(v) == 0)                  {                      f++;                      v *= 10.0;                  }                    var t = f / 3;                  var t3 = t * 3 - f;                    if (t3 != 0)                  {                      t++;                      v *= Math.Pow(10.0' t3 + 3);                  }                    return Compose(context' v' context.Precision' -3 * t);              }
Magic Number,YAMP,Value,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,EngineeringFormat,The following statement contains a magic number: if (U > 3)              {                  var pwr = 3 * ((U - 1) / 3);                  return Compose(context' v * Math.Pow(10.0' -pwr)' context.Precision' pwr);              }              else if (U == 0 && L > 0)              {                  var f = 0;                    while (Math.Floor(v) == 0)                  {                      f++;                      v *= 10.0;                  }                    var t = f / 3;                  var t3 = t * 3 - f;                    if (t3 != 0)                  {                      t++;                      v *= Math.Pow(10.0' t3 + 3);                  }                    return Compose(context' v' context.Precision' -3 * t);              }
Magic Number,YAMP,Value,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,EngineeringFormat,The following statement contains a magic number: if (U > 3)              {                  var pwr = 3 * ((U - 1) / 3);                  return Compose(context' v * Math.Pow(10.0' -pwr)' context.Precision' pwr);              }              else if (U == 0 && L > 0)              {                  var f = 0;                    while (Math.Floor(v) == 0)                  {                      f++;                      v *= 10.0;                  }                    var t = f / 3;                  var t3 = t * 3 - f;                    if (t3 != 0)                  {                      t++;                      v *= Math.Pow(10.0' t3 + 3);                  }                    return Compose(context' v' context.Precision' -3 * t);              }
Magic Number,YAMP,Value,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,EngineeringFormat,The following statement contains a magic number: if (U > 3)              {                  var pwr = 3 * ((U - 1) / 3);                  return Compose(context' v * Math.Pow(10.0' -pwr)' context.Precision' pwr);              }              else if (U == 0 && L > 0)              {                  var f = 0;                    while (Math.Floor(v) == 0)                  {                      f++;                      v *= 10.0;                  }                    var t = f / 3;                  var t3 = t * 3 - f;                    if (t3 != 0)                  {                      t++;                      v *= Math.Pow(10.0' t3 + 3);                  }                    return Compose(context' v' context.Precision' -3 * t);              }
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Pow,The following statement contains a magic number: if (Value == 0.0 && Math.Abs(ImaginaryValue) < 1e-8)                  return new ScalarValue();
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Pow,The following statement contains a magic number: var theta = _real == 0.0 ? Math.PI / 2 * Math.Sign(ImaginaryValue) : Math.Atan2(_imag' _real);
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Sqrt,The following statement contains a magic number: return Pow(new ScalarValue(0.5));
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arcsin,The following statement contains a magic number: var rtp = Math.Sqrt(Math.Pow(x + 1.0' 2.0) + yy);
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arcsin,The following statement contains a magic number: var rtn = Math.Sqrt(Math.Pow(x - 1.0' 2.0) + yy);
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arcsin,The following statement contains a magic number: var alpha = 0.5 * (rtp + rtn);
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arcsin,The following statement contains a magic number: var beta = 0.5 * (rtp - rtn);
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arccos,The following statement contains a magic number: var rtp = Math.Sqrt(Math.Pow(x + 1.0' 2.0) + yy);
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arccos,The following statement contains a magic number: var rtn = Math.Sqrt(Math.Pow(x - 1.0' 2.0) + yy);
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arccos,The following statement contains a magic number: var alpha = 0.5 * (rtp + rtn);
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arccos,The following statement contains a magic number: var beta = 0.5 * (rtp - rtn);
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arctan,The following statement contains a magic number: var re = 0.5 * Math.Atan2(2.0 * x' 1.0 - xx - yy);
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arctan,The following statement contains a magic number: var re = 0.5 * Math.Atan2(2.0 * x' 1.0 - xx - yy);
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arctan,The following statement contains a magic number: var im = 0.25 * Math.Log((xx + Math.Pow(y + 1.0' 2.0)) / (xx + Math.Pow(y - 1.0' 2.0)));
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arctan,The following statement contains a magic number: var im = 0.25 * Math.Log((xx + Math.Pow(y + 1.0' 2.0)) / (xx + Math.Pow(y - 1.0' 2.0)));
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arctan,The following statement contains a magic number: var im = 0.25 * Math.Log((xx + Math.Pow(y + 1.0' 2.0)) / (xx + Math.Pow(y - 1.0' 2.0)));
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Log10,The following statement contains a magic number: var re = Math.Log(Abs()' 10.0);
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Deserialize,The following statement contains a magic number: var imag = BitConverter.ToDouble(content' 8);
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              else              {                  if (n % 2 == 0)                      return (false);                    int m = n - 1;                  int d = m;                  int s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));                }
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              else              {                  if (n % 2 == 0)                      return (false);                    int m = n - 1;                  int d = m;                  int s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));                }
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              else              {                  if (n % 2 == 0)                      return (false);                    int m = n - 1;                  int d = m;                  int s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));                }
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              else              {                  if (n % 2 == 0)                      return (false);                    int m = n - 1;                  int d = m;                  int s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));                }
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              else              {                  if (n % 2 == 0)                      return (false);                    int m = n - 1;                  int d = m;                  int s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));                }
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              else              {                  if (n % 2 == 0)                      return (false);                    int m = n - 1;                  int d = m;                  int s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));                }
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              else              {                  if (n % 2 == 0)                      return (false);                    int m = n - 1;                  int d = m;                  int s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));                }
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              else              {                  if (n % 2 == 0)                      return (false);                    int m = n - 1;                  int d = m;                  int s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));                }
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              else              {                  if (n % 2 == 0)                      return (false);                    int m = n - 1;                  int d = m;                  int s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));                }
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              else              {                  if (n % 2 == 0)                      return (false);                    int m = n - 1;                  int d = m;                  int s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));                }
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              else              {                  if (n % 2 == 0)                      return (false);                    int m = n - 1;                  int d = m;                  int s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));                }
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              else              {                  if (n % 2 == 0)                      return (false);                    int m = n - 1;                  int d = m;                  int s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));                }
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              else              {                  if (n % 2 == 0)                      return (false);                    int m = n - 1;                  int d = m;                  int s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));                }
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              else              {                  if (n % 2 == 0)                      return (false);                    int m = n - 1;                  int d = m;                  int s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));                }
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,IsProbablyPrime,The following statement contains a magic number: for (int i = 0; i < s; i++)              {                  x = PowMod(x' 2' n);                  if (x == 1)                      return false;                  if (x == m)                        return true;              }
Magic Number,YAMP,ScalarValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,ToString,The following statement contains a magic number: var f = Math.Pow(10' -exponent);
Magic Number,YAMP,NumberExpression,C:\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Elementary\NumberExpression.cs,Scan,The following statement contains a magic number: if (ParseEngine.IsNumber(ch) || (ch == '.' && start + 1 < chars.Length && ParseEngine.IsNumber(chars[start + 1])))              {                  var index = start;                  var exp = new NumberExpression(engine);                  var number = 0.0;                  var pow = 0;                                    if (ch != '.')                   {                      number += ToDoubleNumber(chars[index++]);                        while (index < chars.Length && ParseEngine.IsNumber(ch = chars[index]))                      {                          number *= 10.0;                          number += ToDoubleNumber(ch);                          index++;                      }                  }                                    if (ch == '.')                  {                      isreal = true;                      index++;                        if (index < chars.Length && ParseEngine.IsNumber(chars[index]))                      {                          do                          {                              number *= 10.0;                              number += ToDoubleNumber(chars[index++]);                              pow++;                          }                          while (index < chars.Length && ParseEngine.IsNumber(ch = chars[index]));                      }                  }                    if (ch == 'e' || ch == 'E')                  {                      isreal = true;                      var epow = 0;                      var sign = 1;                      index++;                        if (index < chars.Length && (chars[index] == '+' || chars[index] == '-'))                      {                          sign = chars[index] == '-' ? -1 : +1;                          index++;                      }                        while (index < chars.Length && ParseEngine.IsNumber(ch = chars[index]))                      {                          epow *= 10;                          epow += ToInt32Number(ch);                          index++;                      }                        pow -= epow * sign;                  }                    var value = number / Math.Pow(10.0' pow);                    if (ch == 'i')                  {                      exp.value = new ScalarValue(0.0' value);                      index++;                  }                  else if (isreal)                      exp.value = new ScalarValue(value);                  else                      exp.value = new ScalarValue((int)value);                    exp.Length = index - start;                  engine.SetPointer(index);                  return exp;              }
Magic Number,YAMP,NumberExpression,C:\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Elementary\NumberExpression.cs,Scan,The following statement contains a magic number: if (ParseEngine.IsNumber(ch) || (ch == '.' && start + 1 < chars.Length && ParseEngine.IsNumber(chars[start + 1])))              {                  var index = start;                  var exp = new NumberExpression(engine);                  var number = 0.0;                  var pow = 0;                                    if (ch != '.')                   {                      number += ToDoubleNumber(chars[index++]);                        while (index < chars.Length && ParseEngine.IsNumber(ch = chars[index]))                      {                          number *= 10.0;                          number += ToDoubleNumber(ch);                          index++;                      }                  }                                    if (ch == '.')                  {                      isreal = true;                      index++;                        if (index < chars.Length && ParseEngine.IsNumber(chars[index]))                      {                          do                          {                              number *= 10.0;                              number += ToDoubleNumber(chars[index++]);                              pow++;                          }                          while (index < chars.Length && ParseEngine.IsNumber(ch = chars[index]));                      }                  }                    if (ch == 'e' || ch == 'E')                  {                      isreal = true;                      var epow = 0;                      var sign = 1;                      index++;                        if (index < chars.Length && (chars[index] == '+' || chars[index] == '-'))                      {                          sign = chars[index] == '-' ? -1 : +1;                          index++;                      }                        while (index < chars.Length && ParseEngine.IsNumber(ch = chars[index]))                      {                          epow *= 10;                          epow += ToInt32Number(ch);                          index++;                      }                        pow -= epow * sign;                  }                    var value = number / Math.Pow(10.0' pow);                    if (ch == 'i')                  {                      exp.value = new ScalarValue(0.0' value);                      index++;                  }                  else if (isreal)                      exp.value = new ScalarValue(value);                  else                      exp.value = new ScalarValue((int)value);                    exp.Length = index - start;                  engine.SetPointer(index);                  return exp;              }
Magic Number,YAMP,NumberExpression,C:\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Elementary\NumberExpression.cs,Scan,The following statement contains a magic number: if (ParseEngine.IsNumber(ch) || (ch == '.' && start + 1 < chars.Length && ParseEngine.IsNumber(chars[start + 1])))              {                  var index = start;                  var exp = new NumberExpression(engine);                  var number = 0.0;                  var pow = 0;                                    if (ch != '.')                   {                      number += ToDoubleNumber(chars[index++]);                        while (index < chars.Length && ParseEngine.IsNumber(ch = chars[index]))                      {                          number *= 10.0;                          number += ToDoubleNumber(ch);                          index++;                      }                  }                                    if (ch == '.')                  {                      isreal = true;                      index++;                        if (index < chars.Length && ParseEngine.IsNumber(chars[index]))                      {                          do                          {                              number *= 10.0;                              number += ToDoubleNumber(chars[index++]);                              pow++;                          }                          while (index < chars.Length && ParseEngine.IsNumber(ch = chars[index]));                      }                  }                    if (ch == 'e' || ch == 'E')                  {                      isreal = true;                      var epow = 0;                      var sign = 1;                      index++;                        if (index < chars.Length && (chars[index] == '+' || chars[index] == '-'))                      {                          sign = chars[index] == '-' ? -1 : +1;                          index++;                      }                        while (index < chars.Length && ParseEngine.IsNumber(ch = chars[index]))                      {                          epow *= 10;                          epow += ToInt32Number(ch);                          index++;                      }                        pow -= epow * sign;                  }                    var value = number / Math.Pow(10.0' pow);                    if (ch == 'i')                  {                      exp.value = new ScalarValue(0.0' value);                      index++;                  }                  else if (isreal)                      exp.value = new ScalarValue(value);                  else                      exp.value = new ScalarValue((int)value);                    exp.Length = index - start;                  engine.SetPointer(index);                  return exp;              }
Magic Number,YAMP,NumberExpression,C:\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Elementary\NumberExpression.cs,Scan,The following statement contains a magic number: if (ParseEngine.IsNumber(ch) || (ch == '.' && start + 1 < chars.Length && ParseEngine.IsNumber(chars[start + 1])))              {                  var index = start;                  var exp = new NumberExpression(engine);                  var number = 0.0;                  var pow = 0;                                    if (ch != '.')                   {                      number += ToDoubleNumber(chars[index++]);                        while (index < chars.Length && ParseEngine.IsNumber(ch = chars[index]))                      {                          number *= 10.0;                          number += ToDoubleNumber(ch);                          index++;                      }                  }                                    if (ch == '.')                  {                      isreal = true;                      index++;                        if (index < chars.Length && ParseEngine.IsNumber(chars[index]))                      {                          do                          {                              number *= 10.0;                              number += ToDoubleNumber(chars[index++]);                              pow++;                          }                          while (index < chars.Length && ParseEngine.IsNumber(ch = chars[index]));                      }                  }                    if (ch == 'e' || ch == 'E')                  {                      isreal = true;                      var epow = 0;                      var sign = 1;                      index++;                        if (index < chars.Length && (chars[index] == '+' || chars[index] == '-'))                      {                          sign = chars[index] == '-' ? -1 : +1;                          index++;                      }                        while (index < chars.Length && ParseEngine.IsNumber(ch = chars[index]))                      {                          epow *= 10;                          epow += ToInt32Number(ch);                          index++;                      }                        pow -= epow * sign;                  }                    var value = number / Math.Pow(10.0' pow);                    if (ch == 'i')                  {                      exp.value = new ScalarValue(0.0' value);                      index++;                  }                  else if (isreal)                      exp.value = new ScalarValue(value);                  else                      exp.value = new ScalarValue((int)value);                    exp.Length = index - start;                  engine.SetPointer(index);                  return exp;              }
Magic Number,YAMP,NumberExpression,C:\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Elementary\NumberExpression.cs,ToDoubleNumber,The following statement contains a magic number: return (Double)p - 48.0;
Magic Number,YAMP,NumberExpression,C:\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Elementary\NumberExpression.cs,ToInt32Number,The following statement contains a magic number: return (Int32)p - 48;
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Deserialize,The following statement contains a magic number: var dimX = BitConverter.ToInt32(content' 4);
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Deserialize,The following statement contains a magic number: var count = BitConverter.ToInt32(content' 8);
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Deserialize,The following statement contains a magic number: var pos = 12;
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Deserialize,The following statement contains a magic number: for (var i = 0; i < count; i++)              {                  var row = BitConverter.ToInt32(content' pos);                  var col = BitConverter.ToInt32(content' pos + 4);                  var re = BitConverter.ToDouble(content' pos + 8);                  var im = BitConverter.ToDouble(content' pos + 16);                  M._values.Add(new MatrixIndex                  {                      Column = col'                      Row = row                  }' new ScalarValue(re' im));                    pos += 24;              }
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Deserialize,The following statement contains a magic number: for (var i = 0; i < count; i++)              {                  var row = BitConverter.ToInt32(content' pos);                  var col = BitConverter.ToInt32(content' pos + 4);                  var re = BitConverter.ToDouble(content' pos + 8);                  var im = BitConverter.ToDouble(content' pos + 16);                  M._values.Add(new MatrixIndex                  {                      Column = col'                      Row = row                  }' new ScalarValue(re' im));                    pos += 24;              }
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Deserialize,The following statement contains a magic number: for (var i = 0; i < count; i++)              {                  var row = BitConverter.ToInt32(content' pos);                  var col = BitConverter.ToInt32(content' pos + 4);                  var re = BitConverter.ToDouble(content' pos + 8);                  var im = BitConverter.ToDouble(content' pos + 16);                  M._values.Add(new MatrixIndex                  {                      Column = col'                      Row = row                  }' new ScalarValue(re' im));                    pos += 24;              }
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Deserialize,The following statement contains a magic number: for (var i = 0; i < count; i++)              {                  var row = BitConverter.ToInt32(content' pos);                  var col = BitConverter.ToInt32(content' pos + 4);                  var re = BitConverter.ToDouble(content' pos + 8);                  var im = BitConverter.ToDouble(content' pos + 16);                  M._values.Add(new MatrixIndex                  {                      Column = col'                      Row = row                  }' new ScalarValue(re' im));                    pos += 24;              }
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Inverse,The following statement contains a magic number: if (DimensionX < 24)              {                  var lu = new YAMP.Numerics.LUDecomposition(this);                  return lu.Solve(target);              }              else if (IsSymmetric)              {                  var cho = new YAMP.Numerics.CholeskyDecomposition(this);                  return cho.Solve(target);              }
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Det,The following statement contains a magic number: if (DimensionX == DimensionY)  			{  				var n = DimensionX;                    if (n == 1)                  {                      return this[1' 1];                  }                  else if (n == 2)                  {                      return this[1' 1] * this[2' 2] - this[1' 2] * this[2' 1];                  }                  else if (n == 3)                  {                      return this[1' 1] * (this[2' 2] * this[3' 3] - this[2' 3] * this[3' 2]) +                              this[1' 2] * (this[2' 3] * this[3' 1] - this[2' 1] * this[3' 3]) +                              this[1' 3] * (this[2' 1] * this[3' 2] - this[2' 2] * this[3' 1]);                  }                  else if (n == 4)                  {                      //I guess that's right                      return this[1' 1] * (this[2' 2] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 2] - this[3' 2] * this[4' 4]) + this[2' 4] *                                          (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2])) -                              this[1' 2] * (this[2' 1] *                                  (this[3' 3] * this[4' 4] - this[3' 4] * this[4' 3]) + this[2' 3] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 3] - this[3' 3] * this[4' 1])) +                              this[1' 3] * (this[2' 1] *                                  (this[3' 2] * this[4' 4] - this[3' 4] * this[4' 2]) + this[2' 2] *                                      (this[3' 4] * this[4' 1] - this[3' 1] * this[4' 4]) + this[2' 4] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1])) -                              this[1' 4] * (this[2' 1] *                                  (this[3' 2] * this[4' 3] - this[3' 3] * this[4' 2]) + this[2' 2] *                                      (this[3' 3] * this[4' 1] - this[3' 1] * this[4' 3]) + this[2' 3] *                                          (this[3' 1] * this[4' 2] - this[3' 2] * this[4' 1]));                  }    				var lu = new LUDecomposition(this);  				return lu.Determinant();  			}
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Perform,The following statement contains a magic number: if (argument is ArgumentsValue)              {                  var ags = (ArgumentsValue)argument;                    if (ags.Length == 1)                  {                      return Perform(context' ags[1]' values);                  }                  else if (ags.Length > 2)                  {                      throw new YAMPArgumentNumberException("Matrix"' ags.Length' 2);                  }                    var rows = BuildIndex(ags[1]' DimensionY);                  var columns = BuildIndex(ags[2]' DimensionX);                    for (var i = 0; i < columns.Length; i++)                  {                      for (var j = 0; j < rows.Length; j++)                      {                          indices.Add(new MatrixIndex                          {                              Column = columns[i]'                              Row = rows[j]                          });                      }                  }              }              // just a single argument              else if (argument is NumericValue)              {                  // A matrix as argument == probably logical subscripting?                  if (argument is MatrixValue)                  {                      var mm = (MatrixValue)argument;                        // But only logical subscripting of the dimensions match!                      if (mm.DimensionX == DimensionX && mm.DimensionY == DimensionY)                      {                          LogicalSubscripting(mm' indices);                      }                  }                    // So... if it has not been logical subscripting' then build                  // the index for each entry of the matrix.                  if (indices.Count == 0)                  {                      var idx = BuildIndex(argument' Length);                        for (int i = 0; i < idx.Length; i++)                      {                          indices.Add(GetIndex(idx[i]));                      }                  }              }              // no numeric value provided ?              else              {                  throw new YAMPOperationInvalidException("Matrix"' argument);              }
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Perform,The following statement contains a magic number: if (argument is ArgumentsValue)              {                  var ags = (ArgumentsValue)argument;                    if (ags.Length == 1)                  {                      return Perform(context' ags[1]' values);                  }                  else if (ags.Length > 2)                  {                      throw new YAMPArgumentNumberException("Matrix"' ags.Length' 2);                  }                    var rows = BuildIndex(ags[1]' DimensionY);                  var columns = BuildIndex(ags[2]' DimensionX);                    for (var i = 0; i < columns.Length; i++)                  {                      for (var j = 0; j < rows.Length; j++)                      {                          indices.Add(new MatrixIndex                          {                              Column = columns[i]'                              Row = rows[j]                          });                      }                  }              }              // just a single argument              else if (argument is NumericValue)              {                  // A matrix as argument == probably logical subscripting?                  if (argument is MatrixValue)                  {                      var mm = (MatrixValue)argument;                        // But only logical subscripting of the dimensions match!                      if (mm.DimensionX == DimensionX && mm.DimensionY == DimensionY)                      {                          LogicalSubscripting(mm' indices);                      }                  }                    // So... if it has not been logical subscripting' then build                  // the index for each entry of the matrix.                  if (indices.Count == 0)                  {                      var idx = BuildIndex(argument' Length);                        for (int i = 0; i < idx.Length; i++)                      {                          indices.Add(GetIndex(idx[i]));                      }                  }              }              // no numeric value provided ?              else              {                  throw new YAMPOperationInvalidException("Matrix"' argument);              }
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Perform,The following statement contains a magic number: if (argument is ArgumentsValue)              {                  var ags = (ArgumentsValue)argument;                    if (ags.Length == 1)                  {                      return Perform(context' ags[1]' values);                  }                  else if (ags.Length > 2)                  {                      throw new YAMPArgumentNumberException("Matrix"' ags.Length' 2);                  }                    var rows = BuildIndex(ags[1]' DimensionY);                  var columns = BuildIndex(ags[2]' DimensionX);                    for (var i = 0; i < columns.Length; i++)                  {                      for (var j = 0; j < rows.Length; j++)                      {                          indices.Add(new MatrixIndex                          {                              Column = columns[i]'                              Row = rows[j]                          });                      }                  }              }              // just a single argument              else if (argument is NumericValue)              {                  // A matrix as argument == probably logical subscripting?                  if (argument is MatrixValue)                  {                      var mm = (MatrixValue)argument;                        // But only logical subscripting of the dimensions match!                      if (mm.DimensionX == DimensionX && mm.DimensionY == DimensionY)                      {                          LogicalSubscripting(mm' indices);                      }                  }                    // So... if it has not been logical subscripting' then build                  // the index for each entry of the matrix.                  if (indices.Count == 0)                  {                      var idx = BuildIndex(argument' Length);                        for (int i = 0; i < idx.Length; i++)                      {                          indices.Add(GetIndex(idx[i]));                      }                  }              }              // no numeric value provided ?              else              {                  throw new YAMPOperationInvalidException("Matrix"' argument);              }
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Perform,The following statement contains a magic number: if (argument is ArgumentsValue)              {                  var ags = (ArgumentsValue)argument;                    if (ags.Length == 1)                  {                      return Perform(context' ags[1]);                  }                  else if (ags.Length > 2)                  {                      throw new YAMPArgumentNumberException("Matrix"' ags.Length' 2);                  }                    var rows = BuildIndex(ags[1]' DimensionY);                  var columns = BuildIndex(ags[2]' DimensionX);                    if (rows.Length == 1 && columns.Length == 1)                  {                      return this[rows[0]' columns[0]].Clone();                  }                    var m = new MatrixValue(rows.Length' columns.Length);                    for (var i = 1; i <= m.DimensionX; i++)                  {                      for (var j = 1; j <= m.DimensionY; j++)                      {                          m[j' i] = this[rows[j - 1]' columns[i - 1]].Clone();                      }                  }                    return m;              }              else if (argument is NumericValue)              {                  if (argument is MatrixValue)                  {                      var mm = (MatrixValue)argument;                        if (mm.DimensionX == DimensionX && mm.DimensionY == DimensionY)                      {                          return LogicalSubscripting(mm);                      }                  }                    var idx = BuildIndex(argument' Length);                    if (idx.Length == 1)                  {                      return this[idx[0]].Clone();                  }                    var m = new MatrixValue(1' idx.Length);                    for (var i = 1; i <= m.DimensionX; i++)                  {                      m[i] = this[idx[i - 1]].Clone();                  }                    return m;              }
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Perform,The following statement contains a magic number: if (argument is ArgumentsValue)              {                  var ags = (ArgumentsValue)argument;                    if (ags.Length == 1)                  {                      return Perform(context' ags[1]);                  }                  else if (ags.Length > 2)                  {                      throw new YAMPArgumentNumberException("Matrix"' ags.Length' 2);                  }                    var rows = BuildIndex(ags[1]' DimensionY);                  var columns = BuildIndex(ags[2]' DimensionX);                    if (rows.Length == 1 && columns.Length == 1)                  {                      return this[rows[0]' columns[0]].Clone();                  }                    var m = new MatrixValue(rows.Length' columns.Length);                    for (var i = 1; i <= m.DimensionX; i++)                  {                      for (var j = 1; j <= m.DimensionY; j++)                      {                          m[j' i] = this[rows[j - 1]' columns[i - 1]].Clone();                      }                  }                    return m;              }              else if (argument is NumericValue)              {                  if (argument is MatrixValue)                  {                      var mm = (MatrixValue)argument;                        if (mm.DimensionX == DimensionX && mm.DimensionY == DimensionY)                      {                          return LogicalSubscripting(mm);                      }                  }                    var idx = BuildIndex(argument' Length);                    if (idx.Length == 1)                  {                      return this[idx[0]].Clone();                  }                    var m = new MatrixValue(1' idx.Length);                    for (var i = 1; i <= m.DimensionX; i++)                  {                      m[i] = this[idx[i - 1]].Clone();                  }                    return m;              }
Magic Number,YAMP,MatrixValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Perform,The following statement contains a magic number: if (argument is ArgumentsValue)              {                  var ags = (ArgumentsValue)argument;                    if (ags.Length == 1)                  {                      return Perform(context' ags[1]);                  }                  else if (ags.Length > 2)                  {                      throw new YAMPArgumentNumberException("Matrix"' ags.Length' 2);                  }                    var rows = BuildIndex(ags[1]' DimensionY);                  var columns = BuildIndex(ags[2]' DimensionX);                    if (rows.Length == 1 && columns.Length == 1)                  {                      return this[rows[0]' columns[0]].Clone();                  }                    var m = new MatrixValue(rows.Length' columns.Length);                    for (var i = 1; i <= m.DimensionX; i++)                  {                      for (var j = 1; j <= m.DimensionY; j++)                      {                          m[j' i] = this[rows[j - 1]' columns[i - 1]].Clone();                      }                  }                    return m;              }              else if (argument is NumericValue)              {                  if (argument is MatrixValue)                  {                      var mm = (MatrixValue)argument;                        if (mm.DimensionX == DimensionX && mm.DimensionY == DimensionY)                      {                          return LogicalSubscripting(mm);                      }                  }                    var idx = BuildIndex(argument' Length);                    if (idx.Length == 1)                  {                      return this[idx[0]].Clone();                  }                    var m = new MatrixValue(1' idx.Length);                    for (var i = 1; i <= m.DimensionX; i++)                  {                      m[i] = this[idx[i - 1]].Clone();                  }                    return m;              }
Magic Number,YAMP,BinaryOperator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Operators\BinaryOperator.cs,BinaryOperator,The following statement contains a magic number: Expressions = 2;
Magic Number,YAMP,BinaryOperator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Operators\BinaryOperator.cs,Evaluate,The following statement contains a magic number: if (expressions.Length != 2)              {                  throw new YAMPArgumentNumberException(Op' expressions.Length' 2);              }
Magic Number,YAMP,BinaryOperator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Operators\BinaryOperator.cs,Evaluate,The following statement contains a magic number: if (expressions.Length != 2)              {                  throw new YAMPArgumentNumberException(Op' expressions.Length' 2);              }
Magic Number,YAMP,StringExpression,C:\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Elementary\StringExpression.cs,Scan,The following statement contains a magic number: if (chars[start] == '"' || (chars[start] == '@' && start + 1 < chars.Length && chars[start + 1] == '"'))              {                  var index = start;                  var exp = new StringExpression(engine);                  var escape = false;                  var terminated = false;                  var sb = new StringBuilder();                    if (chars[index] == '@')                  {                      index += 2;                      exp.literal = true;                  }                  else                  {                      index++;                  }                    while (index < chars.Length)                  {                      if (!literal && !escape && chars[index] == '\\')                      {                          escape = true;                      }                      else if (!escape && chars[index] == '"')                      {                          terminated = true;                          index++;                          break;                      }                      else if (escape)                      {                          switch (chars[index])                          {                              case 't':                                  sb.Append("\t");                                  break;                              case 'n':                                  sb.AppendLine();                                  break;                              case '\\':                              case '"':                                  sb.Append(chars[index]);                                  break;                              default:                                  engine.SetPointer(index);                                  engine.AddError(new YAMPEscapeSequenceNotFoundError(engine' chars[index])' exp);                                  break;                          }                            escape = false;                      }                      else                      {                          sb.Append(chars[index]);                      }                        index++;                  }                    if (!terminated)                  {                      engine.AddError(new YAMPStringNotTerminatedError(engine)' exp);                  }                    exp.value = sb.ToString();                  exp.Length = index - start;                  engine.SetPointer(index);                  return exp;              }
Magic Number,YAMP,LinspaceFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunctions\LinspaceFunction.cs,Function,The following statement contains a magic number: if (c < 2)              {                  throw new ArgumentException("linspace");              }
Magic Number,YAMP,RangeValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\RangeValue.cs,RangeValue,The following statement contains a magic number: if (count >= Int32.MaxValue / 10)                  throw new YAMPRangeInvalidException("too many entries have been found");
Magic Number,YAMP,RangeValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\RangeValue.cs,Deserialize,The following statement contains a magic number: R.DimensionX = BitConverter.ToInt32(content' 4);
Magic Number,YAMP,RangeValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\RangeValue.cs,Deserialize,The following statement contains a magic number: var count = BitConverter.ToInt32(content' 8);
Magic Number,YAMP,RangeValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\RangeValue.cs,Deserialize,The following statement contains a magic number: var pos = 12;
Magic Number,YAMP,RangeValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\RangeValue.cs,Deserialize,The following statement contains a magic number: for (var i = 0; i < count; i++)              {                  var row = BitConverter.ToInt32(content' pos);                  var col = BitConverter.ToInt32(content' pos + 4);                  var re = BitConverter.ToDouble(content' pos + 8);                  var im = BitConverter.ToDouble(content' pos + 16);                  R[row' col] = new ScalarValue(re' im);                  pos += 24;              }
Magic Number,YAMP,RangeValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\RangeValue.cs,Deserialize,The following statement contains a magic number: for (var i = 0; i < count; i++)              {                  var row = BitConverter.ToInt32(content' pos);                  var col = BitConverter.ToInt32(content' pos + 4);                  var re = BitConverter.ToDouble(content' pos + 8);                  var im = BitConverter.ToDouble(content' pos + 16);                  R[row' col] = new ScalarValue(re' im);                  pos += 24;              }
Magic Number,YAMP,RangeValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\RangeValue.cs,Deserialize,The following statement contains a magic number: for (var i = 0; i < count; i++)              {                  var row = BitConverter.ToInt32(content' pos);                  var col = BitConverter.ToInt32(content' pos + 4);                  var re = BitConverter.ToDouble(content' pos + 8);                  var im = BitConverter.ToDouble(content' pos + 16);                  R[row' col] = new ScalarValue(re' im);                  pos += 24;              }
Magic Number,YAMP,RangeValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\RangeValue.cs,Deserialize,The following statement contains a magic number: for (var i = 0; i < count; i++)              {                  var row = BitConverter.ToInt32(content' pos);                  var col = BitConverter.ToInt32(content' pos + 4);                  var re = BitConverter.ToDouble(content' pos + 8);                  var im = BitConverter.ToDouble(content' pos + 16);                  R[row' col] = new ScalarValue(re' im);                  pos += 24;              }
Magic Number,YAMP,RangeValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\RangeValue.cs,Deserialize,The following statement contains a magic number: R.Start = BitConverter.ToDouble(content' content.Length - 25);
Magic Number,YAMP,RangeValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\RangeValue.cs,Deserialize,The following statement contains a magic number: R.End = BitConverter.ToDouble(content' content.Length - 17);
Magic Number,YAMP,RangeValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\RangeValue.cs,Deserialize,The following statement contains a magic number: R.Step = BitConverter.ToDouble(content' content.Length - 9);
Magic Number,YAMP,LogspaceFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunctions\LogspaceFunction.cs,Function,The following statement contains a magic number: return Function(start' end' count' new ScalarValue(10));
Magic Number,YAMP,LogspaceFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunctions\LogspaceFunction.cs,Function,The following statement contains a magic number: if (c < 2)              {                  throw new ArgumentException("logspace");              }
Magic Number,YAMP,ArgumentsValue,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Arguments\ArgumentsValue.cs,Deserialize,The following statement contains a magic number: using (var ms = new MemoryStream(content))              {                  var buffer = new byte[4];                  ms.Read(buffer' 0' buffer.Length);                  var count = BitConverter.ToInt32(buffer' 0);                    for (var i = 0; i < count; i++)                  {                      ms.Read(buffer' 0' buffer.Length);                      var length = BitConverter.ToInt32(buffer' 0);                      var stringBuffer = new byte[length];                      ms.Read(stringBuffer' 0' stringBuffer.Length);                      var name = Encoding.UTF8.GetString(stringBuffer' 0' stringBuffer.Length);                      ms.Read(buffer' 0' buffer.Length);                      length = BitConverter.ToInt32(buffer' 0);                      var contentBuffer = new byte[length];                      ms.Read(contentBuffer' 0' contentBuffer.Length);                      A._values.Add(Deserialize(name' contentBuffer));                  }              }
Magic Number,YAMP.Help,Documentation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Help\Documentation.cs,ClosestEntry,The following statement contains a magic number: if (!list.Contains(term))              {                  var min = Int32.MaxValue;                  var index = 0;                    for (var i = 0; i < list.Count; i++)                  {                      var sum = Distance(term' list[i]' 10);                        if (sum < min)                      {                          min = sum;                          index = i;                      }                  }                    return list[index];              }
Magic Number,YAMP.Help,Documentation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Help\Documentation.cs,Distance,The following statement contains a magic number: return (s1.Length + s2.Length) / 2 - lcs;
Magic Number,YAMP.Numerics,Fractal,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Fractal.cs,R,The following statement contains a magic number: return Math.Max(Math.Min(c' 255)' 0);
Magic Number,YAMP.Numerics,Fractal,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Fractal.cs,G,The following statement contains a magic number: var c = (int)((color - 0.33333) * maxIterations);
Magic Number,YAMP.Numerics,Fractal,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Fractal.cs,G,The following statement contains a magic number: return Math.Max(Math.Min(c' 255)' 0);
Magic Number,YAMP.Numerics,Fractal,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Fractal.cs,B,The following statement contains a magic number: var c = (int)((color - 0.66666) * maxIterations);
Magic Number,YAMP.Numerics,Fractal,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Fractal.cs,B,The following statement contains a magic number: return Math.Max(Math.Min(c' 255)' 0);
Magic Number,YAMP.Numerics,Julia,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Julia.cs,Run,The following statement contains a magic number: while ((iter < maxiter) && (rpow < 4))              {                  r1pow2 = r1 * r1;                  i1pow2 = i1 * i1;                  i1 = 2 * i1 * r1 + _cy;                  r1 = r1pow2 - i1pow2 + _cx;                  rlastpow = rpow;                  rpow = r1pow2 + i1pow2;                  iter++;              }
Magic Number,YAMP.Numerics,Julia,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Julia.cs,Run,The following statement contains a magic number: while ((iter < maxiter) && (rpow < 4))              {                  r1pow2 = r1 * r1;                  i1pow2 = i1 * i1;                  i1 = 2 * i1 * r1 + _cy;                  r1 = r1pow2 - i1pow2 + _cx;                  rlastpow = rpow;                  rpow = r1pow2 + i1pow2;                  iter++;              }
Magic Number,YAMP.Numerics,Newton,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Newton.cs,Run,The following statement contains a magic number: if(x != 0 || y != 0)              {                  while ((iter < maxiter) && pz.AbsSquare() > 1e-8)                  {                      pz = zn.Pow(new ScalarValue(3)) - 1.0;                      pzd = 3.0 * zn.Square();                      zn = zn - pz / pzd;                      iter++;                  }              }
Magic Number,YAMP.Numerics,Newton,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Newton.cs,Run,The following statement contains a magic number: if(x != 0 || y != 0)              {                  while ((iter < maxiter) && pz.AbsSquare() > 1e-8)                  {                      pz = zn.Pow(new ScalarValue(3)) - 1.0;                      pzd = 3.0 * zn.Square();                      zn = zn - pz / pzd;                      iter++;                  }              }
Magic Number,YAMP.Numerics,Newton,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Newton.cs,Run,The following statement contains a magic number: if(x != 0 || y != 0)              {                  while ((iter < maxiter) && pz.AbsSquare() > 1e-8)                  {                      pz = zn.Pow(new ScalarValue(3)) - 1.0;                      pzd = 3.0 * zn.Square();                      zn = zn - pz / pzd;                      iter++;                  }              }
Magic Number,YAMP.Numerics,Dawson,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,DawsonIntegral,The following statement contains a magic number: if (x < 0.0)              {                  return -DawsonIntegral(-x);              }              else if (x < 1.0)              {                  return DawsonSeries(x);              }              else if (x > 10.0)              {                  return DawsonAsymptotic(x);              }
Magic Number,YAMP.Numerics,Dawson,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,DawsonSeries,The following statement contains a magic number: var xx = -2.0 * x * x;
Magic Number,YAMP.Numerics,Dawson,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,DawsonSeries,The following statement contains a magic number: for (int k = 1; k < 250; k++)              {                  var f_old = f;                  df = df * xx / (2 * k + 1);                  f += df;                    if (f == f_old)                  {                      return f;                  }              }
Magic Number,YAMP.Numerics,Dawson,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,DawsonSeries,The following statement contains a magic number: for (int k = 1; k < 250; k++)              {                  var f_old = f;                  df = df * xx / (2 * k + 1);                  f += df;                    if (f == f_old)                  {                      return f;                  }              }
Magic Number,YAMP.Numerics,Dawson,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,DawsonAsymptotic,The following statement contains a magic number: var xx = 2.0 * x * x;
Magic Number,YAMP.Numerics,Dawson,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,DawsonAsymptotic,The following statement contains a magic number: var df = 0.5 / x;
Magic Number,YAMP.Numerics,Dawson,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,DawsonAsymptotic,The following statement contains a magic number: for (int k = 0; k < 250; k++)              {                  var f_old = f;                  df = df * (2 * k + 1) / xx;                  f += df;                    if (f == f_old)                  {                      return f;                  }              }
Magic Number,YAMP.Numerics,Dawson,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,DawsonAsymptotic,The following statement contains a magic number: for (int k = 0; k < 250; k++)              {                  var f_old = f;                  df = df * (2 * k + 1) / xx;                  f += df;                    if (f == f_old)                  {                      return f;                  }              }
Magic Number,YAMP.Numerics,Dawson,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,DawsonRybicki,The following statement contains a magic number: var n0 = 2 * ((Int32)Math.Round(x / Dawson_Rybicki_h / 2.0));
Magic Number,YAMP.Numerics,Dawson,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,DawsonRybicki,The following statement contains a magic number: var n0 = 2 * ((Int32)Math.Round(x / Dawson_Rybicki_h / 2.0));
Magic Number,YAMP.Numerics,Dawson,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,DawsonRybicki,The following statement contains a magic number: var b = Math.Exp(2.0 * Dawson_Rybicki_h * y);
Magic Number,YAMP.Numerics,Dawson,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,DawsonRybicki,The following statement contains a magic number: for (int k = 0; k < Dawson_Rybicki_coefficients.Length; k++)              {                  var f_old = f;                  var m = 2 * k + 1;                  var df = Dawson_Rybicki_coefficients[k] * (b / (n0 + m) + 1.0 / b / (n0 - m));                  f += df;                    if (f == f_old)                  {                      return Math.Exp(-y * y) / Helpers.SqrtPI * f;                  }                    b = b * bb;              }
Magic Number,YAMP.Numerics,Dawson,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,Compute_Dawson_Rybicki_Coefficients,The following statement contains a magic number: for (int k = 0; k < n; k++)              {                  int m = 2 * k + 1;                  double z = h * m;                  coefficients[k] = Math.Exp(-z * z);              }
Magic Number,YAMP.Numerics,BluesteinTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\BluesteinTransformlet.cs,BluesteinTransformlet,The following statement contains a magic number: Nb = SetBluesteinLength(2 * R - 1);
Magic Number,YAMP.Numerics,BluesteinTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\BluesteinTransformlet.cs,ComputeBluesteinCoefficients,The following statement contains a magic number: int TwoR = 2 * R;
Magic Number,YAMP.Numerics,BluesteinTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\BluesteinTransformlet.cs,ComputeBluesteinCoefficients,The following statement contains a magic number: for (int i = 1; i < R; i++)              {                  s += (2 * i - 1); if (s >= TwoR) s -= TwoR;                  double ts = t * s;                  b[i] = new ScalarValue(Math.Cos(ts)' Math.Sin(ts));              }
Magic Number,YAMP.Numerics,BluesteinTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\BluesteinTransformlet.cs,SetBluesteinLength,The following statement contains a magic number: int t = NextPowerOfBase(N' 2);
Magic Number,YAMP.Numerics,BluesteinTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\BluesteinTransformlet.cs,SetBluesteinLength,The following statement contains a magic number: while (M % 4 == 0)              {                  t = (M / 4) * 3;                    if (t < N)                      break;                    if (t < M)                       M = t;              }
Magic Number,YAMP.Numerics,BluesteinTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\BluesteinTransformlet.cs,SetBluesteinLength,The following statement contains a magic number: while (M % 4 == 0)              {                  t = (M / 4) * 3;                    if (t < N)                      break;                    if (t < M)                       M = t;              }
Magic Number,YAMP.Numerics,BluesteinTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\BluesteinTransformlet.cs,SetBluesteinLength,The following statement contains a magic number: while (M % 4 == 0)              {                  t = (M / 4) * 3;                    if (t < N)                      break;                    if (t < M)                       M = t;              }
Magic Number,YAMP.Numerics,BluesteinTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\BluesteinTransformlet.cs,SetBluesteinLength,The following statement contains a magic number: t = NextPowerOfBase(N' 3);
Magic Number,YAMP.Numerics,Fourier,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,Fourier,The following statement contains a magic number: foreach (Factor factor in factors)              {                  Transformlet t;                  switch (factor.Value)                  {                      // use a radix-specialized transformlet when available                      case 2:                          t = new RadixTwoTransformlet(size' roots);                          break;                      case 3:                          t = new RadixThreeTransformlet(size' roots);                          break;                      // eventually' we should make an optimized radix-4 transform                      case 5:                          t = new RadixFiveTransformlet(size' roots);                          break;                      case 7:                          t = new RadixSevenTransformlet(size' roots);                          break;                      case 11:                      case 13:                          // the base transformlet is R^2' but when R is small' this can still be faster than the Bluestein algorithm                          // timing measurements appear to indicate that this is the case for radix 11 and 13                          // eventually' we should make optimized Winograd transformlets for these factors                          t = new Transformlet(factor.Value' size' roots);                          break;                      default:                          // for large factors with no available specialized transformlet' use the Bluestein algorithm                          t = new BluesteinTransformlet(factor.Value' size' roots);                          break;                  }                    t.Multiplicity = factor.Multiplicity;                  plan.Add(t);              }
Magic Number,YAMP.Numerics,Fourier,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,Fourier,The following statement contains a magic number: foreach (Factor factor in factors)              {                  Transformlet t;                  switch (factor.Value)                  {                      // use a radix-specialized transformlet when available                      case 2:                          t = new RadixTwoTransformlet(size' roots);                          break;                      case 3:                          t = new RadixThreeTransformlet(size' roots);                          break;                      // eventually' we should make an optimized radix-4 transform                      case 5:                          t = new RadixFiveTransformlet(size' roots);                          break;                      case 7:                          t = new RadixSevenTransformlet(size' roots);                          break;                      case 11:                      case 13:                          // the base transformlet is R^2' but when R is small' this can still be faster than the Bluestein algorithm                          // timing measurements appear to indicate that this is the case for radix 11 and 13                          // eventually' we should make optimized Winograd transformlets for these factors                          t = new Transformlet(factor.Value' size' roots);                          break;                      default:                          // for large factors with no available specialized transformlet' use the Bluestein algorithm                          t = new BluesteinTransformlet(factor.Value' size' roots);                          break;                  }                    t.Multiplicity = factor.Multiplicity;                  plan.Add(t);              }
Magic Number,YAMP.Numerics,Fourier,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,Fourier,The following statement contains a magic number: foreach (Factor factor in factors)              {                  Transformlet t;                  switch (factor.Value)                  {                      // use a radix-specialized transformlet when available                      case 2:                          t = new RadixTwoTransformlet(size' roots);                          break;                      case 3:                          t = new RadixThreeTransformlet(size' roots);                          break;                      // eventually' we should make an optimized radix-4 transform                      case 5:                          t = new RadixFiveTransformlet(size' roots);                          break;                      case 7:                          t = new RadixSevenTransformlet(size' roots);                          break;                      case 11:                      case 13:                          // the base transformlet is R^2' but when R is small' this can still be faster than the Bluestein algorithm                          // timing measurements appear to indicate that this is the case for radix 11 and 13                          // eventually' we should make optimized Winograd transformlets for these factors                          t = new Transformlet(factor.Value' size' roots);                          break;                      default:                          // for large factors with no available specialized transformlet' use the Bluestein algorithm                          t = new BluesteinTransformlet(factor.Value' size' roots);                          break;                  }                    t.Multiplicity = factor.Multiplicity;                  plan.Add(t);              }
Magic Number,YAMP.Numerics,Fourier,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,Fourier,The following statement contains a magic number: foreach (Factor factor in factors)              {                  Transformlet t;                  switch (factor.Value)                  {                      // use a radix-specialized transformlet when available                      case 2:                          t = new RadixTwoTransformlet(size' roots);                          break;                      case 3:                          t = new RadixThreeTransformlet(size' roots);                          break;                      // eventually' we should make an optimized radix-4 transform                      case 5:                          t = new RadixFiveTransformlet(size' roots);                          break;                      case 7:                          t = new RadixSevenTransformlet(size' roots);                          break;                      case 11:                      case 13:                          // the base transformlet is R^2' but when R is small' this can still be faster than the Bluestein algorithm                          // timing measurements appear to indicate that this is the case for radix 11 and 13                          // eventually' we should make optimized Winograd transformlets for these factors                          t = new Transformlet(factor.Value' size' roots);                          break;                      default:                          // for large factors with no available specialized transformlet' use the Bluestein algorithm                          t = new BluesteinTransformlet(factor.Value' size' roots);                          break;                  }                    t.Multiplicity = factor.Multiplicity;                  plan.Add(t);              }
Magic Number,YAMP.Numerics,Fourier,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,Fourier,The following statement contains a magic number: foreach (Factor factor in factors)              {                  Transformlet t;                  switch (factor.Value)                  {                      // use a radix-specialized transformlet when available                      case 2:                          t = new RadixTwoTransformlet(size' roots);                          break;                      case 3:                          t = new RadixThreeTransformlet(size' roots);                          break;                      // eventually' we should make an optimized radix-4 transform                      case 5:                          t = new RadixFiveTransformlet(size' roots);                          break;                      case 7:                          t = new RadixSevenTransformlet(size' roots);                          break;                      case 11:                      case 13:                          // the base transformlet is R^2' but when R is small' this can still be faster than the Bluestein algorithm                          // timing measurements appear to indicate that this is the case for radix 11 and 13                          // eventually' we should make optimized Winograd transformlets for these factors                          t = new Transformlet(factor.Value' size' roots);                          break;                      default:                          // for large factors with no available specialized transformlet' use the Bluestein algorithm                          t = new BluesteinTransformlet(factor.Value' size' roots);                          break;                  }                    t.Multiplicity = factor.Multiplicity;                  plan.Add(t);              }
Magic Number,YAMP.Numerics,Fourier,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,Fourier,The following statement contains a magic number: foreach (Factor factor in factors)              {                  Transformlet t;                  switch (factor.Value)                  {                      // use a radix-specialized transformlet when available                      case 2:                          t = new RadixTwoTransformlet(size' roots);                          break;                      case 3:                          t = new RadixThreeTransformlet(size' roots);                          break;                      // eventually' we should make an optimized radix-4 transform                      case 5:                          t = new RadixFiveTransformlet(size' roots);                          break;                      case 7:                          t = new RadixSevenTransformlet(size' roots);                          break;                      case 11:                      case 13:                          // the base transformlet is R^2' but when R is small' this can still be faster than the Bluestein algorithm                          // timing measurements appear to indicate that this is the case for radix 11 and 13                          // eventually' we should make optimized Winograd transformlets for these factors                          t = new Transformlet(factor.Value' size' roots);                          break;                      default:                          // for large factors with no available specialized transformlet' use the Bluestein algorithm                          t = new BluesteinTransformlet(factor.Value' size' roots);                          break;                  }                    t.Multiplicity = factor.Multiplicity;                  plan.Add(t);              }
Magic Number,YAMP.Numerics,Fourier,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByTrialDivision,The following statement contains a magic number: var smallPrimes = new int[] { 2' 3' 5' 7' 11' 13' 17' 19' 23' 29' 31 };
Magic Number,YAMP.Numerics,Fourier,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByTrialDivision,The following statement contains a magic number: var smallPrimes = new int[] { 2' 3' 5' 7' 11' 13' 17' 19' 23' 29' 31 };
Magic Number,YAMP.Numerics,Fourier,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByTrialDivision,The following statement contains a magic number: var smallPrimes = new int[] { 2' 3' 5' 7' 11' 13' 17' 19' 23' 29' 31 };
Magic Number,YAMP.Numerics,Fourier,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByTrialDivision,The following statement contains a magic number: var smallPrimes = new int[] { 2' 3' 5' 7' 11' 13' 17' 19' 23' 29' 31 };
Magic Number,YAMP.Numerics,Fourier,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByTrialDivision,The following statement contains a magic number: var smallPrimes = new int[] { 2' 3' 5' 7' 11' 13' 17' 19' 23' 29' 31 };
Magic Number,YAMP.Numerics,Fourier,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByTrialDivision,The following statement contains a magic number: var smallPrimes = new int[] { 2' 3' 5' 7' 11' 13' 17' 19' 23' 29' 31 };
Magic Number,YAMP.Numerics,Fourier,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByTrialDivision,The following statement contains a magic number: var smallPrimes = new int[] { 2' 3' 5' 7' 11' 13' 17' 19' 23' 29' 31 };
Magic Number,YAMP.Numerics,Fourier,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByTrialDivision,The following statement contains a magic number: var smallPrimes = new int[] { 2' 3' 5' 7' 11' 13' 17' 19' 23' 29' 31 };
Magic Number,YAMP.Numerics,Fourier,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByTrialDivision,The following statement contains a magic number: var smallPrimes = new int[] { 2' 3' 5' 7' 11' 13' 17' 19' 23' 29' 31 };
Magic Number,YAMP.Numerics,Fourier,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByTrialDivision,The following statement contains a magic number: var smallPrimes = new int[] { 2' 3' 5' 7' 11' 13' 17' 19' 23' 29' 31 };
Magic Number,YAMP.Numerics,Fourier,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByTrialDivision,The following statement contains a magic number: var smallPrimes = new int[] { 2' 3' 5' 7' 11' 13' 17' 19' 23' 29' 31 };
Magic Number,YAMP.Numerics,Fourier,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByPollardsRhoMethod,The following statement contains a magic number: int x = 5;
Magic Number,YAMP.Numerics,Fourier,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByPollardsRhoMethod,The following statement contains a magic number: int y = 2;
Magic Number,YAMP.Numerics,Fourier,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByPollardsRhoMethod,The following statement contains a magic number: for (int c = 0; c < 250; c++)              {                  int g = Helpers.GCD(Math.Abs(y - x)' n);                    if (g == n)                      return;                  else if (g == 1)                  {                      k--;                        if (k == 0)                      {                          y = x;                          l = 2 * l;                          k = l;                      }                        x = Helpers.PowMod(x' 2' n) + 1;                      if (x == n) x = 0;                  }                  else                  {                      int m = 0;                        while (n % g == 0)                      {                          n = n / g;                          x = x % n;                          y = y % n;                          m++;                      }                        factors.Add(new Factor(g' m));                  }              }
Magic Number,YAMP.Numerics,Fourier,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByPollardsRhoMethod,The following statement contains a magic number: for (int c = 0; c < 250; c++)              {                  int g = Helpers.GCD(Math.Abs(y - x)' n);                    if (g == n)                      return;                  else if (g == 1)                  {                      k--;                        if (k == 0)                      {                          y = x;                          l = 2 * l;                          k = l;                      }                        x = Helpers.PowMod(x' 2' n) + 1;                      if (x == n) x = 0;                  }                  else                  {                      int m = 0;                        while (n % g == 0)                      {                          n = n / g;                          x = x % n;                          y = y % n;                          m++;                      }                        factors.Add(new Factor(g' m));                  }              }
Magic Number,YAMP.Numerics,Fourier,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByPollardsRhoMethod,The following statement contains a magic number: for (int c = 0; c < 250; c++)              {                  int g = Helpers.GCD(Math.Abs(y - x)' n);                    if (g == n)                      return;                  else if (g == 1)                  {                      k--;                        if (k == 0)                      {                          y = x;                          l = 2 * l;                          k = l;                      }                        x = Helpers.PowMod(x' 2' n) + 1;                      if (x == n) x = 0;                  }                  else                  {                      int m = 0;                        while (n % g == 0)                      {                          n = n / g;                          x = x % n;                          y = y % n;                          m++;                      }                        factors.Add(new Factor(g' m));                  }              }
Magic Number,YAMP.Numerics,RadixFiveTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: double a14p = x[1].Re + x[4].Re;
Magic Number,YAMP.Numerics,RadixFiveTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: double a14m = x[1].Re - x[4].Re;
Magic Number,YAMP.Numerics,RadixFiveTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: double a23p = x[2].Re + x[3].Re;
Magic Number,YAMP.Numerics,RadixFiveTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: double a23p = x[2].Re + x[3].Re;
Magic Number,YAMP.Numerics,RadixFiveTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: double a23m = x[2].Re - x[3].Re;
Magic Number,YAMP.Numerics,RadixFiveTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: double a23m = x[2].Re - x[3].Re;
Magic Number,YAMP.Numerics,RadixFiveTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: double b14p = x[1].Im + x[4].Im;
Magic Number,YAMP.Numerics,RadixFiveTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: double b14m = x[1].Im - x[4].Im;
Magic Number,YAMP.Numerics,RadixFiveTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: double b23p = x[2].Im + x[3].Im;
Magic Number,YAMP.Numerics,RadixFiveTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: double b23p = x[2].Im + x[3].Im;
Magic Number,YAMP.Numerics,RadixFiveTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: double b23m = x[2].Im - x[3].Im;
Magic Number,YAMP.Numerics,RadixFiveTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: double b23m = x[2].Im - x[3].Im;
Magic Number,YAMP.Numerics,RadixFiveTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: y[y0 + 2 * dy] = new ScalarValue(s23a - t23b' s23b + t23a);
Magic Number,YAMP.Numerics,RadixFiveTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: y[y0 + 3 * dy] = new ScalarValue(s23a + t23b' s23b - t23a);
Magic Number,YAMP.Numerics,RadixFiveTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: y[y0 + 4 * dy] = new ScalarValue(s14a + t14b' s14b - t14a);
Magic Number,YAMP.Numerics,RadixFourTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFourTransformlet.cs,FftKernel,The following statement contains a magic number: double a02p = x[0].Re + x[2].Re;
Magic Number,YAMP.Numerics,RadixFourTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFourTransformlet.cs,FftKernel,The following statement contains a magic number: double b02p = x[0].Im + x[2].Im;
Magic Number,YAMP.Numerics,RadixFourTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFourTransformlet.cs,FftKernel,The following statement contains a magic number: double a02m = x[0].Re - x[2].Re;
Magic Number,YAMP.Numerics,RadixFourTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFourTransformlet.cs,FftKernel,The following statement contains a magic number: double b02m = x[0].Im - x[2].Im;
Magic Number,YAMP.Numerics,RadixFourTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFourTransformlet.cs,FftKernel,The following statement contains a magic number: double a13p = x[1].Re + x[3].Re;
Magic Number,YAMP.Numerics,RadixFourTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFourTransformlet.cs,FftKernel,The following statement contains a magic number: double b13p = x[1].Im + x[3].Im;
Magic Number,YAMP.Numerics,RadixFourTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFourTransformlet.cs,FftKernel,The following statement contains a magic number: double b13m = x[1].Im - x[3].Im;
Magic Number,YAMP.Numerics,RadixFourTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFourTransformlet.cs,FftKernel,The following statement contains a magic number: y[y0 + 2 * dy] = new ScalarValue(a02p - a13p' b02p - b13p);
Magic Number,YAMP.Numerics,RadixFourTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFourTransformlet.cs,FftKernel,The following statement contains a magic number: y[y0 + 3 * dy] = new ScalarValue(a02m + b13m' b02m - a13m);
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double a16p = x[1].Re + x[6].Re;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double a16m = x[1].Re - x[6].Re;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double a25p = x[2].Re + x[5].Re;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double a25p = x[2].Re + x[5].Re;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double a25m = x[2].Re - x[5].Re;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double a25m = x[2].Re - x[5].Re;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double a34p = x[3].Re + x[4].Re;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double a34p = x[3].Re + x[4].Re;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double a34m = x[3].Re - x[4].Re;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double a34m = x[3].Re - x[4].Re;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double b16p = x[1].Im + x[6].Im;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double b16m = x[1].Im - x[6].Im;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double b25p = x[2].Im + x[5].Im;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double b25p = x[2].Im + x[5].Im;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double b25m = x[2].Im - x[5].Im;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double b25m = x[2].Im - x[5].Im;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double b34p = x[3].Im + x[4].Im;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double b34p = x[3].Im + x[4].Im;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double b34m = x[3].Im - x[4].Im;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double b34m = x[3].Im - x[4].Im;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: y[y0 + 2 * dy] = new ScalarValue(s25a + t25b' s25b - t25a);
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: y[y0 + 3 * dy] = new ScalarValue(s34a + t34b' s34b - t34a);
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: y[y0 + 4 * dy] = new ScalarValue(s34a - t34b' s34b + t34a);
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: y[y0 + 5 * dy] = new ScalarValue(s25a - t25b' s25b + t25a);
Magic Number,YAMP.Numerics,RadixSevenTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: y[y0 + 6 * dy] = new ScalarValue(s16a + t16b' s16b - t16a);
Magic Number,YAMP.Numerics,RadixThreeTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixThreeTransformlet.cs,FftPass,The following statement contains a magic number: int dx = N / 3;
Magic Number,YAMP.Numerics,RadixThreeTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixThreeTransformlet.cs,FftPass,The following statement contains a magic number: for (int j = 0; j < dx; j++)              {                  int du = (dx / Ns) * (j % Ns);                  int y0 = Expand(j' Ns' 3);                    if (sign < 0)                      FftKernel(x[j]' x[j + dx] * u[N - du]' x[j + 2 * dx] * u[N - 2 * du]' out y[y0]' out y[y0 + Ns]' out y[y0 + 2 * Ns]' -1);                  else                      FftKernel(x[j]' x[j + dx] * u[du]' x[j + 2 * dx] * u[2 * du]' out y[y0]' out y[y0 + Ns]' out y[y0 + 2 * Ns]' 1);              }
Magic Number,YAMP.Numerics,RadixThreeTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixThreeTransformlet.cs,FftPass,The following statement contains a magic number: for (int j = 0; j < dx; j++)              {                  int du = (dx / Ns) * (j % Ns);                  int y0 = Expand(j' Ns' 3);                    if (sign < 0)                      FftKernel(x[j]' x[j + dx] * u[N - du]' x[j + 2 * dx] * u[N - 2 * du]' out y[y0]' out y[y0 + Ns]' out y[y0 + 2 * Ns]' -1);                  else                      FftKernel(x[j]' x[j + dx] * u[du]' x[j + 2 * dx] * u[2 * du]' out y[y0]' out y[y0 + Ns]' out y[y0 + 2 * Ns]' 1);              }
Magic Number,YAMP.Numerics,RadixThreeTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixThreeTransformlet.cs,FftPass,The following statement contains a magic number: for (int j = 0; j < dx; j++)              {                  int du = (dx / Ns) * (j % Ns);                  int y0 = Expand(j' Ns' 3);                    if (sign < 0)                      FftKernel(x[j]' x[j + dx] * u[N - du]' x[j + 2 * dx] * u[N - 2 * du]' out y[y0]' out y[y0 + Ns]' out y[y0 + 2 * Ns]' -1);                  else                      FftKernel(x[j]' x[j + dx] * u[du]' x[j + 2 * dx] * u[2 * du]' out y[y0]' out y[y0 + Ns]' out y[y0 + 2 * Ns]' 1);              }
Magic Number,YAMP.Numerics,RadixThreeTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixThreeTransformlet.cs,FftPass,The following statement contains a magic number: for (int j = 0; j < dx; j++)              {                  int du = (dx / Ns) * (j % Ns);                  int y0 = Expand(j' Ns' 3);                    if (sign < 0)                      FftKernel(x[j]' x[j + dx] * u[N - du]' x[j + 2 * dx] * u[N - 2 * du]' out y[y0]' out y[y0 + Ns]' out y[y0 + 2 * Ns]' -1);                  else                      FftKernel(x[j]' x[j + dx] * u[du]' x[j + 2 * dx] * u[2 * du]' out y[y0]' out y[y0 + Ns]' out y[y0 + 2 * Ns]' 1);              }
Magic Number,YAMP.Numerics,RadixThreeTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixThreeTransformlet.cs,FftPass,The following statement contains a magic number: for (int j = 0; j < dx; j++)              {                  int du = (dx / Ns) * (j % Ns);                  int y0 = Expand(j' Ns' 3);                    if (sign < 0)                      FftKernel(x[j]' x[j + dx] * u[N - du]' x[j + 2 * dx] * u[N - 2 * du]' out y[y0]' out y[y0 + Ns]' out y[y0 + 2 * Ns]' -1);                  else                      FftKernel(x[j]' x[j + dx] * u[du]' x[j + 2 * dx] * u[2 * du]' out y[y0]' out y[y0 + Ns]' out y[y0 + 2 * Ns]' 1);              }
Magic Number,YAMP.Numerics,RadixThreeTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixThreeTransformlet.cs,FftPass,The following statement contains a magic number: for (int j = 0; j < dx; j++)              {                  int du = (dx / Ns) * (j % Ns);                  int y0 = Expand(j' Ns' 3);                    if (sign < 0)                      FftKernel(x[j]' x[j + dx] * u[N - du]' x[j + 2 * dx] * u[N - 2 * du]' out y[y0]' out y[y0 + Ns]' out y[y0 + 2 * Ns]' -1);                  else                      FftKernel(x[j]' x[j + dx] * u[du]' x[j + 2 * dx] * u[2 * du]' out y[y0]' out y[y0 + Ns]' out y[y0 + 2 * Ns]' 1);              }
Magic Number,YAMP.Numerics,RadixThreeTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixThreeTransformlet.cs,FftPass,The following statement contains a magic number: for (int j = 0; j < dx; j++)              {                  int du = (dx / Ns) * (j % Ns);                  int y0 = Expand(j' Ns' 3);                    if (sign < 0)                      FftKernel(x[j]' x[j + dx] * u[N - du]' x[j + 2 * dx] * u[N - 2 * du]' out y[y0]' out y[y0 + Ns]' out y[y0 + 2 * Ns]' -1);                  else                      FftKernel(x[j]' x[j + dx] * u[du]' x[j + 2 * dx] * u[2 * du]' out y[y0]' out y[y0 + Ns]' out y[y0 + 2 * Ns]' 1);              }
Magic Number,YAMP.Numerics,RadixTwoTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixTwoTransformlet.cs,FftPass,The following statement contains a magic number: int dx = N / 2;
Magic Number,YAMP.Numerics,RadixTwoTransformlet,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixTwoTransformlet.cs,FftPass,The following statement contains a magic number: for (int j = 0; j < dx; j++)              {                  int du = (dx / Ns) * (j % Ns);                  int y0 = Expand(j' Ns' 2);                    if (sign < 0)                      FftKernel(x[j]' x[j + dx] * u[N - du]' out y[y0]' out y[y0 + Ns]);                  else                      FftKernel(x[j]' x[j + dx] * u[du]' out y[y0]' out y[y0 + Ns]);              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta,The following statement contains a magic number: var sin_term = (0.5 * Math.PI * s).Sin() / Math.PI;
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta,The following statement contains a magic number: if (sin_term == 0.0)              {                  return ScalarValue.Zero;              }              else if (sabs < 170)              {                  //See below                  int n = (int)Math.Floor(sabs / 10.0);                  var p = new ScalarValue(2.0 * Math.PI).Pow(s + 10.0 * n) / Helpers.TwoPIpow[n];                  var g = Gamma.LinearGamma(1.0 - s);                  return p * g * sin_term * zeta_one_minus_s;              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta,The following statement contains a magic number: if (sin_term == 0.0)              {                  return ScalarValue.Zero;              }              else if (sabs < 170)              {                  //See below                  int n = (int)Math.Floor(sabs / 10.0);                  var p = new ScalarValue(2.0 * Math.PI).Pow(s + 10.0 * n) / Helpers.TwoPIpow[n];                  var g = Gamma.LinearGamma(1.0 - s);                  return p * g * sin_term * zeta_one_minus_s;              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta,The following statement contains a magic number: if (sin_term == 0.0)              {                  return ScalarValue.Zero;              }              else if (sabs < 170)              {                  //See below                  int n = (int)Math.Floor(sabs / 10.0);                  var p = new ScalarValue(2.0 * Math.PI).Pow(s + 10.0 * n) / Helpers.TwoPIpow[n];                  var g = Gamma.LinearGamma(1.0 - s);                  return p * g * sin_term * zeta_one_minus_s;              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta,The following statement contains a magic number: if (sin_term == 0.0)              {                  return ScalarValue.Zero;              }              else if (sabs < 170)              {                  //See below                  int n = (int)Math.Floor(sabs / 10.0);                  var p = new ScalarValue(2.0 * Math.PI).Pow(s + 10.0 * n) / Helpers.TwoPIpow[n];                  var g = Gamma.LinearGamma(1.0 - s);                  return p * g * sin_term * zeta_one_minus_s;              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta,The following statement contains a magic number: var sin_term = ((s % 2.0) == 0.0) ? 0.0 : Math.Sin(0.5 * Math.PI * (s % 4.0)) / Math.PI;
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta,The following statement contains a magic number: var sin_term = ((s % 2.0) == 0.0) ? 0.0 : Math.Sin(0.5 * Math.PI * (s % 4.0)) / Math.PI;
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta,The following statement contains a magic number: var sin_term = ((s % 2.0) == 0.0) ? 0.0 : Math.Sin(0.5 * Math.PI * (s % 4.0)) / Math.PI;
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta,The following statement contains a magic number: if (sin_term == 0.0)              {                  return 0.0;              }              else if (s > -170)              {                  /*                    * We have to be careful about losing digits                   * in calculating pow(2 Pi' s). The gamma                   * function is fine because we were careful                   * with that implementation.                   * We keep an array of (2 Pi)^(10 n).                   */                  var n = (Int32)Math.Floor((-s) / 10.0);                  var fs = s + 10.0 * n;                  var p = Math.Pow(2.0 * Math.PI' fs) / Helpers.TwoPIpow[n];                  var g = Gamma.LinearGamma(1.0 - s);                  return p * g * sin_term * zeta_one_minus_s;              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta,The following statement contains a magic number: if (sin_term == 0.0)              {                  return 0.0;              }              else if (s > -170)              {                  /*                    * We have to be careful about losing digits                   * in calculating pow(2 Pi' s). The gamma                   * function is fine because we were careful                   * with that implementation.                   * We keep an array of (2 Pi)^(10 n).                   */                  var n = (Int32)Math.Floor((-s) / 10.0);                  var fs = s + 10.0 * n;                  var p = Math.Pow(2.0 * Math.PI' fs) / Helpers.TwoPIpow[n];                  var g = Gamma.LinearGamma(1.0 - s);                  return p * g * sin_term * zeta_one_minus_s;              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta,The following statement contains a magic number: if (sin_term == 0.0)              {                  return 0.0;              }              else if (s > -170)              {                  /*                    * We have to be careful about losing digits                   * in calculating pow(2 Pi' s). The gamma                   * function is fine because we were careful                   * with that implementation.                   * We keep an array of (2 Pi)^(10 n).                   */                  var n = (Int32)Math.Floor((-s) / 10.0);                  var fs = s + 10.0 * n;                  var p = Math.Pow(2.0 * Math.PI' fs) / Helpers.TwoPIpow[n];                  var g = Gamma.LinearGamma(1.0 - s);                  return p * g * sin_term * zeta_one_minus_s;              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta,The following statement contains a magic number: if (sin_term == 0.0)              {                  return 0.0;              }              else if (s > -170)              {                  /*                    * We have to be careful about losing digits                   * in calculating pow(2 Pi' s). The gamma                   * function is fine because we were careful                   * with that implementation.                   * We keep an array of (2 Pi)^(10 n).                   */                  var n = (Int32)Math.Floor((-s) / 10.0);                  var fs = s + 10.0 * n;                  var p = Math.Pow(2.0 * Math.PI' fs) / Helpers.TwoPIpow[n];                  var g = Gamma.LinearGamma(1.0 - s);                  return p * g * sin_term * zeta_one_minus_s;              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: if (s.Re < 1.0)              {                  var c = Helpers.ChebEval(zetaLt1' 2.0 * s - 1.0);                  return c / (s - 1.0);              }              else if (s.Re <= 20.0)              {                  var x = (2.0 * s - 21.0) / 19.0;                  var c = Helpers.ChebEval(zetaGt1' x);                  return c / (s - 1.0);              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: if (s.Re < 1.0)              {                  var c = Helpers.ChebEval(zetaLt1' 2.0 * s - 1.0);                  return c / (s - 1.0);              }              else if (s.Re <= 20.0)              {                  var x = (2.0 * s - 21.0) / 19.0;                  var c = Helpers.ChebEval(zetaGt1' x);                  return c / (s - 1.0);              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: if (s.Re < 1.0)              {                  var c = Helpers.ChebEval(zetaLt1' 2.0 * s - 1.0);                  return c / (s - 1.0);              }              else if (s.Re <= 20.0)              {                  var x = (2.0 * s - 21.0) / 19.0;                  var c = Helpers.ChebEval(zetaGt1' x);                  return c / (s - 1.0);              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: if (s.Re < 1.0)              {                  var c = Helpers.ChebEval(zetaLt1' 2.0 * s - 1.0);                  return c / (s - 1.0);              }              else if (s.Re <= 20.0)              {                  var x = (2.0 * s - 21.0) / 19.0;                  var c = Helpers.ChebEval(zetaGt1' x);                  return c / (s - 1.0);              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: if (s.Re < 1.0)              {                  var c = Helpers.ChebEval(zetaLt1' 2.0 * s - 1.0);                  return c / (s - 1.0);              }              else if (s.Re <= 20.0)              {                  var x = (2.0 * s - 21.0) / 19.0;                  var c = Helpers.ChebEval(zetaGt1' x);                  return c / (s - 1.0);              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: var f2 = 1.0 - new ScalarValue(2.0).Pow(-s);
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: var f3 = 1.0 - new ScalarValue(3.0).Pow(-s);
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: var f5 = 1.0 - new ScalarValue(5.0).Pow(-s);
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: var f7 = 1.0 - new ScalarValue(7.0).Pow(-s);
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: if (s < 1.0)              {                  var c = Helpers.ChebEval(zetaLt1' 2.0 * s - 1.0);                  return c / (s - 1.0);              }              else if (s <= 20.0)              {                  var x = (2.0 * s - 21.0) / 19.0;                  var c = Helpers.ChebEval(zetaGt1' x);                  return c / (s - 1.0);              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: if (s < 1.0)              {                  var c = Helpers.ChebEval(zetaLt1' 2.0 * s - 1.0);                  return c / (s - 1.0);              }              else if (s <= 20.0)              {                  var x = (2.0 * s - 21.0) / 19.0;                  var c = Helpers.ChebEval(zetaGt1' x);                  return c / (s - 1.0);              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: if (s < 1.0)              {                  var c = Helpers.ChebEval(zetaLt1' 2.0 * s - 1.0);                  return c / (s - 1.0);              }              else if (s <= 20.0)              {                  var x = (2.0 * s - 21.0) / 19.0;                  var c = Helpers.ChebEval(zetaGt1' x);                  return c / (s - 1.0);              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: if (s < 1.0)              {                  var c = Helpers.ChebEval(zetaLt1' 2.0 * s - 1.0);                  return c / (s - 1.0);              }              else if (s <= 20.0)              {                  var x = (2.0 * s - 21.0) / 19.0;                  var c = Helpers.ChebEval(zetaGt1' x);                  return c / (s - 1.0);              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: if (s < 1.0)              {                  var c = Helpers.ChebEval(zetaLt1' 2.0 * s - 1.0);                  return c / (s - 1.0);              }              else if (s <= 20.0)              {                  var x = (2.0 * s - 21.0) / 19.0;                  var c = Helpers.ChebEval(zetaGt1' x);                  return c / (s - 1.0);              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: var f2 = 1.0 - Math.Pow(2.0' -s);
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: var f3 = 1.0 - Math.Pow(3.0' -s);
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: var f5 = 1.0 - Math.Pow(5.0' -s);
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: var f7 = 1.0 - Math.Pow(7.0' -s);
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: if (s.Re > -19.0)              {                  var x = (-19 - 2.0 * s) / 19.0;                  var c = Helpers.ChebEval(zetaGt1' x);                  return c / (-s);              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: if (s.Re > -19.0)              {                  var x = (-19 - 2.0 * s) / 19.0;                  var c = Helpers.ChebEval(zetaGt1' x);                  return c / (-s);              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: if (s.Re > -19.0)              {                  var x = (-19 - 2.0 * s) / 19.0;                  var c = Helpers.ChebEval(zetaGt1' x);                  return c / (-s);              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: if (s.Re > -19.0)              {                  var x = (-19 - 2.0 * s) / 19.0;                  var c = Helpers.ChebEval(zetaGt1' x);                  return c / (-s);              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: var f2 = 1.0 - new ScalarValue(2.0).Pow(-(1.0 - s));
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: var f3 = 1.0 - new ScalarValue(3.0).Pow(-(1.0 - s));
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: var f5 = 1.0 - new ScalarValue(5.0).Pow(-(1.0 - s));
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: var f7 = 1.0 - new ScalarValue(7.0).Pow(-(1.0 - s));
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: if (s > -19.0)              {                  var x = (-19 - 2.0 * s) / 19.0;                  var c = Helpers.ChebEval(zetaGt1' x);                  return c / (-s);              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: if (s > -19.0)              {                  var x = (-19 - 2.0 * s) / 19.0;                  var c = Helpers.ChebEval(zetaGt1' x);                  return c / (-s);              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: if (s > -19.0)              {                  var x = (-19 - 2.0 * s) / 19.0;                  var c = Helpers.ChebEval(zetaGt1' x);                  return c / (-s);              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: if (s > -19.0)              {                  var x = (-19 - 2.0 * s) / 19.0;                  var c = Helpers.ChebEval(zetaGt1' x);                  return c / (-s);              }
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: var f2 = 1.0 - Math.Pow(2.0' -(1.0 - s));
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: var f3 = 1.0 - Math.Pow(3.0' -(1.0 - s));
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: var f5 = 1.0 - Math.Pow(5.0' -(1.0 - s));
Magic Number,YAMP.Numerics,Zeta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: var f7 = 1.0 - Math.Pow(7.0' -(1.0 - s));
Magic Number,YAMP.Numerics,SimpsonIntegrator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Integration\SimpsonIntegrator.cs,Integrate,The following statement contains a magic number: for (var i = 1; i < N - 1; i += 2)              {                  sum += (x[i + 2].Re - x[i].Re) * (y[i].Re + 4.0 * y[i + 1].Re + y[i + 2].Re);              }
Magic Number,YAMP.Numerics,SimpsonIntegrator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Integration\SimpsonIntegrator.cs,Integrate,The following statement contains a magic number: for (var i = 1; i < N - 1; i += 2)              {                  sum += (x[i + 2].Re - x[i].Re) * (y[i].Re + 4.0 * y[i + 1].Re + y[i + 2].Re);              }
Magic Number,YAMP.Numerics,SimpsonIntegrator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Integration\SimpsonIntegrator.cs,Integrate,The following statement contains a magic number: for (var i = 1; i < N - 1; i += 2)              {                  sum += (x[i + 2].Re - x[i].Re) * (y[i].Re + 4.0 * y[i + 1].Re + y[i + 2].Re);              }
Magic Number,YAMP.Numerics,SimpsonIntegrator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Integration\SimpsonIntegrator.cs,Integrate,The following statement contains a magic number: for (var i = 1; i < N - 1; i += 2)              {                  sum += (x[i + 2].Re - x[i].Re) * (y[i].Re + 4.0 * y[i + 1].Re + y[i + 2].Re);              }
Magic Number,YAMP.Numerics,SimpsonIntegrator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Integration\SimpsonIntegrator.cs,Integrate,The following statement contains a magic number: return new ScalarValue(sum / 6.0);
Magic Number,YAMP.Numerics,TrapezIntegrator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Integration\TrapezIntegrator.cs,Integrate,The following statement contains a magic number: var sum = (x[2].Re - x[1].Re) * y[1] + (x[N].Re - x[N - 1].Re) * y[N];
Magic Number,YAMP.Numerics,TrapezIntegrator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Integration\TrapezIntegrator.cs,Integrate,The following statement contains a magic number: for (var i = 2; i < N; i++)              {                  sum += (x[i + 1].Re - x[i - 1].Re) * y[i].Re;              }
Magic Number,YAMP.Numerics,TrapezIntegrator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Integration\TrapezIntegrator.cs,Integrate,The following statement contains a magic number: return 0.5 * sum;
Magic Number,YAMP.Numerics,Interpolation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\Interpolation.cs,Interpolation,The following statement contains a magic number: if (samples.DimensionX != 2)                  new YAMPMatrixDimensionException(samples.DimensionY' 2' samples.DimensionY' samples.DimensionX);
Magic Number,YAMP.Numerics,Interpolation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\Interpolation.cs,Interpolation,The following statement contains a magic number: if (samples.DimensionX != 2)                  new YAMPMatrixDimensionException(samples.DimensionY' 2' samples.DimensionY' samples.DimensionX);
Magic Number,YAMP.Numerics,Interpolation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\Interpolation.cs,SolveTridiag,The following statement contains a magic number: for (i = 2; i <= n; i++)              {                  sub[i] = sub[i] / diag[i - 1];                  diag[i] = diag[i] - sub[i] * sup[i - 1];                  b[i] = b[i] - sub[i] * b[i - 1];              }
Magic Number,YAMP.Numerics,NewtonInterpolation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\NewtonInterpolation.cs,ComputeValue,The following statement contains a magic number: for (i = 2' LN = Samples[1' 2].Re; i <= Np; i++)              {                  X *= (t - Samples[i' 1].Re);                    for (j = 1' F = 0; j <= i; j++)                  {                      for (k = 1' XX = 1; k <= i; k++)                      {                          if (k != j)                              XX *= Samples[j' 1].Re - Samples[k' 1].Re;                      }                        F += Samples[j' 2].Re / XX;                  }                    LN += X * F;              }
Magic Number,YAMP.Numerics,NewtonInterpolation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\NewtonInterpolation.cs,ComputeValue,The following statement contains a magic number: for (i = 2' LN = Samples[1' 2].Re; i <= Np; i++)              {                  X *= (t - Samples[i' 1].Re);                    for (j = 1' F = 0; j <= i; j++)                  {                      for (k = 1' XX = 1; k <= i; k++)                      {                          if (k != j)                              XX *= Samples[j' 1].Re - Samples[k' 1].Re;                      }                        F += Samples[j' 2].Re / XX;                  }                    LN += X * F;              }
Magic Number,YAMP.Numerics,NewtonInterpolation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\NewtonInterpolation.cs,ComputeValue,The following statement contains a magic number: for (i = 2' LN = Samples[1' 2].Re; i <= Np; i++)              {                  X *= (t - Samples[i' 1].Re);                    for (j = 1' F = 0; j <= i; j++)                  {                      for (k = 1' XX = 1; k <= i; k++)                      {                          if (k != j)                              XX *= Samples[j' 1].Re - Samples[k' 1].Re;                      }                        F += Samples[j' 2].Re / XX;                  }                    LN += X * F;              }
Magic Number,YAMP.Numerics,SplineInterpolation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,SplineInterpolation,The following statement contains a magic number: for (int i = 2; i <= Np; i++)                  h[i - 1] = samples[i' 1].Re - samples[i - 1' 1].Re;
Magic Number,YAMP.Numerics,SplineInterpolation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,SplineInterpolation,The following statement contains a magic number: if (Np > 2)              {                  double[] sub = new double[Np - 1];                  double[] diag = new double[Np - 1];                  double[] sup = new double[Np - 1];                    for (int i = 2; i < Np; i++)                  {                      int j = i - 1;                      diag[j] = (h[j] + h[j + 1]) / 3;                      sup[j] = h[j + 1] / 6;                      sub[j] = h[j] / 6;                      a[j] = (samples[i + 1' 2].Re - samples[i' 2].Re) / h[j + 1] - (samples[i' 2].Re - samples[i - 1' 2].Re) / h[j];                    }                    SolveTridiag(sub' diag' sup' ref a' Np - 2);              }
Magic Number,YAMP.Numerics,SplineInterpolation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,SplineInterpolation,The following statement contains a magic number: if (Np > 2)              {                  double[] sub = new double[Np - 1];                  double[] diag = new double[Np - 1];                  double[] sup = new double[Np - 1];                    for (int i = 2; i < Np; i++)                  {                      int j = i - 1;                      diag[j] = (h[j] + h[j + 1]) / 3;                      sup[j] = h[j + 1] / 6;                      sub[j] = h[j] / 6;                      a[j] = (samples[i + 1' 2].Re - samples[i' 2].Re) / h[j + 1] - (samples[i' 2].Re - samples[i - 1' 2].Re) / h[j];                    }                    SolveTridiag(sub' diag' sup' ref a' Np - 2);              }
Magic Number,YAMP.Numerics,SplineInterpolation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,SplineInterpolation,The following statement contains a magic number: if (Np > 2)              {                  double[] sub = new double[Np - 1];                  double[] diag = new double[Np - 1];                  double[] sup = new double[Np - 1];                    for (int i = 2; i < Np; i++)                  {                      int j = i - 1;                      diag[j] = (h[j] + h[j + 1]) / 3;                      sup[j] = h[j + 1] / 6;                      sub[j] = h[j] / 6;                      a[j] = (samples[i + 1' 2].Re - samples[i' 2].Re) / h[j + 1] - (samples[i' 2].Re - samples[i - 1' 2].Re) / h[j];                    }                    SolveTridiag(sub' diag' sup' ref a' Np - 2);              }
Magic Number,YAMP.Numerics,SplineInterpolation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,SplineInterpolation,The following statement contains a magic number: if (Np > 2)              {                  double[] sub = new double[Np - 1];                  double[] diag = new double[Np - 1];                  double[] sup = new double[Np - 1];                    for (int i = 2; i < Np; i++)                  {                      int j = i - 1;                      diag[j] = (h[j] + h[j + 1]) / 3;                      sup[j] = h[j + 1] / 6;                      sub[j] = h[j] / 6;                      a[j] = (samples[i + 1' 2].Re - samples[i' 2].Re) / h[j + 1] - (samples[i' 2].Re - samples[i - 1' 2].Re) / h[j];                    }                    SolveTridiag(sub' diag' sup' ref a' Np - 2);              }
Magic Number,YAMP.Numerics,SplineInterpolation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,SplineInterpolation,The following statement contains a magic number: if (Np > 2)              {                  double[] sub = new double[Np - 1];                  double[] diag = new double[Np - 1];                  double[] sup = new double[Np - 1];                    for (int i = 2; i < Np; i++)                  {                      int j = i - 1;                      diag[j] = (h[j] + h[j + 1]) / 3;                      sup[j] = h[j + 1] / 6;                      sub[j] = h[j] / 6;                      a[j] = (samples[i + 1' 2].Re - samples[i' 2].Re) / h[j + 1] - (samples[i' 2].Re - samples[i - 1' 2].Re) / h[j];                    }                    SolveTridiag(sub' diag' sup' ref a' Np - 2);              }
Magic Number,YAMP.Numerics,SplineInterpolation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,SplineInterpolation,The following statement contains a magic number: if (Np > 2)              {                  double[] sub = new double[Np - 1];                  double[] diag = new double[Np - 1];                  double[] sup = new double[Np - 1];                    for (int i = 2; i < Np; i++)                  {                      int j = i - 1;                      diag[j] = (h[j] + h[j + 1]) / 3;                      sup[j] = h[j + 1] / 6;                      sub[j] = h[j] / 6;                      a[j] = (samples[i + 1' 2].Re - samples[i' 2].Re) / h[j + 1] - (samples[i' 2].Re - samples[i - 1' 2].Re) / h[j];                    }                    SolveTridiag(sub' diag' sup' ref a' Np - 2);              }
Magic Number,YAMP.Numerics,SplineInterpolation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,SplineInterpolation,The following statement contains a magic number: if (Np > 2)              {                  double[] sub = new double[Np - 1];                  double[] diag = new double[Np - 1];                  double[] sup = new double[Np - 1];                    for (int i = 2; i < Np; i++)                  {                      int j = i - 1;                      diag[j] = (h[j] + h[j + 1]) / 3;                      sup[j] = h[j + 1] / 6;                      sub[j] = h[j] / 6;                      a[j] = (samples[i + 1' 2].Re - samples[i' 2].Re) / h[j + 1] - (samples[i' 2].Re - samples[i - 1' 2].Re) / h[j];                    }                    SolveTridiag(sub' diag' sup' ref a' Np - 2);              }
Magic Number,YAMP.Numerics,SplineInterpolation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,SplineInterpolation,The following statement contains a magic number: if (Np > 2)              {                  double[] sub = new double[Np - 1];                  double[] diag = new double[Np - 1];                  double[] sup = new double[Np - 1];                    for (int i = 2; i < Np; i++)                  {                      int j = i - 1;                      diag[j] = (h[j] + h[j + 1]) / 3;                      sup[j] = h[j + 1] / 6;                      sub[j] = h[j] / 6;                      a[j] = (samples[i + 1' 2].Re - samples[i' 2].Re) / h[j + 1] - (samples[i' 2].Re - samples[i - 1' 2].Re) / h[j];                    }                    SolveTridiag(sub' diag' sup' ref a' Np - 2);              }
Magic Number,YAMP.Numerics,SplineInterpolation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,SplineInterpolation,The following statement contains a magic number: if (Np > 2)              {                  double[] sub = new double[Np - 1];                  double[] diag = new double[Np - 1];                  double[] sup = new double[Np - 1];                    for (int i = 2; i < Np; i++)                  {                      int j = i - 1;                      diag[j] = (h[j] + h[j + 1]) / 3;                      sup[j] = h[j + 1] / 6;                      sub[j] = h[j] / 6;                      a[j] = (samples[i + 1' 2].Re - samples[i' 2].Re) / h[j + 1] - (samples[i' 2].Re - samples[i - 1' 2].Re) / h[j];                    }                    SolveTridiag(sub' diag' sup' ref a' Np - 2);              }
Magic Number,YAMP.Numerics,SplineInterpolation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,SplineInterpolation,The following statement contains a magic number: if (Np > 2)              {                  double[] sub = new double[Np - 1];                  double[] diag = new double[Np - 1];                  double[] sup = new double[Np - 1];                    for (int i = 2; i < Np; i++)                  {                      int j = i - 1;                      diag[j] = (h[j] + h[j + 1]) / 3;                      sup[j] = h[j + 1] / 6;                      sub[j] = h[j] / 6;                      a[j] = (samples[i + 1' 2].Re - samples[i' 2].Re) / h[j + 1] - (samples[i' 2].Re - samples[i - 1' 2].Re) / h[j];                    }                    SolveTridiag(sub' diag' sup' ref a' Np - 2);              }
Magic Number,YAMP.Numerics,SplineInterpolation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,ComputeValue,The following statement contains a magic number: if (a.Length > 1)              {                  int gap = 1;                  double previous = 0.0;                    for (int i = 1; i < a.Length; i++)                  {                      if (samples[i' 1].Re < x && (i == 1 || samples[i' 1].Re > previous))                      {                          previous = samples[i' 1].Re;                          gap = i;                      }                  }                    double x1 = x - previous;                  double x2 = h[gap] - x1;                  return ((-a[gap - 1] / 6 * (x2 + h[gap]) * x1 + samples[gap' 2].Re) * x2 + (-a[gap] / 6 * (x1 + h[gap]) * x2 + samples[gap + 1' 2].Re) * x1) / h[gap];              }
Magic Number,YAMP.Numerics,SplineInterpolation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,ComputeValue,The following statement contains a magic number: if (a.Length > 1)              {                  int gap = 1;                  double previous = 0.0;                    for (int i = 1; i < a.Length; i++)                  {                      if (samples[i' 1].Re < x && (i == 1 || samples[i' 1].Re > previous))                      {                          previous = samples[i' 1].Re;                          gap = i;                      }                  }                    double x1 = x - previous;                  double x2 = h[gap] - x1;                  return ((-a[gap - 1] / 6 * (x2 + h[gap]) * x1 + samples[gap' 2].Re) * x2 + (-a[gap] / 6 * (x1 + h[gap]) * x2 + samples[gap + 1' 2].Re) * x1) / h[gap];              }
Magic Number,YAMP.Numerics,SplineInterpolation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,ComputeValue,The following statement contains a magic number: if (a.Length > 1)              {                  int gap = 1;                  double previous = 0.0;                    for (int i = 1; i < a.Length; i++)                  {                      if (samples[i' 1].Re < x && (i == 1 || samples[i' 1].Re > previous))                      {                          previous = samples[i' 1].Re;                          gap = i;                      }                  }                    double x1 = x - previous;                  double x2 = h[gap] - x1;                  return ((-a[gap - 1] / 6 * (x2 + h[gap]) * x1 + samples[gap' 2].Re) * x2 + (-a[gap] / 6 * (x1 + h[gap]) * x2 + samples[gap + 1' 2].Re) * x1) / h[gap];              }
Magic Number,YAMP.Numerics,SplineInterpolation,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,ComputeValue,The following statement contains a magic number: if (a.Length > 1)              {                  int gap = 1;                  double previous = 0.0;                    for (int i = 1; i < a.Length; i++)                  {                      if (samples[i' 1].Re < x && (i == 1 || samples[i' 1].Re > previous))                      {                          previous = samples[i' 1].Re;                          gap = i;                      }                  }                    double x1 = x - previous;                  double x2 = h[gap] - x1;                  return ((-a[gap - 1] / 6 * (x2 + h[gap]) * x1 + samples[gap' 2].Re) * x2 + (-a[gap] / 6 * (x1 + h[gap]) * x2 + samples[gap + 1' 2].Re) * x1) / h[gap];              }
Magic Number,YAMP.Numerics,HalfDivisionMethod,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\NonLinear\HalfDivisionMethod.cs,HalfDivisionMethod,The following statement contains a magic number: Result = new double[2' 1];
Magic Number,YAMP.Numerics,HalfDivisionMethod,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\NonLinear\HalfDivisionMethod.cs,HalfDivisionMethod,The following statement contains a magic number: while (y > d)              {                  t++;                  x2 = (x0 + x1) / 2;                  if (f(x0) * f(x2) > 0)                      x0 = x2;                  else                      x1 = x2;                  y = Math.Abs(x0 - x1);              }
Magic Number,YAMP.Numerics,SecantMethod,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\NonLinear\SecantMethod.cs,SecantMethod,The following statement contains a magic number: Result = new double[2' 1];
Magic Number,YAMP.Numerics,SecantMethod,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\NonLinear\SecantMethod.cs,SecantMethod,The following statement contains a magic number: for (double i = 0; i <= 10; i = i + dl)              {                  if (f(i) * f(i + dl) < 0)                      Perform(i + dl' delta);              }
Magic Number,YAMP.Numerics,Euler,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\Euler.cs,Calculate,The following statement contains a magic number: double['] result = new double[pointsNum + 1' 2];
Magic Number,YAMP.Numerics,Euler,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\Euler.cs,Calculate,The following statement contains a magic number: for (int i = 0; i <= pointsNum; i++)              {                  f1 = f(x' y);                  y = y1 + (h / 2) * (f(x' y) + f(x + h' y + h * f1));                  result[i' 0] = x;                  result[i' 1] = y1;                  y1 = y;                  x = x + h;              }
Magic Number,YAMP.Numerics,RungeKutta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\RungeKutta.cs,Calculate,The following statement contains a magic number: double['] result = new double[pointsNum + 1' 2];
Magic Number,YAMP.Numerics,RungeKutta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\RungeKutta.cs,Calculate,The following statement contains a magic number: for (int i = 1; i <= pointsNum; i++)              {                  k1 = h * f(x' y);                  x = x + h / 2;                  y = y1 + k1 / 2;                  k2 = f(x' y) * h;                  y = y1 + k2 / 2;                  k3 = f(x' y) * h;                  x = x + h / 2;                  y = y1 + (k1 + 2 * k2 + 2 * k3 + f(x' y) * h) / 6;                  y1 = y;                  result[i' 0] = x;                  result[i' 1] = y1;              }
Magic Number,YAMP.Numerics,RungeKutta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\RungeKutta.cs,Calculate,The following statement contains a magic number: for (int i = 1; i <= pointsNum; i++)              {                  k1 = h * f(x' y);                  x = x + h / 2;                  y = y1 + k1 / 2;                  k2 = f(x' y) * h;                  y = y1 + k2 / 2;                  k3 = f(x' y) * h;                  x = x + h / 2;                  y = y1 + (k1 + 2 * k2 + 2 * k3 + f(x' y) * h) / 6;                  y1 = y;                  result[i' 0] = x;                  result[i' 1] = y1;              }
Magic Number,YAMP.Numerics,RungeKutta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\RungeKutta.cs,Calculate,The following statement contains a magic number: for (int i = 1; i <= pointsNum; i++)              {                  k1 = h * f(x' y);                  x = x + h / 2;                  y = y1 + k1 / 2;                  k2 = f(x' y) * h;                  y = y1 + k2 / 2;                  k3 = f(x' y) * h;                  x = x + h / 2;                  y = y1 + (k1 + 2 * k2 + 2 * k3 + f(x' y) * h) / 6;                  y1 = y;                  result[i' 0] = x;                  result[i' 1] = y1;              }
Magic Number,YAMP.Numerics,RungeKutta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\RungeKutta.cs,Calculate,The following statement contains a magic number: for (int i = 1; i <= pointsNum; i++)              {                  k1 = h * f(x' y);                  x = x + h / 2;                  y = y1 + k1 / 2;                  k2 = f(x' y) * h;                  y = y1 + k2 / 2;                  k3 = f(x' y) * h;                  x = x + h / 2;                  y = y1 + (k1 + 2 * k2 + 2 * k3 + f(x' y) * h) / 6;                  y1 = y;                  result[i' 0] = x;                  result[i' 1] = y1;              }
Magic Number,YAMP.Numerics,RungeKutta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\RungeKutta.cs,Calculate,The following statement contains a magic number: for (int i = 1; i <= pointsNum; i++)              {                  k1 = h * f(x' y);                  x = x + h / 2;                  y = y1 + k1 / 2;                  k2 = f(x' y) * h;                  y = y1 + k2 / 2;                  k3 = f(x' y) * h;                  x = x + h / 2;                  y = y1 + (k1 + 2 * k2 + 2 * k3 + f(x' y) * h) / 6;                  y1 = y;                  result[i' 0] = x;                  result[i' 1] = y1;              }
Magic Number,YAMP.Numerics,RungeKutta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\RungeKutta.cs,Calculate,The following statement contains a magic number: for (int i = 1; i <= pointsNum; i++)              {                  k1 = h * f(x' y);                  x = x + h / 2;                  y = y1 + k1 / 2;                  k2 = f(x' y) * h;                  y = y1 + k2 / 2;                  k3 = f(x' y) * h;                  x = x + h / 2;                  y = y1 + (k1 + 2 * k2 + 2 * k3 + f(x' y) * h) / 6;                  y1 = y;                  result[i' 0] = x;                  result[i' 1] = y1;              }
Magic Number,YAMP.Numerics,RungeKutta,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\RungeKutta.cs,Calculate,The following statement contains a magic number: for (int i = 1; i <= pointsNum; i++)              {                  k1 = h * f(x' y);                  x = x + h / 2;                  y = y1 + k1 / 2;                  k2 = f(x' y) * h;                  y = y1 + k2 / 2;                  k3 = f(x' y) * h;                  x = x + h / 2;                  y = y1 + (k1 + 2 * k2 + 2 * k3 + f(x' y) * h) / 6;                  y1 = y;                  result[i' 0] = x;                  result[i' 1] = y1;              }
Magic Number,YAMP.Numerics,GoldenSection,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\GoldenSection.cs,GoldenSection,The following statement contains a magic number: s1 = (3 - Math.Sqrt(5)) / 2;
Magic Number,YAMP.Numerics,GoldenSection,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\GoldenSection.cs,GoldenSection,The following statement contains a magic number: s1 = (3 - Math.Sqrt(5)) / 2;
Magic Number,YAMP.Numerics,GoldenSection,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\GoldenSection.cs,GoldenSection,The following statement contains a magic number: s1 = (3 - Math.Sqrt(5)) / 2;
Magic Number,YAMP.Numerics,GoldenSection,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\GoldenSection.cs,GoldenSection,The following statement contains a magic number: s2 = (Math.Sqrt(5) - 1) / 2;
Magic Number,YAMP.Numerics,GoldenSection,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\GoldenSection.cs,GoldenSection,The following statement contains a magic number: s2 = (Math.Sqrt(5) - 1) / 2;
Magic Number,YAMP.Numerics,Pijavsky,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\Pijavsky.cs,Pijavsky,The following statement contains a magic number: points = new double[n + 2];
Magic Number,YAMP.Numerics,Pijavsky,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\Pijavsky.cs,Pijavsky,The following statement contains a magic number: values = new double[n + 2];
Magic Number,YAMP.Numerics,Pijavsky,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\Pijavsky.cs,Pijavsky,The following statement contains a magic number: ratings = new double[n + 2];
Magic Number,YAMP.Numerics,Pijavsky,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\Pijavsky.cs,Pijavsky,The following statement contains a magic number: for (i = 2; i <= n + 1; i++)              {                  for (j = 1; j <= i - 1; j++)                      ratings[j] = l / 2.0 * (points[j] - points[j - 1]) - 0.5 * (values[j] + values[j - 1]);                    maxrating = ratings[1];                  maxratingpos = 1;                    for (j = 2; j <= i - 1; j++)                  {                      if (ratings[j] > maxrating)                      {                          maxratingpos = j;                          maxrating = ratings[j];                      }                  }                    points[i] = 0.5 * (points[maxratingpos] + points[maxratingpos - 1]) - 0.5 / l * (values[maxratingpos] - values[maxratingpos - 1]);                  values[i] = f(points[i]);                    for (j = i; j >= 2; j--)                  {                      if (points[j] < points[j - 1])                      {                          t = points[j];                          points[j] = points[j - 1];                          points[j - 1] = t;                          t = values[j];                          values[j] = values[j - 1];                          values[j - 1] = t;                      }                      else                          break;                  }              }
Magic Number,YAMP.Numerics,Pijavsky,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\Pijavsky.cs,Pijavsky,The following statement contains a magic number: for (i = 2; i <= n + 1; i++)              {                  for (j = 1; j <= i - 1; j++)                      ratings[j] = l / 2.0 * (points[j] - points[j - 1]) - 0.5 * (values[j] + values[j - 1]);                    maxrating = ratings[1];                  maxratingpos = 1;                    for (j = 2; j <= i - 1; j++)                  {                      if (ratings[j] > maxrating)                      {                          maxratingpos = j;                          maxrating = ratings[j];                      }                  }                    points[i] = 0.5 * (points[maxratingpos] + points[maxratingpos - 1]) - 0.5 / l * (values[maxratingpos] - values[maxratingpos - 1]);                  values[i] = f(points[i]);                    for (j = i; j >= 2; j--)                  {                      if (points[j] < points[j - 1])                      {                          t = points[j];                          points[j] = points[j - 1];                          points[j - 1] = t;                          t = values[j];                          values[j] = values[j - 1];                          values[j - 1] = t;                      }                      else                          break;                  }              }
Magic Number,YAMP.Numerics,Pijavsky,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\Pijavsky.cs,Pijavsky,The following statement contains a magic number: for (i = 2; i <= n + 1; i++)              {                  for (j = 1; j <= i - 1; j++)                      ratings[j] = l / 2.0 * (points[j] - points[j - 1]) - 0.5 * (values[j] + values[j - 1]);                    maxrating = ratings[1];                  maxratingpos = 1;                    for (j = 2; j <= i - 1; j++)                  {                      if (ratings[j] > maxrating)                      {                          maxratingpos = j;                          maxrating = ratings[j];                      }                  }                    points[i] = 0.5 * (points[maxratingpos] + points[maxratingpos - 1]) - 0.5 / l * (values[maxratingpos] - values[maxratingpos - 1]);                  values[i] = f(points[i]);                    for (j = i; j >= 2; j--)                  {                      if (points[j] < points[j - 1])                      {                          t = points[j];                          points[j] = points[j - 1];                          points[j - 1] = t;                          t = values[j];                          values[j] = values[j - 1];                          values[j - 1] = t;                      }                      else                          break;                  }              }
Magic Number,YAMP.Numerics,Pijavsky,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\Pijavsky.cs,Pijavsky,The following statement contains a magic number: for (i = 2; i <= n + 1; i++)              {                  for (j = 1; j <= i - 1; j++)                      ratings[j] = l / 2.0 * (points[j] - points[j - 1]) - 0.5 * (values[j] + values[j - 1]);                    maxrating = ratings[1];                  maxratingpos = 1;                    for (j = 2; j <= i - 1; j++)                  {                      if (ratings[j] > maxrating)                      {                          maxratingpos = j;                          maxrating = ratings[j];                      }                  }                    points[i] = 0.5 * (points[maxratingpos] + points[maxratingpos - 1]) - 0.5 / l * (values[maxratingpos] - values[maxratingpos - 1]);                  values[i] = f(points[i]);                    for (j = i; j >= 2; j--)                  {                      if (points[j] < points[j - 1])                      {                          t = points[j];                          points[j] = points[j - 1];                          points[j - 1] = t;                          t = values[j];                          values[j] = values[j - 1];                          values[j - 1] = t;                      }                      else                          break;                  }              }
Magic Number,YAMP.Numerics,Pijavsky,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\Pijavsky.cs,Pijavsky,The following statement contains a magic number: for (i = 2; i <= n + 1; i++)              {                  for (j = 1; j <= i - 1; j++)                      ratings[j] = l / 2.0 * (points[j] - points[j - 1]) - 0.5 * (values[j] + values[j - 1]);                    maxrating = ratings[1];                  maxratingpos = 1;                    for (j = 2; j <= i - 1; j++)                  {                      if (ratings[j] > maxrating)                      {                          maxratingpos = j;                          maxrating = ratings[j];                      }                  }                    points[i] = 0.5 * (points[maxratingpos] + points[maxratingpos - 1]) - 0.5 / l * (values[maxratingpos] - values[maxratingpos - 1]);                  values[i] = f(points[i]);                    for (j = i; j >= 2; j--)                  {                      if (points[j] < points[j - 1])                      {                          t = points[j];                          points[j] = points[j - 1];                          points[j - 1] = t;                          t = values[j];                          values[j] = values[j - 1];                          values[j - 1] = t;                      }                      else                          break;                  }              }
Magic Number,YAMP.Numerics,Pijavsky,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\Pijavsky.cs,Pijavsky,The following statement contains a magic number: for (i = 2; i <= n + 1; i++)              {                  for (j = 1; j <= i - 1; j++)                      ratings[j] = l / 2.0 * (points[j] - points[j - 1]) - 0.5 * (values[j] + values[j - 1]);                    maxrating = ratings[1];                  maxratingpos = 1;                    for (j = 2; j <= i - 1; j++)                  {                      if (ratings[j] > maxrating)                      {                          maxratingpos = j;                          maxrating = ratings[j];                      }                  }                    points[i] = 0.5 * (points[maxratingpos] + points[maxratingpos - 1]) - 0.5 / l * (values[maxratingpos] - values[maxratingpos - 1]);                  values[i] = f(points[i]);                    for (j = i; j >= 2; j--)                  {                      if (points[j] < points[j - 1])                      {                          t = points[j];                          points[j] = points[j - 1];                          points[j - 1] = t;                          t = values[j];                          values[j] = values[j - 1];                          values[j - 1] = t;                      }                      else                          break;                  }              }
Magic Number,YAMP.Numerics,Pijavsky,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\Pijavsky.cs,Pijavsky,The following statement contains a magic number: for (i = 2; i <= n + 1; i++)              {                  for (j = 1; j <= i - 1; j++)                      ratings[j] = l / 2.0 * (points[j] - points[j - 1]) - 0.5 * (values[j] + values[j - 1]);                    maxrating = ratings[1];                  maxratingpos = 1;                    for (j = 2; j <= i - 1; j++)                  {                      if (ratings[j] > maxrating)                      {                          maxratingpos = j;                          maxrating = ratings[j];                      }                  }                    points[i] = 0.5 * (points[maxratingpos] + points[maxratingpos - 1]) - 0.5 / l * (values[maxratingpos] - values[maxratingpos - 1]);                  values[i] = f(points[i]);                    for (j = i; j >= 2; j--)                  {                      if (points[j] < points[j - 1])                      {                          t = points[j];                          points[j] = points[j - 1];                          points[j - 1] = t;                          t = values[j];                          values[j] = values[j - 1];                          values[j - 1] = t;                      }                      else                          break;                  }              }
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				var y = x * x;  				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));  				var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var y = z * z;  				var xx = ax - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));  				return Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				var y = x * x;  				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));  				var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var y = z * z;  				var xx = ax - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));  				return Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				var y = x * x;  				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));  				var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var y = z * z;  				var xx = ax - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));  				return Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				var y = x * x;  				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));  				var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var y = z * z;  				var xx = ax - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));  				return Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				var y = x * x;  				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));  				var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var y = z * z;  				var xx = ax - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));  				return Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				var y = x * x;  				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));  				var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var y = z * z;  				var xx = ax - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));  				return Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				var y = x * x;  				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));  				var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var y = z * z;  				var xx = ax - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));  				return Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				var y = x * x;  				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));  				var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var y = z * z;  				var xx = ax - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));  				return Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				var y = x * x;  				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));  				var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var y = z * z;  				var xx = ax - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));  				return Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				var y = x * x;  				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));  				var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var y = z * z;  				var xx = ax - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));  				return Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				var y = x * x;  				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));  				var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var y = z * z;  				var xx = ax - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));  				return Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				var y = x * x;  				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));  				var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var y = z * z;  				var xx = ax - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));  				return Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				var y = x * x;  				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));  				var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var y = z * z;  				var xx = ax - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));  				return Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				var y = x * x;  				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));  				var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var y = z * z;  				var xx = ax - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));  				return Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				var y = x * x;  				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));  				var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var y = z * z;  				var xx = ax - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));  				return Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				var y = x * x;  				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));  				var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var y = z * z;  				var xx = ax - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));  				return Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				var y = x * x;  				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));  				var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var y = z * z;  				var xx = ax - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));  				return Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				var y = x * x;  				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));  				var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var y = z * z;  				var xx = ax - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));  				return Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				var y = x * x;  				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));  				var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var y = z * z;  				var xx = ax - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));  				return Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				var y = x * x;  				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));  				var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var y = z * z;  				var xx = ax - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));  				return Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				var y = x * x;  				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));  				var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var y = z * z;  				var xx = ax - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));  				return Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				var y = x * x;  				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));  				var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var y = z * z;  				var xx = ax - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));  				return Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				var y = x * x;  				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));  				var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var y = z * z;  				var xx = ax - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));  				return Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				var y = x * x;  				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));  				var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var y = z * z;  				var xx = ax - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7)));  				return Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				y = x * x;  				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));  				ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var xx = ax - 2.356194491;  				y = z * z;  				ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				var ans = Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);    				if (x < 0.0)  					ans = -ans;    				return ans;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				y = x * x;  				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));  				ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var xx = ax - 2.356194491;  				y = z * z;  				ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				var ans = Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);    				if (x < 0.0)  					ans = -ans;    				return ans;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				y = x * x;  				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));  				ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var xx = ax - 2.356194491;  				y = z * z;  				ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				var ans = Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);    				if (x < 0.0)  					ans = -ans;    				return ans;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				y = x * x;  				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));  				ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var xx = ax - 2.356194491;  				y = z * z;  				ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				var ans = Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);    				if (x < 0.0)  					ans = -ans;    				return ans;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				y = x * x;  				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));  				ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var xx = ax - 2.356194491;  				y = z * z;  				ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				var ans = Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);    				if (x < 0.0)  					ans = -ans;    				return ans;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				y = x * x;  				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));  				ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var xx = ax - 2.356194491;  				y = z * z;  				ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				var ans = Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);    				if (x < 0.0)  					ans = -ans;    				return ans;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				y = x * x;  				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));  				ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var xx = ax - 2.356194491;  				y = z * z;  				ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				var ans = Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);    				if (x < 0.0)  					ans = -ans;    				return ans;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				y = x * x;  				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));  				ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var xx = ax - 2.356194491;  				y = z * z;  				ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				var ans = Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);    				if (x < 0.0)  					ans = -ans;    				return ans;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				y = x * x;  				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));  				ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var xx = ax - 2.356194491;  				y = z * z;  				ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				var ans = Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);    				if (x < 0.0)  					ans = -ans;    				return ans;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				y = x * x;  				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));  				ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var xx = ax - 2.356194491;  				y = z * z;  				ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				var ans = Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);    				if (x < 0.0)  					ans = -ans;    				return ans;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				y = x * x;  				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));  				ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var xx = ax - 2.356194491;  				y = z * z;  				ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				var ans = Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);    				if (x < 0.0)  					ans = -ans;    				return ans;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				y = x * x;  				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));  				ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var xx = ax - 2.356194491;  				y = z * z;  				ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				var ans = Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);    				if (x < 0.0)  					ans = -ans;    				return ans;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				y = x * x;  				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));  				ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var xx = ax - 2.356194491;  				y = z * z;  				ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				var ans = Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);    				if (x < 0.0)  					ans = -ans;    				return ans;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				y = x * x;  				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));  				ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var xx = ax - 2.356194491;  				y = z * z;  				ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				var ans = Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);    				if (x < 0.0)  					ans = -ans;    				return ans;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				y = x * x;  				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));  				ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var xx = ax - 2.356194491;  				y = z * z;  				ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				var ans = Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);    				if (x < 0.0)  					ans = -ans;    				return ans;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				y = x * x;  				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));  				ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var xx = ax - 2.356194491;  				y = z * z;  				ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				var ans = Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);    				if (x < 0.0)  					ans = -ans;    				return ans;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				y = x * x;  				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));  				ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var xx = ax - 2.356194491;  				y = z * z;  				ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				var ans = Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);    				if (x < 0.0)  					ans = -ans;    				return ans;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				y = x * x;  				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));  				ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var xx = ax - 2.356194491;  				y = z * z;  				ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				var ans = Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);    				if (x < 0.0)  					ans = -ans;    				return ans;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				y = x * x;  				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));  				ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var xx = ax - 2.356194491;  				y = z * z;  				ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				var ans = Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);    				if (x < 0.0)  					ans = -ans;    				return ans;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				y = x * x;  				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));  				ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var xx = ax - 2.356194491;  				y = z * z;  				ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				var ans = Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);    				if (x < 0.0)  					ans = -ans;    				return ans;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				y = x * x;  				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));  				ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var xx = ax - 2.356194491;  				y = z * z;  				ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				var ans = Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);    				if (x < 0.0)  					ans = -ans;    				return ans;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				y = x * x;  				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));  				ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var xx = ax - 2.356194491;  				y = z * z;  				ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				var ans = Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);    				if (x < 0.0)  					ans = -ans;    				return ans;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				y = x * x;  				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));  				ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var xx = ax - 2.356194491;  				y = z * z;  				ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				var ans = Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);    				if (x < 0.0)  					ans = -ans;    				return ans;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: if ((ax = Math.Abs(x)) < 8.0)  			{  				y = x * x;  				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));  				ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));  				return ans1 / ans2;  			}  			else  			{  				var z = 8.0 / ax;  				var xx = ax - 2.356194491;  				y = z * z;  				ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				var ans = Math.Sqrt(0.636619772 / ax) * (Math.Cos(xx) * ans1 - z * Math.Sin(xx) * ans2);    				if (x < 0.0)  					ans = -ans;    				return ans;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,jn,The following statement contains a magic number: double ACC = 40.0;
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,jn,The following statement contains a magic number: double BIGNO = 1.0e+10;
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,jn,The following statement contains a magic number: double BIGNI = 1.0e-10;
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,jn,The following statement contains a magic number: if (ax == 0.0)   				return 0.0;  			else if (ax > (double)n)  			{  				tox = 2.0 / ax;  				bjm = j0(ax);  				bj = j1(ax);  				for (j = 1; j < n; j++)  				{  					bjp = j * tox * bj - bjm;  					bjm = bj;  					bj = bjp;  				}  				ans = bj;  			}  			else  			{  				tox = 2.0 / ax;  				m = 2 * ((n + (int)Math.Sqrt(ACC * n)) / 2);  				jsum = false;  				bjp = ans = sum = 0.0;  				bj = 1.0;    				for (j = m; j > 0; j--)  				{  					bjm = j * tox * bj - bjp;  					bjp = bj;  					bj = bjm;    					if (Math.Abs(bj) > BIGNO)  					{  						bj *= BIGNI;  						bjp *= BIGNI;  						ans *= BIGNI;  						sum *= BIGNI;  					}    					if (jsum)   						sum += bj;    					jsum = !jsum;    					if (j == n)   						ans = bjp;  				}    				sum = 2.0 * sum - bj;  				ans /= sum;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,jn,The following statement contains a magic number: if (ax == 0.0)   				return 0.0;  			else if (ax > (double)n)  			{  				tox = 2.0 / ax;  				bjm = j0(ax);  				bj = j1(ax);  				for (j = 1; j < n; j++)  				{  					bjp = j * tox * bj - bjm;  					bjm = bj;  					bj = bjp;  				}  				ans = bj;  			}  			else  			{  				tox = 2.0 / ax;  				m = 2 * ((n + (int)Math.Sqrt(ACC * n)) / 2);  				jsum = false;  				bjp = ans = sum = 0.0;  				bj = 1.0;    				for (j = m; j > 0; j--)  				{  					bjm = j * tox * bj - bjp;  					bjp = bj;  					bj = bjm;    					if (Math.Abs(bj) > BIGNO)  					{  						bj *= BIGNI;  						bjp *= BIGNI;  						ans *= BIGNI;  						sum *= BIGNI;  					}    					if (jsum)   						sum += bj;    					jsum = !jsum;    					if (j == n)   						ans = bjp;  				}    				sum = 2.0 * sum - bj;  				ans /= sum;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,jn,The following statement contains a magic number: if (ax == 0.0)   				return 0.0;  			else if (ax > (double)n)  			{  				tox = 2.0 / ax;  				bjm = j0(ax);  				bj = j1(ax);  				for (j = 1; j < n; j++)  				{  					bjp = j * tox * bj - bjm;  					bjm = bj;  					bj = bjp;  				}  				ans = bj;  			}  			else  			{  				tox = 2.0 / ax;  				m = 2 * ((n + (int)Math.Sqrt(ACC * n)) / 2);  				jsum = false;  				bjp = ans = sum = 0.0;  				bj = 1.0;    				for (j = m; j > 0; j--)  				{  					bjm = j * tox * bj - bjp;  					bjp = bj;  					bj = bjm;    					if (Math.Abs(bj) > BIGNO)  					{  						bj *= BIGNI;  						bjp *= BIGNI;  						ans *= BIGNI;  						sum *= BIGNI;  					}    					if (jsum)   						sum += bj;    					jsum = !jsum;    					if (j == n)   						ans = bjp;  				}    				sum = 2.0 * sum - bj;  				ans /= sum;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,jn,The following statement contains a magic number: if (ax == 0.0)   				return 0.0;  			else if (ax > (double)n)  			{  				tox = 2.0 / ax;  				bjm = j0(ax);  				bj = j1(ax);  				for (j = 1; j < n; j++)  				{  					bjp = j * tox * bj - bjm;  					bjm = bj;  					bj = bjp;  				}  				ans = bj;  			}  			else  			{  				tox = 2.0 / ax;  				m = 2 * ((n + (int)Math.Sqrt(ACC * n)) / 2);  				jsum = false;  				bjp = ans = sum = 0.0;  				bj = 1.0;    				for (j = m; j > 0; j--)  				{  					bjm = j * tox * bj - bjp;  					bjp = bj;  					bj = bjm;    					if (Math.Abs(bj) > BIGNO)  					{  						bj *= BIGNI;  						bjp *= BIGNI;  						ans *= BIGNI;  						sum *= BIGNI;  					}    					if (jsum)   						sum += bj;    					jsum = !jsum;    					if (j == n)   						ans = bjp;  				}    				sum = 2.0 * sum - bj;  				ans /= sum;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,jn,The following statement contains a magic number: if (ax == 0.0)   				return 0.0;  			else if (ax > (double)n)  			{  				tox = 2.0 / ax;  				bjm = j0(ax);  				bj = j1(ax);  				for (j = 1; j < n; j++)  				{  					bjp = j * tox * bj - bjm;  					bjm = bj;  					bj = bjp;  				}  				ans = bj;  			}  			else  			{  				tox = 2.0 / ax;  				m = 2 * ((n + (int)Math.Sqrt(ACC * n)) / 2);  				jsum = false;  				bjp = ans = sum = 0.0;  				bj = 1.0;    				for (j = m; j > 0; j--)  				{  					bjm = j * tox * bj - bjp;  					bjp = bj;  					bj = bjm;    					if (Math.Abs(bj) > BIGNO)  					{  						bj *= BIGNI;  						bjp *= BIGNI;  						ans *= BIGNI;  						sum *= BIGNI;  					}    					if (jsum)   						sum += bj;    					jsum = !jsum;    					if (j == n)   						ans = bjp;  				}    				sum = 2.0 * sum - bj;  				ans /= sum;  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,jn,The following statement contains a magic number: return x < 0.0 && n % 2 == 1 ? -ans : ans;
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));  				var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));  				return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 0.785398164;  				var ans1 = 1.0 + y * (-0.1098628627e-2 + y * (0.2734510407e-4 + y * (-0.2073370639e-5 + y * 0.2093887211e-6)));  				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7))));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: if (x < 8.0)  			{  				var y = x * x;  				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));  				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));  				return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);  			}  			else  			{  				var z = 8.0 / x;  				var y = z * z;  				var xx = x - 2.356194491;  				var ans1 = 1.0 + y * (0.183105e-2 + y * (-0.3516396496e-4 + y * (0.2457520174e-5 + y * (-0.240337019e-6))));  				var ans2 = 0.04687499995 + y * (-0.2002690873e-3 + y * (0.8449199096e-5 + y * (-0.88228987e-6 + y * 0.105787412e-6)));  				return Math.Sqrt(0.636619772 / x) * (Math.Sin(xx) * ans1 + z * Math.Cos(xx) * ans2);  			}
Magic Number,YAMP.Numerics,Bessel,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,yn,The following statement contains a magic number: tox = 2.0 / x;
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,tql2,The following statement contains a magic number: var eps = Math.Pow(2.0' -52.0);
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,tql2,The following statement contains a magic number: var eps = Math.Pow(2.0' -52.0);
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,tql2,The following statement contains a magic number: for (int l = 0; l < n; l++)              {                  // Find small subdiagonal element                    tst1 = Math.Max(tst1' Math.Abs(d[l]) + Math.Abs(e[l]));                  var m = l;                    while (m < n)                  {                      if (System.Math.Abs(e[m]) <= eps * tst1)                          break;                        m++;                  }                    // If m == l' d[l] is an eigenvalue'                  // otherwise' iterate.                    if (m > l)                  {                      var iter = 0;                        do                      {                          iter = iter + 1; // (Could check iteration count here.)                            // Compute implicit shift                            var g = d[l];                          var p = (d[l + 1] - g) / (2.0 * e[l]);                          var r = Helpers.Hypot(p' 1.0);                            if (p < 0)                              r = -r;                                                    d[l] = e[l] / (p + r);                          d[l + 1] = e[l] * (p + r);                          var dl1 = d[l + 1];                          var h = g - d[l];                            for (int i = l + 2; i < n; i++)                              d[i] -= h;                                                    f = f + h;                            // Implicit QL transformation.                            p = d[m];                          var c = 1.0;                          var c2 = c;                          var c3 = c;                          var el1 = e[l + 1];                          var s = 0.0;                          var s2 = 0.0;                            for (int i = m - 1; i >= l; i--)                          {                              c3 = c2;                              c2 = c;                              s2 = s;                              g = c * e[i];                              h = c * p;                              r = Helpers.Hypot(p' e[i]);                              e[i + 1] = s * r;                              s = e[i] / r;                              c = p / r;                              p = c * d[i] - s * g;                              d[i + 1] = h + s * (c * g + s * d[i]);                                // Accumulate transformation.                                for (int k = 0; k < n; k++)                              {                                  h = V[k][i + 1];                                  V[k][i + 1] = s * V[k][i] + c * h;                                  V[k][i] = c * V[k][i] - s * h;                              }                          }                            p = (-s) * s2 * c3 * el1 * e[l] / dl1;                          e[l] = s * p;                          d[l] = c * p;                            // Check for convergence.                      }                      while (Math.Abs(e[l]) > eps * tst1);                  }                    d[l] = d[l] + f;                  e[l] = 0.0;              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,tql2,The following statement contains a magic number: for (int l = 0; l < n; l++)              {                  // Find small subdiagonal element                    tst1 = Math.Max(tst1' Math.Abs(d[l]) + Math.Abs(e[l]));                  var m = l;                    while (m < n)                  {                      if (System.Math.Abs(e[m]) <= eps * tst1)                          break;                        m++;                  }                    // If m == l' d[l] is an eigenvalue'                  // otherwise' iterate.                    if (m > l)                  {                      var iter = 0;                        do                      {                          iter = iter + 1; // (Could check iteration count here.)                            // Compute implicit shift                            var g = d[l];                          var p = (d[l + 1] - g) / (2.0 * e[l]);                          var r = Helpers.Hypot(p' 1.0);                            if (p < 0)                              r = -r;                                                    d[l] = e[l] / (p + r);                          d[l + 1] = e[l] * (p + r);                          var dl1 = d[l + 1];                          var h = g - d[l];                            for (int i = l + 2; i < n; i++)                              d[i] -= h;                                                    f = f + h;                            // Implicit QL transformation.                            p = d[m];                          var c = 1.0;                          var c2 = c;                          var c3 = c;                          var el1 = e[l + 1];                          var s = 0.0;                          var s2 = 0.0;                            for (int i = m - 1; i >= l; i--)                          {                              c3 = c2;                              c2 = c;                              s2 = s;                              g = c * e[i];                              h = c * p;                              r = Helpers.Hypot(p' e[i]);                              e[i + 1] = s * r;                              s = e[i] / r;                              c = p / r;                              p = c * d[i] - s * g;                              d[i + 1] = h + s * (c * g + s * d[i]);                                // Accumulate transformation.                                for (int k = 0; k < n; k++)                              {                                  h = V[k][i + 1];                                  V[k][i + 1] = s * V[k][i] + c * h;                                  V[k][i] = c * V[k][i] - s * h;                              }                          }                            p = (-s) * s2 * c3 * el1 * e[l] / dl1;                          e[l] = s * p;                          d[l] = c * p;                            // Check for convergence.                      }                      while (Math.Abs(e[l]) > eps * tst1);                  }                    d[l] = d[l] + f;                  e[l] = 0.0;              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: var eps = Math.Pow(2.0' -52.0);
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: var eps = Math.Pow(2.0' -52.0);
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: while (n >= low)              {                  // Look for single small sub-diagonal element                    int l = n;                    while (l > low)                  {                      s = Math.Abs(H[l - 1][l - 1]) + Math.Abs(H[l][l]);                        if (s == 0.0)                          s = norm;                        if (Math.Abs(H[l][l - 1]) < eps * s)                          break;                        l--;                  }                    // Check for convergence                  // One root found                    if (l == n)                  {                      H[n][n] = H[n][n] + exshift;                      d[n] = H[n][n];                      e[n] = 0.0;                      n--;                      iter = 0;                        // Two roots found                  }                  else if (l == n - 1)                  {                      w = H[n][n - 1] * H[n - 1][n];                      p = (H[n - 1][n - 1] - H[n][n]) / 2.0;                      q = p * p + w;                      z = Math.Sqrt(Math.Abs(q));                      H[n][n] = H[n][n] + exshift;                      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;                      x = H[n][n];                        // Real pair                        if (q >= 0)                      {                          if (p >= 0)                              z = p + z;                          else                              z = p - z;                            d[n - 1] = x + z;                          d[n] = d[n - 1];                            if (z != 0.0)                              d[n] = x - w / z;                                                    e[n - 1] = 0.0;                          e[n] = 0.0;                          x = H[n][n - 1];                          s = Math.Abs(x) + Math.Abs(z);                          p = x / s;                          q = z / s;                          r = Math.Sqrt(p * p + q * q);                          p = p / r;                          q = q / r;                            // Row modification                            for (int j = n - 1; j < nn; j++)                          {                              z = H[n - 1][j];                              H[n - 1][j] = q * z + p * H[n][j];                              H[n][j] = q * H[n][j] - p * z;                          }                            // Column modification                            for (int i = 0; i <= n; i++)                          {                              z = H[i][n - 1];                              H[i][n - 1] = q * z + p * H[i][n];                              H[i][n] = q * H[i][n] - p * z;                          }                            // Accumulate transformations                            for (int i = low; i <= high; i++)                          {                              z = V[i][n - 1];                              V[i][n - 1] = q * z + p * V[i][n];                              V[i][n] = q * V[i][n] - p * z;                          }                            // Complex pair                      }                      else                      {                          d[n - 1] = x + p;                          d[n] = x + p;                          e[n - 1] = z;                          e[n] = -z;                      }                        n = n - 2;                      iter = 0;                        // No convergence yet                  }                  else                  {                      // Form shift                        x = H[n][n];                      y = 0.0;                      w = 0.0;                        if (l < n)                      {                          y = H[n - 1][n - 1];                          w = H[n][n - 1] * H[n - 1][n];                      }                        // Wilkinson's original ad hoc shift                        if (iter == 10)                      {                          exshift += x;                            for (int i = low; i <= n; i++)                              H[i][i] -= x;                                                    s = Math.Abs(H[n][n - 1]) + Math.Abs(H[n - 1][n - 2]);                          x = y = 0.75 * s;                          w = (-0.4375) * s * s;                      }                        // MATLAB's new ad hoc shift                        if (iter == 30)                      {                          s = (y - x) / 2.0;                          s = s * s + w;                            if (s > 0)                          {                              s = Math.Sqrt(s);                                if (y < x)                                  s = -s;                                s = x - w / ((y - x) / 2.0 + s);                                for (int i = low; i <= n; i++)                                  H[i][i] -= s;                                                            exshift += s;                              x = y = w = 0.964;                          }                      }                        iter = iter + 1; // (Could check iteration count here.)                        // Look for two consecutive small sub-diagonal elements                        int m = n - 2;                        while (m >= l)                      {                          z = H[m][m];                          r = x - z;                          s = y - z;                          p = (r * s - w) / H[m + 1][m] + H[m][m + 1];                          q = H[m + 1][m + 1] - z - r - s;                          r = H[m + 2][m + 1];                          s = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                          p = p / s;                          q = q / s;                          r = r / s;                            if (m == l)                              break;                                                    if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1]))))                              break;                                                    m--;                      }                        for (int i = m + 2; i <= n; i++)                      {                          H[i][i - 2] = 0.0;                            if (i > m + 2)                              H[i][i - 3] = 0.0;                      }                        // Double QR step involving rows l:n and columns m:n                        for (int k = m; k <= n - 1; k++)                      {                          bool notlast = (k != n - 1);                            if (k != m)                          {                              p = H[k][k - 1];                              q = H[k + 1][k - 1];                              r = (notlast ? H[k + 2][k - 1] : 0.0);                              x = Math.Abs(p) + Math.Abs(q) + Math.Abs(r);                                if (x != 0.0)                              {                                  p = p / x;                                  q = q / x;                                  r = r / x;                              }                          }                            if (x == 0.0)                              break;                            s = Math.Sqrt(p * p + q * q + r * r);                            if (p < 0)                              s = -s;                                                    if (s != 0)                          {                              if (k != m)                                  H[k][k - 1] = (-s) * x;                              else if (l != m)                                  H[k][k - 1] = -H[k][k - 1];                                p = p + s;                              x = p / s;                              y = q / s;                              z = r / s;                              q = q / p;                              r = r / p;                                // Row modification                                for (int j = k; j < nn; j++)                              {                                  p = H[k][j] + q * H[k + 1][j];                                    if (notlast)                                  {                                      p = p + r * H[k + 2][j];                                      H[k + 2][j] = H[k + 2][j] - p * z;                                  }                                    H[k][j] = H[k][j] - p * x;                                  H[k + 1][j] = H[k + 1][j] - p * y;                              }                                // Column modification                                for (int i = 0; i <= Math.Min(n' k + 3); i++)                              {                                  p = x * H[i][k] + y * H[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * H[i][k + 2];                                      H[i][k + 2] = H[i][k + 2] - p * r;                                  }                                    H[i][k] = H[i][k] - p;                                  H[i][k + 1] = H[i][k + 1] - p * q;                              }                                // Accumulate transformations                                for (int i = low; i <= high; i++)                              {                                  p = x * V[i][k] + y * V[i][k + 1];                                    if (notlast)                                  {                                      p = p + z * V[i][k + 2];                                      V[i][k + 2] = V[i][k + 2] - p * r;                                  }                                    V[i][k] = V[i][k] - p;                                  V[i][k + 1] = V[i][k + 1] - p * q;                              }                          } // (s != 0)                      } // k loop                  } // check convergence              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: for (n = nn - 1; n >= 0; n--)              {                  p = d[n];                  q = e[n];                    // Real vector                    if (q == 0)                  {                      int l = n;                      H[n][n] = 1.0;                        for (int i = n - 1; i >= 0; i--)                      {                          w = H[i][i] - p;                          r = 0.0;                            for (int j = l; j <= n; j++)                              r = r + H[i][j] * H[j][n];                            if (e[i] < 0.0)                          {                              z = w;                              s = r;                          }                          else                          {                              l = i;                                if (e[i] == 0.0)                              {                                  if (w != 0.0)                                      H[i][n] = (-r) / w;                                  else                                      H[i][n] = (-r) / (eps * norm);                                    // Solve real equations                              }                              else                              {                                  x = H[i][i + 1];                                  y = H[i + 1][i];                                  q = (d[i] - p) * (d[i] - p) + e[i] * e[i];                                  t = (x * s - z * r) / q;                                  H[i][n] = t;                                    if (Math.Abs(x) > Math.Abs(z))                                      H[i + 1][n] = (-r - w * t) / x;                                  else                                      H[i + 1][n] = (-s - y * t) / z;                              }                                // Overflow control                                t = Math.Abs(H[i][n]);                                if ((eps * t) * t > 1)                              {                                  for (int j = i; j <= n; j++)                                      H[j][n] = H[j][n] / t;                              }                          }                      }                        // Complex vector                  }                  else if (q < 0)                  {                      int l = n - 1;                        // Last vector component imaginary so matrix is triangular                        if (Math.Abs(H[n][n - 1]) > Math.Abs(H[n - 1][n]))                      {                          H[n - 1][n - 1] = q / H[n][n - 1];                          H[n - 1][n] = (-(H[n][n] - p)) / H[n][n - 1];                      }                      else                      {                          cdiv(0.0' -H[n - 1][n]' H[n - 1][n - 1] - p' q);                          H[n - 1][n - 1] = cdivr;                          H[n - 1][n] = cdivi;                      }                        H[n][n - 1] = 0.0;                      H[n][n] = 1.0;                        for (int i = n - 2; i >= 0; i--)                      {                          double ra' sa' vr' vi;                          ra = 0.0;                          sa = 0.0;                            for (int j = l; j <= n; j++)                          {                              ra = ra + H[i][j] * H[j][n - 1];                              sa = sa + H[i][j] * H[j][n];                          }                            w = H[i][i] - p;                            if (e[i] < 0.0)                          {                              z = w;                              r = ra;                              s = sa;                          }                          else                          {                              l = i;                                if (e[i] == 0)                              {                                  cdiv(-ra' -sa' w' q);                                  H[i][n - 1] = cdivr;                                  H[i][n] = cdivi;                              }                              else                              {                                    // Solve complex equations                                    x = H[i][i + 1];                                  y = H[i + 1][i];                                  vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;                                  vi = (d[i] - p) * 2.0 * q;                                    if (vr == 0.0 & vi == 0.0)                                      vr = eps * norm * (Math.Abs(w) + Math.Abs(q) + Math.Abs(x) + Math.Abs(y) + Math.Abs(z));                                    cdiv(x * r - z * ra + q * sa' x * s - z * sa - q * ra' vr' vi);                                  H[i][n - 1] = cdivr;                                  H[i][n] = cdivi;                                    if (Math.Abs(x) > (Math.Abs(z) + Math.Abs(q)))                                  {                                      H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;                                      H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;                                  }                                  else                                  {                                      cdiv(-r - y * H[i][n - 1]' -s - y * H[i][n]' z' q);                                      H[i + 1][n - 1] = cdivr;                                      H[i + 1][n] = cdivi;                                  }                              }                                // Overflow control                                t = Math.Max(Math.Abs(H[i][n - 1])' Math.Abs(H[i][n]));                                if ((eps * t) * t > 1)                              {                                  for (int j = i; j <= n; j++)                                  {                                      H[j][n - 1] = H[j][n - 1] / t;                                      H[j][n] = H[j][n] / t;                                  }                              }                          }                      }                  }              }
Magic Number,YAMP.Numerics,Eigenvalues,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: for (n = nn - 1; n >= 0; n--)              {                  p = d[n];                  q = e[n];                    // Real vector                    if (q == 0)                  {                      int l = n;                      H[n][n] = 1.0;                        for (int i = n - 1; i >= 0; i--)                      {                          w = H[i][i] - p;                          r = 0.0;                            for (int j = l; j <= n; j++)                              r = r + H[i][j] * H[j][n];                            if (e[i] < 0.0)                          {                              z = w;                              s = r;                          }                          else                          {                              l = i;                                if (e[i] == 0.0)                              {                                  if (w != 0.0)                                      H[i][n] = (-r) / w;                                  else                                      H[i][n] = (-r) / (eps * norm);                                    // Solve real equations                              }                              else                              {                                  x = H[i][i + 1];                                  y = H[i + 1][i];                                  q = (d[i] - p) * (d[i] - p) + e[i] * e[i];                                  t = (x * s - z * r) / q;                                  H[i][n] = t;                                    if (Math.Abs(x) > Math.Abs(z))                                      H[i + 1][n] = (-r - w * t) / x;                                  else                                      H[i + 1][n] = (-s - y * t) / z;                              }                                // Overflow control                                t = Math.Abs(H[i][n]);                                if ((eps * t) * t > 1)                              {                                  for (int j = i; j <= n; j++)                                      H[j][n] = H[j][n] / t;                              }                          }                      }                        // Complex vector                  }                  else if (q < 0)                  {                      int l = n - 1;                        // Last vector component imaginary so matrix is triangular                        if (Math.Abs(H[n][n - 1]) > Math.Abs(H[n - 1][n]))                      {                          H[n - 1][n - 1] = q / H[n][n - 1];                          H[n - 1][n] = (-(H[n][n] - p)) / H[n][n - 1];                      }                      else                      {                          cdiv(0.0' -H[n - 1][n]' H[n - 1][n - 1] - p' q);                          H[n - 1][n - 1] = cdivr;                          H[n - 1][n] = cdivi;                      }                        H[n][n - 1] = 0.0;                      H[n][n] = 1.0;                        for (int i = n - 2; i >= 0; i--)                      {                          double ra' sa' vr' vi;                          ra = 0.0;                          sa = 0.0;                            for (int j = l; j <= n; j++)                          {                              ra = ra + H[i][j] * H[j][n - 1];                              sa = sa + H[i][j] * H[j][n];                          }                            w = H[i][i] - p;                            if (e[i] < 0.0)                          {                              z = w;                              r = ra;                              s = sa;                          }                          else                          {                              l = i;                                if (e[i] == 0)                              {                                  cdiv(-ra' -sa' w' q);                                  H[i][n - 1] = cdivr;                                  H[i][n] = cdivi;                              }                              else                              {                                    // Solve complex equations                                    x = H[i][i + 1];                                  y = H[i + 1][i];                                  vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;                                  vi = (d[i] - p) * 2.0 * q;                                    if (vr == 0.0 & vi == 0.0)                                      vr = eps * norm * (Math.Abs(w) + Math.Abs(q) + Math.Abs(x) + Math.Abs(y) + Math.Abs(z));                                    cdiv(x * r - z * ra + q * sa' x * s - z * sa - q * ra' vr' vi);                                  H[i][n - 1] = cdivr;                                  H[i][n] = cdivi;                                    if (Math.Abs(x) > (Math.Abs(z) + Math.Abs(q)))                                  {                                      H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;                                      H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;                                  }                                  else                                  {                                      cdiv(-r - y * H[i][n - 1]' -s - y * H[i][n]' z' q);                                      H[i + 1][n - 1] = cdivr;                                      H[i + 1][n] = cdivi;                                  }                              }                                // Overflow control                                t = Math.Max(Math.Abs(H[i][n - 1])' Math.Abs(H[i][n]));                                if ((eps * t) * t > 1)                              {                                  for (int j = i; j <= n; j++)                                  {                                      H[j][n - 1] = H[j][n - 1] / t;                                      H[j][n] = H[j][n] / t;                                  }                              }                          }                      }                  }              }
Magic Number,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: int nrt = Math.Max(0' Math.Min(n - 2' m));
Magic Number,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: var eps = Math.Pow(2.0' -52.0);
Magic Number,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: var eps = Math.Pow(2.0' -52.0);
Magic Number,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                                            if (Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                      kase = 4;                  else                  {                      int ks;                        for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                                                    var t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                            if (Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                                            if (Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                      kase = 4;                  else                  {                      int ks;                        for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                                                    var t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                            if (Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                                            if (Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                      kase = 4;                  else                  {                      int ks;                        for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                                                    var t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                            if (Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                                            if (Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                      kase = 4;                  else                  {                      int ks;                        for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                                                    var t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                            if (Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                                            if (Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                      kase = 4;                  else                  {                      int ks;                        for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                                                    var t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                            if (Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                                            if (Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                      kase = 4;                  else                  {                      int ks;                        for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                                                    var t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                            if (Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                                            if (Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                      kase = 4;                  else                  {                      int ks;                        for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                                                    var t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                            if (Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                                            if (Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                      kase = 4;                  else                  {                      int ks;                        for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                                                    var t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                            if (Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                                            if (Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                      kase = 4;                  else                  {                      int ks;                        for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                                                    var t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                            if (Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                                            if (Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                      kase = 4;                  else                  {                      int ks;                        for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                                                    var t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                            if (Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                                            if (Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                      kase = 4;                  else                  {                      int ks;                        for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                                                    var t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                            if (Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                                            if (Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                      kase = 4;                  else                  {                      int ks;                        for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                                                    var t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                            if (Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                                            if (Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                      kase = 4;                  else                  {                      int ks;                        for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                                                    var t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                            if (Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                                            if (Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                      kase = 4;                  else                  {                      int ks;                        for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                                                    var t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                            if (Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                                            if (Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                      kase = 4;                  else                  {                      int ks;                        for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                                                    var t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                            if (Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                                            if (Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                      kase = 4;                  else                  {                      int ks;                        for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                                                    var t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                            if (Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0)              {                  int k' kase;                    // Here is where a test for too many iterations would go.                    // This section of the program inspects for                  // negligible elements in the s and e arrays.  On                  // completion the variables kase and k are set as follows.                    // kase = 1     if s(p) and e[k-1] are negligible and k<p                  // kase = 2     if s(k) is negligible and k<p                  // kase = 3     if e[k-1] is negligible' k<p' and                  //              s(k)' ...' s(p) are not negligible (qr step).                  // kase = 4     if e(p-1) is negligible (convergence).                    for (k = p - 2; k >= -1; k--)                  {                      if (k == -1)                          break;                                            if (Math.Abs(e[k]) <= eps * (Math.Abs(s[k]) + Math.Abs(s[k + 1])))                      {                          e[k] = 0.0;                          break;                      }                  }                    if (k == p - 2)                      kase = 4;                  else                  {                      int ks;                        for (ks = p - 1; ks >= k; ks--)                      {                          if (ks == k)                              break;                                                    var t = (ks != p ? Math.Abs(e[ks]) : 0.0) + (ks != k + 1 ? Math.Abs(e[ks - 1]) : 0.0);                            if (Math.Abs(s[ks]) <= eps * t)                          {                              s[ks] = 0.0;                              break;                          }                      }                        if (ks == k)                          kase = 3;                      else if (ks == p - 1)                          kase = 1;                      else                      {                          kase = 2;                          k = ks;                      }                  }                    k++;                    // Perform the task indicated by kase.                  switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }              }
Magic Number,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,Rank,The following statement contains a magic number: var eps = Math.Pow(2.0' -52.0);
Magic Number,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,Rank,The following statement contains a magic number: var eps = Math.Pow(2.0' -52.0);
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)              {                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              }              else if (n % 2 != 0)              {                  var m = n - 1;                  var d = m;                  var s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                  {                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                  }                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)              {                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              }              else if (n % 2 != 0)              {                  var m = n - 1;                  var d = m;                  var s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                  {                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                  }                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)              {                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              }              else if (n % 2 != 0)              {                  var m = n - 1;                  var d = m;                  var s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                  {                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                  }                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)              {                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              }              else if (n % 2 != 0)              {                  var m = n - 1;                  var d = m;                  var s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                  {                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                  }                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)              {                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              }              else if (n % 2 != 0)              {                  var m = n - 1;                  var d = m;                  var s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                  {                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                  }                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)              {                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              }              else if (n % 2 != 0)              {                  var m = n - 1;                  var d = m;                  var s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                  {                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                  }                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)              {                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              }              else if (n % 2 != 0)              {                  var m = n - 1;                  var d = m;                  var s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                  {                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                  }                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)              {                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              }              else if (n % 2 != 0)              {                  var m = n - 1;                  var d = m;                  var s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                  {                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                  }                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)              {                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              }              else if (n % 2 != 0)              {                  var m = n - 1;                  var d = m;                  var s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                  {                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                  }                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)              {                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              }              else if (n % 2 != 0)              {                  var m = n - 1;                  var d = m;                  var s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                  {                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                  }                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)              {                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              }              else if (n % 2 != 0)              {                  var m = n - 1;                  var d = m;                  var s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                  {                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                  }                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)              {                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              }              else if (n % 2 != 0)              {                  var m = n - 1;                  var d = m;                  var s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                  {                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                  }                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)              {                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              }              else if (n % 2 != 0)              {                  var m = n - 1;                  var d = m;                  var s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                  {                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                  }                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,IsPrimeNumber,The following statement contains a magic number: if (n < 8)              {                  return ((n == 2) || (n == 3) || (n == 5) || (n == 7));              }              else if (n % 2 != 0)              {                  var m = n - 1;                  var d = m;                  var s = 0;                    while (d % 2 == 0)                  {                      s++;                      d = d / 2;                  }                    if (n < 1373653)                  {                      return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 3));                  }                    return (IsProbablyPrime(n' m' s' d' 2) && IsProbablyPrime(n' m' s' d' 7) && IsProbablyPrime(n' m' s' d' 61));              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,IsProbablyPrime,The following statement contains a magic number: for (var i = 0; i < s; i++)              {                  x = PowMod(x' 2' n);                    if (x != 1 && x == m)                  {                      return true;                  }              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,GCD,The following statement contains a magic number: while (true)              {                  if (A == B)                  {                      return f * A;                  }                    if (A == 1 || B == 1)                  {                      return f;                  }                    if ((A % 2 == 0) && (B % 2 == 0))                  {                      f = 2 * f;                      A = A / 2;                      B = B / 2;                  }                  else if ((A % 2 == 0) && (B % 2 != 0))                  {                      A = A / 2;                  }                  else if ((A % 2 != 0) && (B % 2 == 0))                  {                      B = B / 2;                  }                  else if (A > B)                  {                      A = (A - B) / 2;                  }                  else                  {                      B = (B - A) / 2;                  }              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,GCD,The following statement contains a magic number: while (true)              {                  if (A == B)                  {                      return f * A;                  }                    if (A == 1 || B == 1)                  {                      return f;                  }                    if ((A % 2 == 0) && (B % 2 == 0))                  {                      f = 2 * f;                      A = A / 2;                      B = B / 2;                  }                  else if ((A % 2 == 0) && (B % 2 != 0))                  {                      A = A / 2;                  }                  else if ((A % 2 != 0) && (B % 2 == 0))                  {                      B = B / 2;                  }                  else if (A > B)                  {                      A = (A - B) / 2;                  }                  else                  {                      B = (B - A) / 2;                  }              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,GCD,The following statement contains a magic number: while (true)              {                  if (A == B)                  {                      return f * A;                  }                    if (A == 1 || B == 1)                  {                      return f;                  }                    if ((A % 2 == 0) && (B % 2 == 0))                  {                      f = 2 * f;                      A = A / 2;                      B = B / 2;                  }                  else if ((A % 2 == 0) && (B % 2 != 0))                  {                      A = A / 2;                  }                  else if ((A % 2 != 0) && (B % 2 == 0))                  {                      B = B / 2;                  }                  else if (A > B)                  {                      A = (A - B) / 2;                  }                  else                  {                      B = (B - A) / 2;                  }              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,GCD,The following statement contains a magic number: while (true)              {                  if (A == B)                  {                      return f * A;                  }                    if (A == 1 || B == 1)                  {                      return f;                  }                    if ((A % 2 == 0) && (B % 2 == 0))                  {                      f = 2 * f;                      A = A / 2;                      B = B / 2;                  }                  else if ((A % 2 == 0) && (B % 2 != 0))                  {                      A = A / 2;                  }                  else if ((A % 2 != 0) && (B % 2 == 0))                  {                      B = B / 2;                  }                  else if (A > B)                  {                      A = (A - B) / 2;                  }                  else                  {                      B = (B - A) / 2;                  }              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,GCD,The following statement contains a magic number: while (true)              {                  if (A == B)                  {                      return f * A;                  }                    if (A == 1 || B == 1)                  {                      return f;                  }                    if ((A % 2 == 0) && (B % 2 == 0))                  {                      f = 2 * f;                      A = A / 2;                      B = B / 2;                  }                  else if ((A % 2 == 0) && (B % 2 != 0))                  {                      A = A / 2;                  }                  else if ((A % 2 != 0) && (B % 2 == 0))                  {                      B = B / 2;                  }                  else if (A > B)                  {                      A = (A - B) / 2;                  }                  else                  {                      B = (B - A) / 2;                  }              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,GCD,The following statement contains a magic number: while (true)              {                  if (A == B)                  {                      return f * A;                  }                    if (A == 1 || B == 1)                  {                      return f;                  }                    if ((A % 2 == 0) && (B % 2 == 0))                  {                      f = 2 * f;                      A = A / 2;                      B = B / 2;                  }                  else if ((A % 2 == 0) && (B % 2 != 0))                  {                      A = A / 2;                  }                  else if ((A % 2 != 0) && (B % 2 == 0))                  {                      B = B / 2;                  }                  else if (A > B)                  {                      A = (A - B) / 2;                  }                  else                  {                      B = (B - A) / 2;                  }              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,GCD,The following statement contains a magic number: while (true)              {                  if (A == B)                  {                      return f * A;                  }                    if (A == 1 || B == 1)                  {                      return f;                  }                    if ((A % 2 == 0) && (B % 2 == 0))                  {                      f = 2 * f;                      A = A / 2;                      B = B / 2;                  }                  else if ((A % 2 == 0) && (B % 2 != 0))                  {                      A = A / 2;                  }                  else if ((A % 2 != 0) && (B % 2 == 0))                  {                      B = B / 2;                  }                  else if (A > B)                  {                      A = (A - B) / 2;                  }                  else                  {                      B = (B - A) / 2;                  }              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,GCD,The following statement contains a magic number: while (true)              {                  if (A == B)                  {                      return f * A;                  }                    if (A == 1 || B == 1)                  {                      return f;                  }                    if ((A % 2 == 0) && (B % 2 == 0))                  {                      f = 2 * f;                      A = A / 2;                      B = B / 2;                  }                  else if ((A % 2 == 0) && (B % 2 != 0))                  {                      A = A / 2;                  }                  else if ((A % 2 != 0) && (B % 2 == 0))                  {                      B = B / 2;                  }                  else if (A > B)                  {                      A = (A - B) / 2;                  }                  else                  {                      B = (B - A) / 2;                  }              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,GCD,The following statement contains a magic number: while (true)              {                  if (A == B)                  {                      return f * A;                  }                    if (A == 1 || B == 1)                  {                      return f;                  }                    if ((A % 2 == 0) && (B % 2 == 0))                  {                      f = 2 * f;                      A = A / 2;                      B = B / 2;                  }                  else if ((A % 2 == 0) && (B % 2 != 0))                  {                      A = A / 2;                  }                  else if ((A % 2 != 0) && (B % 2 == 0))                  {                      B = B / 2;                  }                  else if (A > B)                  {                      A = (A - B) / 2;                  }                  else                  {                      B = (B - A) / 2;                  }              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,GCD,The following statement contains a magic number: while (true)              {                  if (A == B)                  {                      return f * A;                  }                    if (A == 1 || B == 1)                  {                      return f;                  }                    if ((A % 2 == 0) && (B % 2 == 0))                  {                      f = 2 * f;                      A = A / 2;                      B = B / 2;                  }                  else if ((A % 2 == 0) && (B % 2 != 0))                  {                      A = A / 2;                  }                  else if ((A % 2 != 0) && (B % 2 == 0))                  {                      B = B / 2;                  }                  else if (A > B)                  {                      A = (A - B) / 2;                  }                  else                  {                      B = (B - A) / 2;                  }              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,GCD,The following statement contains a magic number: while (true)              {                  if (A == B)                  {                      return f * A;                  }                    if (A == 1 || B == 1)                  {                      return f;                  }                    if ((A % 2 == 0) && (B % 2 == 0))                  {                      f = 2 * f;                      A = A / 2;                      B = B / 2;                  }                  else if ((A % 2 == 0) && (B % 2 != 0))                  {                      A = A / 2;                  }                  else if ((A % 2 != 0) && (B % 2 == 0))                  {                      B = B / 2;                  }                  else if (A > B)                  {                      A = (A - B) / 2;                  }                  else                  {                      B = (B - A) / 2;                  }              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,GCD,The following statement contains a magic number: while (true)              {                  if (A == B)                  {                      return f * A;                  }                    if (A == 1 || B == 1)                  {                      return f;                  }                    if ((A % 2 == 0) && (B % 2 == 0))                  {                      f = 2 * f;                      A = A / 2;                      B = B / 2;                  }                  else if ((A % 2 == 0) && (B % 2 != 0))                  {                      A = A / 2;                  }                  else if ((A % 2 != 0) && (B % 2 == 0))                  {                      B = B / 2;                  }                  else if (A > B)                  {                      A = (A - B) / 2;                  }                  else                  {                      B = (B - A) / 2;                  }              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,GCD,The following statement contains a magic number: while (true)              {                  if (A == B)                  {                      return f * A;                  }                    if (A == 1 || B == 1)                  {                      return f;                  }                    if ((A % 2 == 0) && (B % 2 == 0))                  {                      f = 2 * f;                      A = A / 2;                      B = B / 2;                  }                  else if ((A % 2 == 0) && (B % 2 != 0))                  {                      A = A / 2;                  }                  else if ((A % 2 != 0) && (B % 2 == 0))                  {                      B = B / 2;                  }                  else if (A > B)                  {                      A = (A - B) / 2;                  }                  else                  {                      B = (B - A) / 2;                  }              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,Factorial,The following statement contains a magic number: if (n < 34)              {                  var res = 1.0;                    while (n > 1)                  {                      res *= n--;                  }                    return res;              }              else if (n < 171)              {                  return FACT_34_TO_170[n - 34];              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,Factorial,The following statement contains a magic number: if (n < 34)              {                  var res = 1.0;                    while (n > 1)                  {                      res *= n--;                  }                    return res;              }              else if (n < 171)              {                  return FACT_34_TO_170[n - 34];              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,Factorial,The following statement contains a magic number: if (n < 34)              {                  var res = 1.0;                    while (n > 1)                  {                      res *= n--;                  }                    return res;              }              else if (n < 171)              {                  return FACT_34_TO_170[n - 34];              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: if (Math.Abs(x) < 0.6)              {                  var u0 = 0.0;                  var u1 = 0.0;                  var u2 = 0.0;                  var xx = x + x;                    for (var i = n; i >= 0; i--)                  {                      u2 = u1;                      u1 = u0;                      u0 = xx * u1 + coefficients[i] - u2;                  }                    return (u0 - u2) / 2.0;              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: if (Math.Abs(x) < 0.6)              {                  var u0 = 0.0;                  var u1 = 0.0;                  var u2 = 0.0;                  var xx = x + x;                    for (var i = n; i >= 0; i--)                  {                      u2 = u1;                      u1 = u0;                      u0 = xx * u1 + coefficients[i] - u2;                  }                    return (u0 - u2) / 2.0;              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: if (x > 0.0)              {                  var u1 = 0.0;                  var d1 = 0.0;                  var d2 = 0.0;                  var xx = (x - 0.5) - 0.5;                  xx = xx + xx;                    for (var i = n; i >= 0; i--)                  {                      d2 = d1;                      var u2 = u1;                      d1 = xx * u2 + coefficients[i] + d2;                      u1 = d1 + u2;                  }                    return (d1 + d2) / 2.0;              }              else              {                  // T < =  -0.6 code                  var u1 = 0.0;                  var d1 = 0.0;                  var d2 = 0.0;                  var xx = (x + 0.5) + 0.5;                  xx = xx + xx;                    for (var i = n; i >= 0; i--)                  {                      d2 = d1;                      var u2 = u1;                      d1 = xx * u2 + coefficients[i] - d2;                      u1 = d1 - u2;                  }                    return (d1 - d2) / 2.0;              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: if (x > 0.0)              {                  var u1 = 0.0;                  var d1 = 0.0;                  var d2 = 0.0;                  var xx = (x - 0.5) - 0.5;                  xx = xx + xx;                    for (var i = n; i >= 0; i--)                  {                      d2 = d1;                      var u2 = u1;                      d1 = xx * u2 + coefficients[i] + d2;                      u1 = d1 + u2;                  }                    return (d1 + d2) / 2.0;              }              else              {                  // T < =  -0.6 code                  var u1 = 0.0;                  var d1 = 0.0;                  var d2 = 0.0;                  var xx = (x + 0.5) + 0.5;                  xx = xx + xx;                    for (var i = n; i >= 0; i--)                  {                      d2 = d1;                      var u2 = u1;                      d1 = xx * u2 + coefficients[i] - d2;                      u1 = d1 - u2;                  }                    return (d1 - d2) / 2.0;              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: if (x > 0.0)              {                  var u1 = 0.0;                  var d1 = 0.0;                  var d2 = 0.0;                  var xx = (x - 0.5) - 0.5;                  xx = xx + xx;                    for (var i = n; i >= 0; i--)                  {                      d2 = d1;                      var u2 = u1;                      d1 = xx * u2 + coefficients[i] + d2;                      u1 = d1 + u2;                  }                    return (d1 + d2) / 2.0;              }              else              {                  // T < =  -0.6 code                  var u1 = 0.0;                  var d1 = 0.0;                  var d2 = 0.0;                  var xx = (x + 0.5) + 0.5;                  xx = xx + xx;                    for (var i = n; i >= 0; i--)                  {                      d2 = d1;                      var u2 = u1;                      d1 = xx * u2 + coefficients[i] - d2;                      u1 = d1 - u2;                  }                    return (d1 - d2) / 2.0;              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: if (x > 0.0)              {                  var u1 = 0.0;                  var d1 = 0.0;                  var d2 = 0.0;                  var xx = (x - 0.5) - 0.5;                  xx = xx + xx;                    for (var i = n; i >= 0; i--)                  {                      d2 = d1;                      var u2 = u1;                      d1 = xx * u2 + coefficients[i] + d2;                      u1 = d1 + u2;                  }                    return (d1 + d2) / 2.0;              }              else              {                  // T < =  -0.6 code                  var u1 = 0.0;                  var d1 = 0.0;                  var d2 = 0.0;                  var xx = (x + 0.5) + 0.5;                  xx = xx + xx;                    for (var i = n; i >= 0; i--)                  {                      d2 = d1;                      var u2 = u1;                      d1 = xx * u2 + coefficients[i] - d2;                      u1 = d1 - u2;                  }                    return (d1 - d2) / 2.0;              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: if (x > 0.0)              {                  var u1 = 0.0;                  var d1 = 0.0;                  var d2 = 0.0;                  var xx = (x - 0.5) - 0.5;                  xx = xx + xx;                    for (var i = n; i >= 0; i--)                  {                      d2 = d1;                      var u2 = u1;                      d1 = xx * u2 + coefficients[i] + d2;                      u1 = d1 + u2;                  }                    return (d1 + d2) / 2.0;              }              else              {                  // T < =  -0.6 code                  var u1 = 0.0;                  var d1 = 0.0;                  var d2 = 0.0;                  var xx = (x + 0.5) + 0.5;                  xx = xx + xx;                    for (var i = n; i >= 0; i--)                  {                      d2 = d1;                      var u2 = u1;                      d1 = xx * u2 + coefficients[i] - d2;                      u1 = d1 - u2;                  }                    return (d1 - d2) / 2.0;              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: if (x > 0.0)              {                  var u1 = 0.0;                  var d1 = 0.0;                  var d2 = 0.0;                  var xx = (x - 0.5) - 0.5;                  xx = xx + xx;                    for (var i = n; i >= 0; i--)                  {                      d2 = d1;                      var u2 = u1;                      d1 = xx * u2 + coefficients[i] + d2;                      u1 = d1 + u2;                  }                    return (d1 + d2) / 2.0;              }              else              {                  // T < =  -0.6 code                  var u1 = 0.0;                  var d1 = 0.0;                  var d2 = 0.0;                  var xx = (x + 0.5) + 0.5;                  xx = xx + xx;                    for (var i = n; i >= 0; i--)                  {                      d2 = d1;                      var u2 = u1;                      d1 = xx * u2 + coefficients[i] - d2;                      u1 = d1 - u2;                  }                    return (d1 - d2) / 2.0;              }
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: var y = (2.0 * x - cs.LowerPoint - cs.UpperPoint) / (cs.UpperPoint - cs.LowerPoint);
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: var y2 = 2.0 * y;
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: return y * d - dd + 0.5 * cs.Coefficients[0];
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: var y = (2.0 * z - cs.LowerPoint - cs.UpperPoint) / (cs.UpperPoint - cs.LowerPoint);
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: var y2 = 2.0 * y;
Magic Number,YAMP.Numerics,Helpers,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: return y * d - dd + 0.5 * cs.Coefficients[0];
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: double[] T = {  				9.60497373987051638749E0'  				9.00260197203842689217E1'  				2.23200534594684319226E3'  				7.00332514112805075473E3'  				5.55923013010394962768E4  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: double[] T = {  				9.60497373987051638749E0'  				9.00260197203842689217E1'  				2.23200534594684319226E3'  				7.00332514112805075473E3'  				5.55923013010394962768E4  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: double[] T = {  				9.60497373987051638749E0'  				9.00260197203842689217E1'  				2.23200534594684319226E3'  				7.00332514112805075473E3'  				5.55923013010394962768E4  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: double[] T = {  				9.60497373987051638749E0'  				9.00260197203842689217E1'  				2.23200534594684319226E3'  				7.00332514112805075473E3'  				5.55923013010394962768E4  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: double[] T = {  				9.60497373987051638749E0'  				9.00260197203842689217E1'  				2.23200534594684319226E3'  				7.00332514112805075473E3'  				5.55923013010394962768E4  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: double[] U = {  				3.35617141647503099647E1'  				5.21357949780152679795E2'  				4.59432382970980127987E3'  				2.26290000613890934246E4'  				4.92673942608635921086E4  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: double[] U = {  				3.35617141647503099647E1'  				5.21357949780152679795E2'  				4.59432382970980127987E3'  				2.26290000613890934246E4'  				4.92673942608635921086E4  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: double[] U = {  				3.35617141647503099647E1'  				5.21357949780152679795E2'  				4.59432382970980127987E3'  				2.26290000613890934246E4'  				4.92673942608635921086E4  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: double[] U = {  				3.35617141647503099647E1'  				5.21357949780152679795E2'  				4.59432382970980127987E3'  				2.26290000613890934246E4'  				4.92673942608635921086E4  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: double[] U = {  				3.35617141647503099647E1'  				5.21357949780152679795E2'  				4.59432382970980127987E3'  				2.26290000613890934246E4'  				4.92673942608635921086E4  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: y = x * polevl(z' T' 4) / p1evl(z' U' 5);
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: y = x * polevl(z' T' 4) / p1evl(z' U' 5);
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] P = {  				2.46196981473530512524E-10'  				5.64189564831068821977E-1'  				7.46321056442269912687E0'  				4.86371970985681366614E1'  				1.96520832956077098242E2'  				5.26445194995477358631E2'  				9.34528527171957607540E2'  				1.02755188689515710272E3'  				5.57535335369399327526E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] P = {  				2.46196981473530512524E-10'  				5.64189564831068821977E-1'  				7.46321056442269912687E0'  				4.86371970985681366614E1'  				1.96520832956077098242E2'  				5.26445194995477358631E2'  				9.34528527171957607540E2'  				1.02755188689515710272E3'  				5.57535335369399327526E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] P = {  				2.46196981473530512524E-10'  				5.64189564831068821977E-1'  				7.46321056442269912687E0'  				4.86371970985681366614E1'  				1.96520832956077098242E2'  				5.26445194995477358631E2'  				9.34528527171957607540E2'  				1.02755188689515710272E3'  				5.57535335369399327526E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] P = {  				2.46196981473530512524E-10'  				5.64189564831068821977E-1'  				7.46321056442269912687E0'  				4.86371970985681366614E1'  				1.96520832956077098242E2'  				5.26445194995477358631E2'  				9.34528527171957607540E2'  				1.02755188689515710272E3'  				5.57535335369399327526E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] P = {  				2.46196981473530512524E-10'  				5.64189564831068821977E-1'  				7.46321056442269912687E0'  				4.86371970985681366614E1'  				1.96520832956077098242E2'  				5.26445194995477358631E2'  				9.34528527171957607540E2'  				1.02755188689515710272E3'  				5.57535335369399327526E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] P = {  				2.46196981473530512524E-10'  				5.64189564831068821977E-1'  				7.46321056442269912687E0'  				4.86371970985681366614E1'  				1.96520832956077098242E2'  				5.26445194995477358631E2'  				9.34528527171957607540E2'  				1.02755188689515710272E3'  				5.57535335369399327526E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] P = {  				2.46196981473530512524E-10'  				5.64189564831068821977E-1'  				7.46321056442269912687E0'  				4.86371970985681366614E1'  				1.96520832956077098242E2'  				5.26445194995477358631E2'  				9.34528527171957607540E2'  				1.02755188689515710272E3'  				5.57535335369399327526E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] P = {  				2.46196981473530512524E-10'  				5.64189564831068821977E-1'  				7.46321056442269912687E0'  				4.86371970985681366614E1'  				1.96520832956077098242E2'  				5.26445194995477358631E2'  				9.34528527171957607540E2'  				1.02755188689515710272E3'  				5.57535335369399327526E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] P = {  				2.46196981473530512524E-10'  				5.64189564831068821977E-1'  				7.46321056442269912687E0'  				4.86371970985681366614E1'  				1.96520832956077098242E2'  				5.26445194995477358631E2'  				9.34528527171957607540E2'  				1.02755188689515710272E3'  				5.57535335369399327526E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] Q = {  				1.32281951154744992508E1'  				8.67072140885989742329E1'  				3.54937778887819891062E2'  				9.75708501743205489753E2'  				1.82390916687909736289E3'  				2.24633760818710981792E3'  				1.65666309194161350182E3'  				5.57535340817727675546E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] Q = {  				1.32281951154744992508E1'  				8.67072140885989742329E1'  				3.54937778887819891062E2'  				9.75708501743205489753E2'  				1.82390916687909736289E3'  				2.24633760818710981792E3'  				1.65666309194161350182E3'  				5.57535340817727675546E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] Q = {  				1.32281951154744992508E1'  				8.67072140885989742329E1'  				3.54937778887819891062E2'  				9.75708501743205489753E2'  				1.82390916687909736289E3'  				2.24633760818710981792E3'  				1.65666309194161350182E3'  				5.57535340817727675546E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] Q = {  				1.32281951154744992508E1'  				8.67072140885989742329E1'  				3.54937778887819891062E2'  				9.75708501743205489753E2'  				1.82390916687909736289E3'  				2.24633760818710981792E3'  				1.65666309194161350182E3'  				5.57535340817727675546E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] Q = {  				1.32281951154744992508E1'  				8.67072140885989742329E1'  				3.54937778887819891062E2'  				9.75708501743205489753E2'  				1.82390916687909736289E3'  				2.24633760818710981792E3'  				1.65666309194161350182E3'  				5.57535340817727675546E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] Q = {  				1.32281951154744992508E1'  				8.67072140885989742329E1'  				3.54937778887819891062E2'  				9.75708501743205489753E2'  				1.82390916687909736289E3'  				2.24633760818710981792E3'  				1.65666309194161350182E3'  				5.57535340817727675546E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] Q = {  				1.32281951154744992508E1'  				8.67072140885989742329E1'  				3.54937778887819891062E2'  				9.75708501743205489753E2'  				1.82390916687909736289E3'  				2.24633760818710981792E3'  				1.65666309194161350182E3'  				5.57535340817727675546E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] Q = {  				1.32281951154744992508E1'  				8.67072140885989742329E1'  				3.54937778887819891062E2'  				9.75708501743205489753E2'  				1.82390916687909736289E3'  				2.24633760818710981792E3'  				1.65666309194161350182E3'  				5.57535340817727675546E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] R = {  				5.64189583547755073984E-1'  				1.27536670759978104416E0'  				5.01905042251180477414E0'  				6.16021097993053585195E0'  				7.40974269950448939160E0'  				2.97886665372100240670E0  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] R = {  				5.64189583547755073984E-1'  				1.27536670759978104416E0'  				5.01905042251180477414E0'  				6.16021097993053585195E0'  				7.40974269950448939160E0'  				2.97886665372100240670E0  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] R = {  				5.64189583547755073984E-1'  				1.27536670759978104416E0'  				5.01905042251180477414E0'  				6.16021097993053585195E0'  				7.40974269950448939160E0'  				2.97886665372100240670E0  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] R = {  				5.64189583547755073984E-1'  				1.27536670759978104416E0'  				5.01905042251180477414E0'  				6.16021097993053585195E0'  				7.40974269950448939160E0'  				2.97886665372100240670E0  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] R = {  				5.64189583547755073984E-1'  				1.27536670759978104416E0'  				5.01905042251180477414E0'  				6.16021097993053585195E0'  				7.40974269950448939160E0'  				2.97886665372100240670E0  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] R = {  				5.64189583547755073984E-1'  				1.27536670759978104416E0'  				5.01905042251180477414E0'  				6.16021097993053585195E0'  				7.40974269950448939160E0'  				2.97886665372100240670E0  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] S = {  				2.26052863220117276590E0'  				9.39603524938001434673E0'  				1.20489539808096656605E1'  				1.70814450747565897222E1'  				9.60896809063285878198E0'  				3.36907645100081516050E0  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] S = {  				2.26052863220117276590E0'  				9.39603524938001434673E0'  				1.20489539808096656605E1'  				1.70814450747565897222E1'  				9.60896809063285878198E0'  				3.36907645100081516050E0  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] S = {  				2.26052863220117276590E0'  				9.39603524938001434673E0'  				1.20489539808096656605E1'  				1.70814450747565897222E1'  				9.60896809063285878198E0'  				3.36907645100081516050E0  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] S = {  				2.26052863220117276590E0'  				9.39603524938001434673E0'  				1.20489539808096656605E1'  				1.70814450747565897222E1'  				9.60896809063285878198E0'  				3.36907645100081516050E0  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] S = {  				2.26052863220117276590E0'  				9.39603524938001434673E0'  				1.20489539808096656605E1'  				1.70814450747565897222E1'  				9.60896809063285878198E0'  				3.36907645100081516050E0  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] S = {  				2.26052863220117276590E0'  				9.39603524938001434673E0'  				1.20489539808096656605E1'  				1.70814450747565897222E1'  				9.60896809063285878198E0'  				3.36907645100081516050E0  			};
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: if (z < MAXLOG)  			{  				if (a < 0)  					return (2.0);  				  				return (0.0);  			}
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: if (x < 8.0)  			{  				p = polevl(x' P' 8);  				q = p1evl(x' Q' 8);  			}  			else  			{  				p = polevl(x' R' 5);  				q = p1evl(x' S' 6);  			}
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: if (x < 8.0)  			{  				p = polevl(x' P' 8);  				q = p1evl(x' Q' 8);  			}  			else  			{  				p = polevl(x' R' 5);  				q = p1evl(x' S' 6);  			}
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: if (x < 8.0)  			{  				p = polevl(x' P' 8);  				q = p1evl(x' Q' 8);  			}  			else  			{  				p = polevl(x' R' 5);  				q = p1evl(x' S' 6);  			}
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: if (x < 8.0)  			{  				p = polevl(x' P' 8);  				q = p1evl(x' Q' 8);  			}  			else  			{  				p = polevl(x' R' 5);  				q = p1evl(x' S' 6);  			}
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: if (x < 8.0)  			{  				p = polevl(x' P' 8);  				q = p1evl(x' Q' 8);  			}  			else  			{  				p = polevl(x' R' 5);  				q = p1evl(x' S' 6);  			}
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: if (a < 0)   				y = 2.0 - y;
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: if (y == 0.0)  			{  				if (a < 0)   					return 2.0;  				  				return (0.0);  			}
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: if (z.Abs() < 4.0)                  return Erf_Series(z);              else if (z.Re < 0.0)                  return (-z * z).Exp() * Faddeeva(-ScalarValue.I * z) - 1.0;
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Faddeeva,The following statement contains a magic number: if (z.Im < 0.0)                   return 2.0 * (-z * z).Exp() - Faddeeva(-z);
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Faddeeva,The following statement contains a magic number: if (r < 2.0)                  return (-z * z).Exp() * (1.0 - Erf_Series(-ScalarValue.I * z));              else if ((z.Im < 0.1) && (z.Re < 30.0))                  return Taylor(new ScalarValue(z.Re)' Math.Exp(-z.Re * z.Re) + 2.0 * Dawson.DawsonIntegral(z.Re) / Helpers.SqrtPI * ScalarValue.I' new ScalarValue(0.0' z.Im));              else if (r > 7.0)                  return ContinuedFraction(z);
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Faddeeva,The following statement contains a magic number: if (r < 2.0)                  return (-z * z).Exp() * (1.0 - Erf_Series(-ScalarValue.I * z));              else if ((z.Im < 0.1) && (z.Re < 30.0))                  return Taylor(new ScalarValue(z.Re)' Math.Exp(-z.Re * z.Re) + 2.0 * Dawson.DawsonIntegral(z.Re) / Helpers.SqrtPI * ScalarValue.I' new ScalarValue(0.0' z.Im));              else if (r > 7.0)                  return ContinuedFraction(z);
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Faddeeva,The following statement contains a magic number: if (r < 2.0)                  return (-z * z).Exp() * (1.0 - Erf_Series(-ScalarValue.I * z));              else if ((z.Im < 0.1) && (z.Re < 30.0))                  return Taylor(new ScalarValue(z.Re)' Math.Exp(-z.Re * z.Re) + 2.0 * Dawson.DawsonIntegral(z.Re) / Helpers.SqrtPI * ScalarValue.I' new ScalarValue(0.0' z.Im));              else if (r > 7.0)                  return ContinuedFraction(z);
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Faddeeva,The following statement contains a magic number: if (r < 2.0)                  return (-z * z).Exp() * (1.0 - Erf_Series(-ScalarValue.I * z));              else if ((z.Im < 0.1) && (z.Re < 30.0))                  return Taylor(new ScalarValue(z.Re)' Math.Exp(-z.Re * z.Re) + 2.0 * Dawson.DawsonIntegral(z.Re) / Helpers.SqrtPI * ScalarValue.I' new ScalarValue(0.0' z.Im));              else if (r > 7.0)                  return ContinuedFraction(z);
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Faddeeva,The following statement contains a magic number: if (r < 2.0)                  return (-z * z).Exp() * (1.0 - Erf_Series(-ScalarValue.I * z));              else if ((z.Im < 0.1) && (z.Re < 30.0))                  return Taylor(new ScalarValue(z.Re)' Math.Exp(-z.Re * z.Re) + 2.0 * Dawson.DawsonIntegral(z.Re) / Helpers.SqrtPI * ScalarValue.I' new ScalarValue(0.0' z.Im));              else if (r > 7.0)                  return ContinuedFraction(z);
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf_Series,The following statement contains a magic number: var zp = 2.0 / Helpers.SqrtPI * z;
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf_Series,The following statement contains a magic number: for (var k = 1; k < 250; k++)              {                  var f_old = f;                  zp *= zz / k;                  f += zp / (2 * k + 1);                    if (f == f_old)                  {                      return f;                  }              }
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf_Series,The following statement contains a magic number: for (var k = 1; k < 250; k++)              {                  var f_old = f;                  zp *= zz / k;                  f += zp / (2 * k + 1);                    if (f == f_old)                  {                      return f;                  }              }
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Weideman,The following statement contains a magic number: var f = new ScalarValue(WeidemanCoefficients[40]);
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Weideman,The following statement contains a magic number: for (var k = 39; k > 0; k--)              {                  f = f * ZQ + WeidemanCoefficients[k];              }
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Weideman,The following statement contains a magic number: return 2.0 / ZP * f * ZQ + 1.0 / Helpers.SqrtPI / ZD;
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,ContinuedFraction,The following statement contains a magic number: for (var k = 1; k < 250; k++)              {                  var f_old = f;                  a = -k / 2.0;                  D = 1.0 / (b + a * D);                  Df = (b * D - 1.0) * Df;                  f += Df;                    if (f == f_old)                  {                      return ScalarValue.I / Helpers.SqrtPI * f;                  }              }
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,ContinuedFraction,The following statement contains a magic number: for (var k = 1; k < 250; k++)              {                  var f_old = f;                  a = -k / 2.0;                  D = 1.0 / (b + a * D);                  Df = (b * D - 1.0) * Df;                  f += Df;                    if (f == f_old)                  {                      return ScalarValue.I / Helpers.SqrtPI * f;                  }              }
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Taylor,The following statement contains a magic number: var wp = 2.0 * (ScalarValue.I / Helpers.SqrtPI - z0 * w0);
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Taylor,The following statement contains a magic number: for (var k = 2; k < 250; k++)              {                  // remmeber the current value                  var w_old = w;                    // compute the next derivative                  var wp_new = -2.0 * (z0 * wp + (k - 1) * wp_old);                    wp_old = wp;                  wp = wp_new;                    // use it to generate the next term in the Taylor expansion                  zz = zz * dz / k;                  w = w_old + wp * zz;                    // test whether we have converged                  if (w == w_old)                  {                      return w;                  }              }
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Taylor,The following statement contains a magic number: for (var k = 2; k < 250; k++)              {                  // remmeber the current value                  var w_old = w;                    // compute the next derivative                  var wp_new = -2.0 * (z0 * wp + (k - 1) * wp_old);                    wp_old = wp;                  wp = wp_new;                    // use it to generate the next term in the Taylor expansion                  zz = zz * dz / k;                  w = w_old + wp * zz;                    // test whether we have converged                  if (w == w_old)                  {                      return w;                  }              }
Magic Number,YAMP.Numerics,ErrorFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Taylor,The following statement contains a magic number: for (var k = 2; k < 250; k++)              {                  // remmeber the current value                  var w_old = w;                    // compute the next derivative                  var wp_new = -2.0 * (z0 * wp + (k - 1) * wp_old);                    wp_old = wp;                  wp = wp_new;                    // use it to generate the next term in the Taylor expansion                  zz = zz * dz / k;                  w = w_old + wp * zz;                    // test whether we have converged                  if (w == w_old)                  {                      return w;                  }              }
Magic Number,YAMP.Numerics,FFT,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\FFT.cs,fft,The following statement contains a magic number: if (length % 2 != 0)                   throw new YAMPDifferentLengthsException(length' "2^n");
Magic Number,YAMP.Numerics,FFT,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\FFT.cs,fft,The following statement contains a magic number: var even = new MatrixValue(length / 2' 1);
Magic Number,YAMP.Numerics,FFT,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\FFT.cs,fft,The following statement contains a magic number: for (var k = 1; k <= even.Length; k++)              {                  even[k] = x[2 * k];              }
Magic Number,YAMP.Numerics,FFT,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\FFT.cs,fft,The following statement contains a magic number: for (var k = 1; k <= odd.Length; k++)              {                  odd[k] = x[2 * k - 1];              }
Magic Number,YAMP.Numerics,FFT,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\FFT.cs,fft,The following statement contains a magic number: for (var k = 1; k <= odd.Length; k++)              {                  var value = -2 * (k - 1) * Math.PI / length;                  var wk = new ScalarValue(Math.Cos(value)' Math.Sin(value));                  y[k] = q[k] + (wk * r[k]);                  y[k + odd.Length] = q[k] - (wk * r[k]);              }
Magic Number,YAMP.Numerics,FFT,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\FFT.cs,ifft,The following statement contains a magic number: if (length % 2 != 0)                  throw new YAMPDifferentLengthsException(length' "2^n");
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LinearGamma,The following statement contains a magic number: if (z.Re < 0.5)  				return Math.PI / LinearGamma(1.0 - z) / (Math.PI * z).Sin();
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma,The following statement contains a magic number: if (x <= 0.0)                  return double.PositiveInfinity;              else if (x > 16.0)                  return LogGamma_Stirling(x);
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma,The following statement contains a magic number: if (z.Abs() > 15.0)  				return LogGamma_Stirling(z);
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,Psi,The following statement contains a magic number: if (x <= 0.0)              {                  if (x == Math.Ceiling(x))                      return Double.NaN;                    return Psi(1.0 - x) - Math.PI / Math.Tan(Math.PI * x);              }              else if (x > 16.0)                  return Psi_Stirling(x);
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: var f = (x - 0.5) * Math.Log(x) - x + Math.Log(2.0 * Math.PI) / 2.0;
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: var f = (x - 0.5) * Math.Log(x) - x + Math.Log(2.0 * Math.PI) / 2.0;
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: var f = (x - 0.5) * Math.Log(x) - x + Math.Log(2.0 * Math.PI) / 2.0;
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: for (int i = 1; i < 10; i++)  			{  				var f_old = f;                  f += Helpers.BernoulliNumbers[i] / (2 * i) / (2 * i - 1) / xp;    				if (f == f_old)  					return (f);    				xp *= xsqu;  			}
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: for (int i = 1; i < 10; i++)  			{  				var f_old = f;                  f += Helpers.BernoulliNumbers[i] / (2 * i) / (2 * i - 1) / xp;    				if (f == f_old)  					return (f);    				xp *= xsqu;  			}
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: for (int i = 1; i < 10; i++)  			{  				var f_old = f;                  f += Helpers.BernoulliNumbers[i] / (2 * i) / (2 * i - 1) / xp;    				if (f == f_old)  					return (f);    				xp *= xsqu;  			}
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: var f = (z - 0.5) * z.Ln() - z + Math.Log(2.0 * Math.PI) / 2.0;
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: var f = (z - 0.5) * z.Ln() - z + Math.Log(2.0 * Math.PI) / 2.0;
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: var f = (z - 0.5) * z.Ln() - z + Math.Log(2.0 * Math.PI) / 2.0;
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: var reduce = f.Im / (2.0 * Math.PI);
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: reduce = f.Im - (int)(reduce) * 2.0 * Math.PI;
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: for (var i = 1; i < 10; i++)  			{  				var f_old = f.Clone();                  f += Helpers.BernoulliNumbers[i] / (2 * i) / (2 * i - 1) / zp;                    if (f == f_old)                  {                      return (f);                  }    				zp = zp * zsqu;  			}
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: for (var i = 1; i < 10; i++)  			{  				var f_old = f.Clone();                  f += Helpers.BernoulliNumbers[i] / (2 * i) / (2 * i - 1) / zp;                    if (f == f_old)                  {                      return (f);                  }    				zp = zp * zsqu;  			}
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: for (var i = 1; i < 10; i++)  			{  				var f_old = f.Clone();                  f += Helpers.BernoulliNumbers[i] / (2 * i) / (2 * i - 1) / zp;                    if (f == f_old)                  {                      return (f);                  }    				zp = zp * zsqu;  			}
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LanczosLogGamma,The following statement contains a magic number: sum = 2.0 / Math.Sqrt(Math.PI) * sum / x;
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LanczosLogGamma,The following statement contains a magic number: var xshift = x + 0.5;
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LanczosLogGamma,The following statement contains a magic number: sum = (2.0 / Math.Sqrt(Math.PI)) * (sum / z);
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LanczosLogGamma,The following statement contains a magic number: var zshift = z + 0.5;
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LanczosPsi,The following statement contains a magic number: var xx = x + Helpers.LanczosR + 0.5;
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,Psi_Stirling,The following statement contains a magic number: var f = Math.Log(x) - 1.0 / (2.0 * x);
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,Psi_Stirling,The following statement contains a magic number: for (int i = 1; i < 10; i++)  			{  				var f_old = f;                  f -= Helpers.BernoulliNumbers[i] / (2 * i) / xp;    				if (f == f_old)  					return (f);    				xp *= xsqu;  			}
Magic Number,YAMP.Numerics,Gamma,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,Psi_Stirling,The following statement contains a magic number: for (int i = 1; i < 10; i++)  			{  				var f_old = f;                  f -= Helpers.BernoulliNumbers[i] / (2 * i) / xp;    				if (f == f_old)  					return (f);    				xp *= xsqu;  			}
Magic Number,YAMP.Numerics,Mandelbrot,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Mandelbrot.cs,Run,The following statement contains a magic number: while ((iter < maxiter) && (rpow < 4))              {                  r1pow2 = r1 * r1;                  i1pow2 = i1 * i1;                  i1 = 2.0 * i1 * r1 + y;                  r1 = r1pow2 - i1pow2 + x;                  rlastpow = rpow;                  rpow = r1pow2 + i1pow2;                  iter++;              }
Magic Number,YAMP.Numerics,Mandelbrot,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Mandelbrot.cs,Run,The following statement contains a magic number: while ((iter < maxiter) && (rpow < 4))              {                  r1pow2 = r1 * r1;                  i1pow2 = i1 * i1;                  i1 = 2.0 * i1 * r1 + y;                  r1 = r1pow2 - i1pow2 + x;                  rlastpow = rpow;                  rpow = r1pow2 + i1pow2;                  iter++;              }
Magic Number,YAMP.Numerics,BinomialDistribution,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\BinomialDistribution.cs,BinomialDistribution,The following statement contains a magic number: this.alpha = 0.5;
Magic Number,YAMP.Numerics,BinomialDistribution,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\BinomialDistribution.cs,BinomialDistribution,The following statement contains a magic number: this.alpha = 0.5;
Magic Number,YAMP.Numerics,LaplaceDistribution,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\LaplaceDistribution.cs,NextDouble,The following statement contains a magic number: double rand = 0.5 - this.Generator.NextDouble();
Magic Number,YAMP.Numerics,LaplaceDistribution,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\LaplaceDistribution.cs,NextDouble,The following statement contains a magic number: return this.mu - this.alpha * Math.Sign(rand) * Math.Log(2.0 * Math.Abs(rand));
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,ResetGenerator,The following statement contains a magic number: for (this.mti = 1; this.mti < MT19937Generator.N; this.mti++)              {                  this.mt[mti] = (1812433253U * (this.mt[this.mti - 1] ^ (this.mt[this.mti - 1] >> 30)) + this.mti);                  // See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier.                  // In the previous versions' MSBs of the seed affect only MSBs of the array mt[].                  // 2002/01/09 modified by Makoto Matsumoto              }
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,ResetGenerator,The following statement contains a magic number: this.bitCount = 32;
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,ResetBySeedArray,The following statement contains a magic number: for (; k > 0; k--)              {                  mt[i] = (mt[i] ^ ((mt[i - 1] ^ (mt[i - 1] >> 30)) * 1664525U)) + this.seedArray[j] + j; // non linear                  i++;                  j++;                  if (i >= MT19937Generator.N)                  {                      mt[0] = mt[MT19937Generator.N - 1];                      i = 1;                  }                  if (j >= this.seedArray.Length)                  {                      j = 0;                  }              }
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,ResetBySeedArray,The following statement contains a magic number: for (k = MT19937Generator.N - 1; k > 0; k--)              {                  mt[i] = (mt[i] ^ ((mt[i - 1] ^ (mt[i - 1] >> 30)) * 1566083941U)) - i; // non linear                  i++;                  if (i >= MT19937Generator.N)                  {                      mt[0] = mt[MT19937Generator.N - 1];                      i = 1;                  }              }
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,GenerateNUInts,The following statement contains a magic number: uint[] mag01 = new uint[2] { 0x0U' MT19937Generator.VectorA };
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextUInt,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextUInt,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextUInt,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextUInt,The following statement contains a magic number: return (y ^ (y >> 18));
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextInclusiveMaxValue,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextInclusiveMaxValue,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextInclusiveMaxValue,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextInclusiveMaxValue,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextDouble,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextDouble,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextDouble,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextDouble,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextDouble,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextDouble,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextDouble,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextDouble,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextDouble,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextDouble,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextDouble,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextDouble,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBoolean,The following statement contains a magic number: if (this.bitCount == 32)              {                  // Generate 32 more bits (1 uint) and store it for future calls.                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if (this.mti >= MT19937Generator.N)                  {// generate N words at one time                      this.GenerateNUInts();                  }                  uint y = this.mt[this.mti++];                  // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  this.bitBuffer = (y ^ (y >> 18));                    // Reset the bitCount and use rightmost bit of buffer to generate random bool.                  this.bitCount = 1;                  return (this.bitBuffer & 0x1) == 1;              }
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBoolean,The following statement contains a magic number: if (this.bitCount == 32)              {                  // Generate 32 more bits (1 uint) and store it for future calls.                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if (this.mti >= MT19937Generator.N)                  {// generate N words at one time                      this.GenerateNUInts();                  }                  uint y = this.mt[this.mti++];                  // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  this.bitBuffer = (y ^ (y >> 18));                    // Reset the bitCount and use rightmost bit of buffer to generate random bool.                  this.bitCount = 1;                  return (this.bitBuffer & 0x1) == 1;              }
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBoolean,The following statement contains a magic number: if (this.bitCount == 32)              {                  // Generate 32 more bits (1 uint) and store it for future calls.                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if (this.mti >= MT19937Generator.N)                  {// generate N words at one time                      this.GenerateNUInts();                  }                  uint y = this.mt[this.mti++];                  // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  this.bitBuffer = (y ^ (y >> 18));                    // Reset the bitCount and use rightmost bit of buffer to generate random bool.                  this.bitCount = 1;                  return (this.bitBuffer & 0x1) == 1;              }
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBoolean,The following statement contains a magic number: if (this.bitCount == 32)              {                  // Generate 32 more bits (1 uint) and store it for future calls.                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if (this.mti >= MT19937Generator.N)                  {// generate N words at one time                      this.GenerateNUInts();                  }                  uint y = this.mt[this.mti++];                  // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  this.bitBuffer = (y ^ (y >> 18));                    // Reset the bitCount and use rightmost bit of buffer to generate random bool.                  this.bitCount = 1;                  return (this.bitBuffer & 0x1) == 1;              }
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBoolean,The following statement contains a magic number: if (this.bitCount == 32)              {                  // Generate 32 more bits (1 uint) and store it for future calls.                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if (this.mti >= MT19937Generator.N)                  {// generate N words at one time                      this.GenerateNUInts();                  }                  uint y = this.mt[this.mti++];                  // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  this.bitBuffer = (y ^ (y >> 18));                    // Reset the bitCount and use rightmost bit of buffer to generate random bool.                  this.bitCount = 1;                  return (this.bitBuffer & 0x1) == 1;              }
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: while (i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if (this.mti >= MT19937Generator.N)                  {// generate N words at one time                      this.GenerateNUInts();                  }                  y = this.mt[this.mti++];                  // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  buffer[i++] = (byte)(y >> 8);                  buffer[i++] = (byte)(y >> 16);                  buffer[i++] = (byte)(y >> 24);              }
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: while (i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if (this.mti >= MT19937Generator.N)                  {// generate N words at one time                      this.GenerateNUInts();                  }                  y = this.mt[this.mti++];                  // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  buffer[i++] = (byte)(y >> 8);                  buffer[i++] = (byte)(y >> 16);                  buffer[i++] = (byte)(y >> 24);              }
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: while (i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if (this.mti >= MT19937Generator.N)                  {// generate N words at one time                      this.GenerateNUInts();                  }                  y = this.mt[this.mti++];                  // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  buffer[i++] = (byte)(y >> 8);                  buffer[i++] = (byte)(y >> 16);                  buffer[i++] = (byte)(y >> 24);              }
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: while (i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if (this.mti >= MT19937Generator.N)                  {// generate N words at one time                      this.GenerateNUInts();                  }                  y = this.mt[this.mti++];                  // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  buffer[i++] = (byte)(y >> 8);                  buffer[i++] = (byte)(y >> 16);                  buffer[i++] = (byte)(y >> 24);              }
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: while (i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if (this.mti >= MT19937Generator.N)                  {// generate N words at one time                      this.GenerateNUInts();                  }                  y = this.mt[this.mti++];                  // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  buffer[i++] = (byte)(y >> 8);                  buffer[i++] = (byte)(y >> 16);                  buffer[i++] = (byte)(y >> 24);              }
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: while (i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if (this.mti >= MT19937Generator.N)                  {// generate N words at one time                      this.GenerateNUInts();                  }                  y = this.mt[this.mti++];                  // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  buffer[i++] = (byte)(y >> 8);                  buffer[i++] = (byte)(y >> 16);                  buffer[i++] = (byte)(y >> 24);              }
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: while (i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if (this.mti >= MT19937Generator.N)                  {// generate N words at one time                      this.GenerateNUInts();                  }                  y = this.mt[this.mti++];                  // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  buffer[i++] = (byte)(y >> 8);                  buffer[i++] = (byte)(y >> 16);                  buffer[i++] = (byte)(y >> 24);              }
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: while (i < buffer.Length - 3)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if (this.mti >= MT19937Generator.N)                  {// generate N words at one time                      this.GenerateNUInts();                  }                  y = this.mt[this.mti++];                  // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  buffer[i++] = (byte)(y >> 8);                  buffer[i++] = (byte)(y >> 16);                  buffer[i++] = (byte)(y >> 24);              }
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if (this.mti >= MT19937Generator.N)                  {// generate N words at one time                      this.GenerateNUInts();                  }                  y = this.mt[this.mti++];                  // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(y >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(y >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(y >> 24);                          }                      }                  }              }
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if (this.mti >= MT19937Generator.N)                  {// generate N words at one time                      this.GenerateNUInts();                  }                  y = this.mt[this.mti++];                  // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(y >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(y >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(y >> 24);                          }                      }                  }              }
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if (this.mti >= MT19937Generator.N)                  {// generate N words at one time                      this.GenerateNUInts();                  }                  y = this.mt[this.mti++];                  // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(y >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(y >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(y >> 24);                          }                      }                  }              }
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if (this.mti >= MT19937Generator.N)                  {// generate N words at one time                      this.GenerateNUInts();                  }                  y = this.mt[this.mti++];                  // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(y >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(y >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(y >> 24);                          }                      }                  }              }
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if (this.mti >= MT19937Generator.N)                  {// generate N words at one time                      this.GenerateNUInts();                  }                  y = this.mt[this.mti++];                  // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(y >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(y >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(y >> 24);                          }                      }                  }              }
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if (this.mti >= MT19937Generator.N)                  {// generate N words at one time                      this.GenerateNUInts();                  }                  y = this.mt[this.mti++];                  // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(y >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(y >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(y >> 24);                          }                      }                  }              }
Magic Number,YAMP.Numerics,MT19937Generator,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: if (i < buffer.Length)              {                  // Its faster to explicitly calculate the unsigned random number than simply call NextUInt().                  if (this.mti >= MT19937Generator.N)                  {// generate N words at one time                      this.GenerateNUInts();                  }                  y = this.mt[this.mti++];                  // Tempering                  y ^= (y >> 11);                  y ^= (y << 7) & 0x9d2c5680U;                  y ^= (y << 15) & 0xefc60000U;                  y ^= (y >> 18);                    buffer[i++] = (byte)y;                  if (i < buffer.Length)                  {                      buffer[i++] = (byte)(y >> 8);                      if (i < buffer.Length)                      {                          buffer[i++] = (byte)(y >> 16);                          if (i < buffer.Length)                          {                              buffer[i] = (byte)(y >> 24);                          }                      }                  }              }
Magic Number,YAMP.Numerics,NormalDistribution,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\NormalDistribution.cs,NextDouble,The following statement contains a magic number: if (this.helper2)              {                  this.helper2 = false;                    return this.helper1;              }              else              {  				this.helper2 = true;  				  				while (true)                  {                      double v1 = 2.0 * this.Generator.NextDouble() - 1.0;                      double v2 = 2.0 * this.Generator.NextDouble() - 1.0;                      double w = v1 * v1 + v2 * v2;                        if (w <= 1)                      {                          double y = Math.Sqrt(-2.0 * Math.Log(w) / w) * this.sigma;                          this.helper1 = v2 * y + this.mu;                          return v1 * y + this.mu;                      }                  }              }
Magic Number,YAMP.Numerics,NormalDistribution,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\NormalDistribution.cs,NextDouble,The following statement contains a magic number: if (this.helper2)              {                  this.helper2 = false;                    return this.helper1;              }              else              {  				this.helper2 = true;  				  				while (true)                  {                      double v1 = 2.0 * this.Generator.NextDouble() - 1.0;                      double v2 = 2.0 * this.Generator.NextDouble() - 1.0;                      double w = v1 * v1 + v2 * v2;                        if (w <= 1)                      {                          double y = Math.Sqrt(-2.0 * Math.Log(w) / w) * this.sigma;                          this.helper1 = v2 * y + this.mu;                          return v1 * y + this.mu;                      }                  }              }
Magic Number,YAMP.Numerics,NormalDistribution,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\NormalDistribution.cs,NextDouble,The following statement contains a magic number: if (this.helper2)              {                  this.helper2 = false;                    return this.helper1;              }              else              {  				this.helper2 = true;  				  				while (true)                  {                      double v1 = 2.0 * this.Generator.NextDouble() - 1.0;                      double v2 = 2.0 * this.Generator.NextDouble() - 1.0;                      double w = v1 * v1 + v2 * v2;                        if (w <= 1)                      {                          double y = Math.Sqrt(-2.0 * Math.Log(w) / w) * this.sigma;                          this.helper1 = v2 * y + this.mu;                          return v1 * y + this.mu;                      }                  }              }
Magic Number,YAMP.Numerics,RayleighDistribution,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\RayleighDistribution.cs,NextDouble,The following statement contains a magic number: return Math.Sqrt(Math.Pow(this.normalDistribution1.NextDouble()' 2) + Math.Pow(this.normalDistribution2.NextDouble()' 2));
Magic Number,YAMP.Numerics,RayleighDistribution,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\RayleighDistribution.cs,NextDouble,The following statement contains a magic number: return Math.Sqrt(Math.Pow(this.normalDistribution1.NextDouble()' 2) + Math.Pow(this.normalDistribution2.NextDouble()' 2));
Magic Number,YAMP.Numerics,WeibullDistribution,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\WeibullDistribution.cs,Gamma,The following statement contains a magic number: for (int index = 1; index <= 6; index++)                  sum += WeibullDistribution.LanczosCoefficients[index] / (x + index);
Magic Number,YAMP.Numerics,WeibullDistribution,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\WeibullDistribution.cs,Gamma,The following statement contains a magic number: return Math.Sqrt(2.0 * Math.PI) / x * Math.Pow(x + 5.5' x + 0.5) / Math.Exp(x + 5.5) * sum;
Magic Number,YAMP.Numerics,WeibullDistribution,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\WeibullDistribution.cs,Gamma,The following statement contains a magic number: return Math.Sqrt(2.0 * Math.PI) / x * Math.Pow(x + 5.5' x + 0.5) / Math.Exp(x + 5.5) * sum;
Magic Number,YAMP.Numerics,WeibullDistribution,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\WeibullDistribution.cs,Gamma,The following statement contains a magic number: return Math.Sqrt(2.0 * Math.PI) / x * Math.Pow(x + 5.5' x + 0.5) / Math.Exp(x + 5.5) * sum;
Magic Number,YAMP.Numerics,WeibullDistribution,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\WeibullDistribution.cs,Gamma,The following statement contains a magic number: return Math.Sqrt(2.0 * Math.PI) / x * Math.Pow(x + 5.5' x + 0.5) / Math.Exp(x + 5.5) * sum;
Magic Number,YAMP.Numerics,GMRESkSolver,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Solvers\GMRESkSolver.cs,GMRESkSolver,The following statement contains a magic number: if(restart)                  Restart = MaxIterations / 10;              else //No Restart                  Restart = MaxIterations;
Magic Number,YAMP.Numerics,IterativeSolver,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Solvers\IterativeSolver.cs,IterativeSolver,The following statement contains a magic number: MaxIterations = 5 * A.DimensionX * A.DimensionY;
Magic Number,YAMP.Numerics,IterativeSolver,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Solvers\IterativeSolver.cs,IterativeSolver,The following statement contains a magic number: Tolerance = 1e-10;
Magic Number,YAMP.Numerics.Optimization,NewtonMethod,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\NonLinear\NewtonMethod.cs,NewtonMethod,The following statement contains a magic number: Result = new double[1' 2];
Missing Default,YAMP,TimerFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\SystemFunctions\TimerFunction.cs,Function,The following switch statement is missing a default case: switch (n)  			{  				case -1:  					Reset();  					break;  				case 0:  					Stop();  					break;  				case 1:  					Start();  					break;  			}
Missing Default,YAMP,TimerFunction,C:\repos\FlorianRappl_YAMP\YAMP.Core\Functions\SystemFunctions\TimerFunction.cs,Function,The following switch statement is missing a default case: switch (action.Value.ToLower())  			{  				case "reset":  					Reset();  					break;  				case "stop":  					Stop();  					break;  				case "start":  					Start();  					break;  			}
Missing Default,YAMP,Value,C:\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,ToSuperScript,The following switch statement is missing a default case: switch(ch)                  {                      case '0': target = '⁰'; break;                      case '1': target = '¹'; break;                      case '2': target = '²'; break;                      case '3': target = '³'; break;                      case '4': target = '⁴'; break;                      case '5': target = '⁵'; break;                      case '6': target = '⁶'; break;                      case '7': target = '⁷'; break;                      case '8': target = '⁸'; break;                      case '9': target = '⁹'; break;                  }
Missing Default,YAMP.Numerics,SingularValueDecomposition,C:\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following switch statement is missing a default case: switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
