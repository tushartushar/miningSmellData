Implementation smell,Namespace,Class,File,Method,Description
Long Method,YAMP,BootstrapFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\BootstrapFunction.cs,Function,The method has 100 lines of code.
Long Method,YAMP,JackknifeFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\JackknifeFunction.cs,Function,The method has 150 lines of code.
Long Method,YAMP,MatrixValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Perform,The method has 107 lines of code.
Long Method,YAMP.Numerics,Eigenvalues,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,tred2,The method has 108 lines of code.
Long Method,YAMP.Numerics,Eigenvalues,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,tql2,The method has 110 lines of code.
Long Method,YAMP.Numerics,Eigenvalues,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The method has 422 lines of code.
Long Method,YAMP.Numerics,SingularValueDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The method has 416 lines of code.
Complex Method,YAMP,FindFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Helpers\FindFunction.cs,GetIndices,Cyclomatic complexity of the method is 9
Complex Method,YAMP,Plugin,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Providers\Plugin.cs,Install,Cyclomatic complexity of the method is 8
Complex Method,YAMP,YMath,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Providers\YMath.cs,Histogram,Cyclomatic complexity of the method is 8
Complex Method,YAMP,YMath,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Providers\YMath.cs,Mean,Cyclomatic complexity of the method is 8
Complex Method,YAMP,YMath,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Providers\YMath.cs,HarmonicMean,Cyclomatic complexity of the method is 8
Complex Method,YAMP,YMath,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Providers\YMath.cs,Covariance,Cyclomatic complexity of the method is 8
Complex Method,YAMP,YMath,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Providers\YMath.cs,Variance,Cyclomatic complexity of the method is 8
Complex Method,YAMP,SurfacePlotValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\SurfacePlotValue.cs,AddPoints,Cyclomatic complexity of the method is 9
Complex Method,YAMP,Statement,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\Statement.cs,Finalize,Cyclomatic complexity of the method is 9
Complex Method,YAMP,MatrixExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Container\MatrixExpression.cs,Scan,Cyclomatic complexity of the method is 11
Complex Method,YAMP,BootstrapFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\BootstrapFunction.cs,Function,Cyclomatic complexity of the method is 16
Complex Method,YAMP,JackknifeFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\JackknifeFunction.cs,Function,Cyclomatic complexity of the method is 27
Complex Method,YAMP,ArgumentFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunction.cs,BuildArguments,Cyclomatic complexity of the method is 10
Complex Method,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,ParseStatement,Cyclomatic complexity of the method is 9
Complex Method,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,ParseStatement,Cyclomatic complexity of the method is 9
Complex Method,YAMP,QueryContext,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\QueryContext.cs,Run,Cyclomatic complexity of the method is 9
Complex Method,YAMP,FunctionKeyword,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Keywords\FunctionKeyword.cs,Scan,Cyclomatic complexity of the method is 8
Complex Method,YAMP,ContourPlotValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\ContourPlotValue.cs,AddValues,Cyclomatic complexity of the method is 13
Complex Method,YAMP,ErrorPlotValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\ErrorPlotValue.cs,AddValues,Cyclomatic complexity of the method is 10
Complex Method,YAMP,Plot2DValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\Plot2DValue.cs,AddValues,Cyclomatic complexity of the method is 10
Complex Method,YAMP,Plot3DValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\Plot3DValue.cs,AddPoints,Cyclomatic complexity of the method is 9
Complex Method,YAMP,Plot3DValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\Plot3DValue.cs,AddValues,Cyclomatic complexity of the method is 14
Complex Method,YAMP,SubPlotValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\SubPlotValue.cs,Perform,Cyclomatic complexity of the method is 11
Complex Method,YAMP,Value,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,ToSuperScript,Cyclomatic complexity of the method is 11
Complex Method,YAMP,NumberExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Elementary\NumberExpression.cs,Scan,Cyclomatic complexity of the method is 11
Complex Method,YAMP,MatrixValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,DeleteColumns,Cyclomatic complexity of the method is 8
Complex Method,YAMP,MatrixValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,DeleteRows,Cyclomatic complexity of the method is 8
Complex Method,YAMP,MatrixValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,YAMP,MatrixValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,DeleteFullRows,Cyclomatic complexity of the method is 13
Complex Method,YAMP,MatrixValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,DeleteFullColumns,Cyclomatic complexity of the method is 13
Complex Method,YAMP,MatrixValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Perform,Cyclomatic complexity of the method is 20
Complex Method,YAMP,MatrixValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Perform,Cyclomatic complexity of the method is 12
Complex Method,YAMP,StringExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Elementary\StringExpression.cs,Scan,Cyclomatic complexity of the method is 11
Complex Method,YAMP,RangeOperator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Operators\BinaryOperators\RangeOperator.cs,Perform,Cyclomatic complexity of the method is 8
Complex Method,YAMP,LogicOperator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Operators\LogicOperator.cs,Perform,Cyclomatic complexity of the method is 13
Complex Method,YAMP.Help,Documentation,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Help\Documentation.cs,Distance,Cyclomatic complexity of the method is 8
Complex Method,YAMP.Numerics,HouseholderDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\HouseholderDecomposition.cs,HouseholderDecomposition,Cyclomatic complexity of the method is 9
Complex Method,YAMP.Numerics,HouseholderDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\HouseholderDecomposition.cs,Solve,Cyclomatic complexity of the method is 11
Complex Method,YAMP.Numerics,BluesteinTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\BluesteinTransformlet.cs,FftKernel,Cyclomatic complexity of the method is 9
Complex Method,YAMP.Numerics,Fourier,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,Fourier,Cyclomatic complexity of the method is 8
Complex Method,YAMP.Numerics,Transformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Transformlet.cs,FftKernel,Cyclomatic complexity of the method is 8
Complex Method,YAMP.Numerics,CholeskyDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\CholeskyDecomposition.cs,Solve,Cyclomatic complexity of the method is 11
Complex Method,YAMP.Numerics,Pijavsky,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\Pijavsky.cs,Pijavsky,Cyclomatic complexity of the method is 9
Complex Method,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,jn,Cyclomatic complexity of the method is 10
Complex Method,YAMP.Numerics,Eigenvalues,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,tred2,Cyclomatic complexity of the method is 23
Complex Method,YAMP.Numerics,Eigenvalues,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,tql2,Cyclomatic complexity of the method is 11
Complex Method,YAMP.Numerics,Eigenvalues,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,orthes,Cyclomatic complexity of the method is 20
Complex Method,YAMP.Numerics,Eigenvalues,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,Cyclomatic complexity of the method is 69
Complex Method,YAMP.Numerics,Eigenvalues,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,Eigenvalues,Cyclomatic complexity of the method is 10
Complex Method,YAMP.Numerics,LUDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\LUDecomposition.cs,LUDecomposition,Cyclomatic complexity of the method is 12
Complex Method,YAMP.Numerics,LUDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\LUDecomposition.cs,Solve,Cyclomatic complexity of the method is 10
Complex Method,YAMP.Numerics,SingularValueDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,Cyclomatic complexity of the method is 86
Complex Method,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,GCD,Cyclomatic complexity of the method is 10
Complex Method,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,Cyclomatic complexity of the method is 8
Complex Method,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,Cyclomatic complexity of the method is 9
Long Parameter List,YAMP,NewtonFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Fractals\NewtonFunction.cs,Function,The method has 6 parameters. Parameters: x0' xn' y0' yn' xsteps' ysteps
Long Parameter List,YAMP,BracketExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Container\BracketExpression.cs,BracketExpression,The method has 5 parameters. Parameters: line' column' length' query' child
Long Parameter List,YAMP,MatrixExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Container\MatrixExpression.cs,MatrixExpression,The method has 5 parameters. Parameters: line' column' length' query' child
Long Parameter List,YAMP,MandelbrotFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Fractals\MandelbrotFunction.cs,Function,The method has 6 parameters. Parameters: x0' xn' y0' yn' xsteps' ysteps
Long Parameter List,YAMP,CplotFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Visualization\CplotFunction.cs,Function,The method has 5 parameters. Parameters: f' minX' maxX' minY' maxY
Long Parameter List,YAMP,CplotFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Visualization\CplotFunction.cs,Plot,The method has 5 parameters. Parameters: f' minx' maxx' miny' maxy
Long Parameter List,YAMP,SubPlotValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\SubPlotValue.cs,AddSubPlot,The method has 5 parameters. Parameters: row' column' plot' rowSpan' columnSpan
Long Parameter List,YAMP,SubPlotValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\SubPlotValue.cs,AddSubPlot,The method has 6 parameters. Parameters: context' row' column' plot' rowSpan' columnSpan
Long Parameter List,YAMP,Value,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,ScientificFormat,The method has 5 parameters. Parameters: context' value' sign' U' L
Long Parameter List,YAMP,Value,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,EngineeringFormat,The method has 5 parameters. Parameters: context' value' sign' U' L
Long Parameter List,YAMP,Value,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,StandardFormat,The method has 5 parameters. Parameters: context' v' sign' U' L
Long Parameter List,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,IsProbablyPrime,The method has 5 parameters. Parameters: n' m' s' d' w
Long Parameter List,YAMP,AbsExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Container\AbsExpression.cs,AbsExpression,The method has 5 parameters. Parameters: line' column' length' query' child
Long Parameter List,YAMP.Numerics,Fractal,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Fractal.cs,CalculateMatrix,The method has 6 parameters. Parameters: xi' xf' yi' yf' xsteps' ysteps
Long Parameter List,YAMP.Numerics,BlasL3,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Matrices\BlasL3.cs,dGemm,The method has 15 parameters. Parameters: aStore' aOffset' aRowStride' aColStride' bStore' bOffset' bRowStride' bColStride' cStore' cOffset' cRowStride' cColStride' rowsA' colsB' length
Long Parameter List,YAMP.Numerics,BlasL3,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Matrices\BlasL3.cs,cGemm,The method has 15 parameters. Parameters: aStore' aOffset' aRowStride' aColStride' bStore' bOffset' bRowStride' bColStride' cStore' cOffset' cRowStride' cColStride' rowsA' colsB' length
Long Parameter List,YAMP.Numerics,BlasL1,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Matrices\BlasL1.cs,dCopy,The method has 7 parameters. Parameters: xStore' xOffset' xStride' yStore' yOffset' yStride' count
Long Parameter List,YAMP.Numerics,BlasL1,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Matrices\BlasL1.cs,dSwap,The method has 7 parameters. Parameters: xStore' xOffset' xStride' yStore' yOffset' yStride' count
Long Parameter List,YAMP.Numerics,BlasL1,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Matrices\BlasL1.cs,dDot,The method has 7 parameters. Parameters: aStore' aOffset' aStride' bStore' bOffset' bStride' count
Long Parameter List,YAMP.Numerics,BlasL1,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Matrices\BlasL1.cs,cDot,The method has 7 parameters. Parameters: aStore' aOffset' aStride' bStore' bOffset' bStride' count
Long Parameter List,YAMP.Numerics,BlasL1,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Matrices\BlasL1.cs,dScal,The method has 5 parameters. Parameters: alpha' store' offset' stride' count
Long Parameter List,YAMP.Numerics,BlasL1,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Matrices\BlasL1.cs,cScal,The method has 5 parameters. Parameters: alpha' store' offset' stride' count
Long Parameter List,YAMP.Numerics,BlasL1,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Matrices\BlasL1.cs,dAxpy,The method has 8 parameters. Parameters: alpha' xStore' xOffset' xStride' yStore' yOffset' yStride' count
Long Parameter List,YAMP.Numerics,BlasL1,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Matrices\BlasL1.cs,cAxpy,The method has 8 parameters. Parameters: alpha' xStore' xOffset' xStride' yStore' yOffset' yStride' count
Long Parameter List,YAMP.Numerics,BlasL2,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Matrices\BlasL2.cs,dGemv,The method has 12 parameters. Parameters: aStore' aOffset' aRowStride' aColStride' xStore' xOffset' xStride' yStore' yOffset' yStride' rows' cols
Long Parameter List,YAMP.Numerics,BlasL2,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Matrices\BlasL2.cs,cGemv,The method has 12 parameters. Parameters: aStore' aOffset' aRowStride' aColStride' xStore' xOffset' xStride' yStore' yOffset' yStride' rows' cols
Long Parameter List,YAMP.Numerics,BluesteinTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\BluesteinTransformlet.cs,FftKernel,The method has 5 parameters. Parameters: x' y' y0' dy' sign
Long Parameter List,YAMP.Numerics,RadixFiveTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The method has 5 parameters. Parameters: x' y' y0' dy' sign
Long Parameter List,YAMP.Numerics,RadixFourTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFourTransformlet.cs,FftKernel,The method has 5 parameters. Parameters: x' y' y0' dy' sign
Long Parameter List,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The method has 5 parameters. Parameters: x' y' y0' dy' sign
Long Parameter List,YAMP.Numerics,RadixThreeTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixThreeTransformlet.cs,FftKernel,The method has 7 parameters. Parameters: x0' x1' x2' y0' y1' y2' sign
Long Parameter List,YAMP.Numerics,Transformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Transformlet.cs,FftKernel,The method has 5 parameters. Parameters: x' y' y0' dy' sign
Long Parameter List,YAMP.Numerics,Interpolation,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\Interpolation.cs,SolveTridiag,The method has 5 parameters. Parameters: sub' diag' sup' b' n
Long Parameter List,YAMP.Numerics,Euler,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\Euler.cs,Euler,The method has 5 parameters. Parameters: f' begin' end' y0' pointsNum
Long Parameter List,YAMP.Numerics,ODEBase,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\ODEBase.cs,ODEBase,The method has 5 parameters. Parameters: f' begin' end' y0' pointsNum
Long Parameter List,YAMP.Numerics,RungeKutta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\RungeKutta.cs,RungeKutta,The method has 5 parameters. Parameters: f' begin' end' y0' pointsNum
Long Parameter List,YAMP.Numerics,Pijavsky,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\Pijavsky.cs,Pijavsky,The method has 5 parameters. Parameters: f' a' b' l' n
Long Parameter List,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,IsProbablyPrime,The method has 5 parameters. Parameters: n' m' s' d' w
Long Statement,YAMP,ObjectExtensions,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Extensions\ObjectExtensions.cs,ToDictionary,The length of the statement  "                        throw new ArgumentException("Cannot execute YAMP queries with a list of values that contains types' which are not of a Value' numeric (int' double' float' long) or string (char' string) type."' "values"); " is 204.
Long Statement,YAMP,LinfitFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Numerics\LinfitFunction.cs,Function,The length of the statement  "            return new FunctionValue((parseContext' variable) => ((f.Perform(parseContext' variable) as MatrixValue) * p)[1]' true); " is 120.
Long Statement,YAMP,RGBToImgFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunctions\RGBToImgFunction.cs,Function,The length of the statement  "                    rgbvalues[i' j] = new ScalarValue(rfactor * R[i' j].IntValue + gfactor * G[i' j].IntValue + bfactor * B[i' j].IntValue); " is 120.
Long Statement,YAMP,TypeExtensions,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Providers\Extensions.cs,IsCastableTo,The length of the statement  "                    .Where(m => m.ReturnType == to && (m.Name.Equals("op_Implicit") || m.Name.Equals("op_Explicit")) && m.GetParameters()[0].ParameterType == from); " is 144.
Long Statement,YAMP,TypeExtensions,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Providers\Extensions.cs,Cast,The length of the statement  "                    .Where(m => m.ReturnType == to && (m.Name == "op_Implicit" || m.Name == "op_Explicit") && m.GetParameters()[0].ParameterType == from).First(); " is 142.
Long Statement,YAMP,ObjectValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Arguments\ObjectValue.cs,RegisterOperators,The length of the statement  "            RegisterMember(typeof(ObjectValue)' typeof(StringValue)' (left' right) => ((ObjectValue)left).GetValue((StringValue)right)); " is 124.
Long Statement,YAMP,Statement,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\Statement.cs,ReduceUnary,The length of the statement  "            while (_operators.Count != 0 && _operators.Peek().Expressions == 1 && _operators.Peek().Level >= container.Operator.Level) " is 122.
Long Statement,YAMP,BracketExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Container\BracketExpression.cs,Scan,The length of the statement  "                var exp = new BracketExpression(line' col' engine.Pointer - start' engine.Query' container ?? new ContainerExpression()); " is 121.
Long Statement,YAMP,MatrixExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Container\MatrixExpression.cs,Scan,The length of the statement  "                return new MatrixExpression(line' column' engine.Pointer - start' engine.Query' container ?? new ContainerExpression()); " is 120.
Long Statement,YAMP,FormatFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\SystemFunctions\FormatFunction.cs,Function,The length of the statement  "            Context.RaiseNotification(new NotificationEventArgs(NotificationType.Information' "Display format changed to " + value + ".")); " is 127.
Long Statement,YAMP,HelpFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\SystemFunctions\HelpFunction.cs,Function,The length of the statement  "                return new StringValue(String.Format("The specified entry was not found. Did you mean {0}?"' docu.ClosestEntry(topic.Value))); " is 126.
Long Statement,YAMP,PrecisionFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\SystemFunctions\PrecisionFunction.cs,Function,The length of the statement  "            Context.RaiseNotification(new NotificationEventArgs(NotificationType.Information' "Output precision changed to " + Context.Precision + " digits.")); " is 148.
Long Statement,YAMP,SetFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Visualization\SetFunction.cs,Function,The length of the statement  "                Context.RaiseNotification(new NotificationEventArgs(NotificationType.Failure' "No plot available... Nothing changed.")); " is 120.
Long Statement,YAMP,SetFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Visualization\SetFunction.cs,Function,The length of the statement  "                Context.RaiseNotification(new NotificationEventArgs(NotificationType.Failure' "No plot available... Nothing changed.")); " is 120.
Long Statement,YAMP,SetFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Visualization\SetFunction.cs,Function,The length of the statement  "                Context.RaiseNotification(new NotificationEventArgs(NotificationType.Failure' "No plot available... Nothing changed.")); " is 120.
Long Statement,YAMP,SetFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Visualization\SetFunction.cs,Function,The length of the statement  "            Context.RaiseNotification(new NotificationEventArgs(NotificationType.Failure' "Series " + String.Join("' "' s.ToArray()) + " changed.")); " is 137.
Long Statement,YAMP,ArgsOperator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Operators\PseudoOperators\ArgsOperator.cs,Create,The length of the statement  "            if (start != 0 && !ParseEngine.IsWhiteSpace(engine.Characters[start - 1]) && !ParseEngine.IsNewLine(engine.Characters[start - 1])) " is 130.
Long Statement,YAMP,ArgumentFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunction.cs,BuildArguments,The length of the statement  "                        return new YAMPArgumentInvalidException(Name' _arguments[idx].Header' yp.ParameterTypes[idx].Name.RemoveValueConvention()' idx); " is 128.
Long Statement,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,ParseStatement,The length of the statement  "                AddError(terminationMissing != null ? terminationMissing(this) : new YAMPTerminatorMissingError(_currentLine' _currentColumn' termination)); " is 140.
Long Statement,YAMP,MatrixValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,DeleteFullRows,The length of the statement  "                    if (indices[j].Row == row && !cols.Contains(indices[j].Column) && indices[j].Column >= 1 && indices[j].Column <= Columns) " is 121.
Long Statement,YAMP.Help,Documentation,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Help\Documentation.cs,Get,The length of the statement  "			var topic = topics.SelectMany(m => m.Where(n => n.Name.Equals(entry' StringComparison.CurrentCultureIgnoreCase)).Select(n => n)).FirstOrDefault(); " is 146.
Long Statement,YAMP.Numerics,RadixThreeTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixThreeTransformlet.cs,FftPass,The length of the statement  "                    FftKernel(x[j]' x[j + dx] * u[N - du]' x[j + 2 * dx] * u[N - 2 * du]' out y[y0]' out y[y0 + Ns]' out y[y0 + 2 * Ns]' -1); " is 121.
Long Statement,YAMP.Numerics,SplineInterpolation,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,ComputeValue,The length of the statement  "                return ((-a[gap - 1] / 6 * (x2 + h[gap]) * x1 + samples[gap' 2].Re) * x2 + (-a[gap] / 6 * (x1 + h[gap]) * x2 + samples[gap + 1' 2].Re) * x1) / h[gap]; " is 150.
Long Statement,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The length of the statement  "				var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456))))); " is 130.
Long Statement,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The length of the statement  "				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 - y * 0.934935152e-7))); " is 122.
Long Statement,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The length of the statement  "				ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606)))))); " is 131.
Long Statement,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The length of the statement  "				var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733)))); " is 126.
Long Statement,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The length of the statement  "				var ans2 = -0.1562499995e-1 + y * (0.1430488765e-3 + y * (-0.6911147651e-5 + y * (0.7621095161e-6 + y * (-0.934945152e-7)))); " is 125.
Long Statement,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The length of the statement  "				var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4))))); " is 151.
Long Statement,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The length of the statement  "				var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y))))); " is 148.
Long Statement,YAMP.Numerics,Eigenvalues,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The length of the statement  "                        if (Math.Abs(H[m][m - 1]) * (Math.Abs(q) + Math.Abs(r)) < eps * (Math.Abs(p) * (Math.Abs(H[m - 1][m - 1]) + Math.Abs(z) + Math.Abs(H[m + 1][m + 1])))) " is 150.
Long Statement,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Faddeeva,The length of the statement  "                return Taylor(new ScalarValue(z.Re)' Math.Exp(-z.Re * z.Re) + 2.0 * Dawson.DawsonIntegral(z.Re) / Helpers.SqrtPI * ScalarValue.I' new ScalarValue(0.0' z.Im)); " is 158.
Long Statement,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The length of the statement  "                // 31 random bits (int) will suffice which allows us to shift and cast to an int before the first multiplication and gain better performance. " is 141.
Long Statement,YAMP.Numerics,RayleighDistribution,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\RayleighDistribution.cs,NextDouble,The length of the statement  "            return Math.Sqrt(Math.Pow(this.normalDistribution1.NextDouble()' 2) + Math.Pow(this.normalDistribution2.NextDouble()' 2)); " is 122.
Complex Conditional,YAMP,ObjectExtensions,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Extensions\ObjectExtensions.cs,ToValue,The conditional expression  "s is Double || s is Int32 || s is Single || s is Int64"  is complex.
Complex Conditional,YAMP,SubPlotValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\SubPlotValue.cs,Perform,The conditional expression  "subplots[i].Row <= row && subplots[i].Row + subplots[i].RowSpan - 1 >= row &&                          subplots[i].Column <= column && subplots[i].Column + subplots[i].ColumnSpan - 1 >= column"  is complex.
Complex Conditional,YAMP,NumberExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Elementary\NumberExpression.cs,Scan,The conditional expression  "ParseEngine.IsNumber(ch) || (ch == '.' && start + 1 < chars.Length && ParseEngine.IsNumber(chars[start + 1]))"  is complex.
Complex Conditional,YAMP,MatrixValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,DeleteFullRows,The conditional expression  "indices[j].Row == row && !cols.Contains(indices[j].Column) && indices[j].Column >= 1 && indices[j].Column <= Columns"  is complex.
Complex Conditional,YAMP,MatrixValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,DeleteFullColumns,The conditional expression  "indices[j].Column == col && !rows.Contains(indices[j].Row) && indices[j].Row >= 1 && indices[j].Row <= Rows"  is complex.
Complex Conditional,YAMP,StringExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Elementary\StringExpression.cs,Scan,The conditional expression  "chars[start] == '"' || (chars[start] == '@' && start + 1 < chars.Length && chars[start + 1] == '"')"  is complex.
Virtual Method Call from Constructor,YAMP,FunctionValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Arguments\FunctionValue.cs,FunctionValue,The constructor "FunctionValue" calls a virtual method "ToCode".
Virtual Method Call from Constructor,YAMP,Plot2DValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\Plot2DValue.cs,Plot2DValue,The constructor "Plot2DValue" calls a virtual method "InitializeBoundaries".
Virtual Method Call from Constructor,YAMP,PolarPlotValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\PolarPlotValue.cs,PolarPlotValue,The constructor "PolarPlotValue" calls a virtual method "InitializeBoundaries".
Virtual Method Call from Constructor,YAMP,MatrixValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,MatrixValue,The constructor "MatrixValue" calls a virtual method "Clone".
Virtual Method Call from Constructor,YAMP.Numerics,GivensDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\GivensDecomposition.cs,GivensDecomposition,The constructor "GivensDecomposition" calls a virtual method "Clone".
Virtual Method Call from Constructor,YAMP.Numerics,ODEBase,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\ODEBase.cs,ODEBase,The constructor "ODEBase" calls a virtual method "Calculate".
Empty Catch Block,YAMP,ParseContext,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\ParseContext.cs,ApplyPlotTemplate,The method has an empty catch block.
Empty Catch Block,YAMP,ParseContext,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\ParseContext.cs,ApplyPlotTemplate,The method has an empty catch block.
Magic Number,YAMP,SphereFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunctions\SphereFunction.cs,Function,The following statement contains a magic number: return Function(new ScalarValue(20));
Magic Number,YAMP,SphereFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunctions\SphereFunction.cs,Function,The following statement contains a magic number: dim < 2
Magic Number,YAMP,SphereFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunctions\SphereFunction.cs,Function,The following statement contains a magic number: var stheta = Table(0.0' 2.0 * Math.PI' dim' Math.Sin);
Magic Number,YAMP,SphereFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunctions\SphereFunction.cs,Function,The following statement contains a magic number: var ctheta = Table(0.0' 2.0 * Math.PI' dim' Math.Cos);
Magic Number,YAMP,Bin2DecFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Bin2DecFunction.cs,Function,The following statement contains a magic number: weight *= 2;
Magic Number,YAMP,Cart2PolFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2PolFunction.cs,Function,The following statement contains a magic number: return new MatrixValue(new[] { new ScalarValue(r)' new ScalarValue(phi) }' 2' 1);
Magic Number,YAMP,Cart2PolFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2PolFunction.cs,Function,The following statement contains a magic number: throw new YAMPMatrixDimensionException(2' M.DimensionX' M.DimensionY' M.DimensionX);
Magic Number,YAMP,Cart2PolFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2PolFunction.cs,Function,The following statement contains a magic number: M.DimensionX != 2 && M.DimensionY != 2
Magic Number,YAMP,Cart2PolFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2PolFunction.cs,Function,The following statement contains a magic number: M.DimensionX != 2 && M.DimensionY != 2
Magic Number,YAMP,Cart2PolFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2PolFunction.cs,Function,The following statement contains a magic number: var isTransposed = M.DimensionY != 2;
Magic Number,YAMP,Cart2PolFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2PolFunction.cs,Function,The following statement contains a magic number: var m = new MatrixValue(2' M.DimensionX);
Magic Number,YAMP,Cart2PolFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2PolFunction.cs,Function,The following statement contains a magic number: var y = M[2' i].Re;
Magic Number,YAMP,Cart2PolFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2PolFunction.cs,Function,The following statement contains a magic number: m[2' i] = new ScalarValue(r * Math.Sin(phi));
Magic Number,YAMP,Cart2SphFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2SphFunction.cs,Function,The following statement contains a magic number: return new MatrixValue(new[] { new ScalarValue(r)' new ScalarValue(theta)' new ScalarValue(phi) }' 3' 1);
Magic Number,YAMP,Cart2SphFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2SphFunction.cs,Function,The following statement contains a magic number: throw new YAMPMatrixDimensionException(3' M.DimensionX' M.DimensionY' M.DimensionX);
Magic Number,YAMP,Cart2SphFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2SphFunction.cs,Function,The following statement contains a magic number: M.DimensionX != 3 && M.DimensionY != 3
Magic Number,YAMP,Cart2SphFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2SphFunction.cs,Function,The following statement contains a magic number: M.DimensionX != 3 && M.DimensionY != 3
Magic Number,YAMP,Cart2SphFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2SphFunction.cs,Function,The following statement contains a magic number: var isTransposed = M.DimensionY != 3;
Magic Number,YAMP,Cart2SphFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2SphFunction.cs,Function,The following statement contains a magic number: var m = new MatrixValue(3' M.DimensionX);
Magic Number,YAMP,Cart2SphFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2SphFunction.cs,Function,The following statement contains a magic number: var y = M[2' i].Re;
Magic Number,YAMP,Cart2SphFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2SphFunction.cs,Function,The following statement contains a magic number: var z = M[3' i].Re;
Magic Number,YAMP,Cart2SphFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2SphFunction.cs,Function,The following statement contains a magic number: m[2' i] = new ScalarValue(theta);
Magic Number,YAMP,Cart2SphFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Cart2SphFunction.cs,Function,The following statement contains a magic number: m[3' i] = new ScalarValue(phi);
Magic Number,YAMP,Hex2DecFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Hex2DecFunction.cs,Function,The following statement contains a magic number: weight *= 16;
Magic Number,YAMP,Oct2DecFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Oct2DecFunction.cs,Function,The following statement contains a magic number: weight *= 8;
Magic Number,YAMP,Pol2CartFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Pol2CartFunction.cs,Function,The following statement contains a magic number: return new MatrixValue(new[] { x' y }' 2' 1);
Magic Number,YAMP,Pol2CartFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Pol2CartFunction.cs,Function,The following statement contains a magic number: throw new YAMPMatrixDimensionException(2' M.DimensionX' M.DimensionY' M.DimensionX);
Magic Number,YAMP,Pol2CartFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Pol2CartFunction.cs,Function,The following statement contains a magic number: M.DimensionX != 2 && M.DimensionY != 2
Magic Number,YAMP,Pol2CartFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Pol2CartFunction.cs,Function,The following statement contains a magic number: M.DimensionX != 2 && M.DimensionY != 2
Magic Number,YAMP,Pol2CartFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Pol2CartFunction.cs,Function,The following statement contains a magic number: var isTransposed = M.DimensionY != 2;
Magic Number,YAMP,Pol2CartFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Pol2CartFunction.cs,Function,The following statement contains a magic number: var m = new MatrixValue(2' M.DimensionX);
Magic Number,YAMP,Pol2CartFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Pol2CartFunction.cs,Function,The following statement contains a magic number: var phi = M[2' i].Re;
Magic Number,YAMP,Pol2CartFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Pol2CartFunction.cs,Function,The following statement contains a magic number: m[2' i] = new ScalarValue(r * Math.Sin(phi));
Magic Number,YAMP,Sph2CartFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Sph2CartFunction.cs,Function,The following statement contains a magic number: return new MatrixValue(new[] { x' y' z }' 3' 1);
Magic Number,YAMP,Sph2CartFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Sph2CartFunction.cs,Function,The following statement contains a magic number: throw new YAMPMatrixDimensionException(3' M.DimensionX' M.DimensionY' M.DimensionX);
Magic Number,YAMP,Sph2CartFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Sph2CartFunction.cs,Function,The following statement contains a magic number: M.DimensionX != 3 && M.DimensionY != 3
Magic Number,YAMP,Sph2CartFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Sph2CartFunction.cs,Function,The following statement contains a magic number: M.DimensionX != 3 && M.DimensionY != 3
Magic Number,YAMP,Sph2CartFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Sph2CartFunction.cs,Function,The following statement contains a magic number: var isTransposed = M.DimensionY != 3;
Magic Number,YAMP,Sph2CartFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Sph2CartFunction.cs,Function,The following statement contains a magic number: var m = new MatrixValue(3' M.DimensionX);
Magic Number,YAMP,Sph2CartFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Sph2CartFunction.cs,Function,The following statement contains a magic number: var theta = M[2' i].Re;
Magic Number,YAMP,Sph2CartFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Sph2CartFunction.cs,Function,The following statement contains a magic number: var phi = M[3' i].Re;
Magic Number,YAMP,Sph2CartFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Sph2CartFunction.cs,Function,The following statement contains a magic number: m[2' i] = new ScalarValue(rt * Math.Sin(phi));
Magic Number,YAMP,Sph2CartFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Conversions\Sph2CartFunction.cs,Function,The following statement contains a magic number: m[3' i] = new ScalarValue(r * Math.Cos(theta));
Magic Number,YAMP,NewtonFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Fractals\NewtonFunction.cs,Function,The following statement contains a magic number: return m.CalculateMatrix(-1.0' 1.0' -1.0' 1.0' 150' 150);
Magic Number,YAMP,NewtonFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Fractals\NewtonFunction.cs,Function,The following statement contains a magic number: return m.CalculateMatrix(-1.0' 1.0' -1.0' 1.0' 150' 150);
Magic Number,YAMP,NewtonFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Fractals\NewtonFunction.cs,Function,The following statement contains a magic number: var xsteps = (int)Math.Abs(Math.Ceiling((xn.Re - x0.Re) / 0.1));
Magic Number,YAMP,NewtonFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Fractals\NewtonFunction.cs,Function,The following statement contains a magic number: var ysteps = (int)Math.Abs(Math.Ceiling((yn.Re - y0.Re) / 0.1));
Magic Number,YAMP,LinfitFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Numerics\LinfitFunction.cs,Function,The following statement contains a magic number: throw new YAMPArgumentInvalidException("Linfit"' "f"' 3);
Magic Number,YAMP,LinfitFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Numerics\LinfitFunction.cs,Function,The following statement contains a magic number: m < 2
Magic Number,YAMP,LinfitFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Numerics\LinfitFunction.cs,Function,The following statement contains a magic number: throw new YAMPArgumentInvalidException("Linfit"' "f"' 3);
Magic Number,YAMP,LinfitFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Numerics\LinfitFunction.cs,Function,The following statement contains a magic number: throw new YAMPArgumentInvalidException("Linfit"' "f"' 3);
Magic Number,YAMP,LinfitFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Numerics\LinfitFunction.cs,Function,The following statement contains a magic number: m < 2
Magic Number,YAMP,PolyfitFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Numerics\PolyfitFunction.cs,Function,The following statement contains a magic number: m < 2
Magic Number,YAMP,RandbFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\RandomNumbers\RandbFunction.cs,Function,The following statement contains a magic number: return Function(rows' cols' new ScalarValue(0.5)' new ScalarValue(1.0));
Magic Number,YAMP,RandbFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\RandomNumbers\RandbFunction.cs,Binomial,The following statement contains a magic number: return Binomial(0.5' 1);
Magic Number,YAMP,Log2Function,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\StandardFunctions\Log2Function.cs,GetValue,The following statement contains a magic number: return value.Log(2.0);
Magic Number,YAMP,SizeFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\StandardFunctions\SizeFunction.cs,Function,The following statement contains a magic number: m[1' 2] = new ScalarValue(M.DimensionX);
Magic Number,YAMP,SizeFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\StandardFunctions\SizeFunction.cs,Function,The following statement contains a magic number: m[1' 2] = new ScalarValue(1);
Magic Number,YAMP,SizeFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\StandardFunctions\SizeFunction.cs,Function,The following statement contains a magic number: m[1' 2] = new ScalarValue(str.Value.Length);
Magic Number,YAMP,HistogramFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\HistogramFunction.cs,Function,The following statement contains a magic number: return Function(Y' new ScalarValue(10));
Magic Number,YAMP,DistFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\DistFunction.cs,Function,The following statement contains a magic number: var dist = linearfit.Function(x' fx' new FunctionValue((context' argument) =>              {                  var _x = (argument as ScalarValue - median / 2) / (variance / 4);                  var _exp_x_2 = (-_x * _x).Exp();                  var result = new MatrixValue(1' nP - 1);                    for (var i = 0; i < nP - 1; i++)                  {                      result[i + 1] = _exp_x_2 * _x.Pow(new ScalarValue(i));                  }                    return result;              }' true));
Magic Number,YAMP,DistFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\DistFunction.cs,Function,The following statement contains a magic number: var dist = linearfit.Function(x' fx' new FunctionValue((context' argument) =>              {                  var _x = (argument as ScalarValue - median / 2) / (variance / 4);                  var _exp_x_2 = (-_x * _x).Exp();                  var result = new MatrixValue(1' nP - 1);                    for (var i = 0; i < nP - 1; i++)                  {                      result[i + 1] = _exp_x_2 * _x.Pow(new ScalarValue(i));                  }                    return result;              }' true));
Magic Number,YAMP,ArtanhFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Trigonometric\ArtanhFunction.cs,GetValue,The following statement contains a magic number: return 0.5 * ((1.0 + value) / (1.0 - value)).Ln();
Magic Number,YAMP,CschFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Trigonometric\CschFunction.cs,GetValue,The following statement contains a magic number: return 2.0 / (value.Exp() - (-value).Exp());
Magic Number,YAMP,SechFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Trigonometric\SechFunction.cs,GetValue,The following statement contains a magic number: return 2.0 / (value.Exp() + (-value).Exp());
Magic Number,YAMP,ImgToRGBFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunctions\ImgToRGBFunction.cs,Function,The following statement contains a magic number: rvalues[i' j] = new ScalarValue((value / rfactor) % 256);
Magic Number,YAMP,ImgToRGBFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunctions\ImgToRGBFunction.cs,Function,The following statement contains a magic number: gvalues[i' j] = new ScalarValue((value / gfactor) % 256);
Magic Number,YAMP,ImgToRGBFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunctions\ImgToRGBFunction.cs,Function,The following statement contains a magic number: bvalues[i' j] = new ScalarValue((value / bfactor) % 256);
Magic Number,YAMP,YMath,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Providers\YMath.cs,Histogram,The following statement contains a magic number: D[i] = delta * (i + 0.5) + min;
Magic Number,YAMP,YMath,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Providers\YMath.cs,Median,The following statement contains a magic number: midPoint = M.Length / 2;
Magic Number,YAMP,YMath,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Providers\YMath.cs,Median,The following statement contains a magic number: M.Length % 2 == 1
Magic Number,YAMP,Statement,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\Statement.cs,Statement,The following statement contains a magic number: _maxLevel = -100;
Magic Number,YAMP,MandelbrotFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Fractals\MandelbrotFunction.cs,Function,The following statement contains a magic number: return m.CalculateMatrix(-2.5' 1.0' -1.0' 1.0' 150' 150);
Magic Number,YAMP,MandelbrotFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Fractals\MandelbrotFunction.cs,Function,The following statement contains a magic number: return m.CalculateMatrix(-2.5' 1.0' -1.0' 1.0' 150' 150);
Magic Number,YAMP,MandelbrotFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Fractals\MandelbrotFunction.cs,Function,The following statement contains a magic number: return m.CalculateMatrix(-2.5' 1.0' -1.0' 1.0' 150' 150);
Magic Number,YAMP,MandelbrotFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Fractals\MandelbrotFunction.cs,Function,The following statement contains a magic number: var xsteps = (Int32)Math.Abs(Math.Ceiling((xn.Re - x0.Re) / 0.1));
Magic Number,YAMP,MandelbrotFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Fractals\MandelbrotFunction.cs,Function,The following statement contains a magic number: var ysteps = (Int32)Math.Abs(Math.Ceiling((yn.Re - y0.Re) / 0.1));
Magic Number,YAMP,RootFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Numerics\RootFunction.cs,Function,The following statement contains a magic number: var newton = new NewtonMethod(lambda' x.Re' 0.00001);
Magic Number,YAMP,ACorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\ACorFunction.cs,Function,The following statement contains a magic number: var nOffset = (Int32)(10 * Math.Log10(M.Length));
Magic Number,YAMP,BootstrapFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\BootstrapFunction.cs,Function,The following statement contains a magic number: var result = new MatrixValue(2' nResult);
Magic Number,YAMP,BootstrapFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\BootstrapFunction.cs,Function,The following statement contains a magic number: result[2] = (ScalarValue)error;
Magic Number,YAMP,JackknifeFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\JackknifeFunction.cs,Function,The following statement contains a magic number: var result = new MatrixValue(2' nResult);
Magic Number,YAMP,JackknifeFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\JackknifeFunction.cs,Function,The following statement contains a magic number: result[2] = (ScalarValue)error;
Magic Number,YAMP,LsqFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\LsqFunction.cs,Function,The following statement contains a magic number: M.DimensionX != 2 && M.DimensionY != 2
Magic Number,YAMP,LsqFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\LsqFunction.cs,Function,The following statement contains a magic number: M.DimensionX != 2 && M.DimensionY != 2
Magic Number,YAMP,LsqFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\LsqFunction.cs,Function,The following statement contains a magic number: return Function(M.GetSubMatrix(0' 1' 0' M.DimensionX)' M.GetSubMatrix(1' 2' 0' M.DimensionX));
Magic Number,YAMP,LsqFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\LsqFunction.cs,Function,The following statement contains a magic number: return Function(M.GetSubMatrix(0' M.DimensionY' 0' 1)' M.GetSubMatrix(0' M.DimensionY' 1' 2));
Magic Number,YAMP,XCorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Statistics\XCorFunction.cs,Function,The following statement contains a magic number: var nOffset = (Int32)(10 * Math.Log10(M.Length));
Magic Number,YAMP,SplineFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Numerics\SplineFunction.cs,Function,The following statement contains a magic number: var M = new MatrixValue(1' 2);
Magic Number,YAMP,SplineFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Numerics\SplineFunction.cs,Function,The following statement contains a magic number: M[1' 2].Re = spline.ComputeValue(x.Re);
Magic Number,YAMP,FplotFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Visualization\FplotFunction.cs,Function,The following statement contains a magic number: return Plot(f' -1.0' 1.0' 0.05);
Magic Number,YAMP,FplotFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Visualization\FplotFunction.cs,Function,The following statement contains a magic number: return Plot(f' min.Re' max.Re' 0.05);
Magic Number,YAMP,FplotFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Visualization\FplotFunction.cs,Plot,The following statement contains a magic number: var M = new MatrixValue(N' 2);
Magic Number,YAMP,FplotFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Visualization\FplotFunction.cs,Plot,The following statement contains a magic number: M[row' 2] = (ScalarValue)y;
Magic Number,YAMP,HistFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Visualization\HistFunction.cs,Function,The following statement contains a magic number: return Function(Y' new ScalarValue(10));
Magic Number,YAMP,ArgsOperator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Operators\PseudoOperators\ArgsOperator.cs,ToDebug,The following statement contains a magic number: return string.Format(                  "{2}" + Environment.NewLine +                  "{0}{1}<" + Environment.NewLine +                  "{3}" + Environment.NewLine +                  "{0}{1}>"' pad' tab' baseDebug' _content.ToDebug(padLeft + 3 * tabsize' tabsize));
Magic Number,YAMP,ArcothFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Trigonometric\ArcothFunction.cs,GetValue,The following statement contains a magic number: return 0.5 * ((1.0 + value) / (value - 1.0)).Ln();
Magic Number,YAMP,ArgumentFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunction.cs,Compare,The following statement contains a magic number: return 100 * (y.Length - x.Length) + Math.Sign(y.Weight - x.Weight);
Magic Number,YAMP,CoshFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Trigonometric\CoshFunction.cs,GetValue,The following statement contains a magic number: return (value.Exp() + (-value).Exp()) / 2.0;
Magic Number,YAMP,SinhFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\Trigonometric\SinhFunction.cs,GetValue,The following statement contains a magic number: return (value.Exp() - (-value).Exp()) / 2.0;
Magic Number,YAMP,ParseContext,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\ParseContext.cs,ParseContext,The following statement contains a magic number: _precision = 6;
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,Parse,The following statement contains a magic number: var leftPad = 3;
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,Parse,The following statement contains a magic number: var tabSize = 4;
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsLetter,The following statement contains a magic number: return (ch >= 65 && ch <= 90) ||                  (ch >= 97 && ch <= 123);
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsLetter,The following statement contains a magic number: return (ch >= 65 && ch <= 90) ||                  (ch >= 97 && ch <= 123);
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsLetter,The following statement contains a magic number: return (ch >= 65 && ch <= 90) ||                  (ch >= 97 && ch <= 123);
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsLetter,The following statement contains a magic number: return (ch >= 65 && ch <= 90) ||                  (ch >= 97 && ch <= 123);
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierStart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||  // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||       // A..Z                  (ch >= 97 && ch <= 122);
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierStart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||  // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||       // A..Z                  (ch >= 97 && ch <= 122);
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierStart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||  // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||       // A..Z                  (ch >= 97 && ch <= 122);
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierStart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||  // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||       // A..Z                  (ch >= 97 && ch <= 122);
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierStart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||  // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||       // A..Z                  (ch >= 97 && ch <= 122);
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierStart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||  // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||       // A..Z                  (ch >= 97 && ch <= 122);
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierPart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||    // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||         // A..Z                  (ch >= 97 && ch <= 122) ||        // a..z                  (ch >= 48 && ch <= 57);
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierPart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||    // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||         // A..Z                  (ch >= 97 && ch <= 122) ||        // a..z                  (ch >= 48 && ch <= 57);
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierPart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||    // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||         // A..Z                  (ch >= 97 && ch <= 122) ||        // a..z                  (ch >= 48 && ch <= 57);
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierPart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||    // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||         // A..Z                  (ch >= 97 && ch <= 122) ||        // a..z                  (ch >= 48 && ch <= 57);
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierPart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||    // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||         // A..Z                  (ch >= 97 && ch <= 122) ||        // a..z                  (ch >= 48 && ch <= 57);
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierPart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||    // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||         // A..Z                  (ch >= 97 && ch <= 122) ||        // a..z                  (ch >= 48 && ch <= 57);
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierPart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||    // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||         // A..Z                  (ch >= 97 && ch <= 122) ||        // a..z                  (ch >= 48 && ch <= 57);
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsIdentifierPart,The following statement contains a magic number: return (ch == 36) || (ch == 95) ||    // $ (dollar) and _ (underscore)                  (ch >= 65 && ch <= 90) ||         // A..Z                  (ch >= 97 && ch <= 122) ||        // a..z                  (ch >= 48 && ch <= 57);
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsNumber,The following statement contains a magic number: return ch >= 48 && ch <= 57;
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsNumber,The following statement contains a magic number: return ch >= 48 && ch <= 57;
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsWhiteSpace,The following statement contains a magic number: return (ch == 32) ||  // space                  (ch == 9) ||      // horizontal tab                  (ch == 0xB) ||	  // vertical tab                  (ch == 0xC) ||	  // form feed / new page                  (ch == 0xA0) ||	  // non-breaking space                  (ch >= 0x1680 && unicodeWhitespaces.IndexOf(ch.ToString()) >= 0);
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsWhiteSpace,The following statement contains a magic number: return (ch == 32) ||  // space                  (ch == 9) ||      // horizontal tab                  (ch == 0xB) ||	  // vertical tab                  (ch == 0xC) ||	  // form feed / new page                  (ch == 0xA0) ||	  // non-breaking space                  (ch >= 0x1680 && unicodeWhitespaces.IndexOf(ch.ToString()) >= 0);
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsNewLine,The following statement contains a magic number: return (ch == 10) ||  // line feed                  (ch == 13) ||	  // carriage return                  (ch == 0x2028) || // line seperator                  (ch == 0x2029);
Magic Number,YAMP,ParseEngine,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Parser\ParseEngine.cs,IsNewLine,The following statement contains a magic number: return (ch == 10) ||  // line feed                  (ch == 13) ||	  // carriage return                  (ch == 0x2028) || // line seperator                  (ch == 0x2029);
Magic Number,YAMP,Deserializer,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Providers\Serialization\Deserializer.cs,GetSingle,The following statement contains a magic number: var c = new Byte[4];
Magic Number,YAMP,Deserializer,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Providers\Serialization\Deserializer.cs,GetLong,The following statement contains a magic number: var c = new Byte[8];
Magic Number,YAMP,Deserializer,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Providers\Serialization\Deserializer.cs,GetString,The following statement contains a magic number: var buffer = new Byte[4];
Magic Number,YAMP,Deserializer,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Providers\Serialization\Deserializer.cs,GetScalar,The following statement contains a magic number: var c = new Byte[16];
Magic Number,YAMP,Deserializer,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Providers\Serialization\Deserializer.cs,GetScalar,The following statement contains a magic number: var imag = BitConverter.ToDouble(c' 8);
Magic Number,YAMP,Deserializer,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Providers\Serialization\Deserializer.cs,GetDouble,The following statement contains a magic number: var c = new Byte[8];
Magic Number,YAMP,Deserializer,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Providers\Serialization\Deserializer.cs,GetInt,The following statement contains a magic number: var c = new Byte[4];
Magic Number,YAMP,ContourPlotValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\ContourPlotValue.cs,SetLevels,The following statement contains a magic number: Levels == null || Levels.Length == 0 || n < 2
Magic Number,YAMP,ContourPlotValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\ContourPlotValue.cs,AddValues,The following statement contains a magic number: SetLevels(zmin' zmax' Math.Min(Math.Max(dx' dy)' 10));
Magic Number,YAMP,Plot3DValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\Plot3DValue.cs,AddPoints,The following statement contains a magic number: zs.Length < 2
Magic Number,YAMP,PolarPlotValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\PolarPlotValue.cs,AddValues,The following statement contains a magic number: MaxX = 2.0 * Math.PI;
Magic Number,YAMP,SubPlotValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\SubPlotValue.cs,Perform,The following statement contains a magic number: throw new YAMPArgumentNumberException("SubPlot"' av.Length' 2);
Magic Number,YAMP,SubPlotValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\SubPlotValue.cs,Perform,The following statement contains a magic number: av.Length != 2
Magic Number,YAMP,SubPlotValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Plots\SubPlotValue.cs,Perform,The following statement contains a magic number: InspectIndex(av[2]' out colIndex' out colSpan);
Magic Number,YAMP,Value,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,Format,The following statement contains a magic number: t *= 10.0;
Magic Number,YAMP,Value,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,ScientificFormat,The following statement contains a magic number: return Compose(context' v * Math.Pow(10.0' 1 - U)' context.Precision' U - 1);
Magic Number,YAMP,Value,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,EngineeringFormat,The following statement contains a magic number: var pwr = 3 * ((U - 1) / 3);
Magic Number,YAMP,Value,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,EngineeringFormat,The following statement contains a magic number: var pwr = 3 * ((U - 1) / 3);
Magic Number,YAMP,Value,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,EngineeringFormat,The following statement contains a magic number: return Compose(context' v * Math.Pow(10.0' -pwr)' context.Precision' pwr);
Magic Number,YAMP,Value,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,EngineeringFormat,The following statement contains a magic number: U > 3
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Pow,The following statement contains a magic number: Value == 0.0 && Math.Abs(ImaginaryValue) < 1e-8
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Pow,The following statement contains a magic number: var theta = _real == 0.0 ? Math.PI / 2 * Math.Sign(ImaginaryValue) : Math.Atan2(_imag' _real);
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Sqrt,The following statement contains a magic number: return Pow(new ScalarValue(0.5));
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arcsin,The following statement contains a magic number: var rtp = Math.Sqrt(Math.Pow(x + 1.0' 2.0) + yy);
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arcsin,The following statement contains a magic number: var rtn = Math.Sqrt(Math.Pow(x - 1.0' 2.0) + yy);
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arcsin,The following statement contains a magic number: var alpha = 0.5 * (rtp + rtn);
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arcsin,The following statement contains a magic number: var beta = 0.5 * (rtp - rtn);
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arccos,The following statement contains a magic number: var rtp = Math.Sqrt(Math.Pow(x + 1.0' 2.0) + yy);
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arccos,The following statement contains a magic number: var rtn = Math.Sqrt(Math.Pow(x - 1.0' 2.0) + yy);
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arccos,The following statement contains a magic number: var alpha = 0.5 * (rtp + rtn);
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arccos,The following statement contains a magic number: var beta = 0.5 * (rtp - rtn);
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arctan,The following statement contains a magic number: var re = 0.5 * Math.Atan2(2.0 * x' 1.0 - xx - yy);
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arctan,The following statement contains a magic number: var re = 0.5 * Math.Atan2(2.0 * x' 1.0 - xx - yy);
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arctan,The following statement contains a magic number: var im = 0.25 * Math.Log((xx + Math.Pow(y + 1.0' 2.0)) / (xx + Math.Pow(y - 1.0' 2.0)));
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arctan,The following statement contains a magic number: var im = 0.25 * Math.Log((xx + Math.Pow(y + 1.0' 2.0)) / (xx + Math.Pow(y - 1.0' 2.0)));
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Arctan,The following statement contains a magic number: var im = 0.25 * Math.Log((xx + Math.Pow(y + 1.0' 2.0)) / (xx + Math.Pow(y - 1.0' 2.0)));
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Log10,The following statement contains a magic number: var re = Math.Log(Abs()' 10.0);
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,Deserialize,The following statement contains a magic number: var imag = BitConverter.ToDouble(content' 8);
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,IsPrimeNumber,The following statement contains a magic number: return ((n == 2) || (n == 3) || (n == 5) || (n == 7));
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,IsPrimeNumber,The following statement contains a magic number: return ((n == 2) || (n == 3) || (n == 5) || (n == 7));
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,IsPrimeNumber,The following statement contains a magic number: return ((n == 2) || (n == 3) || (n == 5) || (n == 7));
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,IsPrimeNumber,The following statement contains a magic number: return ((n == 2) || (n == 3) || (n == 5) || (n == 7));
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,IsPrimeNumber,The following statement contains a magic number: n < 8
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,IsProbablyPrime,The following statement contains a magic number: x = PowMod(x' 2' n);
Magic Number,YAMP,ScalarValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\ScalarValue.cs,ToString,The following statement contains a magic number: var f = Math.Pow(10' -exponent);
Magic Number,YAMP,NumberExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Elementary\NumberExpression.cs,Scan,The following statement contains a magic number: number *= 10.0;
Magic Number,YAMP,NumberExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Elementary\NumberExpression.cs,Scan,The following statement contains a magic number: number *= 10.0;
Magic Number,YAMP,NumberExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Elementary\NumberExpression.cs,Scan,The following statement contains a magic number: epow *= 10;
Magic Number,YAMP,NumberExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Elementary\NumberExpression.cs,Scan,The following statement contains a magic number: var value = number / Math.Pow(10.0' pow);
Magic Number,YAMP,NumberExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Elementary\NumberExpression.cs,ToDoubleNumber,The following statement contains a magic number: return (Double)p - 48.0;
Magic Number,YAMP,NumberExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Elementary\NumberExpression.cs,ToInt32Number,The following statement contains a magic number: return (Int32)p - 48;
Magic Number,YAMP,MatrixValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Deserialize,The following statement contains a magic number: var dimX = BitConverter.ToInt32(content' 4);
Magic Number,YAMP,MatrixValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Deserialize,The following statement contains a magic number: var count = BitConverter.ToInt32(content' 8);
Magic Number,YAMP,MatrixValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Deserialize,The following statement contains a magic number: var pos = 12;
Magic Number,YAMP,MatrixValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Deserialize,The following statement contains a magic number: var col = BitConverter.ToInt32(content' pos + 4);
Magic Number,YAMP,MatrixValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Deserialize,The following statement contains a magic number: var re = BitConverter.ToDouble(content' pos + 8);
Magic Number,YAMP,MatrixValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Deserialize,The following statement contains a magic number: var im = BitConverter.ToDouble(content' pos + 16);
Magic Number,YAMP,MatrixValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Deserialize,The following statement contains a magic number: pos += 24;
Magic Number,YAMP,MatrixValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Inverse,The following statement contains a magic number: DimensionX < 24
Magic Number,YAMP,MatrixValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Perform,The following statement contains a magic number: var columns = BuildIndex(ags[2]' DimensionX);
Magic Number,YAMP,MatrixValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\MatrixValue.cs,Perform,The following statement contains a magic number: var columns = BuildIndex(ags[2]' DimensionX);
Magic Number,YAMP,BinaryOperator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Operators\BinaryOperator.cs,BinaryOperator,The following statement contains a magic number: Expressions = 2;
Magic Number,YAMP,BinaryOperator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Operators\BinaryOperator.cs,Evaluate,The following statement contains a magic number: throw new YAMPArgumentNumberException(Op' expressions.Length' 2);
Magic Number,YAMP,BinaryOperator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Operators\BinaryOperator.cs,Evaluate,The following statement contains a magic number: expressions.Length != 2
Magic Number,YAMP,StringExpression,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Expressions\Elementary\StringExpression.cs,Scan,The following statement contains a magic number: index += 2;
Magic Number,YAMP,LinspaceFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunctions\LinspaceFunction.cs,Function,The following statement contains a magic number: c < 2
Magic Number,YAMP,RangeValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\RangeValue.cs,RangeValue,The following statement contains a magic number: count >= Int32.MaxValue / 10
Magic Number,YAMP,RangeValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\RangeValue.cs,Deserialize,The following statement contains a magic number: R.DimensionX = BitConverter.ToInt32(content' 4);
Magic Number,YAMP,RangeValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\RangeValue.cs,Deserialize,The following statement contains a magic number: var count = BitConverter.ToInt32(content' 8);
Magic Number,YAMP,RangeValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\RangeValue.cs,Deserialize,The following statement contains a magic number: var pos = 12;
Magic Number,YAMP,RangeValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\RangeValue.cs,Deserialize,The following statement contains a magic number: var col = BitConverter.ToInt32(content' pos + 4);
Magic Number,YAMP,RangeValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\RangeValue.cs,Deserialize,The following statement contains a magic number: var re = BitConverter.ToDouble(content' pos + 8);
Magic Number,YAMP,RangeValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\RangeValue.cs,Deserialize,The following statement contains a magic number: var im = BitConverter.ToDouble(content' pos + 16);
Magic Number,YAMP,RangeValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\RangeValue.cs,Deserialize,The following statement contains a magic number: pos += 24;
Magic Number,YAMP,RangeValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\RangeValue.cs,Deserialize,The following statement contains a magic number: R.Start = BitConverter.ToDouble(content' content.Length - 25);
Magic Number,YAMP,RangeValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\RangeValue.cs,Deserialize,The following statement contains a magic number: R.End = BitConverter.ToDouble(content' content.Length - 17);
Magic Number,YAMP,RangeValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Numeric\RangeValue.cs,Deserialize,The following statement contains a magic number: R.Step = BitConverter.ToDouble(content' content.Length - 9);
Magic Number,YAMP,LogspaceFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunctions\LogspaceFunction.cs,Function,The following statement contains a magic number: return Function(start' end' count' new ScalarValue(10));
Magic Number,YAMP,LogspaceFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\ArgumentFunctions\LogspaceFunction.cs,Function,The following statement contains a magic number: c < 2
Magic Number,YAMP,ArgumentsValue,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Arguments\ArgumentsValue.cs,Deserialize,The following statement contains a magic number: var buffer = new byte[4];
Magic Number,YAMP.Help,Documentation,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Help\Documentation.cs,ClosestEntry,The following statement contains a magic number: var sum = Distance(term' list[i]' 10);
Magic Number,YAMP.Help,Documentation,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Help\Documentation.cs,Distance,The following statement contains a magic number: return (s1.Length + s2.Length) / 2 - lcs;
Magic Number,YAMP.Numerics,Fractal,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Fractal.cs,R,The following statement contains a magic number: return Math.Max(Math.Min(c' 255)' 0);
Magic Number,YAMP.Numerics,Fractal,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Fractal.cs,G,The following statement contains a magic number: var c = (int)((color - 0.33333) * maxIterations);
Magic Number,YAMP.Numerics,Fractal,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Fractal.cs,G,The following statement contains a magic number: return Math.Max(Math.Min(c' 255)' 0);
Magic Number,YAMP.Numerics,Fractal,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Fractal.cs,B,The following statement contains a magic number: var c = (int)((color - 0.66666) * maxIterations);
Magic Number,YAMP.Numerics,Fractal,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Fractal.cs,B,The following statement contains a magic number: return Math.Max(Math.Min(c' 255)' 0);
Magic Number,YAMP.Numerics,Julia,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Julia.cs,Run,The following statement contains a magic number: i1 = 2 * i1 * r1 + _cy;
Magic Number,YAMP.Numerics,Julia,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Julia.cs,Run,The following statement contains a magic number: (iter < maxiter) && (rpow < 4)
Magic Number,YAMP.Numerics,Newton,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Newton.cs,Run,The following statement contains a magic number: pz = zn.Pow(new ScalarValue(3)) - 1.0;
Magic Number,YAMP.Numerics,Newton,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Newton.cs,Run,The following statement contains a magic number: pzd = 3.0 * zn.Square();
Magic Number,YAMP.Numerics,Newton,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Newton.cs,Run,The following statement contains a magic number: (iter < maxiter) && pz.AbsSquare() > 1e-8
Magic Number,YAMP.Numerics,Dawson,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,DawsonSeries,The following statement contains a magic number: var xx = -2.0 * x * x;
Magic Number,YAMP.Numerics,Dawson,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,DawsonSeries,The following statement contains a magic number: df = df * xx / (2 * k + 1);
Magic Number,YAMP.Numerics,Dawson,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,DawsonSeries,The following statement contains a magic number: k < 250
Magic Number,YAMP.Numerics,Dawson,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,DawsonAsymptotic,The following statement contains a magic number: var xx = 2.0 * x * x;
Magic Number,YAMP.Numerics,Dawson,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,DawsonAsymptotic,The following statement contains a magic number: var df = 0.5 / x;
Magic Number,YAMP.Numerics,Dawson,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,DawsonAsymptotic,The following statement contains a magic number: df = df * (2 * k + 1) / xx;
Magic Number,YAMP.Numerics,Dawson,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,DawsonAsymptotic,The following statement contains a magic number: k < 250
Magic Number,YAMP.Numerics,Dawson,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,DawsonRybicki,The following statement contains a magic number: var n0 = 2 * ((Int32)Math.Round(x / Dawson_Rybicki_h / 2.0));
Magic Number,YAMP.Numerics,Dawson,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,DawsonRybicki,The following statement contains a magic number: var n0 = 2 * ((Int32)Math.Round(x / Dawson_Rybicki_h / 2.0));
Magic Number,YAMP.Numerics,Dawson,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,DawsonRybicki,The following statement contains a magic number: var b = Math.Exp(2.0 * Dawson_Rybicki_h * y);
Magic Number,YAMP.Numerics,Dawson,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,DawsonRybicki,The following statement contains a magic number: var m = 2 * k + 1;
Magic Number,YAMP.Numerics,Dawson,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Dawson.cs,Compute_Dawson_Rybicki_Coefficients,The following statement contains a magic number: int m = 2 * k + 1;
Magic Number,YAMP.Numerics,BluesteinTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\BluesteinTransformlet.cs,BluesteinTransformlet,The following statement contains a magic number: Nb = SetBluesteinLength(2 * R - 1);
Magic Number,YAMP.Numerics,BluesteinTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\BluesteinTransformlet.cs,ComputeBluesteinCoefficients,The following statement contains a magic number: int TwoR = 2 * R;
Magic Number,YAMP.Numerics,BluesteinTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\BluesteinTransformlet.cs,ComputeBluesteinCoefficients,The following statement contains a magic number: s += (2 * i - 1);
Magic Number,YAMP.Numerics,BluesteinTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\BluesteinTransformlet.cs,SetBluesteinLength,The following statement contains a magic number: int t = NextPowerOfBase(N' 2);
Magic Number,YAMP.Numerics,BluesteinTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\BluesteinTransformlet.cs,SetBluesteinLength,The following statement contains a magic number: t = (M / 4) * 3;
Magic Number,YAMP.Numerics,BluesteinTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\BluesteinTransformlet.cs,SetBluesteinLength,The following statement contains a magic number: t = (M / 4) * 3;
Magic Number,YAMP.Numerics,BluesteinTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\BluesteinTransformlet.cs,SetBluesteinLength,The following statement contains a magic number: M % 4 == 0
Magic Number,YAMP.Numerics,BluesteinTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\BluesteinTransformlet.cs,SetBluesteinLength,The following statement contains a magic number: t = NextPowerOfBase(N' 3);
Magic Number,YAMP.Numerics,Fourier,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,Fourier,The following statement contains a magic number: switch (factor.Value)                  {                      // use a radix-specialized transformlet when available                      case 2:                          t = new RadixTwoTransformlet(size' roots);                          break;                      case 3:                          t = new RadixThreeTransformlet(size' roots);                          break;                      // eventually' we should make an optimized radix-4 transform                      case 5:                          t = new RadixFiveTransformlet(size' roots);                          break;                      case 7:                          t = new RadixSevenTransformlet(size' roots);                          break;                      case 11:                      case 13:                          // the base transformlet is R^2' but when R is small' this can still be faster than the Bluestein algorithm                          // timing measurements appear to indicate that this is the case for radix 11 and 13                          // eventually' we should make optimized Winograd transformlets for these factors                          t = new Transformlet(factor.Value' size' roots);                          break;                      default:                          // for large factors with no available specialized transformlet' use the Bluestein algorithm                          t = new BluesteinTransformlet(factor.Value' size' roots);                          break;                  }
Magic Number,YAMP.Numerics,Fourier,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,Fourier,The following statement contains a magic number: switch (factor.Value)                  {                      // use a radix-specialized transformlet when available                      case 2:                          t = new RadixTwoTransformlet(size' roots);                          break;                      case 3:                          t = new RadixThreeTransformlet(size' roots);                          break;                      // eventually' we should make an optimized radix-4 transform                      case 5:                          t = new RadixFiveTransformlet(size' roots);                          break;                      case 7:                          t = new RadixSevenTransformlet(size' roots);                          break;                      case 11:                      case 13:                          // the base transformlet is R^2' but when R is small' this can still be faster than the Bluestein algorithm                          // timing measurements appear to indicate that this is the case for radix 11 and 13                          // eventually' we should make optimized Winograd transformlets for these factors                          t = new Transformlet(factor.Value' size' roots);                          break;                      default:                          // for large factors with no available specialized transformlet' use the Bluestein algorithm                          t = new BluesteinTransformlet(factor.Value' size' roots);                          break;                  }
Magic Number,YAMP.Numerics,Fourier,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,Fourier,The following statement contains a magic number: switch (factor.Value)                  {                      // use a radix-specialized transformlet when available                      case 2:                          t = new RadixTwoTransformlet(size' roots);                          break;                      case 3:                          t = new RadixThreeTransformlet(size' roots);                          break;                      // eventually' we should make an optimized radix-4 transform                      case 5:                          t = new RadixFiveTransformlet(size' roots);                          break;                      case 7:                          t = new RadixSevenTransformlet(size' roots);                          break;                      case 11:                      case 13:                          // the base transformlet is R^2' but when R is small' this can still be faster than the Bluestein algorithm                          // timing measurements appear to indicate that this is the case for radix 11 and 13                          // eventually' we should make optimized Winograd transformlets for these factors                          t = new Transformlet(factor.Value' size' roots);                          break;                      default:                          // for large factors with no available specialized transformlet' use the Bluestein algorithm                          t = new BluesteinTransformlet(factor.Value' size' roots);                          break;                  }
Magic Number,YAMP.Numerics,Fourier,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,Fourier,The following statement contains a magic number: switch (factor.Value)                  {                      // use a radix-specialized transformlet when available                      case 2:                          t = new RadixTwoTransformlet(size' roots);                          break;                      case 3:                          t = new RadixThreeTransformlet(size' roots);                          break;                      // eventually' we should make an optimized radix-4 transform                      case 5:                          t = new RadixFiveTransformlet(size' roots);                          break;                      case 7:                          t = new RadixSevenTransformlet(size' roots);                          break;                      case 11:                      case 13:                          // the base transformlet is R^2' but when R is small' this can still be faster than the Bluestein algorithm                          // timing measurements appear to indicate that this is the case for radix 11 and 13                          // eventually' we should make optimized Winograd transformlets for these factors                          t = new Transformlet(factor.Value' size' roots);                          break;                      default:                          // for large factors with no available specialized transformlet' use the Bluestein algorithm                          t = new BluesteinTransformlet(factor.Value' size' roots);                          break;                  }
Magic Number,YAMP.Numerics,Fourier,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,Fourier,The following statement contains a magic number: switch (factor.Value)                  {                      // use a radix-specialized transformlet when available                      case 2:                          t = new RadixTwoTransformlet(size' roots);                          break;                      case 3:                          t = new RadixThreeTransformlet(size' roots);                          break;                      // eventually' we should make an optimized radix-4 transform                      case 5:                          t = new RadixFiveTransformlet(size' roots);                          break;                      case 7:                          t = new RadixSevenTransformlet(size' roots);                          break;                      case 11:                      case 13:                          // the base transformlet is R^2' but when R is small' this can still be faster than the Bluestein algorithm                          // timing measurements appear to indicate that this is the case for radix 11 and 13                          // eventually' we should make optimized Winograd transformlets for these factors                          t = new Transformlet(factor.Value' size' roots);                          break;                      default:                          // for large factors with no available specialized transformlet' use the Bluestein algorithm                          t = new BluesteinTransformlet(factor.Value' size' roots);                          break;                  }
Magic Number,YAMP.Numerics,Fourier,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,Fourier,The following statement contains a magic number: switch (factor.Value)                  {                      // use a radix-specialized transformlet when available                      case 2:                          t = new RadixTwoTransformlet(size' roots);                          break;                      case 3:                          t = new RadixThreeTransformlet(size' roots);                          break;                      // eventually' we should make an optimized radix-4 transform                      case 5:                          t = new RadixFiveTransformlet(size' roots);                          break;                      case 7:                          t = new RadixSevenTransformlet(size' roots);                          break;                      case 11:                      case 13:                          // the base transformlet is R^2' but when R is small' this can still be faster than the Bluestein algorithm                          // timing measurements appear to indicate that this is the case for radix 11 and 13                          // eventually' we should make optimized Winograd transformlets for these factors                          t = new Transformlet(factor.Value' size' roots);                          break;                      default:                          // for large factors with no available specialized transformlet' use the Bluestein algorithm                          t = new BluesteinTransformlet(factor.Value' size' roots);                          break;                  }
Magic Number,YAMP.Numerics,Fourier,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByTrialDivision,The following statement contains a magic number: var smallPrimes = new int[] { 2' 3' 5' 7' 11' 13' 17' 19' 23' 29' 31 };
Magic Number,YAMP.Numerics,Fourier,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByTrialDivision,The following statement contains a magic number: var smallPrimes = new int[] { 2' 3' 5' 7' 11' 13' 17' 19' 23' 29' 31 };
Magic Number,YAMP.Numerics,Fourier,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByTrialDivision,The following statement contains a magic number: var smallPrimes = new int[] { 2' 3' 5' 7' 11' 13' 17' 19' 23' 29' 31 };
Magic Number,YAMP.Numerics,Fourier,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByTrialDivision,The following statement contains a magic number: var smallPrimes = new int[] { 2' 3' 5' 7' 11' 13' 17' 19' 23' 29' 31 };
Magic Number,YAMP.Numerics,Fourier,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByTrialDivision,The following statement contains a magic number: var smallPrimes = new int[] { 2' 3' 5' 7' 11' 13' 17' 19' 23' 29' 31 };
Magic Number,YAMP.Numerics,Fourier,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByTrialDivision,The following statement contains a magic number: var smallPrimes = new int[] { 2' 3' 5' 7' 11' 13' 17' 19' 23' 29' 31 };
Magic Number,YAMP.Numerics,Fourier,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByTrialDivision,The following statement contains a magic number: var smallPrimes = new int[] { 2' 3' 5' 7' 11' 13' 17' 19' 23' 29' 31 };
Magic Number,YAMP.Numerics,Fourier,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByTrialDivision,The following statement contains a magic number: var smallPrimes = new int[] { 2' 3' 5' 7' 11' 13' 17' 19' 23' 29' 31 };
Magic Number,YAMP.Numerics,Fourier,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByTrialDivision,The following statement contains a magic number: var smallPrimes = new int[] { 2' 3' 5' 7' 11' 13' 17' 19' 23' 29' 31 };
Magic Number,YAMP.Numerics,Fourier,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByTrialDivision,The following statement contains a magic number: var smallPrimes = new int[] { 2' 3' 5' 7' 11' 13' 17' 19' 23' 29' 31 };
Magic Number,YAMP.Numerics,Fourier,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByTrialDivision,The following statement contains a magic number: var smallPrimes = new int[] { 2' 3' 5' 7' 11' 13' 17' 19' 23' 29' 31 };
Magic Number,YAMP.Numerics,Fourier,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByPollardsRhoMethod,The following statement contains a magic number: int x = 5;
Magic Number,YAMP.Numerics,Fourier,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByPollardsRhoMethod,The following statement contains a magic number: int y = 2;
Magic Number,YAMP.Numerics,Fourier,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\Fourier.cs,FactorByPollardsRhoMethod,The following statement contains a magic number: c < 250
Magic Number,YAMP.Numerics,RadixFiveTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: double a14p = x[1].Re + x[4].Re;
Magic Number,YAMP.Numerics,RadixFiveTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: double a14m = x[1].Re - x[4].Re;
Magic Number,YAMP.Numerics,RadixFiveTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: double a23p = x[2].Re + x[3].Re;
Magic Number,YAMP.Numerics,RadixFiveTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: double a23p = x[2].Re + x[3].Re;
Magic Number,YAMP.Numerics,RadixFiveTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: double a23m = x[2].Re - x[3].Re;
Magic Number,YAMP.Numerics,RadixFiveTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: double a23m = x[2].Re - x[3].Re;
Magic Number,YAMP.Numerics,RadixFiveTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: double b14p = x[1].Im + x[4].Im;
Magic Number,YAMP.Numerics,RadixFiveTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: double b14m = x[1].Im - x[4].Im;
Magic Number,YAMP.Numerics,RadixFiveTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: double b23p = x[2].Im + x[3].Im;
Magic Number,YAMP.Numerics,RadixFiveTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: double b23p = x[2].Im + x[3].Im;
Magic Number,YAMP.Numerics,RadixFiveTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: double b23m = x[2].Im - x[3].Im;
Magic Number,YAMP.Numerics,RadixFiveTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: double b23m = x[2].Im - x[3].Im;
Magic Number,YAMP.Numerics,RadixFiveTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: y[y0 + 2 * dy] = new ScalarValue(s23a - t23b' s23b + t23a);
Magic Number,YAMP.Numerics,RadixFiveTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: y[y0 + 3 * dy] = new ScalarValue(s23a + t23b' s23b - t23a);
Magic Number,YAMP.Numerics,RadixFiveTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFiveTransformlet.cs,FftKernel,The following statement contains a magic number: y[y0 + 4 * dy] = new ScalarValue(s14a + t14b' s14b - t14a);
Magic Number,YAMP.Numerics,RadixFourTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFourTransformlet.cs,FftKernel,The following statement contains a magic number: double a02p = x[0].Re + x[2].Re;
Magic Number,YAMP.Numerics,RadixFourTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFourTransformlet.cs,FftKernel,The following statement contains a magic number: double b02p = x[0].Im + x[2].Im;
Magic Number,YAMP.Numerics,RadixFourTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFourTransformlet.cs,FftKernel,The following statement contains a magic number: double a02m = x[0].Re - x[2].Re;
Magic Number,YAMP.Numerics,RadixFourTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFourTransformlet.cs,FftKernel,The following statement contains a magic number: double b02m = x[0].Im - x[2].Im;
Magic Number,YAMP.Numerics,RadixFourTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFourTransformlet.cs,FftKernel,The following statement contains a magic number: double a13p = x[1].Re + x[3].Re;
Magic Number,YAMP.Numerics,RadixFourTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFourTransformlet.cs,FftKernel,The following statement contains a magic number: double b13p = x[1].Im + x[3].Im;
Magic Number,YAMP.Numerics,RadixFourTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFourTransformlet.cs,FftKernel,The following statement contains a magic number: double b13m = x[1].Im - x[3].Im;
Magic Number,YAMP.Numerics,RadixFourTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFourTransformlet.cs,FftKernel,The following statement contains a magic number: y[y0 + 2 * dy] = new ScalarValue(a02p - a13p' b02p - b13p);
Magic Number,YAMP.Numerics,RadixFourTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixFourTransformlet.cs,FftKernel,The following statement contains a magic number: y[y0 + 3 * dy] = new ScalarValue(a02m + b13m' b02m - a13m);
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double a16p = x[1].Re + x[6].Re;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double a16m = x[1].Re - x[6].Re;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double a25p = x[2].Re + x[5].Re;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double a25p = x[2].Re + x[5].Re;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double a25m = x[2].Re - x[5].Re;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double a25m = x[2].Re - x[5].Re;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double a34p = x[3].Re + x[4].Re;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double a34p = x[3].Re + x[4].Re;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double a34m = x[3].Re - x[4].Re;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double a34m = x[3].Re - x[4].Re;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double b16p = x[1].Im + x[6].Im;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double b16m = x[1].Im - x[6].Im;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double b25p = x[2].Im + x[5].Im;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double b25p = x[2].Im + x[5].Im;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double b25m = x[2].Im - x[5].Im;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double b25m = x[2].Im - x[5].Im;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double b34p = x[3].Im + x[4].Im;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double b34p = x[3].Im + x[4].Im;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double b34m = x[3].Im - x[4].Im;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: double b34m = x[3].Im - x[4].Im;
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: y[y0 + 2 * dy] = new ScalarValue(s25a + t25b' s25b - t25a);
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: y[y0 + 3 * dy] = new ScalarValue(s34a + t34b' s34b - t34a);
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: y[y0 + 4 * dy] = new ScalarValue(s34a - t34b' s34b + t34a);
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: y[y0 + 5 * dy] = new ScalarValue(s25a - t25b' s25b + t25a);
Magic Number,YAMP.Numerics,RadixSevenTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixSevenTransformlet.cs,FftKernel,The following statement contains a magic number: y[y0 + 6 * dy] = new ScalarValue(s16a + t16b' s16b - t16a);
Magic Number,YAMP.Numerics,RadixThreeTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixThreeTransformlet.cs,FftPass,The following statement contains a magic number: int dx = N / 3;
Magic Number,YAMP.Numerics,RadixThreeTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixThreeTransformlet.cs,FftPass,The following statement contains a magic number: int y0 = Expand(j' Ns' 3);
Magic Number,YAMP.Numerics,RadixThreeTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixThreeTransformlet.cs,FftPass,The following statement contains a magic number: FftKernel(x[j]' x[j + dx] * u[N - du]' x[j + 2 * dx] * u[N - 2 * du]' out y[y0]' out y[y0 + Ns]' out y[y0 + 2 * Ns]' -1);
Magic Number,YAMP.Numerics,RadixThreeTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixThreeTransformlet.cs,FftPass,The following statement contains a magic number: FftKernel(x[j]' x[j + dx] * u[N - du]' x[j + 2 * dx] * u[N - 2 * du]' out y[y0]' out y[y0 + Ns]' out y[y0 + 2 * Ns]' -1);
Magic Number,YAMP.Numerics,RadixThreeTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixThreeTransformlet.cs,FftPass,The following statement contains a magic number: FftKernel(x[j]' x[j + dx] * u[N - du]' x[j + 2 * dx] * u[N - 2 * du]' out y[y0]' out y[y0 + Ns]' out y[y0 + 2 * Ns]' -1);
Magic Number,YAMP.Numerics,RadixTwoTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixTwoTransformlet.cs,FftPass,The following statement contains a magic number: int dx = N / 2;
Magic Number,YAMP.Numerics,RadixTwoTransformlet,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\RadixTwoTransformlet.cs,FftPass,The following statement contains a magic number: int y0 = Expand(j' Ns' 2);
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta,The following statement contains a magic number: var sin_term = (0.5 * Math.PI * s).Sin() / Math.PI;
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta,The following statement contains a magic number: var sin_term = ((s % 2.0) == 0.0) ? 0.0 : Math.Sin(0.5 * Math.PI * (s % 4.0)) / Math.PI;
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta,The following statement contains a magic number: var sin_term = ((s % 2.0) == 0.0) ? 0.0 : Math.Sin(0.5 * Math.PI * (s % 4.0)) / Math.PI;
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta,The following statement contains a magic number: var sin_term = ((s % 2.0) == 0.0) ? 0.0 : Math.Sin(0.5 * Math.PI * (s % 4.0)) / Math.PI;
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: var c = Helpers.ChebEval(zetaLt1' 2.0 * s - 1.0);
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: var f2 = 1.0 - new ScalarValue(2.0).Pow(-s);
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: var f3 = 1.0 - new ScalarValue(3.0).Pow(-s);
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: var f5 = 1.0 - new ScalarValue(5.0).Pow(-s);
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: var f7 = 1.0 - new ScalarValue(7.0).Pow(-s);
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: var c = Helpers.ChebEval(zetaLt1' 2.0 * s - 1.0);
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: var f2 = 1.0 - Math.Pow(2.0' -s);
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: var f3 = 1.0 - Math.Pow(3.0' -s);
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: var f5 = 1.0 - Math.Pow(5.0' -s);
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZetaGt0,The following statement contains a magic number: var f7 = 1.0 - Math.Pow(7.0' -s);
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: var x = (-19 - 2.0 * s) / 19.0;
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: var x = (-19 - 2.0 * s) / 19.0;
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: var x = (-19 - 2.0 * s) / 19.0;
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: s.Re > -19.0
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: var f2 = 1.0 - new ScalarValue(2.0).Pow(-(1.0 - s));
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: var f3 = 1.0 - new ScalarValue(3.0).Pow(-(1.0 - s));
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: var f5 = 1.0 - new ScalarValue(5.0).Pow(-(1.0 - s));
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: var f7 = 1.0 - new ScalarValue(7.0).Pow(-(1.0 - s));
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: var x = (-19 - 2.0 * s) / 19.0;
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: var x = (-19 - 2.0 * s) / 19.0;
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: var x = (-19 - 2.0 * s) / 19.0;
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: s > -19.0
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: var f2 = 1.0 - Math.Pow(2.0' -(1.0 - s));
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: var f3 = 1.0 - Math.Pow(3.0' -(1.0 - s));
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: var f5 = 1.0 - Math.Pow(5.0' -(1.0 - s));
Magic Number,YAMP.Numerics,Zeta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Zeta.cs,RiemannZeta1msLt0,The following statement contains a magic number: var f7 = 1.0 - Math.Pow(7.0' -(1.0 - s));
Magic Number,YAMP.Numerics,SimpsonIntegrator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Integration\SimpsonIntegrator.cs,Integrate,The following statement contains a magic number: sum += (x[i + 2].Re - x[i].Re) * (y[i].Re + 4.0 * y[i + 1].Re + y[i + 2].Re);
Magic Number,YAMP.Numerics,SimpsonIntegrator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Integration\SimpsonIntegrator.cs,Integrate,The following statement contains a magic number: sum += (x[i + 2].Re - x[i].Re) * (y[i].Re + 4.0 * y[i + 1].Re + y[i + 2].Re);
Magic Number,YAMP.Numerics,SimpsonIntegrator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Integration\SimpsonIntegrator.cs,Integrate,The following statement contains a magic number: sum += (x[i + 2].Re - x[i].Re) * (y[i].Re + 4.0 * y[i + 1].Re + y[i + 2].Re);
Magic Number,YAMP.Numerics,SimpsonIntegrator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Integration\SimpsonIntegrator.cs,Integrate,The following statement contains a magic number: return new ScalarValue(sum / 6.0);
Magic Number,YAMP.Numerics,TrapezIntegrator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Integration\TrapezIntegrator.cs,Integrate,The following statement contains a magic number: var sum = (x[2].Re - x[1].Re) * y[1] + (x[N].Re - x[N - 1].Re) * y[N];
Magic Number,YAMP.Numerics,TrapezIntegrator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Integration\TrapezIntegrator.cs,Integrate,The following statement contains a magic number: return 0.5 * sum;
Magic Number,YAMP.Numerics,Interpolation,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\Interpolation.cs,Interpolation,The following statement contains a magic number: new YAMPMatrixDimensionException(samples.DimensionY' 2' samples.DimensionY' samples.DimensionX);
Magic Number,YAMP.Numerics,Interpolation,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\Interpolation.cs,Interpolation,The following statement contains a magic number: samples.DimensionX != 2
Magic Number,YAMP.Numerics,NewtonInterpolation,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\NewtonInterpolation.cs,ComputeValue,The following statement contains a magic number: F += Samples[j' 2].Re / XX;
Magic Number,YAMP.Numerics,SplineInterpolation,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,SplineInterpolation,The following statement contains a magic number: diag[j] = (h[j] + h[j + 1]) / 3;
Magic Number,YAMP.Numerics,SplineInterpolation,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,SplineInterpolation,The following statement contains a magic number: sup[j] = h[j + 1] / 6;
Magic Number,YAMP.Numerics,SplineInterpolation,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,SplineInterpolation,The following statement contains a magic number: sub[j] = h[j] / 6;
Magic Number,YAMP.Numerics,SplineInterpolation,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,SplineInterpolation,The following statement contains a magic number: a[j] = (samples[i + 1' 2].Re - samples[i' 2].Re) / h[j + 1] - (samples[i' 2].Re - samples[i - 1' 2].Re) / h[j];
Magic Number,YAMP.Numerics,SplineInterpolation,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,SplineInterpolation,The following statement contains a magic number: a[j] = (samples[i + 1' 2].Re - samples[i' 2].Re) / h[j + 1] - (samples[i' 2].Re - samples[i - 1' 2].Re) / h[j];
Magic Number,YAMP.Numerics,SplineInterpolation,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,SplineInterpolation,The following statement contains a magic number: a[j] = (samples[i + 1' 2].Re - samples[i' 2].Re) / h[j + 1] - (samples[i' 2].Re - samples[i - 1' 2].Re) / h[j];
Magic Number,YAMP.Numerics,SplineInterpolation,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,SplineInterpolation,The following statement contains a magic number: a[j] = (samples[i + 1' 2].Re - samples[i' 2].Re) / h[j + 1] - (samples[i' 2].Re - samples[i - 1' 2].Re) / h[j];
Magic Number,YAMP.Numerics,SplineInterpolation,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,SplineInterpolation,The following statement contains a magic number: SolveTridiag(sub' diag' sup' ref a' Np - 2);
Magic Number,YAMP.Numerics,SplineInterpolation,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,SplineInterpolation,The following statement contains a magic number: Np > 2
Magic Number,YAMP.Numerics,SplineInterpolation,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,ComputeValue,The following statement contains a magic number: return ((-a[gap - 1] / 6 * (x2 + h[gap]) * x1 + samples[gap' 2].Re) * x2 + (-a[gap] / 6 * (x1 + h[gap]) * x2 + samples[gap + 1' 2].Re) * x1) / h[gap];
Magic Number,YAMP.Numerics,SplineInterpolation,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,ComputeValue,The following statement contains a magic number: return ((-a[gap - 1] / 6 * (x2 + h[gap]) * x1 + samples[gap' 2].Re) * x2 + (-a[gap] / 6 * (x1 + h[gap]) * x2 + samples[gap + 1' 2].Re) * x1) / h[gap];
Magic Number,YAMP.Numerics,SplineInterpolation,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,ComputeValue,The following statement contains a magic number: return ((-a[gap - 1] / 6 * (x2 + h[gap]) * x1 + samples[gap' 2].Re) * x2 + (-a[gap] / 6 * (x1 + h[gap]) * x2 + samples[gap + 1' 2].Re) * x1) / h[gap];
Magic Number,YAMP.Numerics,SplineInterpolation,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Interpolations\SplineInterpolation.cs,ComputeValue,The following statement contains a magic number: return ((-a[gap - 1] / 6 * (x2 + h[gap]) * x1 + samples[gap' 2].Re) * x2 + (-a[gap] / 6 * (x1 + h[gap]) * x2 + samples[gap + 1' 2].Re) * x1) / h[gap];
Magic Number,YAMP.Numerics,HalfDivisionMethod,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\NonLinear\HalfDivisionMethod.cs,HalfDivisionMethod,The following statement contains a magic number: Result = new double[2' 1];
Magic Number,YAMP.Numerics,HalfDivisionMethod,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\NonLinear\HalfDivisionMethod.cs,HalfDivisionMethod,The following statement contains a magic number: x2 = (x0 + x1) / 2;
Magic Number,YAMP.Numerics,SecantMethod,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\NonLinear\SecantMethod.cs,SecantMethod,The following statement contains a magic number: Result = new double[2' 1];
Magic Number,YAMP.Numerics,SecantMethod,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\NonLinear\SecantMethod.cs,SecantMethod,The following statement contains a magic number: i <= 10
Magic Number,YAMP.Numerics,Euler,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\Euler.cs,Calculate,The following statement contains a magic number: double['] result = new double[pointsNum + 1' 2];
Magic Number,YAMP.Numerics,Euler,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\Euler.cs,Calculate,The following statement contains a magic number: y = y1 + (h / 2) * (f(x' y) + f(x + h' y + h * f1));
Magic Number,YAMP.Numerics,RungeKutta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\RungeKutta.cs,Calculate,The following statement contains a magic number: double['] result = new double[pointsNum + 1' 2];
Magic Number,YAMP.Numerics,RungeKutta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\RungeKutta.cs,Calculate,The following statement contains a magic number: x = x + h / 2;
Magic Number,YAMP.Numerics,RungeKutta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\RungeKutta.cs,Calculate,The following statement contains a magic number: y = y1 + k1 / 2;
Magic Number,YAMP.Numerics,RungeKutta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\RungeKutta.cs,Calculate,The following statement contains a magic number: y = y1 + k2 / 2;
Magic Number,YAMP.Numerics,RungeKutta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\RungeKutta.cs,Calculate,The following statement contains a magic number: x = x + h / 2;
Magic Number,YAMP.Numerics,RungeKutta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\RungeKutta.cs,Calculate,The following statement contains a magic number: y = y1 + (k1 + 2 * k2 + 2 * k3 + f(x' y) * h) / 6;
Magic Number,YAMP.Numerics,RungeKutta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\RungeKutta.cs,Calculate,The following statement contains a magic number: y = y1 + (k1 + 2 * k2 + 2 * k3 + f(x' y) * h) / 6;
Magic Number,YAMP.Numerics,RungeKutta,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\ODE\RungeKutta.cs,Calculate,The following statement contains a magic number: y = y1 + (k1 + 2 * k2 + 2 * k3 + f(x' y) * h) / 6;
Magic Number,YAMP.Numerics,GoldenSection,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\GoldenSection.cs,GoldenSection,The following statement contains a magic number: s1 = (3 - Math.Sqrt(5)) / 2;
Magic Number,YAMP.Numerics,GoldenSection,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\GoldenSection.cs,GoldenSection,The following statement contains a magic number: s1 = (3 - Math.Sqrt(5)) / 2;
Magic Number,YAMP.Numerics,GoldenSection,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\GoldenSection.cs,GoldenSection,The following statement contains a magic number: s1 = (3 - Math.Sqrt(5)) / 2;
Magic Number,YAMP.Numerics,GoldenSection,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\GoldenSection.cs,GoldenSection,The following statement contains a magic number: s2 = (Math.Sqrt(5) - 1) / 2;
Magic Number,YAMP.Numerics,GoldenSection,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\GoldenSection.cs,GoldenSection,The following statement contains a magic number: s2 = (Math.Sqrt(5) - 1) / 2;
Magic Number,YAMP.Numerics,Pijavsky,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\Pijavsky.cs,Pijavsky,The following statement contains a magic number: points = new double[n + 2];
Magic Number,YAMP.Numerics,Pijavsky,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\Pijavsky.cs,Pijavsky,The following statement contains a magic number: values = new double[n + 2];
Magic Number,YAMP.Numerics,Pijavsky,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\Pijavsky.cs,Pijavsky,The following statement contains a magic number: ratings = new double[n + 2];
Magic Number,YAMP.Numerics,Pijavsky,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\Pijavsky.cs,Pijavsky,The following statement contains a magic number: ratings[j] = l / 2.0 * (points[j] - points[j - 1]) - 0.5 * (values[j] + values[j - 1]);
Magic Number,YAMP.Numerics,Pijavsky,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\Pijavsky.cs,Pijavsky,The following statement contains a magic number: ratings[j] = l / 2.0 * (points[j] - points[j - 1]) - 0.5 * (values[j] + values[j - 1]);
Magic Number,YAMP.Numerics,Pijavsky,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\Pijavsky.cs,Pijavsky,The following statement contains a magic number: points[i] = 0.5 * (points[maxratingpos] + points[maxratingpos - 1]) - 0.5 / l * (values[maxratingpos] - values[maxratingpos - 1]);
Magic Number,YAMP.Numerics,Pijavsky,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\Pijavsky.cs,Pijavsky,The following statement contains a magic number: points[i] = 0.5 * (points[maxratingpos] + points[maxratingpos - 1]) - 0.5 / l * (values[maxratingpos] - values[maxratingpos - 1]);
Magic Number,YAMP.Numerics,Pijavsky,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Optimization\Pijavsky.cs,Pijavsky,The following statement contains a magic number: j >= 2
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: var ans1 = 57568490574.0 + y * (-13362590354.0 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: var ans2 = 57568490411.0 + y * (1029532985.0 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y * 1.0))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j0,The following statement contains a magic number: (ax = Math.Abs(x)) < 8.0
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: ans1 = x * (72362614232.0 + y * (-7895059235.0 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: ans2 = 144725228442.0 + y * (2300535178.0 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y * 1.0))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,j1,The following statement contains a magic number: (ax = Math.Abs(x)) < 8.0
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,jn,The following statement contains a magic number: double ACC = 40.0;
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,jn,The following statement contains a magic number: double BIGNO = 1.0e+10;
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,jn,The following statement contains a magic number: double BIGNI = 1.0e-10;
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,jn,The following statement contains a magic number: return x < 0.0 && n % 2 == 1 ? -ans : ans;
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: var ans1 = -2957821389.0 + y * (7062834065.0 + y * (-512359803.6 + y * (10879881.29 + y * (-86327.92757 + y * 228.4622733))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: var ans2 = 40076544269.0 + y * (745249964.8 + y * (7189466.438 + y * (47447.26470 + y * (226.1030244 + y * 1.0))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: return (ans1 / ans2) + 0.636619772 * j0(x) * Math.Log(x);
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y0,The following statement contains a magic number: x < 8.0
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: var ans1 = x * (-0.4900604943e13 + y * (0.1275274390e13 + y * (-0.5153438139e11 + y * (0.7349264551e9 + y * (-0.4237922726e7 + y * 0.8511937935e4)))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: var ans2 = 0.2499580570e14 + y * (0.4244419664e12 + y * (0.3733650367e10 + y * (0.2245904002e8 + y * (0.1020426050e6 + y * (0.3549632885e3 + y)))));
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: return (ans1 / ans2) + 0.636619772 * (j1(x) * Math.Log(x) - 1.0 / x);
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,y1,The following statement contains a magic number: x < 8.0
Magic Number,YAMP.Numerics,Bessel,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Bessel.cs,yn,The following statement contains a magic number: tox = 2.0 / x;
Magic Number,YAMP.Numerics,Eigenvalues,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,tql2,The following statement contains a magic number: var eps = Math.Pow(2.0' -52.0);
Magic Number,YAMP.Numerics,Eigenvalues,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,tql2,The following statement contains a magic number: var eps = Math.Pow(2.0' -52.0);
Magic Number,YAMP.Numerics,Eigenvalues,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,tql2,The following statement contains a magic number: var p = (d[l + 1] - g) / (2.0 * e[l]);
Magic Number,YAMP.Numerics,Eigenvalues,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: var eps = Math.Pow(2.0' -52.0);
Magic Number,YAMP.Numerics,Eigenvalues,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Eigenvalues.cs,hqr2,The following statement contains a magic number: var eps = Math.Pow(2.0' -52.0);
Magic Number,YAMP.Numerics,SingularValueDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: int nrt = Math.Max(0' Math.Min(n - 2' m));
Magic Number,YAMP.Numerics,SingularValueDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: var eps = Math.Pow(2.0' -52.0);
Magic Number,YAMP.Numerics,SingularValueDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: var eps = Math.Pow(2.0' -52.0);
Magic Number,YAMP.Numerics,SingularValueDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: kase = 4;
Magic Number,YAMP.Numerics,SingularValueDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: k == p - 2
Magic Number,YAMP.Numerics,SingularValueDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
Magic Number,YAMP.Numerics,SingularValueDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
Magic Number,YAMP.Numerics,SingularValueDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
Magic Number,YAMP.Numerics,SingularValueDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
Magic Number,YAMP.Numerics,SingularValueDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
Magic Number,YAMP.Numerics,SingularValueDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
Magic Number,YAMP.Numerics,SingularValueDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
Magic Number,YAMP.Numerics,SingularValueDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
Magic Number,YAMP.Numerics,SingularValueDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
Magic Number,YAMP.Numerics,SingularValueDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
Magic Number,YAMP.Numerics,SingularValueDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
Magic Number,YAMP.Numerics,SingularValueDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
Magic Number,YAMP.Numerics,SingularValueDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,Rank,The following statement contains a magic number: var eps = Math.Pow(2.0' -52.0);
Magic Number,YAMP.Numerics,SingularValueDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,Rank,The following statement contains a magic number: var eps = Math.Pow(2.0' -52.0);
Magic Number,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,IsPrimeNumber,The following statement contains a magic number: return ((n == 2) || (n == 3) || (n == 5) || (n == 7));
Magic Number,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,IsPrimeNumber,The following statement contains a magic number: return ((n == 2) || (n == 3) || (n == 5) || (n == 7));
Magic Number,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,IsPrimeNumber,The following statement contains a magic number: return ((n == 2) || (n == 3) || (n == 5) || (n == 7));
Magic Number,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,IsPrimeNumber,The following statement contains a magic number: return ((n == 2) || (n == 3) || (n == 5) || (n == 7));
Magic Number,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,IsPrimeNumber,The following statement contains a magic number: n < 8
Magic Number,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,IsProbablyPrime,The following statement contains a magic number: x = PowMod(x' 2' n);
Magic Number,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,GCD,The following statement contains a magic number: f = 2 * f;
Magic Number,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,GCD,The following statement contains a magic number: A = A / 2;
Magic Number,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,GCD,The following statement contains a magic number: B = B / 2;
Magic Number,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,GCD,The following statement contains a magic number: (A % 2 == 0) && (B % 2 == 0)
Magic Number,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,GCD,The following statement contains a magic number: (A % 2 == 0) && (B % 2 == 0)
Magic Number,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,Factorial,The following statement contains a magic number: n < 34
Magic Number,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: return (u0 - u2) / 2.0;
Magic Number,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: Math.Abs(x) < 0.6
Magic Number,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: var xx = (x - 0.5) - 0.5;
Magic Number,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: var xx = (x - 0.5) - 0.5;
Magic Number,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: return (d1 + d2) / 2.0;
Magic Number,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: var y = (2.0 * x - cs.LowerPoint - cs.UpperPoint) / (cs.UpperPoint - cs.LowerPoint);
Magic Number,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: var y2 = 2.0 * y;
Magic Number,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: return y * d - dd + 0.5 * cs.Coefficients[0];
Magic Number,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: var y = (2.0 * z - cs.LowerPoint - cs.UpperPoint) / (cs.UpperPoint - cs.LowerPoint);
Magic Number,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: var y2 = 2.0 * y;
Magic Number,YAMP.Numerics,Helpers,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Helpers.cs,ChebEval,The following statement contains a magic number: return y * d - dd + 0.5 * cs.Coefficients[0];
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: double[] T = {  				9.60497373987051638749E0'  				9.00260197203842689217E1'  				2.23200534594684319226E3'  				7.00332514112805075473E3'  				5.55923013010394962768E4  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: double[] T = {  				9.60497373987051638749E0'  				9.00260197203842689217E1'  				2.23200534594684319226E3'  				7.00332514112805075473E3'  				5.55923013010394962768E4  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: double[] T = {  				9.60497373987051638749E0'  				9.00260197203842689217E1'  				2.23200534594684319226E3'  				7.00332514112805075473E3'  				5.55923013010394962768E4  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: double[] T = {  				9.60497373987051638749E0'  				9.00260197203842689217E1'  				2.23200534594684319226E3'  				7.00332514112805075473E3'  				5.55923013010394962768E4  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: double[] T = {  				9.60497373987051638749E0'  				9.00260197203842689217E1'  				2.23200534594684319226E3'  				7.00332514112805075473E3'  				5.55923013010394962768E4  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: double[] U = {  				3.35617141647503099647E1'  				5.21357949780152679795E2'  				4.59432382970980127987E3'  				2.26290000613890934246E4'  				4.92673942608635921086E4  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: double[] U = {  				3.35617141647503099647E1'  				5.21357949780152679795E2'  				4.59432382970980127987E3'  				2.26290000613890934246E4'  				4.92673942608635921086E4  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: double[] U = {  				3.35617141647503099647E1'  				5.21357949780152679795E2'  				4.59432382970980127987E3'  				2.26290000613890934246E4'  				4.92673942608635921086E4  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: double[] U = {  				3.35617141647503099647E1'  				5.21357949780152679795E2'  				4.59432382970980127987E3'  				2.26290000613890934246E4'  				4.92673942608635921086E4  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: double[] U = {  				3.35617141647503099647E1'  				5.21357949780152679795E2'  				4.59432382970980127987E3'  				2.26290000613890934246E4'  				4.92673942608635921086E4  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: y = x * polevl(z' T' 4) / p1evl(z' U' 5);
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: y = x * polevl(z' T' 4) / p1evl(z' U' 5);
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] P = {  				2.46196981473530512524E-10'  				5.64189564831068821977E-1'  				7.46321056442269912687E0'  				4.86371970985681366614E1'  				1.96520832956077098242E2'  				5.26445194995477358631E2'  				9.34528527171957607540E2'  				1.02755188689515710272E3'  				5.57535335369399327526E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] P = {  				2.46196981473530512524E-10'  				5.64189564831068821977E-1'  				7.46321056442269912687E0'  				4.86371970985681366614E1'  				1.96520832956077098242E2'  				5.26445194995477358631E2'  				9.34528527171957607540E2'  				1.02755188689515710272E3'  				5.57535335369399327526E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] P = {  				2.46196981473530512524E-10'  				5.64189564831068821977E-1'  				7.46321056442269912687E0'  				4.86371970985681366614E1'  				1.96520832956077098242E2'  				5.26445194995477358631E2'  				9.34528527171957607540E2'  				1.02755188689515710272E3'  				5.57535335369399327526E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] P = {  				2.46196981473530512524E-10'  				5.64189564831068821977E-1'  				7.46321056442269912687E0'  				4.86371970985681366614E1'  				1.96520832956077098242E2'  				5.26445194995477358631E2'  				9.34528527171957607540E2'  				1.02755188689515710272E3'  				5.57535335369399327526E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] P = {  				2.46196981473530512524E-10'  				5.64189564831068821977E-1'  				7.46321056442269912687E0'  				4.86371970985681366614E1'  				1.96520832956077098242E2'  				5.26445194995477358631E2'  				9.34528527171957607540E2'  				1.02755188689515710272E3'  				5.57535335369399327526E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] P = {  				2.46196981473530512524E-10'  				5.64189564831068821977E-1'  				7.46321056442269912687E0'  				4.86371970985681366614E1'  				1.96520832956077098242E2'  				5.26445194995477358631E2'  				9.34528527171957607540E2'  				1.02755188689515710272E3'  				5.57535335369399327526E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] P = {  				2.46196981473530512524E-10'  				5.64189564831068821977E-1'  				7.46321056442269912687E0'  				4.86371970985681366614E1'  				1.96520832956077098242E2'  				5.26445194995477358631E2'  				9.34528527171957607540E2'  				1.02755188689515710272E3'  				5.57535335369399327526E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] P = {  				2.46196981473530512524E-10'  				5.64189564831068821977E-1'  				7.46321056442269912687E0'  				4.86371970985681366614E1'  				1.96520832956077098242E2'  				5.26445194995477358631E2'  				9.34528527171957607540E2'  				1.02755188689515710272E3'  				5.57535335369399327526E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] P = {  				2.46196981473530512524E-10'  				5.64189564831068821977E-1'  				7.46321056442269912687E0'  				4.86371970985681366614E1'  				1.96520832956077098242E2'  				5.26445194995477358631E2'  				9.34528527171957607540E2'  				1.02755188689515710272E3'  				5.57535335369399327526E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] Q = {  				1.32281951154744992508E1'  				8.67072140885989742329E1'  				3.54937778887819891062E2'  				9.75708501743205489753E2'  				1.82390916687909736289E3'  				2.24633760818710981792E3'  				1.65666309194161350182E3'  				5.57535340817727675546E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] Q = {  				1.32281951154744992508E1'  				8.67072140885989742329E1'  				3.54937778887819891062E2'  				9.75708501743205489753E2'  				1.82390916687909736289E3'  				2.24633760818710981792E3'  				1.65666309194161350182E3'  				5.57535340817727675546E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] Q = {  				1.32281951154744992508E1'  				8.67072140885989742329E1'  				3.54937778887819891062E2'  				9.75708501743205489753E2'  				1.82390916687909736289E3'  				2.24633760818710981792E3'  				1.65666309194161350182E3'  				5.57535340817727675546E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] Q = {  				1.32281951154744992508E1'  				8.67072140885989742329E1'  				3.54937778887819891062E2'  				9.75708501743205489753E2'  				1.82390916687909736289E3'  				2.24633760818710981792E3'  				1.65666309194161350182E3'  				5.57535340817727675546E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] Q = {  				1.32281951154744992508E1'  				8.67072140885989742329E1'  				3.54937778887819891062E2'  				9.75708501743205489753E2'  				1.82390916687909736289E3'  				2.24633760818710981792E3'  				1.65666309194161350182E3'  				5.57535340817727675546E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] Q = {  				1.32281951154744992508E1'  				8.67072140885989742329E1'  				3.54937778887819891062E2'  				9.75708501743205489753E2'  				1.82390916687909736289E3'  				2.24633760818710981792E3'  				1.65666309194161350182E3'  				5.57535340817727675546E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] Q = {  				1.32281951154744992508E1'  				8.67072140885989742329E1'  				3.54937778887819891062E2'  				9.75708501743205489753E2'  				1.82390916687909736289E3'  				2.24633760818710981792E3'  				1.65666309194161350182E3'  				5.57535340817727675546E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] Q = {  				1.32281951154744992508E1'  				8.67072140885989742329E1'  				3.54937778887819891062E2'  				9.75708501743205489753E2'  				1.82390916687909736289E3'  				2.24633760818710981792E3'  				1.65666309194161350182E3'  				5.57535340817727675546E2  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] R = {  				5.64189583547755073984E-1'  				1.27536670759978104416E0'  				5.01905042251180477414E0'  				6.16021097993053585195E0'  				7.40974269950448939160E0'  				2.97886665372100240670E0  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] R = {  				5.64189583547755073984E-1'  				1.27536670759978104416E0'  				5.01905042251180477414E0'  				6.16021097993053585195E0'  				7.40974269950448939160E0'  				2.97886665372100240670E0  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] R = {  				5.64189583547755073984E-1'  				1.27536670759978104416E0'  				5.01905042251180477414E0'  				6.16021097993053585195E0'  				7.40974269950448939160E0'  				2.97886665372100240670E0  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] R = {  				5.64189583547755073984E-1'  				1.27536670759978104416E0'  				5.01905042251180477414E0'  				6.16021097993053585195E0'  				7.40974269950448939160E0'  				2.97886665372100240670E0  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] R = {  				5.64189583547755073984E-1'  				1.27536670759978104416E0'  				5.01905042251180477414E0'  				6.16021097993053585195E0'  				7.40974269950448939160E0'  				2.97886665372100240670E0  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] R = {  				5.64189583547755073984E-1'  				1.27536670759978104416E0'  				5.01905042251180477414E0'  				6.16021097993053585195E0'  				7.40974269950448939160E0'  				2.97886665372100240670E0  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] S = {  				2.26052863220117276590E0'  				9.39603524938001434673E0'  				1.20489539808096656605E1'  				1.70814450747565897222E1'  				9.60896809063285878198E0'  				3.36907645100081516050E0  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] S = {  				2.26052863220117276590E0'  				9.39603524938001434673E0'  				1.20489539808096656605E1'  				1.70814450747565897222E1'  				9.60896809063285878198E0'  				3.36907645100081516050E0  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] S = {  				2.26052863220117276590E0'  				9.39603524938001434673E0'  				1.20489539808096656605E1'  				1.70814450747565897222E1'  				9.60896809063285878198E0'  				3.36907645100081516050E0  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] S = {  				2.26052863220117276590E0'  				9.39603524938001434673E0'  				1.20489539808096656605E1'  				1.70814450747565897222E1'  				9.60896809063285878198E0'  				3.36907645100081516050E0  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] S = {  				2.26052863220117276590E0'  				9.39603524938001434673E0'  				1.20489539808096656605E1'  				1.70814450747565897222E1'  				9.60896809063285878198E0'  				3.36907645100081516050E0  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: double[] S = {  				2.26052863220117276590E0'  				9.39603524938001434673E0'  				1.20489539808096656605E1'  				1.70814450747565897222E1'  				9.60896809063285878198E0'  				3.36907645100081516050E0  			};
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: return (2.0);
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: p = polevl(x' P' 8);
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: q = p1evl(x' Q' 8);
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: x < 8.0
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: y = 2.0 - y;
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erfc,The following statement contains a magic number: return 2.0;
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf,The following statement contains a magic number: z.Abs() < 4.0
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Faddeeva,The following statement contains a magic number: return 2.0 * (-z * z).Exp() - Faddeeva(-z);
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Faddeeva,The following statement contains a magic number: r < 2.0
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf_Series,The following statement contains a magic number: var zp = 2.0 / Helpers.SqrtPI * z;
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf_Series,The following statement contains a magic number: f += zp / (2 * k + 1);
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Erf_Series,The following statement contains a magic number: k < 250
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Weideman,The following statement contains a magic number: var f = new ScalarValue(WeidemanCoefficients[40]);
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Weideman,The following statement contains a magic number: return 2.0 / ZP * f * ZQ + 1.0 / Helpers.SqrtPI / ZD;
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,ContinuedFraction,The following statement contains a magic number: a = -k / 2.0;
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,ContinuedFraction,The following statement contains a magic number: k < 250
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Taylor,The following statement contains a magic number: var wp = 2.0 * (ScalarValue.I / Helpers.SqrtPI - z0 * w0);
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Taylor,The following statement contains a magic number: var wp_new = -2.0 * (z0 * wp + (k - 1) * wp_old);
Magic Number,YAMP.Numerics,ErrorFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\ErrorFunction.cs,Taylor,The following statement contains a magic number: k < 250
Magic Number,YAMP.Numerics,FFT,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\FFT.cs,fft,The following statement contains a magic number: length % 2 != 0
Magic Number,YAMP.Numerics,FFT,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\FFT.cs,fft,The following statement contains a magic number: var even = new MatrixValue(length / 2' 1);
Magic Number,YAMP.Numerics,FFT,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\FFT.cs,fft,The following statement contains a magic number: even[k] = x[2 * k];
Magic Number,YAMP.Numerics,FFT,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\FFT.cs,fft,The following statement contains a magic number: odd[k] = x[2 * k - 1];
Magic Number,YAMP.Numerics,FFT,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\FFT.cs,fft,The following statement contains a magic number: var value = -2 * (k - 1) * Math.PI / length;
Magic Number,YAMP.Numerics,FFT,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Spectroscopy\FFT.cs,ifft,The following statement contains a magic number: length % 2 != 0
Magic Number,YAMP.Numerics,Gamma,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LinearGamma,The following statement contains a magic number: z.Re < 0.5
Magic Number,YAMP.Numerics,Gamma,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma,The following statement contains a magic number: z.Abs() > 15.0
Magic Number,YAMP.Numerics,Gamma,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: var f = (x - 0.5) * Math.Log(x) - x + Math.Log(2.0 * Math.PI) / 2.0;
Magic Number,YAMP.Numerics,Gamma,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: var f = (x - 0.5) * Math.Log(x) - x + Math.Log(2.0 * Math.PI) / 2.0;
Magic Number,YAMP.Numerics,Gamma,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: var f = (x - 0.5) * Math.Log(x) - x + Math.Log(2.0 * Math.PI) / 2.0;
Magic Number,YAMP.Numerics,Gamma,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: f += Helpers.BernoulliNumbers[i] / (2 * i) / (2 * i - 1) / xp;
Magic Number,YAMP.Numerics,Gamma,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: f += Helpers.BernoulliNumbers[i] / (2 * i) / (2 * i - 1) / xp;
Magic Number,YAMP.Numerics,Gamma,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: i < 10
Magic Number,YAMP.Numerics,Gamma,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: var f = (z - 0.5) * z.Ln() - z + Math.Log(2.0 * Math.PI) / 2.0;
Magic Number,YAMP.Numerics,Gamma,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: var f = (z - 0.5) * z.Ln() - z + Math.Log(2.0 * Math.PI) / 2.0;
Magic Number,YAMP.Numerics,Gamma,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: var f = (z - 0.5) * z.Ln() - z + Math.Log(2.0 * Math.PI) / 2.0;
Magic Number,YAMP.Numerics,Gamma,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: var reduce = f.Im / (2.0 * Math.PI);
Magic Number,YAMP.Numerics,Gamma,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: reduce = f.Im - (int)(reduce) * 2.0 * Math.PI;
Magic Number,YAMP.Numerics,Gamma,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: f += Helpers.BernoulliNumbers[i] / (2 * i) / (2 * i - 1) / zp;
Magic Number,YAMP.Numerics,Gamma,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: f += Helpers.BernoulliNumbers[i] / (2 * i) / (2 * i - 1) / zp;
Magic Number,YAMP.Numerics,Gamma,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LogGamma_Stirling,The following statement contains a magic number: i < 10
Magic Number,YAMP.Numerics,Gamma,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LanczosLogGamma,The following statement contains a magic number: sum = 2.0 / Math.Sqrt(Math.PI) * sum / x;
Magic Number,YAMP.Numerics,Gamma,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LanczosLogGamma,The following statement contains a magic number: var xshift = x + 0.5;
Magic Number,YAMP.Numerics,Gamma,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LanczosLogGamma,The following statement contains a magic number: sum = (2.0 / Math.Sqrt(Math.PI)) * (sum / z);
Magic Number,YAMP.Numerics,Gamma,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LanczosLogGamma,The following statement contains a magic number: var zshift = z + 0.5;
Magic Number,YAMP.Numerics,Gamma,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,LanczosPsi,The following statement contains a magic number: var xx = x + Helpers.LanczosR + 0.5;
Magic Number,YAMP.Numerics,Gamma,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,Psi_Stirling,The following statement contains a magic number: var f = Math.Log(x) - 1.0 / (2.0 * x);
Magic Number,YAMP.Numerics,Gamma,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,Psi_Stirling,The following statement contains a magic number: f -= Helpers.BernoulliNumbers[i] / (2 * i) / xp;
Magic Number,YAMP.Numerics,Gamma,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Others\Gamma.cs,Psi_Stirling,The following statement contains a magic number: i < 10
Magic Number,YAMP.Numerics,Mandelbrot,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Mandelbrot.cs,Run,The following statement contains a magic number: i1 = 2.0 * i1 * r1 + y;
Magic Number,YAMP.Numerics,Mandelbrot,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Fractals\Mandelbrot.cs,Run,The following statement contains a magic number: (iter < maxiter) && (rpow < 4)
Magic Number,YAMP.Numerics,BinomialDistribution,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\BinomialDistribution.cs,BinomialDistribution,The following statement contains a magic number: this.alpha = 0.5;
Magic Number,YAMP.Numerics,BinomialDistribution,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\BinomialDistribution.cs,BinomialDistribution,The following statement contains a magic number: this.alpha = 0.5;
Magic Number,YAMP.Numerics,LaplaceDistribution,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\LaplaceDistribution.cs,NextDouble,The following statement contains a magic number: double rand = 0.5 - this.Generator.NextDouble();
Magic Number,YAMP.Numerics,LaplaceDistribution,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\LaplaceDistribution.cs,NextDouble,The following statement contains a magic number: return this.mu - this.alpha * Math.Sign(rand) * Math.Log(2.0 * Math.Abs(rand));
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,MT19937Generator,The following statement contains a magic number: this.seed = 19650218U;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,MT19937Generator,The following statement contains a magic number: this.seed = 19650218U;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,ResetGenerator,The following statement contains a magic number: this.mt[mti] = (1812433253U * (this.mt[this.mti - 1] ^ (this.mt[this.mti - 1] >> 30)) + this.mti);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,ResetGenerator,The following statement contains a magic number: this.mt[mti] = (1812433253U * (this.mt[this.mti - 1] ^ (this.mt[this.mti - 1] >> 30)) + this.mti);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,ResetGenerator,The following statement contains a magic number: this.bitCount = 32;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,ResetBySeedArray,The following statement contains a magic number: mt[i] = (mt[i] ^ ((mt[i - 1] ^ (mt[i - 1] >> 30)) * 1664525U)) + this.seedArray[j] + j;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,ResetBySeedArray,The following statement contains a magic number: mt[i] = (mt[i] ^ ((mt[i - 1] ^ (mt[i - 1] >> 30)) * 1664525U)) + this.seedArray[j] + j;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,ResetBySeedArray,The following statement contains a magic number: mt[i] = (mt[i] ^ ((mt[i - 1] ^ (mt[i - 1] >> 30)) * 1566083941U)) - i;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,ResetBySeedArray,The following statement contains a magic number: mt[i] = (mt[i] ^ ((mt[i - 1] ^ (mt[i - 1] >> 30)) * 1566083941U)) - i;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,GenerateNUInts,The following statement contains a magic number: uint[] mag01 = new uint[2] { 0x0U' MT19937Generator.VectorA };
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextUInt,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextUInt,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextUInt,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextUInt,The following statement contains a magic number: return (y ^ (y >> 18));
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextInclusiveMaxValue,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextInclusiveMaxValue,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextInclusiveMaxValue,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextInclusiveMaxValue,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,Next,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextDouble,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextDouble,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextDouble,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextDouble,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextDouble,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextDouble,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextDouble,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextDouble,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextDouble,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextDouble,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextDouble,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextDouble,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBoolean,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBoolean,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBoolean,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBoolean,The following statement contains a magic number: this.bitBuffer = (y ^ (y >> 18));
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBoolean,The following statement contains a magic number: this.bitCount == 32
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: buffer[i++] = (byte)(y >> 8);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: buffer[i++] = (byte)(y >> 16);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: buffer[i++] = (byte)(y >> 24);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: i < buffer.Length - 3
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: y ^= (y >> 11);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: y ^= (y << 7) & 0x9d2c5680U;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: y ^= (y << 15) & 0xefc60000U;
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: y ^= (y >> 18);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: buffer[i++] = (byte)(y >> 8);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: buffer[i++] = (byte)(y >> 16);
Magic Number,YAMP.Numerics,MT19937Generator,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\MT19937Generator.cs,NextBytes,The following statement contains a magic number: buffer[i] = (byte)(y >> 24);
Magic Number,YAMP.Numerics,RayleighDistribution,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\RayleighDistribution.cs,NextDouble,The following statement contains a magic number: return Math.Sqrt(Math.Pow(this.normalDistribution1.NextDouble()' 2) + Math.Pow(this.normalDistribution2.NextDouble()' 2));
Magic Number,YAMP.Numerics,RayleighDistribution,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\RayleighDistribution.cs,NextDouble,The following statement contains a magic number: return Math.Sqrt(Math.Pow(this.normalDistribution1.NextDouble()' 2) + Math.Pow(this.normalDistribution2.NextDouble()' 2));
Magic Number,YAMP.Numerics,WeibullDistribution,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\WeibullDistribution.cs,Gamma,The following statement contains a magic number: index <= 6
Magic Number,YAMP.Numerics,WeibullDistribution,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\WeibullDistribution.cs,Gamma,The following statement contains a magic number: return Math.Sqrt(2.0 * Math.PI) / x * Math.Pow(x + 5.5' x + 0.5) / Math.Exp(x + 5.5) * sum;
Magic Number,YAMP.Numerics,WeibullDistribution,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\WeibullDistribution.cs,Gamma,The following statement contains a magic number: return Math.Sqrt(2.0 * Math.PI) / x * Math.Pow(x + 5.5' x + 0.5) / Math.Exp(x + 5.5) * sum;
Magic Number,YAMP.Numerics,WeibullDistribution,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\WeibullDistribution.cs,Gamma,The following statement contains a magic number: return Math.Sqrt(2.0 * Math.PI) / x * Math.Pow(x + 5.5' x + 0.5) / Math.Exp(x + 5.5) * sum;
Magic Number,YAMP.Numerics,WeibullDistribution,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Random\WeibullDistribution.cs,Gamma,The following statement contains a magic number: return Math.Sqrt(2.0 * Math.PI) / x * Math.Pow(x + 5.5' x + 0.5) / Math.Exp(x + 5.5) * sum;
Magic Number,YAMP.Numerics,GMRESkSolver,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Solvers\GMRESkSolver.cs,GMRESkSolver,The following statement contains a magic number: Restart = MaxIterations / 10;
Magic Number,YAMP.Numerics,IterativeSolver,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Solvers\IterativeSolver.cs,IterativeSolver,The following statement contains a magic number: MaxIterations = 5 * A.DimensionX * A.DimensionY;
Magic Number,YAMP.Numerics,IterativeSolver,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Solvers\IterativeSolver.cs,IterativeSolver,The following statement contains a magic number: Tolerance = 1e-10;
Magic Number,YAMP.Numerics.Optimization,NewtonMethod,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\NonLinear\NewtonMethod.cs,NewtonMethod,The following statement contains a magic number: Result = new double[1' 2];
Missing Default,YAMP,TimerFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\SystemFunctions\TimerFunction.cs,Function,The following switch statement is missing a default case: switch (n)  			{  				case -1:  					Reset();  					break;  				case 0:  					Stop();  					break;  				case 1:  					Start();  					break;  			}
Missing Default,YAMP,TimerFunction,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Functions\SystemFunctions\TimerFunction.cs,Function,The following switch statement is missing a default case: switch (action.Value.ToLower())  			{  				case "reset":  					Reset();  					break;  				case "stop":  					Stop();  					break;  				case "start":  					Start();  					break;  			}
Missing Default,YAMP,Value,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Values\Value.cs,ToSuperScript,The following switch statement is missing a default case: switch(ch)                  {                      case '0': target = '⁰'; break;                      case '1': target = '¹'; break;                      case '2': target = '²'; break;                      case '3': target = '³'; break;                      case '4': target = '⁴'; break;                      case '5': target = '⁵'; break;                      case '6': target = '⁶'; break;                      case '7': target = '⁷'; break;                      case '8': target = '⁸'; break;                      case '9': target = '⁹'; break;                  }
Missing Default,YAMP.Numerics,SingularValueDecomposition,D:\research\architectureSmells\repos\FlorianRappl_YAMP\YAMP.Core\Numerics\Decompositions\SingularValueDecomposition.cs,SingularValueDecomposition,The following switch statement is missing a default case: switch (kase)                  {                      // Deflate negligible s(p).                      case 1:                          {                              var f = e[p - 2];                              e[p - 2] = 0.0;                                for (int j = p - 2; j >= k; j--)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                    if (j != k)                                  {                                      f = (-sn) * e[j - 1];                                      e[j - 1] = cs * e[j - 1];                                  }                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][p - 1];                                          V[i][p - 1] = (-sn) * V[i][j] + cs * V[i][p - 1];                                          V[i][j] = t;                                      }                                  }                              }                          }                            break;                        // Split at negligible s(k).                      case 2:                          {                              var f = e[k - 1];                              e[k - 1] = 0.0;                                for (int j = k; j < p; j++)                              {                                  var t = Helpers.Hypot(s[j]' f);                                  var cs = s[j] / t;                                  var sn = f / t;                                  s[j] = t;                                  f = (-sn) * e[j];                                  e[j] = cs * e[j];                                    if (wantu)                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][k - 1];                                          U[i][k - 1] = (-sn) * U[i][j] + cs * U[i][k - 1];                                          U[i][j] = t;                                      }                                  }                              }                          }                          break;                        // Perform one qr step.                      case 3:                          {                              // Calculate the shift.                              var scale = Math.Max(Math.Max(Math.Max(Math.Max(Math.Abs(s[p - 1])' Math.Abs(s[p - 2]))' Math.Abs(e[p - 2]))' Math.Abs(s[k]))' Math.Abs(e[k]));                              var sp = s[p - 1] / scale;                              var spm1 = s[p - 2] / scale;                              var epm1 = e[p - 2] / scale;                              var sk = s[k] / scale;                              var ek = e[k] / scale;                              var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;                              var c = (sp * epm1) * (sp * epm1);                              var shift = 0.0;                                if ((b != 0.0) | (c != 0.0))                              {                                  shift = Math.Sqrt(b * b + c);                                    if (b < 0.0)                                      shift = -shift;                                                                    shift = c / (b + shift);                              }                                var f = (sk + sp) * (sk - sp) + shift;                              var g = sk * ek;                                // Chase zeros.                                for (int j = k; j < p - 1; j++)                              {                                  var t = Helpers.Hypot(f' g);                                  var cs = f / t;                                  var sn = g / t;                                    if (j != k)                                      e[j - 1] = t;                                                                    f = cs * s[j] + sn * e[j];                                  e[j] = cs * e[j] - sn * s[j];                                  g = sn * s[j + 1];                                  s[j + 1] = cs * s[j + 1];                                    if (wantv)                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = cs * V[i][j] + sn * V[i][j + 1];                                          V[i][j + 1] = (-sn) * V[i][j] + cs * V[i][j + 1];                                          V[i][j] = t;                                      }                                  }                                    t = Helpers.Hypot(f' g);                                  cs = f / t;                                  sn = g / t;                                  s[j] = t;                                  f = cs * e[j] + sn * s[j + 1];                                  s[j + 1] = (-sn) * e[j] + cs * s[j + 1];                                  g = sn * e[j + 1];                                  e[j + 1] = cs * e[j + 1];                                    if (wantu && (j < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = cs * U[i][j] + sn * U[i][j + 1];                                          U[i][j + 1] = (-sn) * U[i][j] + cs * U[i][j + 1];                                          U[i][j] = t;                                      }                                  }                              }                                e[p - 2] = f;                              iter = iter + 1;                          }                          break;                        // Convergence.                      case 4:                          {                              // Make the singular values positive.                              if (s[k] <= 0.0)                              {                                  s[k] = (s[k] < 0.0 ? -s[k] : 0.0);                                    if (wantv)                                  {                                      for (int i = 0; i <= pp; i++)                                      {                                          V[i][k] = -V[i][k];                                      }                                  }                              }                                // Order the singular values.                              while (k < pp)                              {                                  if (s[k] >= s[k + 1])                                      break;                                    var t = s[k];                                  s[k] = s[k + 1];                                  s[k + 1] = t;                                    if (wantv && (k < n - 1))                                  {                                      for (int i = 0; i < n; i++)                                      {                                          t = V[i][k + 1];                                           V[i][k + 1] = V[i][k];                                           V[i][k] = t;                                      }                                  }                                    if (wantu && (k < m - 1))                                  {                                      for (int i = 0; i < m; i++)                                      {                                          t = U[i][k + 1];                                          U[i][k + 1] = U[i][k];                                           U[i][k] = t;                                      }                                  }                                    k++;                              }                                iter = 0;                              p--;                          }                          break;                  }
