Implementation smell,Namespace,Class,File,Method,Description
Long Method,YAMP.Physics,CombinedUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\CombinedUnit.cs,Parse,The method has 103 lines of code.
Complex Method,YAMP.Physics,PolyLogFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PolyLogFunction.cs,Polylog,Cyclomatic complexity of the method is 12
Complex Method,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL1,Cyclomatic complexity of the method is 8
Complex Method,YAMP.Physics,ZernikeFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\ZernikeFunction.cs,Zernike,Cyclomatic complexity of the method is 9
Complex Method,YAMP.Physics,CombinedUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\CombinedUnit.cs,Unpack,Cyclomatic complexity of the method is 13
Complex Method,YAMP.Physics,CombinedUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\CombinedUnit.cs,Parse,Cyclomatic complexity of the method is 16
Long Parameter List,YAMP.Physics,ClebschFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\ClebschFunction.cs,CGCoefficients,The method has 5 parameters. Parameters: j1' j2' j' m1' m2
Long Identifier,YAMP.Physics,HermiteFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\HermiteFunction.cs,HermitePolynomial,The length of the parameter two_z_to_the_n_minus_2_times_m is 30.
Long Statement,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The length of the statement  "                // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005. " is 128.
Long Statement,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The length of the statement  "                    var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5 " is 122.
Long Statement,YAMP.Physics,CarlsonFFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonFFunction.cs,CarlsonF,The length of the statement  "                    var F = 1.0 - E2 / 10.0 - E3 / 14.0 + E2 * E2 / 24.0 + 3.0 * E2 * E3 / 44.0 - 5.0 / 208.0 * E2 * E2 * E2 + 3.0 / 104.0 * E3 * E3 - E2 * E2 * E3 / 16.0; " is 151.
Complex Conditional,YAMP.Physics,CarlsonFFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonFFunction.cs,CarlsonF,The conditional expression  "((x == 0.0) && ((y == 0.0) || (z == 0.0))) || ((y == 0.0) && (z == 0.0))"  is complex.
Complex Conditional,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The conditional expression  "(s > max_bits && q < 1.0) || (s > 0.5 * max_bits && q < 0.25)"  is complex.
Complex Conditional,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The conditional expression  "(sabs > max_bits && qabs < 1.0) || (sabs > 0.5 * max_bits && qabs < 0.25)"  is complex.
Virtual Method Call from Constructor,YAMP.Physics,PhysicalUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\PhysicalUnit.cs,PhysicalUnit,The constructor "PhysicalUnit" calls a virtual method "SetPrefixes".
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: var c4 = Math.Pow(2.0' 2.0 / 3.0);
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: var c4 = Math.Pow(2.0' 2.0 / 3.0);
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: var c4 = Math.Pow(2.0' 2.0 / 3.0);
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonDFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonDFunction.cs,CarlsonD,The following statement contains a magic number: for (int n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + 3.0 * z) / 5.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  double e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    // Our series development (DLMF 19.36.2) goes up to O(e^6). In order that the neglected term e^7 <~ 1.0E-16' we need e <~ 0.005.                  if (e < 0.005)                  {                      var xy = dx * dy;                       var zz = dz * dz;                      var E2 = xy - 6.0 * zz;                      var E3 = (3.0 * xy - 8.0 * zz) * dz;                      var E4 = 3.0 * (xy - zz) * zz;                      var E5 = xy * zz * dz;                      var F = 1.0 - 3.0 / 14.0 * E2 - E3 / 6.0 + 9.0 / 88.0 * E2 * E2 - 3.0 / 22.0 * E4 + 9.0 / 52.0 * E2 * E3 - 3.0 / 26.0 * E5                          - E2 * E2 * E2 / 16.0 + 3.0 / 40.0 * E3 * E3 + 3.0 / 20.0 * E2 * E4;                        return F / Math.Pow(m' 3.0 / 2.0) + t;                  }                    // we are not close enough; use the duplication theory to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    t += 3.0 / Math.Sqrt(z) / (z + lambda);                  x = (x + lambda) / c4;                  y = (y + lambda) / c4;                  z = (z + lambda) / c4;              }
Magic Number,YAMP.Physics,CarlsonFFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonFFunction.cs,CarlsonF,The following statement contains a magic number: for (var n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + z) / 3.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  var e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    if (e < 0.01)                  {                      var E2 = dx * dy + dx * dz + dy * dz;                      var E3 = dx * dy * dz;                      var F = 1.0 - E2 / 10.0 - E3 / 14.0 + E2 * E2 / 24.0 + 3.0 * E2 * E3 / 44.0 - 5.0 / 208.0 * E2 * E2 * E2 + 3.0 / 104.0 * E3 * E3 - E2 * E2 * E3 / 16.0;                      return F / Math.Sqrt(m);                  }                    // if we are not close enough' use the duplication theorem (DLMF 19.26.18) to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    x = (x + lambda) / 4.0;                  y = (y + lambda) / 4.0;                  z = (z + lambda) / 4.0;              }
Magic Number,YAMP.Physics,CarlsonFFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonFFunction.cs,CarlsonF,The following statement contains a magic number: for (var n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + z) / 3.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  var e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    if (e < 0.01)                  {                      var E2 = dx * dy + dx * dz + dy * dz;                      var E3 = dx * dy * dz;                      var F = 1.0 - E2 / 10.0 - E3 / 14.0 + E2 * E2 / 24.0 + 3.0 * E2 * E3 / 44.0 - 5.0 / 208.0 * E2 * E2 * E2 + 3.0 / 104.0 * E3 * E3 - E2 * E2 * E3 / 16.0;                      return F / Math.Sqrt(m);                  }                    // if we are not close enough' use the duplication theorem (DLMF 19.26.18) to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    x = (x + lambda) / 4.0;                  y = (y + lambda) / 4.0;                  z = (z + lambda) / 4.0;              }
Magic Number,YAMP.Physics,CarlsonFFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonFFunction.cs,CarlsonF,The following statement contains a magic number: for (var n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + z) / 3.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  var e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    if (e < 0.01)                  {                      var E2 = dx * dy + dx * dz + dy * dz;                      var E3 = dx * dy * dz;                      var F = 1.0 - E2 / 10.0 - E3 / 14.0 + E2 * E2 / 24.0 + 3.0 * E2 * E3 / 44.0 - 5.0 / 208.0 * E2 * E2 * E2 + 3.0 / 104.0 * E3 * E3 - E2 * E2 * E3 / 16.0;                      return F / Math.Sqrt(m);                  }                    // if we are not close enough' use the duplication theorem (DLMF 19.26.18) to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    x = (x + lambda) / 4.0;                  y = (y + lambda) / 4.0;                  z = (z + lambda) / 4.0;              }
Magic Number,YAMP.Physics,CarlsonFFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonFFunction.cs,CarlsonF,The following statement contains a magic number: for (var n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + z) / 3.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  var e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    if (e < 0.01)                  {                      var E2 = dx * dy + dx * dz + dy * dz;                      var E3 = dx * dy * dz;                      var F = 1.0 - E2 / 10.0 - E3 / 14.0 + E2 * E2 / 24.0 + 3.0 * E2 * E3 / 44.0 - 5.0 / 208.0 * E2 * E2 * E2 + 3.0 / 104.0 * E3 * E3 - E2 * E2 * E3 / 16.0;                      return F / Math.Sqrt(m);                  }                    // if we are not close enough' use the duplication theorem (DLMF 19.26.18) to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    x = (x + lambda) / 4.0;                  y = (y + lambda) / 4.0;                  z = (z + lambda) / 4.0;              }
Magic Number,YAMP.Physics,CarlsonFFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonFFunction.cs,CarlsonF,The following statement contains a magic number: for (var n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + z) / 3.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  var e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    if (e < 0.01)                  {                      var E2 = dx * dy + dx * dz + dy * dz;                      var E3 = dx * dy * dz;                      var F = 1.0 - E2 / 10.0 - E3 / 14.0 + E2 * E2 / 24.0 + 3.0 * E2 * E3 / 44.0 - 5.0 / 208.0 * E2 * E2 * E2 + 3.0 / 104.0 * E3 * E3 - E2 * E2 * E3 / 16.0;                      return F / Math.Sqrt(m);                  }                    // if we are not close enough' use the duplication theorem (DLMF 19.26.18) to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    x = (x + lambda) / 4.0;                  y = (y + lambda) / 4.0;                  z = (z + lambda) / 4.0;              }
Magic Number,YAMP.Physics,CarlsonFFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonFFunction.cs,CarlsonF,The following statement contains a magic number: for (var n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + z) / 3.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  var e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    if (e < 0.01)                  {                      var E2 = dx * dy + dx * dz + dy * dz;                      var E3 = dx * dy * dz;                      var F = 1.0 - E2 / 10.0 - E3 / 14.0 + E2 * E2 / 24.0 + 3.0 * E2 * E3 / 44.0 - 5.0 / 208.0 * E2 * E2 * E2 + 3.0 / 104.0 * E3 * E3 - E2 * E2 * E3 / 16.0;                      return F / Math.Sqrt(m);                  }                    // if we are not close enough' use the duplication theorem (DLMF 19.26.18) to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    x = (x + lambda) / 4.0;                  y = (y + lambda) / 4.0;                  z = (z + lambda) / 4.0;              }
Magic Number,YAMP.Physics,CarlsonFFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonFFunction.cs,CarlsonF,The following statement contains a magic number: for (var n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + z) / 3.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  var e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    if (e < 0.01)                  {                      var E2 = dx * dy + dx * dz + dy * dz;                      var E3 = dx * dy * dz;                      var F = 1.0 - E2 / 10.0 - E3 / 14.0 + E2 * E2 / 24.0 + 3.0 * E2 * E3 / 44.0 - 5.0 / 208.0 * E2 * E2 * E2 + 3.0 / 104.0 * E3 * E3 - E2 * E2 * E3 / 16.0;                      return F / Math.Sqrt(m);                  }                    // if we are not close enough' use the duplication theorem (DLMF 19.26.18) to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    x = (x + lambda) / 4.0;                  y = (y + lambda) / 4.0;                  z = (z + lambda) / 4.0;              }
Magic Number,YAMP.Physics,CarlsonFFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonFFunction.cs,CarlsonF,The following statement contains a magic number: for (var n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + z) / 3.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  var e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    if (e < 0.01)                  {                      var E2 = dx * dy + dx * dz + dy * dz;                      var E3 = dx * dy * dz;                      var F = 1.0 - E2 / 10.0 - E3 / 14.0 + E2 * E2 / 24.0 + 3.0 * E2 * E3 / 44.0 - 5.0 / 208.0 * E2 * E2 * E2 + 3.0 / 104.0 * E3 * E3 - E2 * E2 * E3 / 16.0;                      return F / Math.Sqrt(m);                  }                    // if we are not close enough' use the duplication theorem (DLMF 19.26.18) to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    x = (x + lambda) / 4.0;                  y = (y + lambda) / 4.0;                  z = (z + lambda) / 4.0;              }
Magic Number,YAMP.Physics,CarlsonFFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonFFunction.cs,CarlsonF,The following statement contains a magic number: for (var n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + z) / 3.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  var e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    if (e < 0.01)                  {                      var E2 = dx * dy + dx * dz + dy * dz;                      var E3 = dx * dy * dz;                      var F = 1.0 - E2 / 10.0 - E3 / 14.0 + E2 * E2 / 24.0 + 3.0 * E2 * E3 / 44.0 - 5.0 / 208.0 * E2 * E2 * E2 + 3.0 / 104.0 * E3 * E3 - E2 * E2 * E3 / 16.0;                      return F / Math.Sqrt(m);                  }                    // if we are not close enough' use the duplication theorem (DLMF 19.26.18) to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    x = (x + lambda) / 4.0;                  y = (y + lambda) / 4.0;                  z = (z + lambda) / 4.0;              }
Magic Number,YAMP.Physics,CarlsonFFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonFFunction.cs,CarlsonF,The following statement contains a magic number: for (var n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + z) / 3.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  var e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    if (e < 0.01)                  {                      var E2 = dx * dy + dx * dz + dy * dz;                      var E3 = dx * dy * dz;                      var F = 1.0 - E2 / 10.0 - E3 / 14.0 + E2 * E2 / 24.0 + 3.0 * E2 * E3 / 44.0 - 5.0 / 208.0 * E2 * E2 * E2 + 3.0 / 104.0 * E3 * E3 - E2 * E2 * E3 / 16.0;                      return F / Math.Sqrt(m);                  }                    // if we are not close enough' use the duplication theorem (DLMF 19.26.18) to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    x = (x + lambda) / 4.0;                  y = (y + lambda) / 4.0;                  z = (z + lambda) / 4.0;              }
Magic Number,YAMP.Physics,CarlsonFFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonFFunction.cs,CarlsonF,The following statement contains a magic number: for (var n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + z) / 3.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  var e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    if (e < 0.01)                  {                      var E2 = dx * dy + dx * dz + dy * dz;                      var E3 = dx * dy * dz;                      var F = 1.0 - E2 / 10.0 - E3 / 14.0 + E2 * E2 / 24.0 + 3.0 * E2 * E3 / 44.0 - 5.0 / 208.0 * E2 * E2 * E2 + 3.0 / 104.0 * E3 * E3 - E2 * E2 * E3 / 16.0;                      return F / Math.Sqrt(m);                  }                    // if we are not close enough' use the duplication theorem (DLMF 19.26.18) to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    x = (x + lambda) / 4.0;                  y = (y + lambda) / 4.0;                  z = (z + lambda) / 4.0;              }
Magic Number,YAMP.Physics,CarlsonFFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonFFunction.cs,CarlsonF,The following statement contains a magic number: for (var n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + z) / 3.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  var e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    if (e < 0.01)                  {                      var E2 = dx * dy + dx * dz + dy * dz;                      var E3 = dx * dy * dz;                      var F = 1.0 - E2 / 10.0 - E3 / 14.0 + E2 * E2 / 24.0 + 3.0 * E2 * E3 / 44.0 - 5.0 / 208.0 * E2 * E2 * E2 + 3.0 / 104.0 * E3 * E3 - E2 * E2 * E3 / 16.0;                      return F / Math.Sqrt(m);                  }                    // if we are not close enough' use the duplication theorem (DLMF 19.26.18) to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    x = (x + lambda) / 4.0;                  y = (y + lambda) / 4.0;                  z = (z + lambda) / 4.0;              }
Magic Number,YAMP.Physics,CarlsonFFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonFFunction.cs,CarlsonF,The following statement contains a magic number: for (var n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + z) / 3.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  var e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    if (e < 0.01)                  {                      var E2 = dx * dy + dx * dz + dy * dz;                      var E3 = dx * dy * dz;                      var F = 1.0 - E2 / 10.0 - E3 / 14.0 + E2 * E2 / 24.0 + 3.0 * E2 * E3 / 44.0 - 5.0 / 208.0 * E2 * E2 * E2 + 3.0 / 104.0 * E3 * E3 - E2 * E2 * E3 / 16.0;                      return F / Math.Sqrt(m);                  }                    // if we are not close enough' use the duplication theorem (DLMF 19.26.18) to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    x = (x + lambda) / 4.0;                  y = (y + lambda) / 4.0;                  z = (z + lambda) / 4.0;              }
Magic Number,YAMP.Physics,CarlsonFFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonFFunction.cs,CarlsonF,The following statement contains a magic number: for (var n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + z) / 3.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  var e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    if (e < 0.01)                  {                      var E2 = dx * dy + dx * dz + dy * dz;                      var E3 = dx * dy * dz;                      var F = 1.0 - E2 / 10.0 - E3 / 14.0 + E2 * E2 / 24.0 + 3.0 * E2 * E3 / 44.0 - 5.0 / 208.0 * E2 * E2 * E2 + 3.0 / 104.0 * E3 * E3 - E2 * E2 * E3 / 16.0;                      return F / Math.Sqrt(m);                  }                    // if we are not close enough' use the duplication theorem (DLMF 19.26.18) to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    x = (x + lambda) / 4.0;                  y = (y + lambda) / 4.0;                  z = (z + lambda) / 4.0;              }
Magic Number,YAMP.Physics,CarlsonFFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonFFunction.cs,CarlsonF,The following statement contains a magic number: for (var n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + z) / 3.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  var e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    if (e < 0.01)                  {                      var E2 = dx * dy + dx * dz + dy * dz;                      var E3 = dx * dy * dz;                      var F = 1.0 - E2 / 10.0 - E3 / 14.0 + E2 * E2 / 24.0 + 3.0 * E2 * E3 / 44.0 - 5.0 / 208.0 * E2 * E2 * E2 + 3.0 / 104.0 * E3 * E3 - E2 * E2 * E3 / 16.0;                      return F / Math.Sqrt(m);                  }                    // if we are not close enough' use the duplication theorem (DLMF 19.26.18) to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    x = (x + lambda) / 4.0;                  y = (y + lambda) / 4.0;                  z = (z + lambda) / 4.0;              }
Magic Number,YAMP.Physics,CarlsonFFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\CarlsonFFunction.cs,CarlsonF,The following statement contains a magic number: for (var n = 0; n < 250; n++)              {                  // find out how close we are to the expansion point                  var m = (x + y + z) / 3.0;                  var dx = (x - m) / m;                  var dy = (y - m) / m;                  var dz = (z - m) / m;                  var e = Math.Max(Math.Abs(dx)' Math.Max(Math.Abs(dy)' Math.Abs(dz)));                    if (e < 0.01)                  {                      var E2 = dx * dy + dx * dz + dy * dz;                      var E3 = dx * dy * dz;                      var F = 1.0 - E2 / 10.0 - E3 / 14.0 + E2 * E2 / 24.0 + 3.0 * E2 * E3 / 44.0 - 5.0 / 208.0 * E2 * E2 * E2 + 3.0 / 104.0 * E3 * E3 - E2 * E2 * E3 / 16.0;                      return F / Math.Sqrt(m);                  }                    // if we are not close enough' use the duplication theorem (DLMF 19.26.18) to move us closer                  var lambda = Math.Sqrt(x * y) + Math.Sqrt(x * z) + Math.Sqrt(y * z);                    x = (x + lambda) / 4.0;                  y = (y + lambda) / 4.0;                  z = (z + lambda) / 4.0;              }
Magic Number,YAMP.Physics,InvTangentFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\InvTangentFunction.cs,Function,The following statement contains a magic number: return Function(new ScalarValue(2)' z);
Magic Number,YAMP.Physics,InvTangentFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\InvTangentFunction.cs,Function,The following statement contains a magic number: return Function(new ScalarValue(2)' Z);
Magic Number,YAMP.Physics,ChebyshevFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\ChebyshevFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                          var s = 1;                            for (var k = 0; k <= m; k++)                          {                              var nom = s * Helpers.Factorial(n - k - 1) * Math.Pow(2 * x' n - 2 * k);                              var den = Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k);                              s *= (-1);                              sum += nom / den;                          }                            return n / 2.0 * sum;                      };              }
Magic Number,YAMP.Physics,ChebyshevFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\ChebyshevFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                          var s = 1;                            for (var k = 0; k <= m; k++)                          {                              var nom = s * Helpers.Factorial(n - k - 1) * Math.Pow(2 * x' n - 2 * k);                              var den = Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k);                              s *= (-1);                              sum += nom / den;                          }                            return n / 2.0 * sum;                      };              }
Magic Number,YAMP.Physics,ChebyshevFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\ChebyshevFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                          var s = 1;                            for (var k = 0; k <= m; k++)                          {                              var nom = s * Helpers.Factorial(n - k - 1) * Math.Pow(2 * x' n - 2 * k);                              var den = Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k);                              s *= (-1);                              sum += nom / den;                          }                            return n / 2.0 * sum;                      };              }
Magic Number,YAMP.Physics,ChebyshevFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\ChebyshevFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                          var s = 1;                            for (var k = 0; k <= m; k++)                          {                              var nom = s * Helpers.Factorial(n - k - 1) * Math.Pow(2 * x' n - 2 * k);                              var den = Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k);                              s *= (-1);                              sum += nom / den;                          }                            return n / 2.0 * sum;                      };              }
Magic Number,YAMP.Physics,ChebyshevFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\ChebyshevFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                          var s = 1;                            for (var k = 0; k <= m; k++)                          {                              var nom = s * Helpers.Factorial(n - k - 1) * Math.Pow(2 * x' n - 2 * k);                              var den = Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k);                              s *= (-1);                              sum += nom / den;                          }                            return n / 2.0 * sum;                      };              }
Magic Number,YAMP.Physics,ClebschFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\ClebschFunction.cs,Function,The following statement contains a magic number: for (var m1 = -j1.Re; m1 <= j1.Re; m1 += 1.0)              {                  for (var m2 = -j2.Re; m2 <= j2.Re; m2 += 1.0)                  {                      var m = m1 + m2;                      var ja = j1.Re + j2.Re;                        for (var j = Math.Abs(m); j <= ja; j += 1.0)                      {                          var v = CGCoefficients(j1.Re' j2.Re' j' m1' m2);                          M[l' 1] = new ScalarValue(m);                          M[l' 2] = new ScalarValue(m1);                          M[l' 3] = new ScalarValue(m2);                          M[l' 4] = new ScalarValue(j);                          M[l' 5] = new ScalarValue(v);                          l++;                      }                  }              }
Magic Number,YAMP.Physics,ClebschFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\ClebschFunction.cs,Function,The following statement contains a magic number: for (var m1 = -j1.Re; m1 <= j1.Re; m1 += 1.0)              {                  for (var m2 = -j2.Re; m2 <= j2.Re; m2 += 1.0)                  {                      var m = m1 + m2;                      var ja = j1.Re + j2.Re;                        for (var j = Math.Abs(m); j <= ja; j += 1.0)                      {                          var v = CGCoefficients(j1.Re' j2.Re' j' m1' m2);                          M[l' 1] = new ScalarValue(m);                          M[l' 2] = new ScalarValue(m1);                          M[l' 3] = new ScalarValue(m2);                          M[l' 4] = new ScalarValue(j);                          M[l' 5] = new ScalarValue(v);                          l++;                      }                  }              }
Magic Number,YAMP.Physics,ClebschFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\ClebschFunction.cs,Function,The following statement contains a magic number: for (var m1 = -j1.Re; m1 <= j1.Re; m1 += 1.0)              {                  for (var m2 = -j2.Re; m2 <= j2.Re; m2 += 1.0)                  {                      var m = m1 + m2;                      var ja = j1.Re + j2.Re;                        for (var j = Math.Abs(m); j <= ja; j += 1.0)                      {                          var v = CGCoefficients(j1.Re' j2.Re' j' m1' m2);                          M[l' 1] = new ScalarValue(m);                          M[l' 2] = new ScalarValue(m1);                          M[l' 3] = new ScalarValue(m2);                          M[l' 4] = new ScalarValue(j);                          M[l' 5] = new ScalarValue(v);                          l++;                      }                  }              }
Magic Number,YAMP.Physics,ClebschFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\ClebschFunction.cs,Function,The following statement contains a magic number: for (var m1 = -j1.Re; m1 <= j1.Re; m1 += 1.0)              {                  for (var m2 = -j2.Re; m2 <= j2.Re; m2 += 1.0)                  {                      var m = m1 + m2;                      var ja = j1.Re + j2.Re;                        for (var j = Math.Abs(m); j <= ja; j += 1.0)                      {                          var v = CGCoefficients(j1.Re' j2.Re' j' m1' m2);                          M[l' 1] = new ScalarValue(m);                          M[l' 2] = new ScalarValue(m1);                          M[l' 3] = new ScalarValue(m2);                          M[l' 4] = new ScalarValue(j);                          M[l' 5] = new ScalarValue(v);                          l++;                      }                  }              }
Magic Number,YAMP.Physics,ClebschFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\ClebschFunction.cs,CGCoefficients,The following statement contains a magic number: var f2 = factorial(j1 + m1) * factorial(j1 - m1) * factorial(j + m) * factorial(j - m) * (2.0 * j + 1.0);
Magic Number,YAMP.Physics,ClebschFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\ClebschFunction.cs,isNotHalf,The following statement contains a magic number: return Math.IEEERemainder(j.Re' 0.5) != 0.0;
Magic Number,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The following statement contains a magic number: var max_bits = 54.0;
Magic Number,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The following statement contains a magic number: if ((s > max_bits && q < 1.0) || (s > 0.5 * max_bits && q < 0.25))              {                  return Math.Pow(q' -s);              }              else if (s > 0.5 * max_bits && q < 1.0)              {                  var p1 = Math.Pow(q' -s);                  var p2 = Math.Pow(q / (1.0 + q)' s);                  var p3 = Math.Pow(q / (2.0 + q)' s);                  return p1 * (1.0 + p2 + p3);              }
Magic Number,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The following statement contains a magic number: if ((s > max_bits && q < 1.0) || (s > 0.5 * max_bits && q < 0.25))              {                  return Math.Pow(q' -s);              }              else if (s > 0.5 * max_bits && q < 1.0)              {                  var p1 = Math.Pow(q' -s);                  var p2 = Math.Pow(q / (1.0 + q)' s);                  var p3 = Math.Pow(q / (2.0 + q)' s);                  return p1 * (1.0 + p2 + p3);              }
Magic Number,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The following statement contains a magic number: if ((s > max_bits && q < 1.0) || (s > 0.5 * max_bits && q < 0.25))              {                  return Math.Pow(q' -s);              }              else if (s > 0.5 * max_bits && q < 1.0)              {                  var p1 = Math.Pow(q' -s);                  var p2 = Math.Pow(q / (1.0 + q)' s);                  var p3 = Math.Pow(q / (2.0 + q)' s);                  return p1 * (1.0 + p2 + p3);              }
Magic Number,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The following statement contains a magic number: if ((s > max_bits && q < 1.0) || (s > 0.5 * max_bits && q < 0.25))              {                  return Math.Pow(q' -s);              }              else if (s > 0.5 * max_bits && q < 1.0)              {                  var p1 = Math.Pow(q' -s);                  var p2 = Math.Pow(q / (1.0 + q)' s);                  var p3 = Math.Pow(q / (2.0 + q)' s);                  return p1 * (1.0 + p2 + p3);              }
Magic Number,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The following statement contains a magic number: const int jmax = 12;
Magic Number,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The following statement contains a magic number: const int kmax = 10;
Magic Number,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The following statement contains a magic number: var ans = pmax * ((kmax + q) / (s - 1.0) + 0.5);
Magic Number,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The following statement contains a magic number: for (var j = 0; j <= jmax; j++)              {                  Double delta = COEFFICIENTS[j + 1] * scp * pcp;                  ans += delta;                    if (Math.Abs(delta / ans) < 0.5 * Double.Epsilon)                  {                      break;                  }                    scp *= (s + 2 * j + 1) * (s + 2 * j + 2);                  pcp /= (kmax + q) * (kmax + q);              }
Magic Number,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The following statement contains a magic number: for (var j = 0; j <= jmax; j++)              {                  Double delta = COEFFICIENTS[j + 1] * scp * pcp;                  ans += delta;                    if (Math.Abs(delta / ans) < 0.5 * Double.Epsilon)                  {                      break;                  }                    scp *= (s + 2 * j + 1) * (s + 2 * j + 2);                  pcp /= (kmax + q) * (kmax + q);              }
Magic Number,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The following statement contains a magic number: for (var j = 0; j <= jmax; j++)              {                  Double delta = COEFFICIENTS[j + 1] * scp * pcp;                  ans += delta;                    if (Math.Abs(delta / ans) < 0.5 * Double.Epsilon)                  {                      break;                  }                    scp *= (s + 2 * j + 1) * (s + 2 * j + 2);                  pcp /= (kmax + q) * (kmax + q);              }
Magic Number,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The following statement contains a magic number: for (var j = 0; j <= jmax; j++)              {                  Double delta = COEFFICIENTS[j + 1] * scp * pcp;                  ans += delta;                    if (Math.Abs(delta / ans) < 0.5 * Double.Epsilon)                  {                      break;                  }                    scp *= (s + 2 * j + 1) * (s + 2 * j + 2);                  pcp /= (kmax + q) * (kmax + q);              }
Magic Number,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The following statement contains a magic number: var max_bits = 54.0;
Magic Number,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The following statement contains a magic number: if ((sabs > max_bits && qabs < 1.0) || (sabs > 0.5 * max_bits && qabs < 0.25))              {                  return q.Pow(-ss);              }              else if (sabs > 0.5 * max_bits && qabs < 1.0)              {                  var p1 = q.Pow(-ss);                  var p2 = (q / (1.0 + q)).Pow(ss);                  var p3 = (q / (2.0 + q)).Pow(ss);                  return p1 * (1.0 + p2 + p3);              }
Magic Number,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The following statement contains a magic number: if ((sabs > max_bits && qabs < 1.0) || (sabs > 0.5 * max_bits && qabs < 0.25))              {                  return q.Pow(-ss);              }              else if (sabs > 0.5 * max_bits && qabs < 1.0)              {                  var p1 = q.Pow(-ss);                  var p2 = (q / (1.0 + q)).Pow(ss);                  var p3 = (q / (2.0 + q)).Pow(ss);                  return p1 * (1.0 + p2 + p3);              }
Magic Number,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The following statement contains a magic number: if ((sabs > max_bits && qabs < 1.0) || (sabs > 0.5 * max_bits && qabs < 0.25))              {                  return q.Pow(-ss);              }              else if (sabs > 0.5 * max_bits && qabs < 1.0)              {                  var p1 = q.Pow(-ss);                  var p2 = (q / (1.0 + q)).Pow(ss);                  var p3 = (q / (2.0 + q)).Pow(ss);                  return p1 * (1.0 + p2 + p3);              }
Magic Number,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The following statement contains a magic number: if ((sabs > max_bits && qabs < 1.0) || (sabs > 0.5 * max_bits && qabs < 0.25))              {                  return q.Pow(-ss);              }              else if (sabs > 0.5 * max_bits && qabs < 1.0)              {                  var p1 = q.Pow(-ss);                  var p2 = (q / (1.0 + q)).Pow(ss);                  var p3 = (q / (2.0 + q)).Pow(ss);                  return p1 * (1.0 + p2 + p3);              }
Magic Number,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The following statement contains a magic number: const int jmax = 12;
Magic Number,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The following statement contains a magic number: const int kmax = 10;
Magic Number,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The following statement contains a magic number: var ans = pmax * ((kmax + q) / (s - 1.0) + 0.5);
Magic Number,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The following statement contains a magic number: for (var j = 0; j <= jmax; j++)              {                  var delta = COEFFICIENTS[j + 1] * scp * pcp;                  ans += delta;                    if ((delta / ans).Abs() < 0.5 * Double.Epsilon)                  {                      break;                  }                    scp *= (s + 2 * j + 1) * (s + 2 * j + 2);                  pcp /= (kmax + q) * (kmax + q);              }
Magic Number,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The following statement contains a magic number: for (var j = 0; j <= jmax; j++)              {                  var delta = COEFFICIENTS[j + 1] * scp * pcp;                  ans += delta;                    if ((delta / ans).Abs() < 0.5 * Double.Epsilon)                  {                      break;                  }                    scp *= (s + 2 * j + 1) * (s + 2 * j + 2);                  pcp /= (kmax + q) * (kmax + q);              }
Magic Number,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The following statement contains a magic number: for (var j = 0; j <= jmax; j++)              {                  var delta = COEFFICIENTS[j + 1] * scp * pcp;                  ans += delta;                    if ((delta / ans).Abs() < 0.5 * Double.Epsilon)                  {                      break;                  }                    scp *= (s + 2 * j + 1) * (s + 2 * j + 2);                  pcp /= (kmax + q) * (kmax + q);              }
Magic Number,YAMP.Physics,HzetaFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\HzetaFunction.cs,HurwitzZeta,The following statement contains a magic number: for (var j = 0; j <= jmax; j++)              {                  var delta = COEFFICIENTS[j + 1] * scp * pcp;                  ans += delta;                    if ((delta / ans).Abs() < 0.5 * Double.Epsilon)                  {                      break;                  }                    scp *= (s + 2 * j + 1) * (s + 2 * j + 2);                  pcp /= (kmax + q) * (kmax + q);              }
Magic Number,YAMP.Physics,PolyLogFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PolyLogFunction.cs,PolylogInversion,The following statement contains a magic number: int nh = n / 2;
Magic Number,YAMP.Physics,PolyLogFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PolyLogFunction.cs,PolylogInversion,The following statement contains a magic number: for (var r = 1; r <= nh; r++)              {                  j = 2 * r;                  p = PolylogZetaNegative(j);                  j = n - j;                    if (j == 0)                  {                      s += p;                      break;                  }                    q = w.Pow(new ScalarValue(j)) * (p.Re / Helpers.Factorial(j));                  s += q;              }
Magic Number,YAMP.Physics,PolyLogFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PolyLogFunction.cs,PolylogInversion,The following statement contains a magic number: s = 2.0 * s;
Magic Number,YAMP.Physics,PolyLogFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PolyLogFunction.cs,PolylogNeg3,The following statement contains a magic number: return (z + 4.0 * zz + z * zz) / pp.Square();
Magic Number,YAMP.Physics,PolyLogFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PolyLogFunction.cs,PolylogNeg4,The following statement contains a magic number: return (z + 11.0 * zz + 11.0 * zz * z + zz * zz) / (pppp * p);
Magic Number,YAMP.Physics,PolyLogFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PolyLogFunction.cs,PolylogNeg4,The following statement contains a magic number: return (z + 11.0 * zz + 11.0 * zz * z + zz * zz) / (pppp * p);
Magic Number,YAMP.Physics,PolyLogFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PolyLogFunction.cs,PolylogZetaNegative,The following statement contains a magic number: return s * (Math.Pow(2.0' 1 - n) - 1.0);
Magic Number,YAMP.Physics,PolyLogFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PolyLogFunction.cs,Polylog,The following statement contains a magic number: if (n == 2)                  return SpenceFunction.DiLog(z);
Magic Number,YAMP.Physics,PolyLogFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PolyLogFunction.cs,Polylog,The following statement contains a magic number: if (n == -2)                  return PolylogNeg2(z);
Magic Number,YAMP.Physics,PolyLogFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PolyLogFunction.cs,Polylog,The following statement contains a magic number: if (n == -3)                  return PolylogNeg3(z);
Magic Number,YAMP.Physics,PolyLogFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PolyLogFunction.cs,Polylog,The following statement contains a magic number: if (n == -4)                  return PolylogNeg4(z);
Magic Number,YAMP.Physics,PolyLogFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PolyLogFunction.cs,Polylog,The following statement contains a magic number: if (n < -4)                  return PolylogNegative(n' z);
Magic Number,YAMP.Physics,PolyLogFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PolyLogFunction.cs,Polylog,The following statement contains a magic number: if (ah > 3.0)                  return PolylogInversion(n' z);              else if (ah >= 0.75)              {                  var ad = 0.0;                  var x = z.Log();                  var h = -((-x).Log());                    for (i = 1; i < n; i++)                      h += 1.0 / i;                    var p = ScalarValue.One;                  s = PolylogZetaPositive(n);                    for (j = 1; j <= n + 1; j++)                  {                      p = p * x / j;                        if (j == n - 1)                          s += h * p;                      else                          s += PolylogZetaPositive(n - j) * p;                  }                    j = n + 3;                  x = x * x;                    for (; ; )                  {                      p = p * x / ((j - 1) * j);                      h = PolylogZetaPositive(n - j);                      h = h * p;                      s += h;                      ah = Math.Abs(h.Re) + Math.Abs(h.Im);                      ad = Math.Abs(s.Re) + Math.Abs(s.Im);                        if (ah < ad * double.Epsilon)                          break;                        j += 2;                  }                    return s;              }              else if(ah >= 1e-6)              {                  var p = z * z * z;                  var ad = 0.0;                  var k = 3.0;                  var h = ScalarValue.Zero;                    do                  {                      p = p * z;                      k += 1.0;                      h = p / Math.Pow(k' n);                      s += h;                      ah = Math.Abs(h.Re) + Math.Abs(h.Im);                      ad = Math.Abs(s.Re) + Math.Abs(s.Im);                  }                  while (ah > ad * 1.1e-16);              }
Magic Number,YAMP.Physics,PolyLogFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PolyLogFunction.cs,Polylog,The following statement contains a magic number: if (ah > 3.0)                  return PolylogInversion(n' z);              else if (ah >= 0.75)              {                  var ad = 0.0;                  var x = z.Log();                  var h = -((-x).Log());                    for (i = 1; i < n; i++)                      h += 1.0 / i;                    var p = ScalarValue.One;                  s = PolylogZetaPositive(n);                    for (j = 1; j <= n + 1; j++)                  {                      p = p * x / j;                        if (j == n - 1)                          s += h * p;                      else                          s += PolylogZetaPositive(n - j) * p;                  }                    j = n + 3;                  x = x * x;                    for (; ; )                  {                      p = p * x / ((j - 1) * j);                      h = PolylogZetaPositive(n - j);                      h = h * p;                      s += h;                      ah = Math.Abs(h.Re) + Math.Abs(h.Im);                      ad = Math.Abs(s.Re) + Math.Abs(s.Im);                        if (ah < ad * double.Epsilon)                          break;                        j += 2;                  }                    return s;              }              else if(ah >= 1e-6)              {                  var p = z * z * z;                  var ad = 0.0;                  var k = 3.0;                  var h = ScalarValue.Zero;                    do                  {                      p = p * z;                      k += 1.0;                      h = p / Math.Pow(k' n);                      s += h;                      ah = Math.Abs(h.Re) + Math.Abs(h.Im);                      ad = Math.Abs(s.Re) + Math.Abs(s.Im);                  }                  while (ah > ad * 1.1e-16);              }
Magic Number,YAMP.Physics,PolyLogFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PolyLogFunction.cs,Polylog,The following statement contains a magic number: if (ah > 3.0)                  return PolylogInversion(n' z);              else if (ah >= 0.75)              {                  var ad = 0.0;                  var x = z.Log();                  var h = -((-x).Log());                    for (i = 1; i < n; i++)                      h += 1.0 / i;                    var p = ScalarValue.One;                  s = PolylogZetaPositive(n);                    for (j = 1; j <= n + 1; j++)                  {                      p = p * x / j;                        if (j == n - 1)                          s += h * p;                      else                          s += PolylogZetaPositive(n - j) * p;                  }                    j = n + 3;                  x = x * x;                    for (; ; )                  {                      p = p * x / ((j - 1) * j);                      h = PolylogZetaPositive(n - j);                      h = h * p;                      s += h;                      ah = Math.Abs(h.Re) + Math.Abs(h.Im);                      ad = Math.Abs(s.Re) + Math.Abs(s.Im);                        if (ah < ad * double.Epsilon)                          break;                        j += 2;                  }                    return s;              }              else if(ah >= 1e-6)              {                  var p = z * z * z;                  var ad = 0.0;                  var k = 3.0;                  var h = ScalarValue.Zero;                    do                  {                      p = p * z;                      k += 1.0;                      h = p / Math.Pow(k' n);                      s += h;                      ah = Math.Abs(h.Re) + Math.Abs(h.Im);                      ad = Math.Abs(s.Re) + Math.Abs(s.Im);                  }                  while (ah > ad * 1.1e-16);              }
Magic Number,YAMP.Physics,PolyLogFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PolyLogFunction.cs,Polylog,The following statement contains a magic number: if (ah > 3.0)                  return PolylogInversion(n' z);              else if (ah >= 0.75)              {                  var ad = 0.0;                  var x = z.Log();                  var h = -((-x).Log());                    for (i = 1; i < n; i++)                      h += 1.0 / i;                    var p = ScalarValue.One;                  s = PolylogZetaPositive(n);                    for (j = 1; j <= n + 1; j++)                  {                      p = p * x / j;                        if (j == n - 1)                          s += h * p;                      else                          s += PolylogZetaPositive(n - j) * p;                  }                    j = n + 3;                  x = x * x;                    for (; ; )                  {                      p = p * x / ((j - 1) * j);                      h = PolylogZetaPositive(n - j);                      h = h * p;                      s += h;                      ah = Math.Abs(h.Re) + Math.Abs(h.Im);                      ad = Math.Abs(s.Re) + Math.Abs(s.Im);                        if (ah < ad * double.Epsilon)                          break;                        j += 2;                  }                    return s;              }              else if(ah >= 1e-6)              {                  var p = z * z * z;                  var ad = 0.0;                  var k = 3.0;                  var h = ScalarValue.Zero;                    do                  {                      p = p * z;                      k += 1.0;                      h = p / Math.Pow(k' n);                      s += h;                      ah = Math.Abs(h.Re) + Math.Abs(h.Im);                      ad = Math.Abs(s.Re) + Math.Abs(s.Im);                  }                  while (ah > ad * 1.1e-16);              }
Magic Number,YAMP.Physics,PolyLogFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PolyLogFunction.cs,Polylog,The following statement contains a magic number: if (ah > 3.0)                  return PolylogInversion(n' z);              else if (ah >= 0.75)              {                  var ad = 0.0;                  var x = z.Log();                  var h = -((-x).Log());                    for (i = 1; i < n; i++)                      h += 1.0 / i;                    var p = ScalarValue.One;                  s = PolylogZetaPositive(n);                    for (j = 1; j <= n + 1; j++)                  {                      p = p * x / j;                        if (j == n - 1)                          s += h * p;                      else                          s += PolylogZetaPositive(n - j) * p;                  }                    j = n + 3;                  x = x * x;                    for (; ; )                  {                      p = p * x / ((j - 1) * j);                      h = PolylogZetaPositive(n - j);                      h = h * p;                      s += h;                      ah = Math.Abs(h.Re) + Math.Abs(h.Im);                      ad = Math.Abs(s.Re) + Math.Abs(s.Im);                        if (ah < ad * double.Epsilon)                          break;                        j += 2;                  }                    return s;              }              else if(ah >= 1e-6)              {                  var p = z * z * z;                  var ad = 0.0;                  var k = 3.0;                  var h = ScalarValue.Zero;                    do                  {                      p = p * z;                      k += 1.0;                      h = p / Math.Pow(k' n);                      s += h;                      ah = Math.Abs(h.Re) + Math.Abs(h.Im);                      ad = Math.Abs(s.Re) + Math.Abs(s.Im);                  }                  while (ah > ad * 1.1e-16);              }
Magic Number,YAMP.Physics,PolyLogFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PolyLogFunction.cs,Polylog,The following statement contains a magic number: if (ah > 3.0)                  return PolylogInversion(n' z);              else if (ah >= 0.75)              {                  var ad = 0.0;                  var x = z.Log();                  var h = -((-x).Log());                    for (i = 1; i < n; i++)                      h += 1.0 / i;                    var p = ScalarValue.One;                  s = PolylogZetaPositive(n);                    for (j = 1; j <= n + 1; j++)                  {                      p = p * x / j;                        if (j == n - 1)                          s += h * p;                      else                          s += PolylogZetaPositive(n - j) * p;                  }                    j = n + 3;                  x = x * x;                    for (; ; )                  {                      p = p * x / ((j - 1) * j);                      h = PolylogZetaPositive(n - j);                      h = h * p;                      s += h;                      ah = Math.Abs(h.Re) + Math.Abs(h.Im);                      ad = Math.Abs(s.Re) + Math.Abs(s.Im);                        if (ah < ad * double.Epsilon)                          break;                        j += 2;                  }                    return s;              }              else if(ah >= 1e-6)              {                  var p = z * z * z;                  var ad = 0.0;                  var k = 3.0;                  var h = ScalarValue.Zero;                    do                  {                      p = p * z;                      k += 1.0;                      h = p / Math.Pow(k' n);                      s += h;                      ah = Math.Abs(h.Re) + Math.Abs(h.Im);                      ad = Math.Abs(s.Re) + Math.Abs(s.Im);                  }                  while (ah > ad * 1.1e-16);              }
Magic Number,YAMP.Physics,PolyLogFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PolyLogFunction.cs,Polylog,The following statement contains a magic number: if (ah > 3.0)                  return PolylogInversion(n' z);              else if (ah >= 0.75)              {                  var ad = 0.0;                  var x = z.Log();                  var h = -((-x).Log());                    for (i = 1; i < n; i++)                      h += 1.0 / i;                    var p = ScalarValue.One;                  s = PolylogZetaPositive(n);                    for (j = 1; j <= n + 1; j++)                  {                      p = p * x / j;                        if (j == n - 1)                          s += h * p;                      else                          s += PolylogZetaPositive(n - j) * p;                  }                    j = n + 3;                  x = x * x;                    for (; ; )                  {                      p = p * x / ((j - 1) * j);                      h = PolylogZetaPositive(n - j);                      h = h * p;                      s += h;                      ah = Math.Abs(h.Re) + Math.Abs(h.Im);                      ad = Math.Abs(s.Re) + Math.Abs(s.Im);                        if (ah < ad * double.Epsilon)                          break;                        j += 2;                  }                    return s;              }              else if(ah >= 1e-6)              {                  var p = z * z * z;                  var ad = 0.0;                  var k = 3.0;                  var h = ScalarValue.Zero;                    do                  {                      p = p * z;                      k += 1.0;                      h = p / Math.Pow(k' n);                      s += h;                      ah = Math.Abs(h.Re) + Math.Abs(h.Im);                      ad = Math.Abs(s.Re) + Math.Abs(s.Im);                  }                  while (ah > ad * 1.1e-16);              }
Magic Number,YAMP.Physics,PolyLogFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PolyLogFunction.cs,Polylog,The following statement contains a magic number: s += z * z * z / Math.Pow(3.0' n);
Magic Number,YAMP.Physics,PolyLogFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PolyLogFunction.cs,Polylog,The following statement contains a magic number: s += z * z / Math.Pow(2.0' n);
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL0,The following statement contains a magic number: const int NTERM1 = 25;
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL0,The following statement contains a magic number: const int NTERM2 = 14;
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL0,The following statement contains a magic number: const int NTERM3 = 21;
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL0,The following statement contains a magic number: const double XLOW = 4.4703484e-8;
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL0,The following statement contains a magic number: const double XMAX = 1.797693e308;
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL0,The following statement contains a magic number: const double XHIGH1 = 5.1982303e8;
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL0,The following statement contains a magic number: const double XHIGH2 = 2.5220158e17;
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL0,The following statement contains a magic number: if (x <= 16.0)              {                  if (x < XLOW)                      return TWOBPI * x;                    double T = (4.0 * x - 24.0) / (x + 24.0);                  return TWOBPI * x * Helpers.ChebEval(NTERM1' ARL0' T) * Math.Exp(x);              }
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL0,The following statement contains a magic number: if (x <= 16.0)              {                  if (x < XLOW)                      return TWOBPI * x;                    double T = (4.0 * x - 24.0) / (x + 24.0);                  return TWOBPI * x * Helpers.ChebEval(NTERM1' ARL0' T) * Math.Exp(x);              }
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL0,The following statement contains a magic number: if (x <= 16.0)              {                  if (x < XLOW)                      return TWOBPI * x;                    double T = (4.0 * x - 24.0) / (x + 24.0);                  return TWOBPI * x * Helpers.ChebEval(NTERM1' ARL0' T) * Math.Exp(x);              }
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL0,The following statement contains a magic number: if (x <= 16.0)              {                  if (x < XLOW)                      return TWOBPI * x;                    double T = (4.0 * x - 24.0) / (x + 24.0);                  return TWOBPI * x * Helpers.ChebEval(NTERM1' ARL0' T) * Math.Exp(x);              }
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL0,The following statement contains a magic number: if (x > XHIGH2)                  ch1 = 1.0;              else              {                  double T = (x - 28.0) / (4.0 - x);                  ch1 = Helpers.ChebEval(NTERM2' ARL0AS' T);              }
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL0,The following statement contains a magic number: if (x > XHIGH2)                  ch1 = 1.0;              else              {                  double T = (x - 28.0) / (4.0 - x);                  ch1 = Helpers.ChebEval(NTERM2' ARL0AS' T);              }
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL0,The following statement contains a magic number: if (x > XHIGH1)                  ch2 = 1.0;              else              {                  double xsq = x * x;                  double T = (800.0 - xsq) / (288.0 + xsq);                  ch2 = Helpers.ChebEval(NTERM3' AI0ML0' T);              }
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL0,The following statement contains a magic number: if (x > XHIGH1)                  ch2 = 1.0;              else              {                  double xsq = x * x;                  double T = (800.0 - xsq) / (288.0 + xsq);                  ch2 = Helpers.ChebEval(NTERM3' AI0ML0' T);              }
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL0,The following statement contains a magic number: double test = Math.Log(ch1) - LNR2PI - Math.Log(x) / 2.0 + x;
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL1,The following statement contains a magic number: const int NTERM1 = 24;
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL1,The following statement contains a magic number: const int NTERM2 = 13;
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL1,The following statement contains a magic number: const int NTERM3 = 22;
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL1,The following statement contains a magic number: const double XLOW1 = 5.7711949e-8;
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL1,The following statement contains a magic number: const double XLOW2 = 3.3354714e-154;
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL1,The following statement contains a magic number: const double XMAX = 1.797693e308;
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL1,The following statement contains a magic number: const double XHIGH1 = 5.19823025e8;
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL1,The following statement contains a magic number: const double XHIGH2 = 2.7021597e17;
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL1,The following statement contains a magic number: if (x <= 16.0)              {                  if (x <= XLOW2)                      return 0.0;                    double xsq = x * x;                    if (x < XLOW1)                      return xsq / PI3BY2;                    double t = (4.0 * x - 24.0) / (x + 24.0);                  return xsq * Helpers.ChebEval(NTERM1' ARL1' t) * Math.Exp(x) / PI3BY2;              }
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL1,The following statement contains a magic number: if (x <= 16.0)              {                  if (x <= XLOW2)                      return 0.0;                    double xsq = x * x;                    if (x < XLOW1)                      return xsq / PI3BY2;                    double t = (4.0 * x - 24.0) / (x + 24.0);                  return xsq * Helpers.ChebEval(NTERM1' ARL1' t) * Math.Exp(x) / PI3BY2;              }
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL1,The following statement contains a magic number: if (x <= 16.0)              {                  if (x <= XLOW2)                      return 0.0;                    double xsq = x * x;                    if (x < XLOW1)                      return xsq / PI3BY2;                    double t = (4.0 * x - 24.0) / (x + 24.0);                  return xsq * Helpers.ChebEval(NTERM1' ARL1' t) * Math.Exp(x) / PI3BY2;              }
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL1,The following statement contains a magic number: if (x <= 16.0)              {                  if (x <= XLOW2)                      return 0.0;                    double xsq = x * x;                    if (x < XLOW1)                      return xsq / PI3BY2;                    double t = (4.0 * x - 24.0) / (x + 24.0);                  return xsq * Helpers.ChebEval(NTERM1' ARL1' t) * Math.Exp(x) / PI3BY2;              }
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL1,The following statement contains a magic number: if (x > XHIGH2)                  ch1 = 1.0;              else              {                  double t = (x - 30.0) / (2.0 - x);                  ch1 = Helpers.ChebEval(NTERM2' ARL1AS' t);              }
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL1,The following statement contains a magic number: if (x > XHIGH2)                  ch1 = 1.0;              else              {                  double t = (x - 30.0) / (2.0 - x);                  ch1 = Helpers.ChebEval(NTERM2' ARL1AS' t);              }
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL1,The following statement contains a magic number: if (x > XHIGH1)                  ch2 = 1.0;              else              {                  double xsq = x * x;                  double t = (800.0 - xsq) / (288.0 + xsq);                  ch2 = Helpers.ChebEval(NTERM3' AI1ML1' t);              }
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL1,The following statement contains a magic number: if (x > XHIGH1)                  ch2 = 1.0;              else              {                  double xsq = x * x;                  double t = (800.0 - xsq) / (288.0 + xsq);                  ch2 = Helpers.ChebEval(NTERM3' AI1ML1' t);              }
Magic Number,YAMP.Physics,StruveFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\StruveFunction.cs,StruveL1,The following statement contains a magic number: double test = Math.Log(ch1) - LNR2PI - Math.Log(x) / 2.0 + x;
Magic Number,YAMP.Physics,EllipticKFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\EllipticKFunction.cs,EllipticK,The following statement contains a magic number: if (k < 0.25)              {                  return EllipticSeries(k);              }              else if (k > 0.875)              {                  // for large k' use the asymptotic expansion near k~1' k'~0                  var k1 = Math.Sqrt(1.0 - k * k);                    // k'=0.484 at k=0.875                  if (k1 == 0.0)                  {                      return Double.PositiveInfinity;                  }                    return EllipticAsymptotic(k1);              }
Magic Number,YAMP.Physics,EllipticKFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\EllipticKFunction.cs,EllipticK,The following statement contains a magic number: if (k < 0.25)              {                  return EllipticSeries(k);              }              else if (k > 0.875)              {                  // for large k' use the asymptotic expansion near k~1' k'~0                  var k1 = Math.Sqrt(1.0 - k * k);                    // k'=0.484 at k=0.875                  if (k1 == 0.0)                  {                      return Double.PositiveInfinity;                  }                    return EllipticAsymptotic(k1);              }
Magic Number,YAMP.Physics,EllipticKFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\EllipticKFunction.cs,EllipticSeries,The following statement contains a magic number: for (var n = 1; n < 250; n++)              {                  var f_old = f;                  z = z * (2 * n - 1) / (2 * n) * k;                  f += z * z;                    if (f == f_old)                  {                      return Helpers.HalfPI * f;                  }              }
Magic Number,YAMP.Physics,EllipticKFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\EllipticKFunction.cs,EllipticSeries,The following statement contains a magic number: for (var n = 1; n < 250; n++)              {                  var f_old = f;                  z = z * (2 * n - 1) / (2 * n) * k;                  f += z * z;                    if (f == f_old)                  {                      return Helpers.HalfPI * f;                  }              }
Magic Number,YAMP.Physics,EllipticKFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\EllipticKFunction.cs,EllipticSeries,The following statement contains a magic number: for (var n = 1; n < 250; n++)              {                  var f_old = f;                  z = z * (2 * n - 1) / (2 * n) * k;                  f += z * z;                    if (f == f_old)                  {                      return Helpers.HalfPI * f;                  }              }
Magic Number,YAMP.Physics,EllipticKFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\EllipticKFunction.cs,EllipticAsymptotic,The following statement contains a magic number: var q = Math.Log(1.0 / k1) + 2.0 * Helpers.LogTwo;
Magic Number,YAMP.Physics,EllipticKFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\EllipticKFunction.cs,EllipticAsymptotic,The following statement contains a magic number: for (var m = 1; m < 250; m++)              {                  var f_old = f;                  p *= k1 / m * (m - 0.5);                  q -= 1.0 / m / (2 * m - 1);                  var df = p * p * q;                  f += df;                    if (f == f_old)                  {                      return f;                  }              }
Magic Number,YAMP.Physics,EllipticKFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\EllipticKFunction.cs,EllipticAsymptotic,The following statement contains a magic number: for (var m = 1; m < 250; m++)              {                  var f_old = f;                  p *= k1 / m * (m - 0.5);                  q -= 1.0 / m / (2 * m - 1);                  var df = p * p * q;                  f += df;                    if (f == f_old)                  {                      return f;                  }              }
Magic Number,YAMP.Physics,EllipticKFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\EllipticKFunction.cs,EllipticAsymptotic,The following statement contains a magic number: for (var m = 1; m < 250; m++)              {                  var f_old = f;                  p *= k1 / m * (m - 0.5);                  q -= 1.0 / m / (2 * m - 1);                  var df = p * p * q;                  f += df;                    if (f == f_old)                  {                      return f;                  }              }
Magic Number,YAMP.Physics,EllipticKFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\EllipticKFunction.cs,EllipticAGM,The following statement contains a magic number: var tol = Math.Pow(2.0' -24);
Magic Number,YAMP.Physics,EllipticKFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\EllipticKFunction.cs,EllipticAGM,The following statement contains a magic number: var tol = Math.Pow(2.0' -24);
Magic Number,YAMP.Physics,EllipticKFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\EllipticKFunction.cs,EllipticAGM,The following statement contains a magic number: for (var n = 0; n < 250; n++)              {                  var am = (a + b) / 2.0;                    if (Math.Abs(a - b) < tol)                  {                      return Helpers.HalfPI / am;                  }                    var gm = Math.Sqrt(a * b);                  a = am;                  b = gm;              }
Magic Number,YAMP.Physics,EllipticKFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Integrals\EllipticKFunction.cs,EllipticAGM,The following statement contains a magic number: for (var n = 0; n < 250; n++)              {                  var am = (a + b) / 2.0;                    if (Math.Abs(a - b) < tol)                  {                      return Helpers.HalfPI / am;                  }                    var gm = Math.Sqrt(a * b);                  a = am;                  b = gm;              }
Magic Number,YAMP.Physics,GegenbauerFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\GegenbauerFunction.cs,Gegenbauer,The following statement contains a magic number: var C1 = 2.0 * alpha * x;
Magic Number,YAMP.Physics,GegenbauerFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\GegenbauerFunction.cs,Gegenbauer,The following statement contains a magic number: for (var k = 2; k <= n; k++)              {                  var Ck = (2 * x * (k + alpha - 1) * C1 - (k + 2 * alpha - 2) * C0) / k;                  C0 = C1;                  C1 = Ck;              }
Magic Number,YAMP.Physics,GegenbauerFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\GegenbauerFunction.cs,Gegenbauer,The following statement contains a magic number: for (var k = 2; k <= n; k++)              {                  var Ck = (2 * x * (k + alpha - 1) * C1 - (k + 2 * alpha - 2) * C0) / k;                  C0 = C1;                  C1 = Ck;              }
Magic Number,YAMP.Physics,GegenbauerFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\GegenbauerFunction.cs,Gegenbauer,The following statement contains a magic number: for (var k = 2; k <= n; k++)              {                  var Ck = (2 * x * (k + alpha - 1) * C1 - (k + 2 * alpha - 2) * C0) / k;                  C0 = C1;                  C1 = Ck;              }
Magic Number,YAMP.Physics,GegenbauerFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\GegenbauerFunction.cs,Gegenbauer,The following statement contains a magic number: for (var k = 2; k <= n; k++)              {                  var Ck = (2 * x * (k + alpha - 1) * C1 - (k + 2 * alpha - 2) * C0) / k;                  C0 = C1;                  C1 = Ck;              }
Magic Number,YAMP.Physics,HermiteFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\HermiteFunction.cs,HermitePolynomial,The following statement contains a magic number: var mh = m / 2;
Magic Number,YAMP.Physics,HermiteFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\HermiteFunction.cs,HermitePolynomial,The following statement contains a magic number: var two_z = z * 2;
Magic Number,YAMP.Physics,HermiteFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\HermiteFunction.cs,HermitePolynomial,The following statement contains a magic number: var two_z_to_the_n_minus_2_times_m = m % 2 == 0 ? ScalarValue.One : two_z;
Magic Number,YAMP.Physics,HermiteFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\HermiteFunction.cs,HermitePolynomial,The following statement contains a magic number: for (int k = mh; k >= 0; k--)              {                  p += s / (Helpers.Factorial(k) * Helpers.Factorial(m - 2 * k)) * two_z_to_the_n_minus_2_times_m;                  s *= (-1);                  two_z_to_the_n_minus_2_times_m *= two_z_squared;              }
Magic Number,YAMP.Physics,JacobiFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\JacobiFunction.cs,JacobiPolynomial,The following statement contains a magic number: for (int k = 0; k < n / 2 + 1; k++)              {                  n_over_m[k] = 1;                    for (int i = 1; i <= k; i++)                      n_over_m[k] *= (n - (k - i)) / i;                    n_over_m[n - k] = n_over_m[k];              }
Magic Number,YAMP.Physics,JacobiFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\JacobiFunction.cs,JacobiPolynomial,The following statement contains a magic number: for (int k = 2; k < m; k++)                  n_factorial *= k;
Magic Number,YAMP.Physics,JacobiFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\JacobiFunction.cs,JacobiPolynomial,The following statement contains a magic number: z_minus_1_over_2 /= 2;
Magic Number,YAMP.Physics,LambertFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\LambertFunction.cs,LambertW,The following statement contains a magic number: if (abs < EI / 2.0)              {                  W = SeriesSmall(x);                    if ((x + EI).Abs() < 1e-6)                  {                      return W;                  }              }              else if (abs < EI)              {                  W = SeriesZero(x);              }              else if (abs > Math.E)              {                  W = SeriesLarge(x);              }              else              {                  W = new ScalarValue(0.5);              }
Magic Number,YAMP.Physics,LambertFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\LambertFunction.cs,LambertW,The following statement contains a magic number: if (abs < EI / 2.0)              {                  W = SeriesSmall(x);                    if ((x + EI).Abs() < 1e-6)                  {                      return W;                  }              }              else if (abs < EI)              {                  W = SeriesZero(x);              }              else if (abs > Math.E)              {                  W = SeriesLarge(x);              }              else              {                  W = new ScalarValue(0.5);              }
Magic Number,YAMP.Physics,LambertFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\LambertFunction.cs,LambertW,The following statement contains a magic number: if (abs < EI / 2.0)              {                  W = SeriesSmall(x);                    if ((x + EI).Abs() < 1e-6)                  {                      return W;                  }              }              else if (abs < EI)              {                  W = SeriesZero(x);              }              else if (abs > Math.E)              {                  W = SeriesLarge(x);              }              else              {                  W = new ScalarValue(0.5);              }
Magic Number,YAMP.Physics,LambertFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\LambertFunction.cs,Halley,The following statement contains a magic number: for (var i = 0; i < 250; i++)              {                  var e = w0.Exp();                  var f = e * w0 - x;                  var dw = f / ((w0 + 1.0) * e - ((w0 + 2.0) / (w0 + 1.0)) * f / 2.0);                  var w1 = w0 - dw;                    if (w1 == w0)                  {                      return w1;                  }                    w0 = w1;              }
Magic Number,YAMP.Physics,LambertFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\LambertFunction.cs,Halley,The following statement contains a magic number: for (var i = 0; i < 250; i++)              {                  var e = w0.Exp();                  var f = e * w0 - x;                  var dw = f / ((w0 + 1.0) * e - ((w0 + 2.0) / (w0 + 1.0)) * f / 2.0);                  var w1 = w0 - dw;                    if (w1 == w0)                  {                      return w1;                  }                    w0 = w1;              }
Magic Number,YAMP.Physics,LambertFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\LambertFunction.cs,Halley,The following statement contains a magic number: for (var i = 0; i < 250; i++)              {                  var e = w0.Exp();                  var f = e * w0 - x;                  var dw = f / ((w0 + 1.0) * e - ((w0 + 2.0) / (w0 + 1.0)) * f / 2.0);                  var w1 = w0 - dw;                    if (w1 == w0)                  {                      return w1;                  }                    w0 = w1;              }
Magic Number,YAMP.Physics,LambertFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\LambertFunction.cs,SeriesZero,The following statement contains a magic number: return x - xx + (3.0 / 2.0) * xx * x - (8.0 / 3.0) * xx * xx;
Magic Number,YAMP.Physics,LambertFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\LambertFunction.cs,SeriesZero,The following statement contains a magic number: return x - xx + (3.0 / 2.0) * xx * x - (8.0 / 3.0) * xx * xx;
Magic Number,YAMP.Physics,LambertFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\LambertFunction.cs,SeriesZero,The following statement contains a magic number: return x - xx + (3.0 / 2.0) * xx * x - (8.0 / 3.0) * xx * xx;
Magic Number,YAMP.Physics,LambertFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\LambertFunction.cs,SeriesZero,The following statement contains a magic number: return x - xx + (3.0 / 2.0) * xx * x - (8.0 / 3.0) * xx * xx;
Magic Number,YAMP.Physics,LambertFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\LambertFunction.cs,SeriesSmall,The following statement contains a magic number: var p = (2.0 * (Math.E * x + 1.0)).Sqrt();
Magic Number,YAMP.Physics,LambertFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\LambertFunction.cs,SeriesSmall,The following statement contains a magic number: return -1.0 + p - pp / 3.0 + (11.0 / 72.0) * pp * p - (43.0 / 540.0) * pp * pp;
Magic Number,YAMP.Physics,LambertFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\LambertFunction.cs,SeriesSmall,The following statement contains a magic number: return -1.0 + p - pp / 3.0 + (11.0 / 72.0) * pp * p - (43.0 / 540.0) * pp * pp;
Magic Number,YAMP.Physics,LambertFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\LambertFunction.cs,SeriesSmall,The following statement contains a magic number: return -1.0 + p - pp / 3.0 + (11.0 / 72.0) * pp * p - (43.0 / 540.0) * pp * pp;
Magic Number,YAMP.Physics,LambertFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\LambertFunction.cs,SeriesSmall,The following statement contains a magic number: return -1.0 + p - pp / 3.0 + (11.0 / 72.0) * pp * p - (43.0 / 540.0) * pp * pp;
Magic Number,YAMP.Physics,LambertFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\LambertFunction.cs,SeriesSmall,The following statement contains a magic number: return -1.0 + p - pp / 3.0 + (11.0 / 72.0) * pp * p - (43.0 / 540.0) * pp * pp;
Magic Number,YAMP.Physics,LambertFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\LambertFunction.cs,SeriesLarge,The following statement contains a magic number: return L1 - L2 + L2L1 + (L2 - 2.0) * L2L1 / L1 / 2.0;
Magic Number,YAMP.Physics,LambertFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\LambertFunction.cs,SeriesLarge,The following statement contains a magic number: return L1 - L2 + L2L1 + (L2 - 2.0) * L2L1 / L1 / 2.0;
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,LegendreFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\LegendreFunction.cs,GetPolynom,The following statement contains a magic number: switch (n)              {                  case 0:                      return x => 1.0;                  case 1:                      return x => x;                  case 2:                      return x => 1.5 * x * x - 0.5;                  case 3:                      return x => 2.5 * x * x * x - 1.5 * x;                  case 4:                      return x => (35.0 * x * x * x * x - 30.0 * x * x + 3.0) / 8.0;                  case 5:                      return x => (63.0 * x * x * x * x * x - 70.0 * x * x * x + 15.0 * x) / 8.0;                  case 6:                      return x => (231.0 * x * x * x * x * x * x - 315.0 * x * x * x * x + 105 * x * x - 5.0) / 16.0;                  default:                      return x =>                      {                          var sum = 0.0;                          var m = n / 2;                            for(var k = 0; k <= m; k++)                          {                              var nom = Helpers.Factorial(2 * n - 2 * k) * Math.Pow(x' n - 2 * k);                              var den = Helpers.Factorial(n - k) * Helpers.Factorial(n - 2 * k) * Helpers.Factorial(k) * Math.Pow(2' n);                              sum += nom / den;                          }                            return sum;                      };              }
Magic Number,YAMP.Physics,PsiFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PsiFunction.cs,Psi,The following statement contains a magic number: if (n % 2 == 0)                  result = -result;
Magic Number,YAMP.Physics,PsiFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PsiFunction.cs,Psi,The following statement contains a magic number: if (n % 2 == 0)                  result = -result;
Magic Number,YAMP.Physics,PsiFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PsiFunction.cs,Psi1,The following statement contains a magic number: if (x == 0.0 || x == -1.0 || x == -2.0)                  throw new YAMPArgumentRangeException("x"' "All values except 0.0' -1.0' -2.0");
Magic Number,YAMP.Physics,PsiFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PsiFunction.cs,Psi1,The following statement contains a magic number: if (x > 0.0)                  return PsiXgt0(1' x);              else if (x > -5.0)              {                  /* Abramowitz + Stegun 6.4.6 */                  int M = -((int)(Math.Floor(x)));                  var fx = x + M;                  var sum = 0.0;                    if (fx == 0.0)                      throw new YAMPNotConvergedException("psi");                    for (int m = 0; m < M; ++m)                  {                      var xm = x + m;                      sum += 1.0 / (xm * xm);                  }                    return PsiXgt0(1' fx) + sum;              }
Magic Number,YAMP.Physics,PsiFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PsiFunction.cs,Psi1,The following statement contains a magic number: if (z.Re == 0.0 || z.Re == -1.0 || z.Re == -2.0)                  throw new YAMPArgumentRangeException("z"' "All values except 0.0' -1.0' -2.0");
Magic Number,YAMP.Physics,PsiFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PsiFunction.cs,Psi1,The following statement contains a magic number: if (z.Re > 0.0)              {                  return PsiXgt0(1' z);              }              else if (z.Re > -5.0)              {                  /* Abramowitz + Stegun 6.4.6 */                  int M = -((Int32)(Math.Floor(z.Re)));                  var fx = z + M;                  var sum = ScalarValue.Zero;                    if (fx == 0.0)                      throw new YAMPNotConvergedException("psi");                    for (var m = 0; m < M; ++m)                  {                      var xm = z + m;                      sum += 1.0 / (xm * xm);                  }                    return PsiXgt0(1' fx) + sum;              }
Magic Number,YAMP.Physics,PsiFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PsiFunction.cs,PsiXgt0,The following statement contains a magic number: if (n % 2 == 0)              {                  result = -result;              }
Magic Number,YAMP.Physics,PsiFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PsiFunction.cs,PsiXgt0,The following statement contains a magic number: if (n % 2 == 0)                  result = -result;
Magic Number,YAMP.Physics,PsiFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PsiFunction.cs,Psi0rhp,The following statement contains a magic number: if (z.Re < 20.0 && Math.Abs(z.Im) < 20.0)              {                  double sp = Math.Sqrt(20.0 + z.Im);                  double sn = Math.Sqrt(20.0 - z.Im);                  double rhs = sp * sn - z.Re;                    if (rhs > 0.0)                      n_recurse = (int)(Math.Ceiling(rhs));              }
Magic Number,YAMP.Physics,PsiFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PsiFunction.cs,Psi0rhp,The following statement contains a magic number: if (z.Re < 20.0 && Math.Abs(z.Im) < 20.0)              {                  double sp = Math.Sqrt(20.0 + z.Im);                  double sn = Math.Sqrt(20.0 - z.Im);                  double rhs = sp * sn - z.Re;                    if (rhs > 0.0)                      n_recurse = (int)(Math.Ceiling(rhs));              }
Magic Number,YAMP.Physics,PsiFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PsiFunction.cs,Psi0rhp,The following statement contains a magic number: if (z.Re < 20.0 && Math.Abs(z.Im) < 20.0)              {                  double sp = Math.Sqrt(20.0 + z.Im);                  double sn = Math.Sqrt(20.0 - z.Im);                  double rhs = sp * sn - z.Re;                    if (rhs > 0.0)                      n_recurse = (int)(Math.Ceiling(rhs));              }
Magic Number,YAMP.Physics,PsiFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PsiFunction.cs,Psi0rhp,The following statement contains a magic number: if (z.Re < 20.0 && Math.Abs(z.Im) < 20.0)              {                  double sp = Math.Sqrt(20.0 + z.Im);                  double sn = Math.Sqrt(20.0 - z.Im);                  double rhs = sp * sn - z.Re;                    if (rhs > 0.0)                      n_recurse = (int)(Math.Ceiling(rhs));              }
Magic Number,YAMP.Physics,PsiFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PsiFunction.cs,Psi0asymptotic,The following statement contains a magic number: const double c1 = -0.1;
Magic Number,YAMP.Physics,PsiFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PsiFunction.cs,Psi0asymptotic,The following statement contains a magic number: const double c2 = 1.0 / 21.0;
Magic Number,YAMP.Physics,PsiFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PsiFunction.cs,Psi0asymptotic,The following statement contains a magic number: const double c3 = -0.05;
Magic Number,YAMP.Physics,PsiFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PsiFunction.cs,Psi0asymptotic,The following statement contains a magic number: const double c4 = -1.0 / 12.0;
Magic Number,YAMP.Physics,PsiFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\PsiFunction.cs,Psi0asymptotic,The following statement contains a magic number: cs = cs + (zi * (-0.5));
Magic Number,YAMP.Physics,SpenceFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\SpenceFunction.cs,DiLog,The following statement contains a magic number: if (a0 > 1.0)              {                  // outside the unit disk' reflect into the unit disk                  var ln = (-z).Ln();                  f = -Math.PI * Math.PI / 6.0 - ln * ln / 2.0 - DiLog(1.0 / z);              }              else              {                  // inside the unit disk...                  if (a0 < 0.75)                  {                      f = DiLog0(z);                  }                  else if (z.Re < 0.0)                  {                      f = DiLog(z * z) / 2.0 - DiLog(-z);                  }                  else                  {                      var e = 1.0 - z;                      f = e.Abs() < 0.5 ? DiLog1(e) : DiLog_Log_Series(z);                  }              }
Magic Number,YAMP.Physics,SpenceFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\SpenceFunction.cs,DiLog,The following statement contains a magic number: if (a0 > 1.0)              {                  // outside the unit disk' reflect into the unit disk                  var ln = (-z).Ln();                  f = -Math.PI * Math.PI / 6.0 - ln * ln / 2.0 - DiLog(1.0 / z);              }              else              {                  // inside the unit disk...                  if (a0 < 0.75)                  {                      f = DiLog0(z);                  }                  else if (z.Re < 0.0)                  {                      f = DiLog(z * z) / 2.0 - DiLog(-z);                  }                  else                  {                      var e = 1.0 - z;                      f = e.Abs() < 0.5 ? DiLog1(e) : DiLog_Log_Series(z);                  }              }
Magic Number,YAMP.Physics,SpenceFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\SpenceFunction.cs,DiLog,The following statement contains a magic number: if (a0 > 1.0)              {                  // outside the unit disk' reflect into the unit disk                  var ln = (-z).Ln();                  f = -Math.PI * Math.PI / 6.0 - ln * ln / 2.0 - DiLog(1.0 / z);              }              else              {                  // inside the unit disk...                  if (a0 < 0.75)                  {                      f = DiLog0(z);                  }                  else if (z.Re < 0.0)                  {                      f = DiLog(z * z) / 2.0 - DiLog(-z);                  }                  else                  {                      var e = 1.0 - z;                      f = e.Abs() < 0.5 ? DiLog1(e) : DiLog_Log_Series(z);                  }              }
Magic Number,YAMP.Physics,SpenceFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\SpenceFunction.cs,DiLog,The following statement contains a magic number: if (a0 > 1.0)              {                  // outside the unit disk' reflect into the unit disk                  var ln = (-z).Ln();                  f = -Math.PI * Math.PI / 6.0 - ln * ln / 2.0 - DiLog(1.0 / z);              }              else              {                  // inside the unit disk...                  if (a0 < 0.75)                  {                      f = DiLog0(z);                  }                  else if (z.Re < 0.0)                  {                      f = DiLog(z * z) / 2.0 - DiLog(-z);                  }                  else                  {                      var e = 1.0 - z;                      f = e.Abs() < 0.5 ? DiLog1(e) : DiLog_Log_Series(z);                  }              }
Magic Number,YAMP.Physics,SpenceFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\SpenceFunction.cs,DiLog,The following statement contains a magic number: if (a0 > 1.0)              {                  // outside the unit disk' reflect into the unit disk                  var ln = (-z).Ln();                  f = -Math.PI * Math.PI / 6.0 - ln * ln / 2.0 - DiLog(1.0 / z);              }              else              {                  // inside the unit disk...                  if (a0 < 0.75)                  {                      f = DiLog0(z);                  }                  else if (z.Re < 0.0)                  {                      f = DiLog(z * z) / 2.0 - DiLog(-z);                  }                  else                  {                      var e = 1.0 - z;                      f = e.Abs() < 0.5 ? DiLog1(e) : DiLog_Log_Series(z);                  }              }
Magic Number,YAMP.Physics,SpenceFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\SpenceFunction.cs,DiLog0,The following statement contains a magic number: for (var k = 2; k < 250; k++)              {                  var f_old = f.Clone();                  zz *= z;                  f += zz / (k * k);                    if (f == f_old)                  {                      return f;                  }              }
Magic Number,YAMP.Physics,SpenceFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\SpenceFunction.cs,DiLog0,The following statement contains a magic number: for (var k = 2; k < 250; k++)              {                  var f_old = f.Clone();                  zz *= z;                  f += zz / (k * k);                    if (f == f_old)                  {                      return f;                  }              }
Magic Number,YAMP.Physics,SpenceFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\SpenceFunction.cs,DiLog1,The following statement contains a magic number: var f = new ScalarValue(Math.PI * Math.PI / 6.0);
Magic Number,YAMP.Physics,SpenceFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\SpenceFunction.cs,DiLog1,The following statement contains a magic number: for (var k = 1; k < 250; k++)              {                  var f_old = f.Clone();                  ek *= e;                  var df = ek * (L - 1.0 / k) / k;                  f += df;                    if (f == f_old)                  {                      return f;                  }              }
Magic Number,YAMP.Physics,SpenceFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\SpenceFunction.cs,DiLog_Log_Series,The following statement contains a magic number: var f = Math.PI * Math.PI / 6.0 + ln * (1.0 - (-ln).Ln()) - ln2 / 4.0;
Magic Number,YAMP.Physics,SpenceFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\SpenceFunction.cs,DiLog_Log_Series,The following statement contains a magic number: var f = Math.PI * Math.PI / 6.0 + ln * (1.0 - (-ln).Ln()) - ln2 / 4.0;
Magic Number,YAMP.Physics,SpenceFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\SpenceFunction.cs,DiLog_Log_Series,The following statement contains a magic number: for (var k = 1; k < 17; k++)              {                  var f_old = f.Clone();                  p *= ln2 / (2 * k + 1) / (2 * k);                  f += (-Helpers.BernoulliNumbers[k] / (2 * k)) * p;                    if (f == f_old)                  {                      return f;                  }              }
Magic Number,YAMP.Physics,SpenceFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\SpenceFunction.cs,DiLog_Log_Series,The following statement contains a magic number: for (var k = 1; k < 17; k++)              {                  var f_old = f.Clone();                  p *= ln2 / (2 * k + 1) / (2 * k);                  f += (-Helpers.BernoulliNumbers[k] / (2 * k)) * p;                    if (f == f_old)                  {                      return f;                  }              }
Magic Number,YAMP.Physics,SpenceFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\SpenceFunction.cs,DiLog_Log_Series,The following statement contains a magic number: for (var k = 1; k < 17; k++)              {                  var f_old = f.Clone();                  p *= ln2 / (2 * k + 1) / (2 * k);                  f += (-Helpers.BernoulliNumbers[k] / (2 * k)) * p;                    if (f == f_old)                  {                      return f;                  }              }
Magic Number,YAMP.Physics,SpenceFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\SpenceFunction.cs,DiLog_Log_Series,The following statement contains a magic number: for (var k = 1; k < 17; k++)              {                  var f_old = f.Clone();                  p *= ln2 / (2 * k + 1) / (2 * k);                  f += (-Helpers.BernoulliNumbers[k] / (2 * k)) * p;                    if (f == f_old)                  {                      return f;                  }              }
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Pl,The following statement contains a magic number: if (l == 0)                  return 1.0;              else if (l == 1)                  return x;              else if (l == 2)                  return 0.5 * (3.0 * x * x - 1.0);              else if (x == 1.0)                  return 1.0;              else if (x == -1.0)                  return (l % 2 == 1 ? -1.0 : 1.0);              else if (l < 100000)              {                  /* upward recurrence: l P_l = (2l-1) z P_{l-1} - (l-1) P_{l-2} */                    var p_ellm2 = 1.0;    /* P_0(x) */                  var p_ellm1 = x;      /* P_1(x) */                  var p_ell = p_ellm1;                  var e_ellm2 = double.Epsilon;                  var e_ellm1 = Math.Abs(x) * double.Epsilon;                  var e_ell = e_ellm1;                    for (int ell = 2; ell <= l; ell++)                  {                      p_ell = (x * (2 * ell - 1) * p_ellm1 - (ell - 1) * p_ellm2) / ell;                      p_ellm2 = p_ellm1;                      p_ellm1 = p_ell;                      e_ell = 0.5 * (Math.Abs(x) * (2 * ell - 1.0) * e_ellm1 + (ell - 1.0) * e_ellm2) / ell;                      e_ellm2 = e_ellm1;                      e_ellm1 = e_ell;                  }                    return p_ell;              }
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Pl,The following statement contains a magic number: if (l == 0)                  return 1.0;              else if (l == 1)                  return x;              else if (l == 2)                  return 0.5 * (3.0 * x * x - 1.0);              else if (x == 1.0)                  return 1.0;              else if (x == -1.0)                  return (l % 2 == 1 ? -1.0 : 1.0);              else if (l < 100000)              {                  /* upward recurrence: l P_l = (2l-1) z P_{l-1} - (l-1) P_{l-2} */                    var p_ellm2 = 1.0;    /* P_0(x) */                  var p_ellm1 = x;      /* P_1(x) */                  var p_ell = p_ellm1;                  var e_ellm2 = double.Epsilon;                  var e_ellm1 = Math.Abs(x) * double.Epsilon;                  var e_ell = e_ellm1;                    for (int ell = 2; ell <= l; ell++)                  {                      p_ell = (x * (2 * ell - 1) * p_ellm1 - (ell - 1) * p_ellm2) / ell;                      p_ellm2 = p_ellm1;                      p_ellm1 = p_ell;                      e_ell = 0.5 * (Math.Abs(x) * (2 * ell - 1.0) * e_ellm1 + (ell - 1.0) * e_ellm2) / ell;                      e_ellm2 = e_ellm1;                      e_ellm1 = e_ell;                  }                    return p_ell;              }
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Pl,The following statement contains a magic number: if (l == 0)                  return 1.0;              else if (l == 1)                  return x;              else if (l == 2)                  return 0.5 * (3.0 * x * x - 1.0);              else if (x == 1.0)                  return 1.0;              else if (x == -1.0)                  return (l % 2 == 1 ? -1.0 : 1.0);              else if (l < 100000)              {                  /* upward recurrence: l P_l = (2l-1) z P_{l-1} - (l-1) P_{l-2} */                    var p_ellm2 = 1.0;    /* P_0(x) */                  var p_ellm1 = x;      /* P_1(x) */                  var p_ell = p_ellm1;                  var e_ellm2 = double.Epsilon;                  var e_ellm1 = Math.Abs(x) * double.Epsilon;                  var e_ell = e_ellm1;                    for (int ell = 2; ell <= l; ell++)                  {                      p_ell = (x * (2 * ell - 1) * p_ellm1 - (ell - 1) * p_ellm2) / ell;                      p_ellm2 = p_ellm1;                      p_ellm1 = p_ell;                      e_ell = 0.5 * (Math.Abs(x) * (2 * ell - 1.0) * e_ellm1 + (ell - 1.0) * e_ellm2) / ell;                      e_ellm2 = e_ellm1;                      e_ellm1 = e_ell;                  }                    return p_ell;              }
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Pl,The following statement contains a magic number: if (l == 0)                  return 1.0;              else if (l == 1)                  return x;              else if (l == 2)                  return 0.5 * (3.0 * x * x - 1.0);              else if (x == 1.0)                  return 1.0;              else if (x == -1.0)                  return (l % 2 == 1 ? -1.0 : 1.0);              else if (l < 100000)              {                  /* upward recurrence: l P_l = (2l-1) z P_{l-1} - (l-1) P_{l-2} */                    var p_ellm2 = 1.0;    /* P_0(x) */                  var p_ellm1 = x;      /* P_1(x) */                  var p_ell = p_ellm1;                  var e_ellm2 = double.Epsilon;                  var e_ellm1 = Math.Abs(x) * double.Epsilon;                  var e_ell = e_ellm1;                    for (int ell = 2; ell <= l; ell++)                  {                      p_ell = (x * (2 * ell - 1) * p_ellm1 - (ell - 1) * p_ellm2) / ell;                      p_ellm2 = p_ellm1;                      p_ellm1 = p_ell;                      e_ell = 0.5 * (Math.Abs(x) * (2 * ell - 1.0) * e_ellm1 + (ell - 1.0) * e_ellm2) / ell;                      e_ellm2 = e_ellm1;                      e_ellm1 = e_ell;                  }                    return p_ell;              }
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Pl,The following statement contains a magic number: if (l == 0)                  return 1.0;              else if (l == 1)                  return x;              else if (l == 2)                  return 0.5 * (3.0 * x * x - 1.0);              else if (x == 1.0)                  return 1.0;              else if (x == -1.0)                  return (l % 2 == 1 ? -1.0 : 1.0);              else if (l < 100000)              {                  /* upward recurrence: l P_l = (2l-1) z P_{l-1} - (l-1) P_{l-2} */                    var p_ellm2 = 1.0;    /* P_0(x) */                  var p_ellm1 = x;      /* P_1(x) */                  var p_ell = p_ellm1;                  var e_ellm2 = double.Epsilon;                  var e_ellm1 = Math.Abs(x) * double.Epsilon;                  var e_ell = e_ellm1;                    for (int ell = 2; ell <= l; ell++)                  {                      p_ell = (x * (2 * ell - 1) * p_ellm1 - (ell - 1) * p_ellm2) / ell;                      p_ellm2 = p_ellm1;                      p_ellm1 = p_ell;                      e_ell = 0.5 * (Math.Abs(x) * (2 * ell - 1.0) * e_ellm1 + (ell - 1.0) * e_ellm2) / ell;                      e_ellm2 = e_ellm1;                      e_ellm1 = e_ell;                  }                    return p_ell;              }
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Pl,The following statement contains a magic number: if (l == 0)                  return 1.0;              else if (l == 1)                  return x;              else if (l == 2)                  return 0.5 * (3.0 * x * x - 1.0);              else if (x == 1.0)                  return 1.0;              else if (x == -1.0)                  return (l % 2 == 1 ? -1.0 : 1.0);              else if (l < 100000)              {                  /* upward recurrence: l P_l = (2l-1) z P_{l-1} - (l-1) P_{l-2} */                    var p_ellm2 = 1.0;    /* P_0(x) */                  var p_ellm1 = x;      /* P_1(x) */                  var p_ell = p_ellm1;                  var e_ellm2 = double.Epsilon;                  var e_ellm1 = Math.Abs(x) * double.Epsilon;                  var e_ell = e_ellm1;                    for (int ell = 2; ell <= l; ell++)                  {                      p_ell = (x * (2 * ell - 1) * p_ellm1 - (ell - 1) * p_ellm2) / ell;                      p_ellm2 = p_ellm1;                      p_ellm1 = p_ell;                      e_ell = 0.5 * (Math.Abs(x) * (2 * ell - 1.0) * e_ellm1 + (ell - 1.0) * e_ellm2) / ell;                      e_ellm2 = e_ellm1;                      e_ellm1 = e_ell;                  }                    return p_ell;              }
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Pl,The following statement contains a magic number: if (l == 0)                  return 1.0;              else if (l == 1)                  return x;              else if (l == 2)                  return 0.5 * (3.0 * x * x - 1.0);              else if (x == 1.0)                  return 1.0;              else if (x == -1.0)                  return (l % 2 == 1 ? -1.0 : 1.0);              else if (l < 100000)              {                  /* upward recurrence: l P_l = (2l-1) z P_{l-1} - (l-1) P_{l-2} */                    var p_ellm2 = 1.0;    /* P_0(x) */                  var p_ellm1 = x;      /* P_1(x) */                  var p_ell = p_ellm1;                  var e_ellm2 = double.Epsilon;                  var e_ellm1 = Math.Abs(x) * double.Epsilon;                  var e_ell = e_ellm1;                    for (int ell = 2; ell <= l; ell++)                  {                      p_ell = (x * (2 * ell - 1) * p_ellm1 - (ell - 1) * p_ellm2) / ell;                      p_ellm2 = p_ellm1;                      p_ellm1 = p_ell;                      e_ell = 0.5 * (Math.Abs(x) * (2 * ell - 1.0) * e_ellm1 + (ell - 1.0) * e_ellm2) / ell;                      e_ellm2 = e_ellm1;                      e_ellm1 = e_ell;                  }                    return p_ell;              }
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Pl,The following statement contains a magic number: if (l == 0)                  return 1.0;              else if (l == 1)                  return x;              else if (l == 2)                  return 0.5 * (3.0 * x * x - 1.0);              else if (x == 1.0)                  return 1.0;              else if (x == -1.0)                  return (l % 2 == 1 ? -1.0 : 1.0);              else if (l < 100000)              {                  /* upward recurrence: l P_l = (2l-1) z P_{l-1} - (l-1) P_{l-2} */                    var p_ellm2 = 1.0;    /* P_0(x) */                  var p_ellm1 = x;      /* P_1(x) */                  var p_ell = p_ellm1;                  var e_ellm2 = double.Epsilon;                  var e_ellm1 = Math.Abs(x) * double.Epsilon;                  var e_ell = e_ellm1;                    for (int ell = 2; ell <= l; ell++)                  {                      p_ell = (x * (2 * ell - 1) * p_ellm1 - (ell - 1) * p_ellm2) / ell;                      p_ellm2 = p_ellm1;                      p_ellm1 = p_ell;                      e_ell = 0.5 * (Math.Abs(x) * (2 * ell - 1.0) * e_ellm1 + (ell - 1.0) * e_ellm2) / ell;                      e_ellm2 = e_ellm1;                      e_ellm1 = e_ell;                  }                    return p_ell;              }
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Pl,The following statement contains a magic number: if (l == 0)                  return 1.0;              else if (l == 1)                  return x;              else if (l == 2)                  return 0.5 * (3.0 * x * x - 1.0);              else if (x == 1.0)                  return 1.0;              else if (x == -1.0)                  return (l % 2 == 1 ? -1.0 : 1.0);              else if (l < 100000)              {                  /* upward recurrence: l P_l = (2l-1) z P_{l-1} - (l-1) P_{l-2} */                    var p_ellm2 = 1.0;    /* P_0(x) */                  var p_ellm1 = x;      /* P_1(x) */                  var p_ell = p_ellm1;                  var e_ellm2 = double.Epsilon;                  var e_ellm1 = Math.Abs(x) * double.Epsilon;                  var e_ell = e_ellm1;                    for (int ell = 2; ell <= l; ell++)                  {                      p_ell = (x * (2 * ell - 1) * p_ellm1 - (ell - 1) * p_ellm2) / ell;                      p_ellm2 = p_ellm1;                      p_ellm1 = p_ell;                      e_ell = 0.5 * (Math.Abs(x) * (2 * ell - 1.0) * e_ellm1 + (ell - 1.0) * e_ellm2) / ell;                      e_ellm2 = e_ellm1;                      e_ellm1 = e_ell;                  }                    return p_ell;              }
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Pl,The following statement contains a magic number: double u = l + 0.5;
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Pl,The following statement contains a magic number: if (th < 1.2207031250000000e-04)              {                  B00 = (1.0 + th * th / 15.0) / 24.0;                  pre = 1.0 + th * th / 12.0;              }              else              {                  double sin_th = Math.Sqrt(1.0 - x * x);                  double cot_th = x / sin_th;                  B00 = 1.0 / 8.0 * (1.0 - th * cot_th) / (th * th);                  pre = Math.Sqrt(th / sin_th);              }
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Pl,The following statement contains a magic number: if (th < 1.2207031250000000e-04)              {                  B00 = (1.0 + th * th / 15.0) / 24.0;                  pre = 1.0 + th * th / 12.0;              }              else              {                  double sin_th = Math.Sqrt(1.0 - x * x);                  double cot_th = x / sin_th;                  B00 = 1.0 / 8.0 * (1.0 - th * cot_th) / (th * th);                  pre = Math.Sqrt(th / sin_th);              }
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Pl,The following statement contains a magic number: if (th < 1.2207031250000000e-04)              {                  B00 = (1.0 + th * th / 15.0) / 24.0;                  pre = 1.0 + th * th / 12.0;              }              else              {                  double sin_th = Math.Sqrt(1.0 - x * x);                  double cot_th = x / sin_th;                  B00 = 1.0 / 8.0 * (1.0 - th * cot_th) / (th * th);                  pre = Math.Sqrt(th / sin_th);              }
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Pl,The following statement contains a magic number: if (th < 1.2207031250000000e-04)              {                  B00 = (1.0 + th * th / 15.0) / 24.0;                  pre = 1.0 + th * th / 12.0;              }              else              {                  double sin_th = Math.Sqrt(1.0 - x * x);                  double cot_th = x / sin_th;                  B00 = 1.0 / 8.0 * (1.0 - th * cot_th) / (th * th);                  pre = Math.Sqrt(th / sin_th);              }
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Pl,The following statement contains a magic number: if (th < 1.2207031250000000e-04)              {                  B00 = (1.0 + th * th / 15.0) / 24.0;                  pre = 1.0 + th * th / 12.0;              }              else              {                  double sin_th = Math.Sqrt(1.0 - x * x);                  double cot_th = x / sin_th;                  B00 = 1.0 / 8.0 * (1.0 - th * cot_th) / (th * th);                  pre = Math.Sqrt(th / sin_th);              }
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Plm,The following statement contains a magic number: if (m == 0)              {                  var res = Pl(l' x);                  var pre = Math.Sqrt((2.0 * l + 1.0) / (4.0 * Math.PI));                  return pre * res;              }              else if (x == 1.0 || x == -1.0)                  return 0.0;
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Plm,The following statement contains a magic number: if (m == 0)              {                  var res = Pl(l' x);                  var pre = Math.Sqrt((2.0 * l + 1.0) / (4.0 * Math.PI));                  return pre * res;              }              else if (x == 1.0 || x == -1.0)                  return 0.0;
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Plm,The following statement contains a magic number: double sgn = m % 2 == 1 ? -1.0 : 1.0;
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Plm,The following statement contains a magic number: double y_mmp1_factor = x * Math.Sqrt(2.0 * m + 3.0);
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Plm,The following statement contains a magic number: double y_mmp1_factor = x * Math.Sqrt(2.0 * m + 3.0);
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Plm,The following statement contains a magic number: double lnpoch = Gamma.LogGamma(m + 0.5) - Gamma.LogGamma(m);
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Plm,The following statement contains a magic number: double expf = Math.Exp(0.5 * (lnpoch + m * lncirc) - 0.25 * Helpers.LogPI);
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Plm,The following statement contains a magic number: double expf = Math.Exp(0.5 * (lnpoch + m * lncirc) - 0.25 * Helpers.LogPI);
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Plm,The following statement contains a magic number: double sr = Math.Sqrt((2.0 + 1.0 / m) / Helpers.FourPI);
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Plm,The following statement contains a magic number: for (int ell = m + 2; ell <= l; ell++)              {                  var rat1 = (double)(ell - m) / (double)(ell + m);                  var rat2 = (ell - m - 1.0) / (ell + m - 1.0);                  var factor1 = Math.Sqrt(rat1 * (2.0 * ell + 1.0) * (2.0 * ell - 1.0));                  var factor2 = Math.Sqrt(rat1 * rat2 * (2.0 * ell + 1.0) / (2.0 * ell - 3.0));                  y_ell = (x * y_mmp1 * factor1 - (ell + m - 1.0) * y_mm * factor2) / (ell - m);                  y_mm = y_mmp1;                  y_mmp1 = y_ell;              }
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Plm,The following statement contains a magic number: for (int ell = m + 2; ell <= l; ell++)              {                  var rat1 = (double)(ell - m) / (double)(ell + m);                  var rat2 = (ell - m - 1.0) / (ell + m - 1.0);                  var factor1 = Math.Sqrt(rat1 * (2.0 * ell + 1.0) * (2.0 * ell - 1.0));                  var factor2 = Math.Sqrt(rat1 * rat2 * (2.0 * ell + 1.0) / (2.0 * ell - 3.0));                  y_ell = (x * y_mmp1 * factor1 - (ell + m - 1.0) * y_mm * factor2) / (ell - m);                  y_mm = y_mmp1;                  y_mmp1 = y_ell;              }
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Plm,The following statement contains a magic number: for (int ell = m + 2; ell <= l; ell++)              {                  var rat1 = (double)(ell - m) / (double)(ell + m);                  var rat2 = (ell - m - 1.0) / (ell + m - 1.0);                  var factor1 = Math.Sqrt(rat1 * (2.0 * ell + 1.0) * (2.0 * ell - 1.0));                  var factor2 = Math.Sqrt(rat1 * rat2 * (2.0 * ell + 1.0) / (2.0 * ell - 3.0));                  y_ell = (x * y_mmp1 * factor1 - (ell + m - 1.0) * y_mm * factor2) / (ell - m);                  y_mm = y_mmp1;                  y_mmp1 = y_ell;              }
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Plm,The following statement contains a magic number: for (int ell = m + 2; ell <= l; ell++)              {                  var rat1 = (double)(ell - m) / (double)(ell + m);                  var rat2 = (ell - m - 1.0) / (ell + m - 1.0);                  var factor1 = Math.Sqrt(rat1 * (2.0 * ell + 1.0) * (2.0 * ell - 1.0));                  var factor2 = Math.Sqrt(rat1 * rat2 * (2.0 * ell + 1.0) / (2.0 * ell - 3.0));                  y_ell = (x * y_mmp1 * factor1 - (ell + m - 1.0) * y_mm * factor2) / (ell - m);                  y_mm = y_mmp1;                  y_mmp1 = y_ell;              }
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Plm,The following statement contains a magic number: for (int ell = m + 2; ell <= l; ell++)              {                  var rat1 = (double)(ell - m) / (double)(ell + m);                  var rat2 = (ell - m - 1.0) / (ell + m - 1.0);                  var factor1 = Math.Sqrt(rat1 * (2.0 * ell + 1.0) * (2.0 * ell - 1.0));                  var factor2 = Math.Sqrt(rat1 * rat2 * (2.0 * ell + 1.0) / (2.0 * ell - 3.0));                  y_ell = (x * y_mmp1 * factor1 - (ell + m - 1.0) * y_mm * factor2) / (ell - m);                  y_mm = y_mmp1;                  y_mmp1 = y_ell;              }
Magic Number,YAMP.Physics,YlmFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Special\YlmFunction.cs,Plm,The following statement contains a magic number: for (int ell = m + 2; ell <= l; ell++)              {                  var rat1 = (double)(ell - m) / (double)(ell + m);                  var rat2 = (ell - m - 1.0) / (ell + m - 1.0);                  var factor1 = Math.Sqrt(rat1 * (2.0 * ell + 1.0) * (2.0 * ell - 1.0));                  var factor2 = Math.Sqrt(rat1 * rat2 * (2.0 * ell + 1.0) / (2.0 * ell - 3.0));                  y_ell = (x * y_mmp1 * factor1 - (ell + m - 1.0) * y_mm * factor2) / (ell - m);                  y_mm = y_mmp1;                  y_mmp1 = y_ell;              }
Magic Number,YAMP.Physics,ZernikeFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\ZernikeFunction.cs,Zernike,The following statement contains a magic number: if ((n - m) % 2 != 0)              {                  return ScalarValue.Zero;              }
Magic Number,YAMP.Physics,ZernikeFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\ZernikeFunction.cs,Zernike,The following statement contains a magic number: while (true)              {                  k += 2;                    // *                  //  \                  //   * recurrence involving two lesser m's                  //  /                  // *                  // 2n R^{m+1}_{n-1} = (n+m) R^{m}_{n-2} + (n-m) R^{m}_{n}                    var r0 = ((2 * k) * rho * r1 - (k + m) * r2) / (k - m);                    if (k == n)                  {                      return r0;                  }                    //   *                  //  /                  // * recurrence involving two greater m's                  //  \                  //   *                  //                     var rp = (2 * (k + 1) * rho * r0 - (k - m) * r1) / (k + m + 2);                    r2 = r0;                  r1 = rp;              }
Magic Number,YAMP.Physics,ZernikeFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\ZernikeFunction.cs,Zernike,The following statement contains a magic number: while (true)              {                  k += 2;                    // *                  //  \                  //   * recurrence involving two lesser m's                  //  /                  // *                  // 2n R^{m+1}_{n-1} = (n+m) R^{m}_{n-2} + (n-m) R^{m}_{n}                    var r0 = ((2 * k) * rho * r1 - (k + m) * r2) / (k - m);                    if (k == n)                  {                      return r0;                  }                    //   *                  //  /                  // * recurrence involving two greater m's                  //  \                  //   *                  //                     var rp = (2 * (k + 1) * rho * r0 - (k - m) * r1) / (k + m + 2);                    r2 = r0;                  r1 = rp;              }
Magic Number,YAMP.Physics,ZernikeFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\ZernikeFunction.cs,Zernike,The following statement contains a magic number: while (true)              {                  k += 2;                    // *                  //  \                  //   * recurrence involving two lesser m's                  //  /                  // *                  // 2n R^{m+1}_{n-1} = (n+m) R^{m}_{n-2} + (n-m) R^{m}_{n}                    var r0 = ((2 * k) * rho * r1 - (k + m) * r2) / (k - m);                    if (k == n)                  {                      return r0;                  }                    //   *                  //  /                  // * recurrence involving two greater m's                  //  \                  //   *                  //                     var rp = (2 * (k + 1) * rho * r0 - (k - m) * r1) / (k + m + 2);                    r2 = r0;                  r1 = rp;              }
Magic Number,YAMP.Physics,ZernikeFunction,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Functions\Polynomials\ZernikeFunction.cs,Zernike,The following statement contains a magic number: while (true)              {                  k += 2;                    // *                  //  \                  //   * recurrence involving two lesser m's                  //  /                  // *                  // 2n R^{m+1}_{n-1} = (n+m) R^{m}_{n-2} + (n-m) R^{m}_{n}                    var r0 = ((2 * k) * rho * r1 - (k + m) * r2) / (k - m);                    if (k == n)                  {                      return r0;                  }                    //   *                  //  /                  // * recurrence involving two greater m's                  //  \                  //   *                  //                     var rp = (2 * (k + 1) * rho * r0 - (k - m) * r1) / (k + m + 2);                    r2 = r0;                  r1 = rp;              }
Magic Number,YAMP.Physics,CombinedUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\CombinedUnit.cs,Simplify,The following statement contains a magic number: do              {                  //Criteria for cancelling: avoid MORE changes than last round                  total = minChanges;                    if (!String.IsNullOrEmpty(minUnit))                  {                      var U = CombinedUnits[minUnit];                      var sgn = isReversed ? -1.0 : 1.0;                        foreach (var unit in U._units)                      {                          AddUnit(_units' unit.Key' -sgn * unit.Value);                      }                        _factor /= U._factor;                      AddUnit(_units' U.Unit' sgn);                  }                    foreach (var cu in CombinedUnits)                  {                      var reversed = false;                      var changes = GetChanges(cu.Value' out reversed);                        if (changes < minChanges)                      {                          minChanges = changes;                          minUnit = cu.Key;                          isReversed = reversed;                      }                  }              }              while(minChanges > 0 &&  minChanges < total && i++ < 8);
Magic Number,YAMP.Physics,CombinedUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\CombinedUnit.cs,Sqrt,The following statement contains a magic number: return Raise(0.5);
Magic Number,YAMP.Physics,gUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\GUnit.cs,gUnit,The following statement contains a magic number: Add("lb"' 0.002205);
Magic Number,YAMP.Physics,KUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\KUnit.cs,KUnit,The following statement contains a magic number: Add("°C"' 1.0' -273.16);
Magic Number,YAMP.Physics,KUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\KUnit.cs,KUnit,The following statement contains a magic number: Add("°F"' 9.0 / 5.0' -460.0);
Magic Number,YAMP.Physics,KUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\KUnit.cs,KUnit,The following statement contains a magic number: Add("°F"' 9.0 / 5.0' -460.0);
Magic Number,YAMP.Physics,KUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\KUnit.cs,KUnit,The following statement contains a magic number: Add("°F"' 9.0 / 5.0' -460.0);
Magic Number,YAMP.Physics,mUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\mUnit.cs,mUnit,The following statement contains a magic number: Add("yd"' 1.0936).Add("in"' 39.370).Add("ft"' 3.2808).Add("Å"' 1e10);
Magic Number,YAMP.Physics,mUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\mUnit.cs,mUnit,The following statement contains a magic number: Add("yd"' 1.0936).Add("in"' 39.370).Add("ft"' 3.2808).Add("Å"' 1e10);
Magic Number,YAMP.Physics,mUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\mUnit.cs,mUnit,The following statement contains a magic number: Add("yd"' 1.0936).Add("in"' 39.370).Add("ft"' 3.2808).Add("Å"' 1e10);
Magic Number,YAMP.Physics,mUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\mUnit.cs,mUnit,The following statement contains a magic number: Add("yd"' 1.0936).Add("in"' 39.370).Add("ft"' 3.2808).Add("Å"' 1e10);
Magic Number,YAMP.Physics,PhysicalUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\PhysicalUnit.cs,SetPrefixes,The following statement contains a magic number: _prefixes.Add("da"' 10);
Magic Number,YAMP.Physics,PhysicalUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\PhysicalUnit.cs,SetPrefixes,The following statement contains a magic number: _prefixes.Add("h"' 100);
Magic Number,YAMP.Physics,PhysicalUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\PhysicalUnit.cs,SetPrefixes,The following statement contains a magic number: _prefixes.Add("k"' 1e3);
Magic Number,YAMP.Physics,PhysicalUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\PhysicalUnit.cs,SetPrefixes,The following statement contains a magic number: _prefixes.Add("M"' 1e6);
Magic Number,YAMP.Physics,PhysicalUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\PhysicalUnit.cs,SetPrefixes,The following statement contains a magic number: _prefixes.Add("G"' 1e9);
Magic Number,YAMP.Physics,PhysicalUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\PhysicalUnit.cs,SetPrefixes,The following statement contains a magic number: _prefixes.Add("T"' 1e12);
Magic Number,YAMP.Physics,PhysicalUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\PhysicalUnit.cs,SetPrefixes,The following statement contains a magic number: _prefixes.Add("P"' 1e15);
Magic Number,YAMP.Physics,PhysicalUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\PhysicalUnit.cs,SetPrefixes,The following statement contains a magic number: _prefixes.Add("E"' 1e18);
Magic Number,YAMP.Physics,PhysicalUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\PhysicalUnit.cs,SetPrefixes,The following statement contains a magic number: _prefixes.Add("Z"' 1e21);
Magic Number,YAMP.Physics,PhysicalUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\PhysicalUnit.cs,SetPrefixes,The following statement contains a magic number: _prefixes.Add("Y"' 1e24);
Magic Number,YAMP.Physics,PhysicalUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\PhysicalUnit.cs,SetPrefixes,The following statement contains a magic number: _prefixes.Add("d"' 1e-1);
Magic Number,YAMP.Physics,PhysicalUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\PhysicalUnit.cs,SetPrefixes,The following statement contains a magic number: _prefixes.Add("c"' 1e-2);
Magic Number,YAMP.Physics,PhysicalUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\PhysicalUnit.cs,SetPrefixes,The following statement contains a magic number: _prefixes.Add("m"' 1e-3);
Magic Number,YAMP.Physics,PhysicalUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\PhysicalUnit.cs,SetPrefixes,The following statement contains a magic number: _prefixes.Add("µ"' 1e-6);
Magic Number,YAMP.Physics,PhysicalUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\PhysicalUnit.cs,SetPrefixes,The following statement contains a magic number: _prefixes.Add("n"' 1e-9);
Magic Number,YAMP.Physics,PhysicalUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\PhysicalUnit.cs,SetPrefixes,The following statement contains a magic number: _prefixes.Add("p"' 1e-12);
Magic Number,YAMP.Physics,PhysicalUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\PhysicalUnit.cs,SetPrefixes,The following statement contains a magic number: _prefixes.Add("f"' 1e-15);
Magic Number,YAMP.Physics,PhysicalUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\PhysicalUnit.cs,SetPrefixes,The following statement contains a magic number: _prefixes.Add("a"' 1e-18);
Magic Number,YAMP.Physics,PhysicalUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\PhysicalUnit.cs,SetPrefixes,The following statement contains a magic number: _prefixes.Add("z"' 1e-21);
Magic Number,YAMP.Physics,PhysicalUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\PhysicalUnit.cs,SetPrefixes,The following statement contains a magic number: _prefixes.Add("y"' 1e-24);
Magic Number,YAMP.Physics,sUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\sUnit.cs,sUnit,The following statement contains a magic number: Add("d"' 1.0 / 86400.0);
Magic Number,YAMP.Physics,sUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\sUnit.cs,sUnit,The following statement contains a magic number: Add("h"' 1.0 / 3600.0);
Magic Number,YAMP.Physics,sUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\sUnit.cs,sUnit,The following statement contains a magic number: Add("yr"' 1.0 / (86400.0 * 365.25));
Magic Number,YAMP.Physics,sUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\sUnit.cs,sUnit,The following statement contains a magic number: Add("yr"' 1.0 / (86400.0 * 365.25));
Magic Number,YAMP.Physics,UnitValue,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Values\UnitValue.cs,Deserialize,The following statement contains a magic number: unit.Im = BitConverter.ToDouble(content' 8);
Magic Number,YAMP.Physics,UnitValue,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Values\UnitValue.cs,Deserialize,The following statement contains a magic number: var str = new char[BitConverter.ToInt32(content' 16)];
Magic Number,YAMP.Physics,UnitValue,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Values\UnitValue.cs,Deserialize,The following statement contains a magic number: for (var i = 0; i < str.Length; i++)              {                  str[i] = BitConverter.ToChar(content' 20 + 2 * i);              }
Magic Number,YAMP.Physics,UnitValue,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Values\UnitValue.cs,Deserialize,The following statement contains a magic number: for (var i = 0; i < str.Length; i++)              {                  str[i] = BitConverter.ToChar(content' 20 + 2 * i);              }
Missing Default,YAMP.Physics,CombinedUnit,C:\repos\FlorianRappl_YAMP\YAMP.Physics\Units\CombinedUnit.cs,Parse,The following switch statement is missing a default case: switch (op)                  {                      case Token.Multiply:                          if (current == Token.Number)                              _factor *= Math.Pow(ConvertToDouble(result)' r);                          else if (current == Token.Letter)                              AddUnit(units' result' r);                          else                              throw new YAMPUnitParseException(i' unit.Substring(i));                          break;                        case Token.Divide:                          if (current == Token.Number)                              _factor /= Math.Pow(ConvertToDouble(result)' r);                          else if (current == Token.Letter)                              AddUnit(units' result' -r);                          else                              throw new YAMPUnitParseException(i' unit.Substring(i));                          break;                        case Token.Power:                          if (current != Token.Number)                              throw new YAMPUnitParseException(i' unit.Substring(i));                            var exp = ConvertToDouble(result);                          AddUnit(units' _lastAddedUnit' _lastAddedFactor * (exp - 1));                          break;                  }
