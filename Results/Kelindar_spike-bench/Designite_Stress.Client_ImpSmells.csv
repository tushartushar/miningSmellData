Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,Cyclomatic complexity of the method is 17
Complex Method,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,Cyclomatic complexity of the method is 14
Complex Method,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,Cyclomatic complexity of the method is 11
Complex Method,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Seek,Cyclomatic complexity of the method is 9
Complex Method,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadDynamic,Cyclomatic complexity of the method is 14
Complex Method,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,FormatBuffer,Cyclomatic complexity of the method is 10
Complex Method,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,WriteDynamic,Cyclomatic complexity of the method is 62
Complex Method,Spike.Network,TcpSocket,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Send,Cyclomatic complexity of the method is 8
Complex Method,Spike.Network,TcpSocket,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Receive,Cyclomatic complexity of the method is 8
Complex Method,Spike.Network,OperationReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Read,Cyclomatic complexity of the method is 24
Complex Method,Spike.Network,TcpChannel,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,OnReceive,Cyclomatic complexity of the method is 23
Long Parameter List,Stress.Client,Program,C:\repos\Kelindar_spike-bench\Stress.Client\Program.cs,Main,The method has 11 parameters.
Long Parameter List,Spike.Network,TcpChannel,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,SupplyCredentials,The method has 5 parameters.
Long Statement,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The length of the statement  "			if (start > 0 && buffer [idx] == '/' && buffer [idx + 1] == '1' && buffer [idx + 2] == '.' && buffer [idx + 3] == '1') { " is 120.
Long Statement,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The length of the statement  "			if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) { " is 223.
Long Statement,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The length of the statement  "			if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) { " is 223.
Long Statement,Spike.Network,TcpChannelBase,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Connect,The length of the statement  "		throw new InvalidOperationException ("Unable to connect as the socket is currently connected. Please disconnect first."); " is 121.
Complex Conditional,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The conditional expression  "buffer [idx] == 0x0D && buffer [idx + 1] == 0x0A && buffer [idx + 2] == 0x0D && buffer [idx + 3] == 0x0A"  is complex.
Complex Conditional,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The conditional expression  "start > 0 && buffer [idx] == '/' && buffer [idx + 1] == '1' && buffer [idx + 2] == '.' && buffer [idx + 3] == '1'"  is complex.
Complex Conditional,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The conditional expression  "(off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]"  is complex.
Complex Conditional,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The conditional expression  "(off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]"  is complex.
Empty Catch Block,Spike.Network,TcpChannelBase,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Dispose,The method has an empty catch block.
Magic Number,Stress.Client,Program,C:\repos\Kelindar_spike-bench\Stress.Client\Program.cs,Main,The following statement contains a magic number: Timer = new Timer (OnTick' null' TimeSpan.Zero' TimeSpan.FromMilliseconds (50));  
Magic Number,Stress.Client,Program,C:\repos\Kelindar_spike-bench\Stress.Client\Program.cs,Main,The following statement contains a magic number: Server.Connect ("127.0.0.1"' 8002);  
Magic Number,Spike.Network,BasePool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,BasePool,The following statement contains a magic number: this.Items = new T[4];  
Magic Number,Spike.Network,BasePool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,BasePool,The following statement contains a magic number: this.FreeList = new int[4];  
Magic Number,Spike.Network,BasePool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,BasePool,The following statement contains a magic number: this.UsedList = new byte[4];  
Magic Number,Spike.Network,BasePool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,GetFreeIndex,The following statement contains a magic number: newSize |= newSize >> 2;  
Magic Number,Spike.Network,BasePool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,GetFreeIndex,The following statement contains a magic number: newSize |= newSize >> 4;  
Magic Number,Spike.Network,BasePool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,GetFreeIndex,The following statement contains a magic number: newSize |= newSize >> 8;  
Magic Number,Spike.Network,BasePool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,GetFreeIndex,The following statement contains a magic number: newSize |= newSize >> 16;  
Magic Number,Spike.Network,BasePool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,SetAsUsed,The following statement contains a magic number: if (this.UsedList [handle] == 0) {  	this.UsedList [handle] = 1;  	if (handle >= this.RawCount) {  		// have to reallocate  		int newSize = this.RawCount;  		newSize |= newSize >> 1;  		newSize |= newSize >> 2;  		newSize |= newSize >> 4;  		newSize |= newSize >> 8;  		newSize |= newSize >> 16;  		newSize++;  		Array.Resize (ref this.Items' newSize);  		Array.Resize (ref this.UsedList' newSize);  	}  	else {  		if (this.FreeListCount == 1 && this.FreeList [0] == handle) {  			FreeListCount = 0;  		}  		else if (FreeListCount > 1) {  			// Remove from the free list  			RemoveArrayItem<int> (ref this.FreeList' handle);  			this.FreeListCount--;  		}  	}  }  
Magic Number,Spike.Network,BasePool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,SetAsUsed,The following statement contains a magic number: if (this.UsedList [handle] == 0) {  	this.UsedList [handle] = 1;  	if (handle >= this.RawCount) {  		// have to reallocate  		int newSize = this.RawCount;  		newSize |= newSize >> 1;  		newSize |= newSize >> 2;  		newSize |= newSize >> 4;  		newSize |= newSize >> 8;  		newSize |= newSize >> 16;  		newSize++;  		Array.Resize (ref this.Items' newSize);  		Array.Resize (ref this.UsedList' newSize);  	}  	else {  		if (this.FreeListCount == 1 && this.FreeList [0] == handle) {  			FreeListCount = 0;  		}  		else if (FreeListCount > 1) {  			// Remove from the free list  			RemoveArrayItem<int> (ref this.FreeList' handle);  			this.FreeListCount--;  		}  	}  }  
Magic Number,Spike.Network,BasePool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,SetAsUsed,The following statement contains a magic number: if (this.UsedList [handle] == 0) {  	this.UsedList [handle] = 1;  	if (handle >= this.RawCount) {  		// have to reallocate  		int newSize = this.RawCount;  		newSize |= newSize >> 1;  		newSize |= newSize >> 2;  		newSize |= newSize >> 4;  		newSize |= newSize >> 8;  		newSize |= newSize >> 16;  		newSize++;  		Array.Resize (ref this.Items' newSize);  		Array.Resize (ref this.UsedList' newSize);  	}  	else {  		if (this.FreeListCount == 1 && this.FreeList [0] == handle) {  			FreeListCount = 0;  		}  		else if (FreeListCount > 1) {  			// Remove from the free list  			RemoveArrayItem<int> (ref this.FreeList' handle);  			this.FreeListCount--;  		}  	}  }  
Magic Number,Spike.Network,BasePool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,SetAsUsed,The following statement contains a magic number: if (this.UsedList [handle] == 0) {  	this.UsedList [handle] = 1;  	if (handle >= this.RawCount) {  		// have to reallocate  		int newSize = this.RawCount;  		newSize |= newSize >> 1;  		newSize |= newSize >> 2;  		newSize |= newSize >> 4;  		newSize |= newSize >> 8;  		newSize |= newSize >> 16;  		newSize++;  		Array.Resize (ref this.Items' newSize);  		Array.Resize (ref this.UsedList' newSize);  	}  	else {  		if (this.FreeListCount == 1 && this.FreeList [0] == handle) {  			FreeListCount = 0;  		}  		else if (FreeListCount > 1) {  			// Remove from the free list  			RemoveArrayItem<int> (ref this.FreeList' handle);  			this.FreeListCount--;  		}  	}  }  
Magic Number,Spike.Network,BasePool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,SetAsUsed,The following statement contains a magic number: if (handle >= this.RawCount) {  	// have to reallocate  	int newSize = this.RawCount;  	newSize |= newSize >> 1;  	newSize |= newSize >> 2;  	newSize |= newSize >> 4;  	newSize |= newSize >> 8;  	newSize |= newSize >> 16;  	newSize++;  	Array.Resize (ref this.Items' newSize);  	Array.Resize (ref this.UsedList' newSize);  }  else {  	if (this.FreeListCount == 1 && this.FreeList [0] == handle) {  		FreeListCount = 0;  	}  	else if (FreeListCount > 1) {  		// Remove from the free list  		RemoveArrayItem<int> (ref this.FreeList' handle);  		this.FreeListCount--;  	}  }  
Magic Number,Spike.Network,BasePool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,SetAsUsed,The following statement contains a magic number: if (handle >= this.RawCount) {  	// have to reallocate  	int newSize = this.RawCount;  	newSize |= newSize >> 1;  	newSize |= newSize >> 2;  	newSize |= newSize >> 4;  	newSize |= newSize >> 8;  	newSize |= newSize >> 16;  	newSize++;  	Array.Resize (ref this.Items' newSize);  	Array.Resize (ref this.UsedList' newSize);  }  else {  	if (this.FreeListCount == 1 && this.FreeList [0] == handle) {  		FreeListCount = 0;  	}  	else if (FreeListCount > 1) {  		// Remove from the free list  		RemoveArrayItem<int> (ref this.FreeList' handle);  		this.FreeListCount--;  	}  }  
Magic Number,Spike.Network,BasePool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,SetAsUsed,The following statement contains a magic number: if (handle >= this.RawCount) {  	// have to reallocate  	int newSize = this.RawCount;  	newSize |= newSize >> 1;  	newSize |= newSize >> 2;  	newSize |= newSize >> 4;  	newSize |= newSize >> 8;  	newSize |= newSize >> 16;  	newSize++;  	Array.Resize (ref this.Items' newSize);  	Array.Resize (ref this.UsedList' newSize);  }  else {  	if (this.FreeListCount == 1 && this.FreeList [0] == handle) {  		FreeListCount = 0;  	}  	else if (FreeListCount > 1) {  		// Remove from the free list  		RemoveArrayItem<int> (ref this.FreeList' handle);  		this.FreeListCount--;  	}  }  
Magic Number,Spike.Network,BasePool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,SetAsUsed,The following statement contains a magic number: if (handle >= this.RawCount) {  	// have to reallocate  	int newSize = this.RawCount;  	newSize |= newSize >> 1;  	newSize |= newSize >> 2;  	newSize |= newSize >> 4;  	newSize |= newSize >> 8;  	newSize |= newSize >> 16;  	newSize++;  	Array.Resize (ref this.Items' newSize);  	Array.Resize (ref this.UsedList' newSize);  }  else {  	if (this.FreeListCount == 1 && this.FreeList [0] == handle) {  		FreeListCount = 0;  	}  	else if (FreeListCount > 1) {  		// Remove from the free list  		RemoveArrayItem<int> (ref this.FreeList' handle);  		this.FreeListCount--;  	}  }  
Magic Number,Spike.Network,BasePool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,SetAsUsed,The following statement contains a magic number: newSize |= newSize >> 2;  
Magic Number,Spike.Network,BasePool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,SetAsUsed,The following statement contains a magic number: newSize |= newSize >> 4;  
Magic Number,Spike.Network,BasePool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,SetAsUsed,The following statement contains a magic number: newSize |= newSize >> 8;  
Magic Number,Spike.Network,BasePool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,SetAsUsed,The following statement contains a magic number: newSize |= newSize >> 16;  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: lock (this.Items) {  	if (this.FreeListCount > 0) {  		this.FreeListCount--;  		int handle = this.FreeList [this.FreeListCount];  		this.UsedList [handle] = 1;  		this.Count++;  		if (this.Items [handle] == null) {  			item = new byte[this.fBufferSize];  			this.Items [handle] = item;  			return handle;  		}  		item = this.Items [handle];  		return handle;  	}  	else {  		int handle = this.RawCount;  		if (handle < this.Items.Length) {  			this.UsedList [handle] = 1;  			this.Count++;  			if (this.Items [handle] == null) {  				item = new byte[this.fBufferSize];  				this.Items [handle] = item;  				this.RawCount++;  				return handle;  			}  			item = this.Items [handle];  			this.RawCount++;  			return handle;  		}  		else {  			// have to reallocate  			int newSize = this.RawCount;  			newSize |= newSize >> 1;  			newSize |= newSize >> 2;  			newSize |= newSize >> 4;  			newSize |= newSize >> 8;  			newSize |= newSize >> 16;  			newSize++;  			Array.Resize (ref this.Items' newSize);  			Array.Resize (ref this.UsedList' newSize);  			item = new byte[this.fBufferSize];  			this.Items [handle] = item;  			this.UsedList [handle] = 1;  			this.Count++;  			this.RawCount++;  			return handle;  		}  	}  }  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: lock (this.Items) {  	if (this.FreeListCount > 0) {  		this.FreeListCount--;  		int handle = this.FreeList [this.FreeListCount];  		this.UsedList [handle] = 1;  		this.Count++;  		if (this.Items [handle] == null) {  			item = new byte[this.fBufferSize];  			this.Items [handle] = item;  			return handle;  		}  		item = this.Items [handle];  		return handle;  	}  	else {  		int handle = this.RawCount;  		if (handle < this.Items.Length) {  			this.UsedList [handle] = 1;  			this.Count++;  			if (this.Items [handle] == null) {  				item = new byte[this.fBufferSize];  				this.Items [handle] = item;  				this.RawCount++;  				return handle;  			}  			item = this.Items [handle];  			this.RawCount++;  			return handle;  		}  		else {  			// have to reallocate  			int newSize = this.RawCount;  			newSize |= newSize >> 1;  			newSize |= newSize >> 2;  			newSize |= newSize >> 4;  			newSize |= newSize >> 8;  			newSize |= newSize >> 16;  			newSize++;  			Array.Resize (ref this.Items' newSize);  			Array.Resize (ref this.UsedList' newSize);  			item = new byte[this.fBufferSize];  			this.Items [handle] = item;  			this.UsedList [handle] = 1;  			this.Count++;  			this.RawCount++;  			return handle;  		}  	}  }  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: lock (this.Items) {  	if (this.FreeListCount > 0) {  		this.FreeListCount--;  		int handle = this.FreeList [this.FreeListCount];  		this.UsedList [handle] = 1;  		this.Count++;  		if (this.Items [handle] == null) {  			item = new byte[this.fBufferSize];  			this.Items [handle] = item;  			return handle;  		}  		item = this.Items [handle];  		return handle;  	}  	else {  		int handle = this.RawCount;  		if (handle < this.Items.Length) {  			this.UsedList [handle] = 1;  			this.Count++;  			if (this.Items [handle] == null) {  				item = new byte[this.fBufferSize];  				this.Items [handle] = item;  				this.RawCount++;  				return handle;  			}  			item = this.Items [handle];  			this.RawCount++;  			return handle;  		}  		else {  			// have to reallocate  			int newSize = this.RawCount;  			newSize |= newSize >> 1;  			newSize |= newSize >> 2;  			newSize |= newSize >> 4;  			newSize |= newSize >> 8;  			newSize |= newSize >> 16;  			newSize++;  			Array.Resize (ref this.Items' newSize);  			Array.Resize (ref this.UsedList' newSize);  			item = new byte[this.fBufferSize];  			this.Items [handle] = item;  			this.UsedList [handle] = 1;  			this.Count++;  			this.RawCount++;  			return handle;  		}  	}  }  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: lock (this.Items) {  	if (this.FreeListCount > 0) {  		this.FreeListCount--;  		int handle = this.FreeList [this.FreeListCount];  		this.UsedList [handle] = 1;  		this.Count++;  		if (this.Items [handle] == null) {  			item = new byte[this.fBufferSize];  			this.Items [handle] = item;  			return handle;  		}  		item = this.Items [handle];  		return handle;  	}  	else {  		int handle = this.RawCount;  		if (handle < this.Items.Length) {  			this.UsedList [handle] = 1;  			this.Count++;  			if (this.Items [handle] == null) {  				item = new byte[this.fBufferSize];  				this.Items [handle] = item;  				this.RawCount++;  				return handle;  			}  			item = this.Items [handle];  			this.RawCount++;  			return handle;  		}  		else {  			// have to reallocate  			int newSize = this.RawCount;  			newSize |= newSize >> 1;  			newSize |= newSize >> 2;  			newSize |= newSize >> 4;  			newSize |= newSize >> 8;  			newSize |= newSize >> 16;  			newSize++;  			Array.Resize (ref this.Items' newSize);  			Array.Resize (ref this.UsedList' newSize);  			item = new byte[this.fBufferSize];  			this.Items [handle] = item;  			this.UsedList [handle] = 1;  			this.Count++;  			this.RawCount++;  			return handle;  		}  	}  }  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: if (this.FreeListCount > 0) {  	this.FreeListCount--;  	int handle = this.FreeList [this.FreeListCount];  	this.UsedList [handle] = 1;  	this.Count++;  	if (this.Items [handle] == null) {  		item = new byte[this.fBufferSize];  		this.Items [handle] = item;  		return handle;  	}  	item = this.Items [handle];  	return handle;  }  else {  	int handle = this.RawCount;  	if (handle < this.Items.Length) {  		this.UsedList [handle] = 1;  		this.Count++;  		if (this.Items [handle] == null) {  			item = new byte[this.fBufferSize];  			this.Items [handle] = item;  			this.RawCount++;  			return handle;  		}  		item = this.Items [handle];  		this.RawCount++;  		return handle;  	}  	else {  		// have to reallocate  		int newSize = this.RawCount;  		newSize |= newSize >> 1;  		newSize |= newSize >> 2;  		newSize |= newSize >> 4;  		newSize |= newSize >> 8;  		newSize |= newSize >> 16;  		newSize++;  		Array.Resize (ref this.Items' newSize);  		Array.Resize (ref this.UsedList' newSize);  		item = new byte[this.fBufferSize];  		this.Items [handle] = item;  		this.UsedList [handle] = 1;  		this.Count++;  		this.RawCount++;  		return handle;  	}  }  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: if (this.FreeListCount > 0) {  	this.FreeListCount--;  	int handle = this.FreeList [this.FreeListCount];  	this.UsedList [handle] = 1;  	this.Count++;  	if (this.Items [handle] == null) {  		item = new byte[this.fBufferSize];  		this.Items [handle] = item;  		return handle;  	}  	item = this.Items [handle];  	return handle;  }  else {  	int handle = this.RawCount;  	if (handle < this.Items.Length) {  		this.UsedList [handle] = 1;  		this.Count++;  		if (this.Items [handle] == null) {  			item = new byte[this.fBufferSize];  			this.Items [handle] = item;  			this.RawCount++;  			return handle;  		}  		item = this.Items [handle];  		this.RawCount++;  		return handle;  	}  	else {  		// have to reallocate  		int newSize = this.RawCount;  		newSize |= newSize >> 1;  		newSize |= newSize >> 2;  		newSize |= newSize >> 4;  		newSize |= newSize >> 8;  		newSize |= newSize >> 16;  		newSize++;  		Array.Resize (ref this.Items' newSize);  		Array.Resize (ref this.UsedList' newSize);  		item = new byte[this.fBufferSize];  		this.Items [handle] = item;  		this.UsedList [handle] = 1;  		this.Count++;  		this.RawCount++;  		return handle;  	}  }  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: if (this.FreeListCount > 0) {  	this.FreeListCount--;  	int handle = this.FreeList [this.FreeListCount];  	this.UsedList [handle] = 1;  	this.Count++;  	if (this.Items [handle] == null) {  		item = new byte[this.fBufferSize];  		this.Items [handle] = item;  		return handle;  	}  	item = this.Items [handle];  	return handle;  }  else {  	int handle = this.RawCount;  	if (handle < this.Items.Length) {  		this.UsedList [handle] = 1;  		this.Count++;  		if (this.Items [handle] == null) {  			item = new byte[this.fBufferSize];  			this.Items [handle] = item;  			this.RawCount++;  			return handle;  		}  		item = this.Items [handle];  		this.RawCount++;  		return handle;  	}  	else {  		// have to reallocate  		int newSize = this.RawCount;  		newSize |= newSize >> 1;  		newSize |= newSize >> 2;  		newSize |= newSize >> 4;  		newSize |= newSize >> 8;  		newSize |= newSize >> 16;  		newSize++;  		Array.Resize (ref this.Items' newSize);  		Array.Resize (ref this.UsedList' newSize);  		item = new byte[this.fBufferSize];  		this.Items [handle] = item;  		this.UsedList [handle] = 1;  		this.Count++;  		this.RawCount++;  		return handle;  	}  }  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: if (this.FreeListCount > 0) {  	this.FreeListCount--;  	int handle = this.FreeList [this.FreeListCount];  	this.UsedList [handle] = 1;  	this.Count++;  	if (this.Items [handle] == null) {  		item = new byte[this.fBufferSize];  		this.Items [handle] = item;  		return handle;  	}  	item = this.Items [handle];  	return handle;  }  else {  	int handle = this.RawCount;  	if (handle < this.Items.Length) {  		this.UsedList [handle] = 1;  		this.Count++;  		if (this.Items [handle] == null) {  			item = new byte[this.fBufferSize];  			this.Items [handle] = item;  			this.RawCount++;  			return handle;  		}  		item = this.Items [handle];  		this.RawCount++;  		return handle;  	}  	else {  		// have to reallocate  		int newSize = this.RawCount;  		newSize |= newSize >> 1;  		newSize |= newSize >> 2;  		newSize |= newSize >> 4;  		newSize |= newSize >> 8;  		newSize |= newSize >> 16;  		newSize++;  		Array.Resize (ref this.Items' newSize);  		Array.Resize (ref this.UsedList' newSize);  		item = new byte[this.fBufferSize];  		this.Items [handle] = item;  		this.UsedList [handle] = 1;  		this.Count++;  		this.RawCount++;  		return handle;  	}  }  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: if (handle < this.Items.Length) {  	this.UsedList [handle] = 1;  	this.Count++;  	if (this.Items [handle] == null) {  		item = new byte[this.fBufferSize];  		this.Items [handle] = item;  		this.RawCount++;  		return handle;  	}  	item = this.Items [handle];  	this.RawCount++;  	return handle;  }  else {  	// have to reallocate  	int newSize = this.RawCount;  	newSize |= newSize >> 1;  	newSize |= newSize >> 2;  	newSize |= newSize >> 4;  	newSize |= newSize >> 8;  	newSize |= newSize >> 16;  	newSize++;  	Array.Resize (ref this.Items' newSize);  	Array.Resize (ref this.UsedList' newSize);  	item = new byte[this.fBufferSize];  	this.Items [handle] = item;  	this.UsedList [handle] = 1;  	this.Count++;  	this.RawCount++;  	return handle;  }  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: if (handle < this.Items.Length) {  	this.UsedList [handle] = 1;  	this.Count++;  	if (this.Items [handle] == null) {  		item = new byte[this.fBufferSize];  		this.Items [handle] = item;  		this.RawCount++;  		return handle;  	}  	item = this.Items [handle];  	this.RawCount++;  	return handle;  }  else {  	// have to reallocate  	int newSize = this.RawCount;  	newSize |= newSize >> 1;  	newSize |= newSize >> 2;  	newSize |= newSize >> 4;  	newSize |= newSize >> 8;  	newSize |= newSize >> 16;  	newSize++;  	Array.Resize (ref this.Items' newSize);  	Array.Resize (ref this.UsedList' newSize);  	item = new byte[this.fBufferSize];  	this.Items [handle] = item;  	this.UsedList [handle] = 1;  	this.Count++;  	this.RawCount++;  	return handle;  }  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: if (handle < this.Items.Length) {  	this.UsedList [handle] = 1;  	this.Count++;  	if (this.Items [handle] == null) {  		item = new byte[this.fBufferSize];  		this.Items [handle] = item;  		this.RawCount++;  		return handle;  	}  	item = this.Items [handle];  	this.RawCount++;  	return handle;  }  else {  	// have to reallocate  	int newSize = this.RawCount;  	newSize |= newSize >> 1;  	newSize |= newSize >> 2;  	newSize |= newSize >> 4;  	newSize |= newSize >> 8;  	newSize |= newSize >> 16;  	newSize++;  	Array.Resize (ref this.Items' newSize);  	Array.Resize (ref this.UsedList' newSize);  	item = new byte[this.fBufferSize];  	this.Items [handle] = item;  	this.UsedList [handle] = 1;  	this.Count++;  	this.RawCount++;  	return handle;  }  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: if (handle < this.Items.Length) {  	this.UsedList [handle] = 1;  	this.Count++;  	if (this.Items [handle] == null) {  		item = new byte[this.fBufferSize];  		this.Items [handle] = item;  		this.RawCount++;  		return handle;  	}  	item = this.Items [handle];  	this.RawCount++;  	return handle;  }  else {  	// have to reallocate  	int newSize = this.RawCount;  	newSize |= newSize >> 1;  	newSize |= newSize >> 2;  	newSize |= newSize >> 4;  	newSize |= newSize >> 8;  	newSize |= newSize >> 16;  	newSize++;  	Array.Resize (ref this.Items' newSize);  	Array.Resize (ref this.UsedList' newSize);  	item = new byte[this.fBufferSize];  	this.Items [handle] = item;  	this.UsedList [handle] = 1;  	this.Count++;  	this.RawCount++;  	return handle;  }  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: newSize |= newSize >> 2;  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: newSize |= newSize >> 4;  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: newSize |= newSize >> 8;  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: newSize |= newSize >> 16;  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: lock (this.Items) {  	buffer = null;  	int handle = 0;  	if (this.FreeListCount > 0)// Check the free list  	 {  		// goes through freed items  		for (int i = 0; i < this.FreeListCount; ++i) {  			// satisfies the length condition?  			handle = this.FreeList [i];  			if (this.Items [handle].Length >= minimumLength) {  				// Overwrite the current number with the last one  				this.FreeList [i] = this.FreeList [--this.FreeListCount];  				this.UsedList [handle] = 1;  				this.Count++;  				// Return the buffer  				buffer = this.Items [handle];  				return handle;  			}  		}  	}  	// Not found in free buffers' allocate  	handle = this.RawCount;  	if (handle < this.Items.Length) {  		// Return a new buffer  		buffer = AllocateBuffer (handle' minimumLength);  		return handle;  	}  	else {  		// have to reallocate  		int newSize = this.RawCount;  		newSize |= newSize >> 1;  		newSize |= newSize >> 2;  		newSize |= newSize >> 4;  		newSize |= newSize >> 8;  		newSize |= newSize >> 16;  		newSize++;  		Array.Resize (ref this.Items' newSize);  		Array.Resize (ref this.UsedList' newSize);  		// Return a new buffer  		buffer = AllocateBuffer (handle' minimumLength);  		return handle;  	}  }  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: lock (this.Items) {  	buffer = null;  	int handle = 0;  	if (this.FreeListCount > 0)// Check the free list  	 {  		// goes through freed items  		for (int i = 0; i < this.FreeListCount; ++i) {  			// satisfies the length condition?  			handle = this.FreeList [i];  			if (this.Items [handle].Length >= minimumLength) {  				// Overwrite the current number with the last one  				this.FreeList [i] = this.FreeList [--this.FreeListCount];  				this.UsedList [handle] = 1;  				this.Count++;  				// Return the buffer  				buffer = this.Items [handle];  				return handle;  			}  		}  	}  	// Not found in free buffers' allocate  	handle = this.RawCount;  	if (handle < this.Items.Length) {  		// Return a new buffer  		buffer = AllocateBuffer (handle' minimumLength);  		return handle;  	}  	else {  		// have to reallocate  		int newSize = this.RawCount;  		newSize |= newSize >> 1;  		newSize |= newSize >> 2;  		newSize |= newSize >> 4;  		newSize |= newSize >> 8;  		newSize |= newSize >> 16;  		newSize++;  		Array.Resize (ref this.Items' newSize);  		Array.Resize (ref this.UsedList' newSize);  		// Return a new buffer  		buffer = AllocateBuffer (handle' minimumLength);  		return handle;  	}  }  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: lock (this.Items) {  	buffer = null;  	int handle = 0;  	if (this.FreeListCount > 0)// Check the free list  	 {  		// goes through freed items  		for (int i = 0; i < this.FreeListCount; ++i) {  			// satisfies the length condition?  			handle = this.FreeList [i];  			if (this.Items [handle].Length >= minimumLength) {  				// Overwrite the current number with the last one  				this.FreeList [i] = this.FreeList [--this.FreeListCount];  				this.UsedList [handle] = 1;  				this.Count++;  				// Return the buffer  				buffer = this.Items [handle];  				return handle;  			}  		}  	}  	// Not found in free buffers' allocate  	handle = this.RawCount;  	if (handle < this.Items.Length) {  		// Return a new buffer  		buffer = AllocateBuffer (handle' minimumLength);  		return handle;  	}  	else {  		// have to reallocate  		int newSize = this.RawCount;  		newSize |= newSize >> 1;  		newSize |= newSize >> 2;  		newSize |= newSize >> 4;  		newSize |= newSize >> 8;  		newSize |= newSize >> 16;  		newSize++;  		Array.Resize (ref this.Items' newSize);  		Array.Resize (ref this.UsedList' newSize);  		// Return a new buffer  		buffer = AllocateBuffer (handle' minimumLength);  		return handle;  	}  }  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: lock (this.Items) {  	buffer = null;  	int handle = 0;  	if (this.FreeListCount > 0)// Check the free list  	 {  		// goes through freed items  		for (int i = 0; i < this.FreeListCount; ++i) {  			// satisfies the length condition?  			handle = this.FreeList [i];  			if (this.Items [handle].Length >= minimumLength) {  				// Overwrite the current number with the last one  				this.FreeList [i] = this.FreeList [--this.FreeListCount];  				this.UsedList [handle] = 1;  				this.Count++;  				// Return the buffer  				buffer = this.Items [handle];  				return handle;  			}  		}  	}  	// Not found in free buffers' allocate  	handle = this.RawCount;  	if (handle < this.Items.Length) {  		// Return a new buffer  		buffer = AllocateBuffer (handle' minimumLength);  		return handle;  	}  	else {  		// have to reallocate  		int newSize = this.RawCount;  		newSize |= newSize >> 1;  		newSize |= newSize >> 2;  		newSize |= newSize >> 4;  		newSize |= newSize >> 8;  		newSize |= newSize >> 16;  		newSize++;  		Array.Resize (ref this.Items' newSize);  		Array.Resize (ref this.UsedList' newSize);  		// Return a new buffer  		buffer = AllocateBuffer (handle' minimumLength);  		return handle;  	}  }  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: if (handle < this.Items.Length) {  	// Return a new buffer  	buffer = AllocateBuffer (handle' minimumLength);  	return handle;  }  else {  	// have to reallocate  	int newSize = this.RawCount;  	newSize |= newSize >> 1;  	newSize |= newSize >> 2;  	newSize |= newSize >> 4;  	newSize |= newSize >> 8;  	newSize |= newSize >> 16;  	newSize++;  	Array.Resize (ref this.Items' newSize);  	Array.Resize (ref this.UsedList' newSize);  	// Return a new buffer  	buffer = AllocateBuffer (handle' minimumLength);  	return handle;  }  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: if (handle < this.Items.Length) {  	// Return a new buffer  	buffer = AllocateBuffer (handle' minimumLength);  	return handle;  }  else {  	// have to reallocate  	int newSize = this.RawCount;  	newSize |= newSize >> 1;  	newSize |= newSize >> 2;  	newSize |= newSize >> 4;  	newSize |= newSize >> 8;  	newSize |= newSize >> 16;  	newSize++;  	Array.Resize (ref this.Items' newSize);  	Array.Resize (ref this.UsedList' newSize);  	// Return a new buffer  	buffer = AllocateBuffer (handle' minimumLength);  	return handle;  }  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: if (handle < this.Items.Length) {  	// Return a new buffer  	buffer = AllocateBuffer (handle' minimumLength);  	return handle;  }  else {  	// have to reallocate  	int newSize = this.RawCount;  	newSize |= newSize >> 1;  	newSize |= newSize >> 2;  	newSize |= newSize >> 4;  	newSize |= newSize >> 8;  	newSize |= newSize >> 16;  	newSize++;  	Array.Resize (ref this.Items' newSize);  	Array.Resize (ref this.UsedList' newSize);  	// Return a new buffer  	buffer = AllocateBuffer (handle' minimumLength);  	return handle;  }  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: if (handle < this.Items.Length) {  	// Return a new buffer  	buffer = AllocateBuffer (handle' minimumLength);  	return handle;  }  else {  	// have to reallocate  	int newSize = this.RawCount;  	newSize |= newSize >> 1;  	newSize |= newSize >> 2;  	newSize |= newSize >> 4;  	newSize |= newSize >> 8;  	newSize |= newSize >> 16;  	newSize++;  	Array.Resize (ref this.Items' newSize);  	Array.Resize (ref this.UsedList' newSize);  	// Return a new buffer  	buffer = AllocateBuffer (handle' minimumLength);  	return handle;  }  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: newSize |= newSize >> 2;  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: newSize |= newSize >> 4;  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: newSize |= newSize >> 8;  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Acquire,The following statement contains a magic number: newSize |= newSize >> 16;  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,AllocateBuffer,The following statement contains a magic number: newBufferSize |= newBufferSize >> 2;  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,AllocateBuffer,The following statement contains a magic number: newBufferSize |= newBufferSize >> 4;  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,AllocateBuffer,The following statement contains a magic number: newBufferSize |= newBufferSize >> 8;  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,AllocateBuffer,The following statement contains a magic number: newBufferSize |= newBufferSize >> 16;  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Release,The following statement contains a magic number: lock (this.Items) {  	if (this.UsedList [handle] == 0)  		return;  	// the spot is already free  	this.UsedList [handle] = 0;  	this.Count--;  	if (this.FreeListCount < this.FreeList.Length) {  		this.FreeList [this.FreeListCount++] = handle;  		return;  	}  	// have to reallocate  	int newSize = this.FreeListCount;  	newSize |= newSize >> 1;  	newSize |= newSize >> 2;  	newSize |= newSize >> 4;  	newSize |= newSize >> 8;  	newSize |= newSize >> 16;  	newSize++;  	Array.Resize (ref this.FreeList' newSize);  	this.FreeList [this.FreeListCount] = handle;  	this.FreeListCount++;  }  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Release,The following statement contains a magic number: lock (this.Items) {  	if (this.UsedList [handle] == 0)  		return;  	// the spot is already free  	this.UsedList [handle] = 0;  	this.Count--;  	if (this.FreeListCount < this.FreeList.Length) {  		this.FreeList [this.FreeListCount++] = handle;  		return;  	}  	// have to reallocate  	int newSize = this.FreeListCount;  	newSize |= newSize >> 1;  	newSize |= newSize >> 2;  	newSize |= newSize >> 4;  	newSize |= newSize >> 8;  	newSize |= newSize >> 16;  	newSize++;  	Array.Resize (ref this.FreeList' newSize);  	this.FreeList [this.FreeListCount] = handle;  	this.FreeListCount++;  }  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Release,The following statement contains a magic number: lock (this.Items) {  	if (this.UsedList [handle] == 0)  		return;  	// the spot is already free  	this.UsedList [handle] = 0;  	this.Count--;  	if (this.FreeListCount < this.FreeList.Length) {  		this.FreeList [this.FreeListCount++] = handle;  		return;  	}  	// have to reallocate  	int newSize = this.FreeListCount;  	newSize |= newSize >> 1;  	newSize |= newSize >> 2;  	newSize |= newSize >> 4;  	newSize |= newSize >> 8;  	newSize |= newSize >> 16;  	newSize++;  	Array.Resize (ref this.FreeList' newSize);  	this.FreeList [this.FreeListCount] = handle;  	this.FreeListCount++;  }  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Release,The following statement contains a magic number: lock (this.Items) {  	if (this.UsedList [handle] == 0)  		return;  	// the spot is already free  	this.UsedList [handle] = 0;  	this.Count--;  	if (this.FreeListCount < this.FreeList.Length) {  		this.FreeList [this.FreeListCount++] = handle;  		return;  	}  	// have to reallocate  	int newSize = this.FreeListCount;  	newSize |= newSize >> 1;  	newSize |= newSize >> 2;  	newSize |= newSize >> 4;  	newSize |= newSize >> 8;  	newSize |= newSize >> 16;  	newSize++;  	Array.Resize (ref this.FreeList' newSize);  	this.FreeList [this.FreeListCount] = handle;  	this.FreeListCount++;  }  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Release,The following statement contains a magic number: newSize |= newSize >> 2;  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Release,The following statement contains a magic number: newSize |= newSize >> 4;  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Release,The following statement contains a magic number: newSize |= newSize >> 8;  
Magic Number,Spike.Network,BufferPool,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Release,The following statement contains a magic number: newSize |= newSize >> 16;  
Magic Number,Spike.Network,ChannelBase,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,WriteLength,The following statement contains a magic number: buffer [0] = (byte)(value >> 24);  
Magic Number,Spike.Network,ChannelBase,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,WriteLength,The following statement contains a magic number: buffer [1] = (byte)(value >> 16);  
Magic Number,Spike.Network,ChannelBase,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,WriteLength,The following statement contains a magic number: buffer [2] = (byte)(value >> 8);  
Magic Number,Spike.Network,ChannelBase,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,WriteLength,The following statement contains a magic number: buffer [2] = (byte)(value >> 8);  
Magic Number,Spike.Network,ChannelBase,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,WriteLength,The following statement contains a magic number: buffer [3] = (byte)value;  
Magic Number,Spike.Network,ChannelBase,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,WriteLength,The following statement contains a magic number: stream.Write (buffer' 0' 4);  
Magic Number,Spike.Network,ChannelBase,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,WriteKey,The following statement contains a magic number: for (int i = 0; i < Packet.HeaderKeySize * 2; i += 2)  	buffer [i / 2] = byte.Parse (value.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber);  
Magic Number,Spike.Network,ChannelBase,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,WriteKey,The following statement contains a magic number: for (int i = 0; i < Packet.HeaderKeySize * 2; i += 2)  	buffer [i / 2] = byte.Parse (value.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber);  
Magic Number,Spike.Network,ChannelBase,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,WriteKey,The following statement contains a magic number: for (int i = 0; i < Packet.HeaderKeySize * 2; i += 2)  	buffer [i / 2] = byte.Parse (value.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber);  
Magic Number,Spike.Network,ChannelBase,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,WriteKey,The following statement contains a magic number: for (int i = 0; i < Packet.HeaderKeySize * 2; i += 2)  	buffer [i / 2] = byte.Parse (value.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber);  
Magic Number,Spike.Network,ChannelBase,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,WriteKey,The following statement contains a magic number: i += 2
Magic Number,Spike.Network,ChannelBase,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,WriteKey,The following statement contains a magic number: buffer [i / 2] = byte.Parse (value.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber);  
Magic Number,Spike.Network,ChannelBase,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,WriteKey,The following statement contains a magic number: buffer [i / 2] = byte.Parse (value.Substring (i' 2)' System.Globalization.NumberStyles.HexNumber);  
Magic Number,Spike.Network,ChannelBase,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadLength,The following statement contains a magic number: return stream.ReadByte () << 24 | (stream.ReadByte () << 16) | (stream.ReadByte () << 8) | (stream.ReadByte ());  
Magic Number,Spike.Network,ChannelBase,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadLength,The following statement contains a magic number: return stream.ReadByte () << 24 | (stream.ReadByte () << 16) | (stream.ReadByte () << 8) | (stream.ReadByte ());  
Magic Number,Spike.Network,ChannelBase,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadLength,The following statement contains a magic number: return stream.ReadByte () << 24 | (stream.ReadByte () << 16) | (stream.ReadByte () << 8) | (stream.ReadByte ());  
Magic Number,Spike.Network,ChannelBase,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadKey,The following statement contains a magic number: for (int y = 0' x = 0; y < Packet.HeaderKeySize; ++y' ++x) {  	readByte = (byte)stream.ReadByte ();  	current = ((byte)(readByte >> 4));  	chars [x] = (char)(current > 9 ? current + 0x37 : current + 0x30);  	current = ((byte)(readByte & 0xF));  	chars [++x] = (char)(current > 9 ? current + 0x37 : current + 0x30);  }  
Magic Number,Spike.Network,ChannelBase,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadKey,The following statement contains a magic number: for (int y = 0' x = 0; y < Packet.HeaderKeySize; ++y' ++x) {  	readByte = (byte)stream.ReadByte ();  	current = ((byte)(readByte >> 4));  	chars [x] = (char)(current > 9 ? current + 0x37 : current + 0x30);  	current = ((byte)(readByte & 0xF));  	chars [++x] = (char)(current > 9 ? current + 0x37 : current + 0x30);  }  
Magic Number,Spike.Network,ChannelBase,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadKey,The following statement contains a magic number: for (int y = 0' x = 0; y < Packet.HeaderKeySize; ++y' ++x) {  	readByte = (byte)stream.ReadByte ();  	current = ((byte)(readByte >> 4));  	chars [x] = (char)(current > 9 ? current + 0x37 : current + 0x30);  	current = ((byte)(readByte & 0xF));  	chars [++x] = (char)(current > 9 ? current + 0x37 : current + 0x30);  }  
Magic Number,Spike.Network,ChannelBase,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadKey,The following statement contains a magic number: current = ((byte)(readByte >> 4));  
Magic Number,Spike.Network,ChannelBase,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadKey,The following statement contains a magic number: chars [x] = (char)(current > 9 ? current + 0x37 : current + 0x30);  
Magic Number,Spike.Network,ChannelBase,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadKey,The following statement contains a magic number: chars [++x] = (char)(current > 9 ? current + 0x37 : current + 0x30);  
Magic Number,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The following statement contains a magic number: using (MemoryStream stream = new MemoryStream ()) {  	int start = 0;  	int end = length;  	int idx = 0;  	int len = Math.Min (length' buffer.Length);  	while (idx < len - 4) {  		if (buffer [idx] == 0x0D && buffer [idx + 1] == 0x0A && buffer [idx + 2] == 0x0D && buffer [idx + 3] == 0x0A) {  			start = idx + 4;  		}  		if (start > 0 && buffer [idx] == '/' && buffer [idx + 1] == '1' && buffer [idx + 2] == '.' && buffer [idx + 3] == '1') {  			// HTTP/1.1  			end = idx - 4;  			// Get Payload  			string utf8Payload = Encoding.UTF8.GetString (buffer' start' end - start);  			byte[] decoded = System.Convert.FromBase64String (utf8Payload);  			stream.Write (decoded' 0' decoded.Length);  			start = 0;  			end = length;  		}  		idx++;  	}  	// Get Payload  	if (start > 0) {  		string utf8PayloadLast = Encoding.UTF8.GetString (buffer' start' end - start);  		byte[] decodedLast = System.Convert.FromBase64String (utf8PayloadLast);  		stream.Write (decodedLast' 0' decodedLast.Length);  	}  	// Get the resut buffer  	buffer = stream.GetBuffer ();  	length = (int)stream.Length;  }  
Magic Number,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The following statement contains a magic number: using (MemoryStream stream = new MemoryStream ()) {  	int start = 0;  	int end = length;  	int idx = 0;  	int len = Math.Min (length' buffer.Length);  	while (idx < len - 4) {  		if (buffer [idx] == 0x0D && buffer [idx + 1] == 0x0A && buffer [idx + 2] == 0x0D && buffer [idx + 3] == 0x0A) {  			start = idx + 4;  		}  		if (start > 0 && buffer [idx] == '/' && buffer [idx + 1] == '1' && buffer [idx + 2] == '.' && buffer [idx + 3] == '1') {  			// HTTP/1.1  			end = idx - 4;  			// Get Payload  			string utf8Payload = Encoding.UTF8.GetString (buffer' start' end - start);  			byte[] decoded = System.Convert.FromBase64String (utf8Payload);  			stream.Write (decoded' 0' decoded.Length);  			start = 0;  			end = length;  		}  		idx++;  	}  	// Get Payload  	if (start > 0) {  		string utf8PayloadLast = Encoding.UTF8.GetString (buffer' start' end - start);  		byte[] decodedLast = System.Convert.FromBase64String (utf8PayloadLast);  		stream.Write (decodedLast' 0' decodedLast.Length);  	}  	// Get the resut buffer  	buffer = stream.GetBuffer ();  	length = (int)stream.Length;  }  
Magic Number,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The following statement contains a magic number: using (MemoryStream stream = new MemoryStream ()) {  	int start = 0;  	int end = length;  	int idx = 0;  	int len = Math.Min (length' buffer.Length);  	while (idx < len - 4) {  		if (buffer [idx] == 0x0D && buffer [idx + 1] == 0x0A && buffer [idx + 2] == 0x0D && buffer [idx + 3] == 0x0A) {  			start = idx + 4;  		}  		if (start > 0 && buffer [idx] == '/' && buffer [idx + 1] == '1' && buffer [idx + 2] == '.' && buffer [idx + 3] == '1') {  			// HTTP/1.1  			end = idx - 4;  			// Get Payload  			string utf8Payload = Encoding.UTF8.GetString (buffer' start' end - start);  			byte[] decoded = System.Convert.FromBase64String (utf8Payload);  			stream.Write (decoded' 0' decoded.Length);  			start = 0;  			end = length;  		}  		idx++;  	}  	// Get Payload  	if (start > 0) {  		string utf8PayloadLast = Encoding.UTF8.GetString (buffer' start' end - start);  		byte[] decodedLast = System.Convert.FromBase64String (utf8PayloadLast);  		stream.Write (decodedLast' 0' decodedLast.Length);  	}  	// Get the resut buffer  	buffer = stream.GetBuffer ();  	length = (int)stream.Length;  }  
Magic Number,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The following statement contains a magic number: using (MemoryStream stream = new MemoryStream ()) {  	int start = 0;  	int end = length;  	int idx = 0;  	int len = Math.Min (length' buffer.Length);  	while (idx < len - 4) {  		if (buffer [idx] == 0x0D && buffer [idx + 1] == 0x0A && buffer [idx + 2] == 0x0D && buffer [idx + 3] == 0x0A) {  			start = idx + 4;  		}  		if (start > 0 && buffer [idx] == '/' && buffer [idx + 1] == '1' && buffer [idx + 2] == '.' && buffer [idx + 3] == '1') {  			// HTTP/1.1  			end = idx - 4;  			// Get Payload  			string utf8Payload = Encoding.UTF8.GetString (buffer' start' end - start);  			byte[] decoded = System.Convert.FromBase64String (utf8Payload);  			stream.Write (decoded' 0' decoded.Length);  			start = 0;  			end = length;  		}  		idx++;  	}  	// Get Payload  	if (start > 0) {  		string utf8PayloadLast = Encoding.UTF8.GetString (buffer' start' end - start);  		byte[] decodedLast = System.Convert.FromBase64String (utf8PayloadLast);  		stream.Write (decodedLast' 0' decodedLast.Length);  	}  	// Get the resut buffer  	buffer = stream.GetBuffer ();  	length = (int)stream.Length;  }  
Magic Number,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The following statement contains a magic number: using (MemoryStream stream = new MemoryStream ()) {  	int start = 0;  	int end = length;  	int idx = 0;  	int len = Math.Min (length' buffer.Length);  	while (idx < len - 4) {  		if (buffer [idx] == 0x0D && buffer [idx + 1] == 0x0A && buffer [idx + 2] == 0x0D && buffer [idx + 3] == 0x0A) {  			start = idx + 4;  		}  		if (start > 0 && buffer [idx] == '/' && buffer [idx + 1] == '1' && buffer [idx + 2] == '.' && buffer [idx + 3] == '1') {  			// HTTP/1.1  			end = idx - 4;  			// Get Payload  			string utf8Payload = Encoding.UTF8.GetString (buffer' start' end - start);  			byte[] decoded = System.Convert.FromBase64String (utf8Payload);  			stream.Write (decoded' 0' decoded.Length);  			start = 0;  			end = length;  		}  		idx++;  	}  	// Get Payload  	if (start > 0) {  		string utf8PayloadLast = Encoding.UTF8.GetString (buffer' start' end - start);  		byte[] decodedLast = System.Convert.FromBase64String (utf8PayloadLast);  		stream.Write (decodedLast' 0' decodedLast.Length);  	}  	// Get the resut buffer  	buffer = stream.GetBuffer ();  	length = (int)stream.Length;  }  
Magic Number,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The following statement contains a magic number: using (MemoryStream stream = new MemoryStream ()) {  	int start = 0;  	int end = length;  	int idx = 0;  	int len = Math.Min (length' buffer.Length);  	while (idx < len - 4) {  		if (buffer [idx] == 0x0D && buffer [idx + 1] == 0x0A && buffer [idx + 2] == 0x0D && buffer [idx + 3] == 0x0A) {  			start = idx + 4;  		}  		if (start > 0 && buffer [idx] == '/' && buffer [idx + 1] == '1' && buffer [idx + 2] == '.' && buffer [idx + 3] == '1') {  			// HTTP/1.1  			end = idx - 4;  			// Get Payload  			string utf8Payload = Encoding.UTF8.GetString (buffer' start' end - start);  			byte[] decoded = System.Convert.FromBase64String (utf8Payload);  			stream.Write (decoded' 0' decoded.Length);  			start = 0;  			end = length;  		}  		idx++;  	}  	// Get Payload  	if (start > 0) {  		string utf8PayloadLast = Encoding.UTF8.GetString (buffer' start' end - start);  		byte[] decodedLast = System.Convert.FromBase64String (utf8PayloadLast);  		stream.Write (decodedLast' 0' decodedLast.Length);  	}  	// Get the resut buffer  	buffer = stream.GetBuffer ();  	length = (int)stream.Length;  }  
Magic Number,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The following statement contains a magic number: using (MemoryStream stream = new MemoryStream ()) {  	int start = 0;  	int end = length;  	int idx = 0;  	int len = Math.Min (length' buffer.Length);  	while (idx < len - 4) {  		if (buffer [idx] == 0x0D && buffer [idx + 1] == 0x0A && buffer [idx + 2] == 0x0D && buffer [idx + 3] == 0x0A) {  			start = idx + 4;  		}  		if (start > 0 && buffer [idx] == '/' && buffer [idx + 1] == '1' && buffer [idx + 2] == '.' && buffer [idx + 3] == '1') {  			// HTTP/1.1  			end = idx - 4;  			// Get Payload  			string utf8Payload = Encoding.UTF8.GetString (buffer' start' end - start);  			byte[] decoded = System.Convert.FromBase64String (utf8Payload);  			stream.Write (decoded' 0' decoded.Length);  			start = 0;  			end = length;  		}  		idx++;  	}  	// Get Payload  	if (start > 0) {  		string utf8PayloadLast = Encoding.UTF8.GetString (buffer' start' end - start);  		byte[] decodedLast = System.Convert.FromBase64String (utf8PayloadLast);  		stream.Write (decodedLast' 0' decodedLast.Length);  	}  	// Get the resut buffer  	buffer = stream.GetBuffer ();  	length = (int)stream.Length;  }  
Magic Number,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The following statement contains a magic number: while (idx < len - 4) {  	if (buffer [idx] == 0x0D && buffer [idx + 1] == 0x0A && buffer [idx + 2] == 0x0D && buffer [idx + 3] == 0x0A) {  		start = idx + 4;  	}  	if (start > 0 && buffer [idx] == '/' && buffer [idx + 1] == '1' && buffer [idx + 2] == '.' && buffer [idx + 3] == '1') {  		// HTTP/1.1  		end = idx - 4;  		// Get Payload  		string utf8Payload = Encoding.UTF8.GetString (buffer' start' end - start);  		byte[] decoded = System.Convert.FromBase64String (utf8Payload);  		stream.Write (decoded' 0' decoded.Length);  		start = 0;  		end = length;  	}  	idx++;  }  
Magic Number,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The following statement contains a magic number: while (idx < len - 4) {  	if (buffer [idx] == 0x0D && buffer [idx + 1] == 0x0A && buffer [idx + 2] == 0x0D && buffer [idx + 3] == 0x0A) {  		start = idx + 4;  	}  	if (start > 0 && buffer [idx] == '/' && buffer [idx + 1] == '1' && buffer [idx + 2] == '.' && buffer [idx + 3] == '1') {  		// HTTP/1.1  		end = idx - 4;  		// Get Payload  		string utf8Payload = Encoding.UTF8.GetString (buffer' start' end - start);  		byte[] decoded = System.Convert.FromBase64String (utf8Payload);  		stream.Write (decoded' 0' decoded.Length);  		start = 0;  		end = length;  	}  	idx++;  }  
Magic Number,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The following statement contains a magic number: while (idx < len - 4) {  	if (buffer [idx] == 0x0D && buffer [idx + 1] == 0x0A && buffer [idx + 2] == 0x0D && buffer [idx + 3] == 0x0A) {  		start = idx + 4;  	}  	if (start > 0 && buffer [idx] == '/' && buffer [idx + 1] == '1' && buffer [idx + 2] == '.' && buffer [idx + 3] == '1') {  		// HTTP/1.1  		end = idx - 4;  		// Get Payload  		string utf8Payload = Encoding.UTF8.GetString (buffer' start' end - start);  		byte[] decoded = System.Convert.FromBase64String (utf8Payload);  		stream.Write (decoded' 0' decoded.Length);  		start = 0;  		end = length;  	}  	idx++;  }  
Magic Number,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The following statement contains a magic number: while (idx < len - 4) {  	if (buffer [idx] == 0x0D && buffer [idx + 1] == 0x0A && buffer [idx + 2] == 0x0D && buffer [idx + 3] == 0x0A) {  		start = idx + 4;  	}  	if (start > 0 && buffer [idx] == '/' && buffer [idx + 1] == '1' && buffer [idx + 2] == '.' && buffer [idx + 3] == '1') {  		// HTTP/1.1  		end = idx - 4;  		// Get Payload  		string utf8Payload = Encoding.UTF8.GetString (buffer' start' end - start);  		byte[] decoded = System.Convert.FromBase64String (utf8Payload);  		stream.Write (decoded' 0' decoded.Length);  		start = 0;  		end = length;  	}  	idx++;  }  
Magic Number,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The following statement contains a magic number: while (idx < len - 4) {  	if (buffer [idx] == 0x0D && buffer [idx + 1] == 0x0A && buffer [idx + 2] == 0x0D && buffer [idx + 3] == 0x0A) {  		start = idx + 4;  	}  	if (start > 0 && buffer [idx] == '/' && buffer [idx + 1] == '1' && buffer [idx + 2] == '.' && buffer [idx + 3] == '1') {  		// HTTP/1.1  		end = idx - 4;  		// Get Payload  		string utf8Payload = Encoding.UTF8.GetString (buffer' start' end - start);  		byte[] decoded = System.Convert.FromBase64String (utf8Payload);  		stream.Write (decoded' 0' decoded.Length);  		start = 0;  		end = length;  	}  	idx++;  }  
Magic Number,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The following statement contains a magic number: while (idx < len - 4) {  	if (buffer [idx] == 0x0D && buffer [idx + 1] == 0x0A && buffer [idx + 2] == 0x0D && buffer [idx + 3] == 0x0A) {  		start = idx + 4;  	}  	if (start > 0 && buffer [idx] == '/' && buffer [idx + 1] == '1' && buffer [idx + 2] == '.' && buffer [idx + 3] == '1') {  		// HTTP/1.1  		end = idx - 4;  		// Get Payload  		string utf8Payload = Encoding.UTF8.GetString (buffer' start' end - start);  		byte[] decoded = System.Convert.FromBase64String (utf8Payload);  		stream.Write (decoded' 0' decoded.Length);  		start = 0;  		end = length;  	}  	idx++;  }  
Magic Number,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The following statement contains a magic number: while (idx < len - 4) {  	if (buffer [idx] == 0x0D && buffer [idx + 1] == 0x0A && buffer [idx + 2] == 0x0D && buffer [idx + 3] == 0x0A) {  		start = idx + 4;  	}  	if (start > 0 && buffer [idx] == '/' && buffer [idx + 1] == '1' && buffer [idx + 2] == '.' && buffer [idx + 3] == '1') {  		// HTTP/1.1  		end = idx - 4;  		// Get Payload  		string utf8Payload = Encoding.UTF8.GetString (buffer' start' end - start);  		byte[] decoded = System.Convert.FromBase64String (utf8Payload);  		stream.Write (decoded' 0' decoded.Length);  		start = 0;  		end = length;  	}  	idx++;  }  
Magic Number,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The following statement contains a magic number: if (buffer [idx] == 0x0D && buffer [idx + 1] == 0x0A && buffer [idx + 2] == 0x0D && buffer [idx + 3] == 0x0A) {  	start = idx + 4;  }  
Magic Number,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The following statement contains a magic number: if (buffer [idx] == 0x0D && buffer [idx + 1] == 0x0A && buffer [idx + 2] == 0x0D && buffer [idx + 3] == 0x0A) {  	start = idx + 4;  }  
Magic Number,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The following statement contains a magic number: if (buffer [idx] == 0x0D && buffer [idx + 1] == 0x0A && buffer [idx + 2] == 0x0D && buffer [idx + 3] == 0x0A) {  	start = idx + 4;  }  
Magic Number,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The following statement contains a magic number: start = idx + 4;  
Magic Number,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The following statement contains a magic number: if (start > 0 && buffer [idx] == '/' && buffer [idx + 1] == '1' && buffer [idx + 2] == '.' && buffer [idx + 3] == '1') {  	// HTTP/1.1  	end = idx - 4;  	// Get Payload  	string utf8Payload = Encoding.UTF8.GetString (buffer' start' end - start);  	byte[] decoded = System.Convert.FromBase64String (utf8Payload);  	stream.Write (decoded' 0' decoded.Length);  	start = 0;  	end = length;  }  
Magic Number,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The following statement contains a magic number: if (start > 0 && buffer [idx] == '/' && buffer [idx + 1] == '1' && buffer [idx + 2] == '.' && buffer [idx + 3] == '1') {  	// HTTP/1.1  	end = idx - 4;  	// Get Payload  	string utf8Payload = Encoding.UTF8.GetString (buffer' start' end - start);  	byte[] decoded = System.Convert.FromBase64String (utf8Payload);  	stream.Write (decoded' 0' decoded.Length);  	start = 0;  	end = length;  }  
Magic Number,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The following statement contains a magic number: if (start > 0 && buffer [idx] == '/' && buffer [idx + 1] == '1' && buffer [idx + 2] == '.' && buffer [idx + 3] == '1') {  	// HTTP/1.1  	end = idx - 4;  	// Get Payload  	string utf8Payload = Encoding.UTF8.GetString (buffer' start' end - start);  	byte[] decoded = System.Convert.FromBase64String (utf8Payload);  	stream.Write (decoded' 0' decoded.Length);  	start = 0;  	end = length;  }  
Magic Number,Spike.Network,RayHttpEncoder,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,DecodeIncomingPacket,The following statement contains a magic number: end = idx - 4;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: hval = (hval << 8) | input [iidx + 2];  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: hval = (hval << 8) | input [iidx + 2];  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (oidx + lit + 1 + 3 >= outputLength)  	return 0;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: len -= 2;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (len < 7) {  	output [oidx++] = (byte)((off >> 8) + (len << 5));  }  else {  	output [oidx++] = (byte)((off >> 8) + (7 << 5));  	output [oidx++] = (byte)(len - 7);  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (len < 7) {  	output [oidx++] = (byte)((off >> 8) + (len << 5));  }  else {  	output [oidx++] = (byte)((off >> 8) + (7 << 5));  	output [oidx++] = (byte)(len - 7);  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (len < 7) {  	output [oidx++] = (byte)((off >> 8) + (len << 5));  }  else {  	output [oidx++] = (byte)((off >> 8) + (7 << 5));  	output [oidx++] = (byte)(len - 7);  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (len < 7) {  	output [oidx++] = (byte)((off >> 8) + (len << 5));  }  else {  	output [oidx++] = (byte)((off >> 8) + (7 << 5));  	output [oidx++] = (byte)(len - 7);  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (len < 7) {  	output [oidx++] = (byte)((off >> 8) + (len << 5));  }  else {  	output [oidx++] = (byte)((off >> 8) + (7 << 5));  	output [oidx++] = (byte)(len - 7);  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (len < 7) {  	output [oidx++] = (byte)((off >> 8) + (len << 5));  }  else {  	output [oidx++] = (byte)((off >> 8) + (7 << 5));  	output [oidx++] = (byte)(len - 7);  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (len < 7) {  	output [oidx++] = (byte)((off >> 8) + (len << 5));  }  else {  	output [oidx++] = (byte)((off >> 8) + (7 << 5));  	output [oidx++] = (byte)(len - 7);  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: output [oidx++] = (byte)((off >> 8) + (len << 5));  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: output [oidx++] = (byte)((off >> 8) + (len << 5));  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: output [oidx++] = (byte)((off >> 8) + (7 << 5));  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: output [oidx++] = (byte)((off >> 8) + (7 << 5));  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: output [oidx++] = (byte)((off >> 8) + (7 << 5));  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: output [oidx++] = (byte)(len - 7);  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: hval = (hval << 8) | input [iidx + 2];  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: hval = (hval << 8) | input [iidx + 2];  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: hval = (hval << 8) | input [iidx + 2];  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: hval = (hval << 8) | input [iidx + 2];  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				oidx++;  				output.WriteByte ((byte)(lit - 1));  				lit = -lit;  				do {  					oidx++;  					output.WriteByte (input [iidx + lit]);  				}  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (len << 5)));  			}  			else {  				oidx++;  				oidx++;  				output.WriteByte ((byte)((off >> 8) + (7 << 5)));  				output.WriteByte ((byte)(len - 7));  			}  			oidx++;  			output.WriteByte ((byte)off);  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		oidx++;  		output.WriteByte ((byte)(MAX_LIT - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			oidx++;  			output.WriteByte ((byte)(lit - 1));  			lit = -lit;  			do {  				oidx++;  				output.WriteByte (input [iidx + lit]);  			}  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (len << 5)));  		}  		else {  			oidx++;  			oidx++;  			output.WriteByte ((byte)((off >> 8) + (7 << 5)));  			output.WriteByte ((byte)(len - 7));  		}  		oidx++;  		output.WriteByte ((byte)off);  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: hval = (hval << 8) | input [iidx + 2];  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: hval = (hval << 8) | input [iidx + 2];  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		oidx++;  		output.WriteByte ((byte)(lit - 1));  		lit = -lit;  		do {  			oidx++;  			output.WriteByte (input [iidx + lit]);  		}  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (len << 5)));  	}  	else {  		oidx++;  		oidx++;  		output.WriteByte ((byte)((off >> 8) + (7 << 5)));  		output.WriteByte ((byte)(len - 7));  	}  	oidx++;  	output.WriteByte ((byte)off);  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: len -= 2;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (len < 7) {  	oidx++;  	output.WriteByte ((byte)((off >> 8) + (len << 5)));  }  else {  	oidx++;  	oidx++;  	output.WriteByte ((byte)((off >> 8) + (7 << 5)));  	output.WriteByte ((byte)(len - 7));  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (len < 7) {  	oidx++;  	output.WriteByte ((byte)((off >> 8) + (len << 5)));  }  else {  	oidx++;  	oidx++;  	output.WriteByte ((byte)((off >> 8) + (7 << 5)));  	output.WriteByte ((byte)(len - 7));  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (len < 7) {  	oidx++;  	output.WriteByte ((byte)((off >> 8) + (len << 5)));  }  else {  	oidx++;  	oidx++;  	output.WriteByte ((byte)((off >> 8) + (7 << 5)));  	output.WriteByte ((byte)(len - 7));  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (len < 7) {  	oidx++;  	output.WriteByte ((byte)((off >> 8) + (len << 5)));  }  else {  	oidx++;  	oidx++;  	output.WriteByte ((byte)((off >> 8) + (7 << 5)));  	output.WriteByte ((byte)(len - 7));  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (len < 7) {  	oidx++;  	output.WriteByte ((byte)((off >> 8) + (len << 5)));  }  else {  	oidx++;  	oidx++;  	output.WriteByte ((byte)((off >> 8) + (7 << 5)));  	output.WriteByte ((byte)(len - 7));  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (len < 7) {  	oidx++;  	output.WriteByte ((byte)((off >> 8) + (len << 5)));  }  else {  	oidx++;  	oidx++;  	output.WriteByte ((byte)((off >> 8) + (7 << 5)));  	output.WriteByte ((byte)(len - 7));  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: if (len < 7) {  	oidx++;  	output.WriteByte ((byte)((off >> 8) + (len << 5)));  }  else {  	oidx++;  	oidx++;  	output.WriteByte ((byte)((off >> 8) + (7 << 5)));  	output.WriteByte ((byte)(len - 7));  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: output.WriteByte ((byte)((off >> 8) + (len << 5)));  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: output.WriteByte ((byte)((off >> 8) + (len << 5)));  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: output.WriteByte ((byte)((off >> 8) + (7 << 5)));  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: output.WriteByte ((byte)((off >> 8) + (7 << 5)));  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: output.WriteByte ((byte)((off >> 8) + (7 << 5)));  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: output.WriteByte ((byte)(len - 7));  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: hval = (hval << 8) | input [iidx + 2];  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: hval = (hval << 8) | input [iidx + 2];  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: hval = (hval << 8) | input [iidx + 2];  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: hval = (hval << 8) | input [iidx + 2];  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Compress,The following statement contains a magic number: HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: do {  	uint ctrl = input [iidx++];  	if (ctrl < (1 << 5))/* literal run */ {  		ctrl++;  		if (oidx + ctrl > outputLength) {  			// Promote the buffer  			outputLength = (int)(oidx + ctrl) * 2;  			Array.Resize<byte> (ref output' outputLength);  		}  		do  			output [oidx++] = input [iidx++];  		while ((--ctrl) != 0);  	}  	else/* back reference */ {  		uint len = ctrl >> 5;  		int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  		if (len == 7)  			len += input [iidx++];  		reference -= input [iidx++];  		if (oidx + len + 2 > outputLength) {  			// Promote the buffer  			outputLength = (int)(oidx + len + 2) * 2;  			Array.Resize<byte> (ref output' outputLength);  		}  		if (reference < 0) {  			//SET_ERRNO (EINVAL);  			return 0;  		}  		output [oidx++] = output [reference++];  		output [oidx++] = output [reference++];  		do  			output [oidx++] = output [reference++];  		while ((--len) != 0);  	}  }  while (iidx < inputLength);  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: do {  	uint ctrl = input [iidx++];  	if (ctrl < (1 << 5))/* literal run */ {  		ctrl++;  		if (oidx + ctrl > outputLength) {  			// Promote the buffer  			outputLength = (int)(oidx + ctrl) * 2;  			Array.Resize<byte> (ref output' outputLength);  		}  		do  			output [oidx++] = input [iidx++];  		while ((--ctrl) != 0);  	}  	else/* back reference */ {  		uint len = ctrl >> 5;  		int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  		if (len == 7)  			len += input [iidx++];  		reference -= input [iidx++];  		if (oidx + len + 2 > outputLength) {  			// Promote the buffer  			outputLength = (int)(oidx + len + 2) * 2;  			Array.Resize<byte> (ref output' outputLength);  		}  		if (reference < 0) {  			//SET_ERRNO (EINVAL);  			return 0;  		}  		output [oidx++] = output [reference++];  		output [oidx++] = output [reference++];  		do  			output [oidx++] = output [reference++];  		while ((--len) != 0);  	}  }  while (iidx < inputLength);  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: do {  	uint ctrl = input [iidx++];  	if (ctrl < (1 << 5))/* literal run */ {  		ctrl++;  		if (oidx + ctrl > outputLength) {  			// Promote the buffer  			outputLength = (int)(oidx + ctrl) * 2;  			Array.Resize<byte> (ref output' outputLength);  		}  		do  			output [oidx++] = input [iidx++];  		while ((--ctrl) != 0);  	}  	else/* back reference */ {  		uint len = ctrl >> 5;  		int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  		if (len == 7)  			len += input [iidx++];  		reference -= input [iidx++];  		if (oidx + len + 2 > outputLength) {  			// Promote the buffer  			outputLength = (int)(oidx + len + 2) * 2;  			Array.Resize<byte> (ref output' outputLength);  		}  		if (reference < 0) {  			//SET_ERRNO (EINVAL);  			return 0;  		}  		output [oidx++] = output [reference++];  		output [oidx++] = output [reference++];  		do  			output [oidx++] = output [reference++];  		while ((--len) != 0);  	}  }  while (iidx < inputLength);  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: do {  	uint ctrl = input [iidx++];  	if (ctrl < (1 << 5))/* literal run */ {  		ctrl++;  		if (oidx + ctrl > outputLength) {  			// Promote the buffer  			outputLength = (int)(oidx + ctrl) * 2;  			Array.Resize<byte> (ref output' outputLength);  		}  		do  			output [oidx++] = input [iidx++];  		while ((--ctrl) != 0);  	}  	else/* back reference */ {  		uint len = ctrl >> 5;  		int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  		if (len == 7)  			len += input [iidx++];  		reference -= input [iidx++];  		if (oidx + len + 2 > outputLength) {  			// Promote the buffer  			outputLength = (int)(oidx + len + 2) * 2;  			Array.Resize<byte> (ref output' outputLength);  		}  		if (reference < 0) {  			//SET_ERRNO (EINVAL);  			return 0;  		}  		output [oidx++] = output [reference++];  		output [oidx++] = output [reference++];  		do  			output [oidx++] = output [reference++];  		while ((--len) != 0);  	}  }  while (iidx < inputLength);  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: do {  	uint ctrl = input [iidx++];  	if (ctrl < (1 << 5))/* literal run */ {  		ctrl++;  		if (oidx + ctrl > outputLength) {  			// Promote the buffer  			outputLength = (int)(oidx + ctrl) * 2;  			Array.Resize<byte> (ref output' outputLength);  		}  		do  			output [oidx++] = input [iidx++];  		while ((--ctrl) != 0);  	}  	else/* back reference */ {  		uint len = ctrl >> 5;  		int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  		if (len == 7)  			len += input [iidx++];  		reference -= input [iidx++];  		if (oidx + len + 2 > outputLength) {  			// Promote the buffer  			outputLength = (int)(oidx + len + 2) * 2;  			Array.Resize<byte> (ref output' outputLength);  		}  		if (reference < 0) {  			//SET_ERRNO (EINVAL);  			return 0;  		}  		output [oidx++] = output [reference++];  		output [oidx++] = output [reference++];  		do  			output [oidx++] = output [reference++];  		while ((--len) != 0);  	}  }  while (iidx < inputLength);  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: do {  	uint ctrl = input [iidx++];  	if (ctrl < (1 << 5))/* literal run */ {  		ctrl++;  		if (oidx + ctrl > outputLength) {  			// Promote the buffer  			outputLength = (int)(oidx + ctrl) * 2;  			Array.Resize<byte> (ref output' outputLength);  		}  		do  			output [oidx++] = input [iidx++];  		while ((--ctrl) != 0);  	}  	else/* back reference */ {  		uint len = ctrl >> 5;  		int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  		if (len == 7)  			len += input [iidx++];  		reference -= input [iidx++];  		if (oidx + len + 2 > outputLength) {  			// Promote the buffer  			outputLength = (int)(oidx + len + 2) * 2;  			Array.Resize<byte> (ref output' outputLength);  		}  		if (reference < 0) {  			//SET_ERRNO (EINVAL);  			return 0;  		}  		output [oidx++] = output [reference++];  		output [oidx++] = output [reference++];  		do  			output [oidx++] = output [reference++];  		while ((--len) != 0);  	}  }  while (iidx < inputLength);  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: do {  	uint ctrl = input [iidx++];  	if (ctrl < (1 << 5))/* literal run */ {  		ctrl++;  		if (oidx + ctrl > outputLength) {  			// Promote the buffer  			outputLength = (int)(oidx + ctrl) * 2;  			Array.Resize<byte> (ref output' outputLength);  		}  		do  			output [oidx++] = input [iidx++];  		while ((--ctrl) != 0);  	}  	else/* back reference */ {  		uint len = ctrl >> 5;  		int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  		if (len == 7)  			len += input [iidx++];  		reference -= input [iidx++];  		if (oidx + len + 2 > outputLength) {  			// Promote the buffer  			outputLength = (int)(oidx + len + 2) * 2;  			Array.Resize<byte> (ref output' outputLength);  		}  		if (reference < 0) {  			//SET_ERRNO (EINVAL);  			return 0;  		}  		output [oidx++] = output [reference++];  		output [oidx++] = output [reference++];  		do  			output [oidx++] = output [reference++];  		while ((--len) != 0);  	}  }  while (iidx < inputLength);  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: do {  	uint ctrl = input [iidx++];  	if (ctrl < (1 << 5))/* literal run */ {  		ctrl++;  		if (oidx + ctrl > outputLength) {  			// Promote the buffer  			outputLength = (int)(oidx + ctrl) * 2;  			Array.Resize<byte> (ref output' outputLength);  		}  		do  			output [oidx++] = input [iidx++];  		while ((--ctrl) != 0);  	}  	else/* back reference */ {  		uint len = ctrl >> 5;  		int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  		if (len == 7)  			len += input [iidx++];  		reference -= input [iidx++];  		if (oidx + len + 2 > outputLength) {  			// Promote the buffer  			outputLength = (int)(oidx + len + 2) * 2;  			Array.Resize<byte> (ref output' outputLength);  		}  		if (reference < 0) {  			//SET_ERRNO (EINVAL);  			return 0;  		}  		output [oidx++] = output [reference++];  		output [oidx++] = output [reference++];  		do  			output [oidx++] = output [reference++];  		while ((--len) != 0);  	}  }  while (iidx < inputLength);  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: if (ctrl < (1 << 5))/* literal run */ {  	ctrl++;  	if (oidx + ctrl > outputLength) {  		// Promote the buffer  		outputLength = (int)(oidx + ctrl) * 2;  		Array.Resize<byte> (ref output' outputLength);  	}  	do  		output [oidx++] = input [iidx++];  	while ((--ctrl) != 0);  }  else/* back reference */ {  	uint len = ctrl >> 5;  	int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  	if (len == 7)  		len += input [iidx++];  	reference -= input [iidx++];  	if (oidx + len + 2 > outputLength) {  		// Promote the buffer  		outputLength = (int)(oidx + len + 2) * 2;  		Array.Resize<byte> (ref output' outputLength);  	}  	if (reference < 0) {  		//SET_ERRNO (EINVAL);  		return 0;  	}  	output [oidx++] = output [reference++];  	output [oidx++] = output [reference++];  	do  		output [oidx++] = output [reference++];  	while ((--len) != 0);  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: if (ctrl < (1 << 5))/* literal run */ {  	ctrl++;  	if (oidx + ctrl > outputLength) {  		// Promote the buffer  		outputLength = (int)(oidx + ctrl) * 2;  		Array.Resize<byte> (ref output' outputLength);  	}  	do  		output [oidx++] = input [iidx++];  	while ((--ctrl) != 0);  }  else/* back reference */ {  	uint len = ctrl >> 5;  	int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  	if (len == 7)  		len += input [iidx++];  	reference -= input [iidx++];  	if (oidx + len + 2 > outputLength) {  		// Promote the buffer  		outputLength = (int)(oidx + len + 2) * 2;  		Array.Resize<byte> (ref output' outputLength);  	}  	if (reference < 0) {  		//SET_ERRNO (EINVAL);  		return 0;  	}  	output [oidx++] = output [reference++];  	output [oidx++] = output [reference++];  	do  		output [oidx++] = output [reference++];  	while ((--len) != 0);  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: if (ctrl < (1 << 5))/* literal run */ {  	ctrl++;  	if (oidx + ctrl > outputLength) {  		// Promote the buffer  		outputLength = (int)(oidx + ctrl) * 2;  		Array.Resize<byte> (ref output' outputLength);  	}  	do  		output [oidx++] = input [iidx++];  	while ((--ctrl) != 0);  }  else/* back reference */ {  	uint len = ctrl >> 5;  	int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  	if (len == 7)  		len += input [iidx++];  	reference -= input [iidx++];  	if (oidx + len + 2 > outputLength) {  		// Promote the buffer  		outputLength = (int)(oidx + len + 2) * 2;  		Array.Resize<byte> (ref output' outputLength);  	}  	if (reference < 0) {  		//SET_ERRNO (EINVAL);  		return 0;  	}  	output [oidx++] = output [reference++];  	output [oidx++] = output [reference++];  	do  		output [oidx++] = output [reference++];  	while ((--len) != 0);  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: if (ctrl < (1 << 5))/* literal run */ {  	ctrl++;  	if (oidx + ctrl > outputLength) {  		// Promote the buffer  		outputLength = (int)(oidx + ctrl) * 2;  		Array.Resize<byte> (ref output' outputLength);  	}  	do  		output [oidx++] = input [iidx++];  	while ((--ctrl) != 0);  }  else/* back reference */ {  	uint len = ctrl >> 5;  	int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  	if (len == 7)  		len += input [iidx++];  	reference -= input [iidx++];  	if (oidx + len + 2 > outputLength) {  		// Promote the buffer  		outputLength = (int)(oidx + len + 2) * 2;  		Array.Resize<byte> (ref output' outputLength);  	}  	if (reference < 0) {  		//SET_ERRNO (EINVAL);  		return 0;  	}  	output [oidx++] = output [reference++];  	output [oidx++] = output [reference++];  	do  		output [oidx++] = output [reference++];  	while ((--len) != 0);  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: if (ctrl < (1 << 5))/* literal run */ {  	ctrl++;  	if (oidx + ctrl > outputLength) {  		// Promote the buffer  		outputLength = (int)(oidx + ctrl) * 2;  		Array.Resize<byte> (ref output' outputLength);  	}  	do  		output [oidx++] = input [iidx++];  	while ((--ctrl) != 0);  }  else/* back reference */ {  	uint len = ctrl >> 5;  	int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  	if (len == 7)  		len += input [iidx++];  	reference -= input [iidx++];  	if (oidx + len + 2 > outputLength) {  		// Promote the buffer  		outputLength = (int)(oidx + len + 2) * 2;  		Array.Resize<byte> (ref output' outputLength);  	}  	if (reference < 0) {  		//SET_ERRNO (EINVAL);  		return 0;  	}  	output [oidx++] = output [reference++];  	output [oidx++] = output [reference++];  	do  		output [oidx++] = output [reference++];  	while ((--len) != 0);  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: if (ctrl < (1 << 5))/* literal run */ {  	ctrl++;  	if (oidx + ctrl > outputLength) {  		// Promote the buffer  		outputLength = (int)(oidx + ctrl) * 2;  		Array.Resize<byte> (ref output' outputLength);  	}  	do  		output [oidx++] = input [iidx++];  	while ((--ctrl) != 0);  }  else/* back reference */ {  	uint len = ctrl >> 5;  	int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  	if (len == 7)  		len += input [iidx++];  	reference -= input [iidx++];  	if (oidx + len + 2 > outputLength) {  		// Promote the buffer  		outputLength = (int)(oidx + len + 2) * 2;  		Array.Resize<byte> (ref output' outputLength);  	}  	if (reference < 0) {  		//SET_ERRNO (EINVAL);  		return 0;  	}  	output [oidx++] = output [reference++];  	output [oidx++] = output [reference++];  	do  		output [oidx++] = output [reference++];  	while ((--len) != 0);  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: if (ctrl < (1 << 5))/* literal run */ {  	ctrl++;  	if (oidx + ctrl > outputLength) {  		// Promote the buffer  		outputLength = (int)(oidx + ctrl) * 2;  		Array.Resize<byte> (ref output' outputLength);  	}  	do  		output [oidx++] = input [iidx++];  	while ((--ctrl) != 0);  }  else/* back reference */ {  	uint len = ctrl >> 5;  	int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  	if (len == 7)  		len += input [iidx++];  	reference -= input [iidx++];  	if (oidx + len + 2 > outputLength) {  		// Promote the buffer  		outputLength = (int)(oidx + len + 2) * 2;  		Array.Resize<byte> (ref output' outputLength);  	}  	if (reference < 0) {  		//SET_ERRNO (EINVAL);  		return 0;  	}  	output [oidx++] = output [reference++];  	output [oidx++] = output [reference++];  	do  		output [oidx++] = output [reference++];  	while ((--len) != 0);  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: if (ctrl < (1 << 5))/* literal run */ {  	ctrl++;  	if (oidx + ctrl > outputLength) {  		// Promote the buffer  		outputLength = (int)(oidx + ctrl) * 2;  		Array.Resize<byte> (ref output' outputLength);  	}  	do  		output [oidx++] = input [iidx++];  	while ((--ctrl) != 0);  }  else/* back reference */ {  	uint len = ctrl >> 5;  	int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  	if (len == 7)  		len += input [iidx++];  	reference -= input [iidx++];  	if (oidx + len + 2 > outputLength) {  		// Promote the buffer  		outputLength = (int)(oidx + len + 2) * 2;  		Array.Resize<byte> (ref output' outputLength);  	}  	if (reference < 0) {  		//SET_ERRNO (EINVAL);  		return 0;  	}  	output [oidx++] = output [reference++];  	output [oidx++] = output [reference++];  	do  		output [oidx++] = output [reference++];  	while ((--len) != 0);  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: if (oidx + ctrl > outputLength) {  	// Promote the buffer  	outputLength = (int)(oidx + ctrl) * 2;  	Array.Resize<byte> (ref output' outputLength);  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: outputLength = (int)(oidx + ctrl) * 2;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: if (len == 7)  	len += input [iidx++];  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: if (oidx + len + 2 > outputLength) {  	// Promote the buffer  	outputLength = (int)(oidx + len + 2) * 2;  	Array.Resize<byte> (ref output' outputLength);  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: if (oidx + len + 2 > outputLength) {  	// Promote the buffer  	outputLength = (int)(oidx + len + 2) * 2;  	Array.Resize<byte> (ref output' outputLength);  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: if (oidx + len + 2 > outputLength) {  	// Promote the buffer  	outputLength = (int)(oidx + len + 2) * 2;  	Array.Resize<byte> (ref output' outputLength);  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: outputLength = (int)(oidx + len + 2) * 2;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: outputLength = (int)(oidx + len + 2) * 2;  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: do {  	uint ctrl = input [iidx++];  	if (ctrl < (1 << 5))/* literal run */ {  		ctrl++;  		do {  			oidx++;  			output.WriteByte (input [iidx++]);  		}  		while ((--ctrl) != 0);  	}  	else/* back reference */ {  		uint len = ctrl >> 5;  		int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  		if (len == 7)  			len += input [iidx++];  		reference -= input [iidx++];  		if (reference < 0) {  			//SET_ERRNO (EINVAL);  			return 0;  		}  		byte[] buffer = output.GetBuffer ();  		byte b1 = buffer [reference++];  		output.WriteByte (b1);  		oidx++;  		byte b2 = buffer [reference++];  		output.WriteByte (b2);  		oidx++;  		do {  			buffer = output.GetBuffer ();  			output.WriteByte (buffer [reference++]);  			oidx++;  		}  		while ((--len) != 0);  	}  }  while (iidx < inputLength);  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: do {  	uint ctrl = input [iidx++];  	if (ctrl < (1 << 5))/* literal run */ {  		ctrl++;  		do {  			oidx++;  			output.WriteByte (input [iidx++]);  		}  		while ((--ctrl) != 0);  	}  	else/* back reference */ {  		uint len = ctrl >> 5;  		int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  		if (len == 7)  			len += input [iidx++];  		reference -= input [iidx++];  		if (reference < 0) {  			//SET_ERRNO (EINVAL);  			return 0;  		}  		byte[] buffer = output.GetBuffer ();  		byte b1 = buffer [reference++];  		output.WriteByte (b1);  		oidx++;  		byte b2 = buffer [reference++];  		output.WriteByte (b2);  		oidx++;  		do {  			buffer = output.GetBuffer ();  			output.WriteByte (buffer [reference++]);  			oidx++;  		}  		while ((--len) != 0);  	}  }  while (iidx < inputLength);  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: do {  	uint ctrl = input [iidx++];  	if (ctrl < (1 << 5))/* literal run */ {  		ctrl++;  		do {  			oidx++;  			output.WriteByte (input [iidx++]);  		}  		while ((--ctrl) != 0);  	}  	else/* back reference */ {  		uint len = ctrl >> 5;  		int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  		if (len == 7)  			len += input [iidx++];  		reference -= input [iidx++];  		if (reference < 0) {  			//SET_ERRNO (EINVAL);  			return 0;  		}  		byte[] buffer = output.GetBuffer ();  		byte b1 = buffer [reference++];  		output.WriteByte (b1);  		oidx++;  		byte b2 = buffer [reference++];  		output.WriteByte (b2);  		oidx++;  		do {  			buffer = output.GetBuffer ();  			output.WriteByte (buffer [reference++]);  			oidx++;  		}  		while ((--len) != 0);  	}  }  while (iidx < inputLength);  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: do {  	uint ctrl = input [iidx++];  	if (ctrl < (1 << 5))/* literal run */ {  		ctrl++;  		do {  			oidx++;  			output.WriteByte (input [iidx++]);  		}  		while ((--ctrl) != 0);  	}  	else/* back reference */ {  		uint len = ctrl >> 5;  		int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  		if (len == 7)  			len += input [iidx++];  		reference -= input [iidx++];  		if (reference < 0) {  			//SET_ERRNO (EINVAL);  			return 0;  		}  		byte[] buffer = output.GetBuffer ();  		byte b1 = buffer [reference++];  		output.WriteByte (b1);  		oidx++;  		byte b2 = buffer [reference++];  		output.WriteByte (b2);  		oidx++;  		do {  			buffer = output.GetBuffer ();  			output.WriteByte (buffer [reference++]);  			oidx++;  		}  		while ((--len) != 0);  	}  }  while (iidx < inputLength);  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: if (ctrl < (1 << 5))/* literal run */ {  	ctrl++;  	do {  		oidx++;  		output.WriteByte (input [iidx++]);  	}  	while ((--ctrl) != 0);  }  else/* back reference */ {  	uint len = ctrl >> 5;  	int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  	if (len == 7)  		len += input [iidx++];  	reference -= input [iidx++];  	if (reference < 0) {  		//SET_ERRNO (EINVAL);  		return 0;  	}  	byte[] buffer = output.GetBuffer ();  	byte b1 = buffer [reference++];  	output.WriteByte (b1);  	oidx++;  	byte b2 = buffer [reference++];  	output.WriteByte (b2);  	oidx++;  	do {  		buffer = output.GetBuffer ();  		output.WriteByte (buffer [reference++]);  		oidx++;  	}  	while ((--len) != 0);  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: if (ctrl < (1 << 5))/* literal run */ {  	ctrl++;  	do {  		oidx++;  		output.WriteByte (input [iidx++]);  	}  	while ((--ctrl) != 0);  }  else/* back reference */ {  	uint len = ctrl >> 5;  	int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  	if (len == 7)  		len += input [iidx++];  	reference -= input [iidx++];  	if (reference < 0) {  		//SET_ERRNO (EINVAL);  		return 0;  	}  	byte[] buffer = output.GetBuffer ();  	byte b1 = buffer [reference++];  	output.WriteByte (b1);  	oidx++;  	byte b2 = buffer [reference++];  	output.WriteByte (b2);  	oidx++;  	do {  		buffer = output.GetBuffer ();  		output.WriteByte (buffer [reference++]);  		oidx++;  	}  	while ((--len) != 0);  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: if (ctrl < (1 << 5))/* literal run */ {  	ctrl++;  	do {  		oidx++;  		output.WriteByte (input [iidx++]);  	}  	while ((--ctrl) != 0);  }  else/* back reference */ {  	uint len = ctrl >> 5;  	int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  	if (len == 7)  		len += input [iidx++];  	reference -= input [iidx++];  	if (reference < 0) {  		//SET_ERRNO (EINVAL);  		return 0;  	}  	byte[] buffer = output.GetBuffer ();  	byte b1 = buffer [reference++];  	output.WriteByte (b1);  	oidx++;  	byte b2 = buffer [reference++];  	output.WriteByte (b2);  	oidx++;  	do {  		buffer = output.GetBuffer ();  		output.WriteByte (buffer [reference++]);  		oidx++;  	}  	while ((--len) != 0);  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: if (ctrl < (1 << 5))/* literal run */ {  	ctrl++;  	do {  		oidx++;  		output.WriteByte (input [iidx++]);  	}  	while ((--ctrl) != 0);  }  else/* back reference */ {  	uint len = ctrl >> 5;  	int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  	if (len == 7)  		len += input [iidx++];  	reference -= input [iidx++];  	if (reference < 0) {  		//SET_ERRNO (EINVAL);  		return 0;  	}  	byte[] buffer = output.GetBuffer ();  	byte b1 = buffer [reference++];  	output.WriteByte (b1);  	oidx++;  	byte b2 = buffer [reference++];  	output.WriteByte (b2);  	oidx++;  	do {  		buffer = output.GetBuffer ();  		output.WriteByte (buffer [reference++]);  		oidx++;  	}  	while ((--len) != 0);  }  
Magic Number,Spike.Network,LZF,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Decompress,The following statement contains a magic number: if (len == 7)  	len += input [iidx++];  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadInt64,The following statement contains a magic number: if ((Index + 8) > Size)  	return 0;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadUInt64,The following statement contains a magic number: if ((Index + 8) > Size)  	return 0;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadUInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadUInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadUInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadUInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadUInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadUInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadUInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadInt32,The following statement contains a magic number: if ((Index + 4) > Size)  	return 0;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadInt32,The following statement contains a magic number: return Data [Index++] << 24 | (Data [Index++] << 16) | (Data [Index++] << 8) | (Data [Index++]);  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadInt32,The following statement contains a magic number: return Data [Index++] << 24 | (Data [Index++] << 16) | (Data [Index++] << 8) | (Data [Index++]);  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadInt32,The following statement contains a magic number: return Data [Index++] << 24 | (Data [Index++] << 16) | (Data [Index++] << 8) | (Data [Index++]);  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadInt16,The following statement contains a magic number: if ((Index + 2) > Size)  	return 0;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadInt16,The following statement contains a magic number: return (short)((Data [Index++] << 8) | Data [Index++]);  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadUInt32,The following statement contains a magic number: if ((Index + 4) > Size)  	return 0;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadUInt32,The following statement contains a magic number: return (uint)((Data [Index++] << 24) | (Data [Index++] << 16) | (Data [Index++] << 8) | Data [Index++]);  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadUInt32,The following statement contains a magic number: return (uint)((Data [Index++] << 24) | (Data [Index++] << 16) | (Data [Index++] << 8) | Data [Index++]);  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadUInt32,The following statement contains a magic number: return (uint)((Data [Index++] << 24) | (Data [Index++] << 16) | (Data [Index++] << 8) | Data [Index++]);  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadUInt16,The following statement contains a magic number: if ((Index + 2) > Size)  	return 0;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadUInt16,The following statement contains a magic number: return (ushort)((Data [Index++] << 8) | Data [Index++]);  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadSingle,The following statement contains a magic number: Index += 4;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadDynamic,The following statement contains a magic number: if (ReadByte () == 1) {  	string stringType = "System." + ReadString ();  	Type type = Type.GetType (stringType);  	switch (SupportedTypes.Map [type]) {  	case 0:  		return ReadByte ();  	case 1:  		return ReadInt16 ();  	case 2:  		return ReadInt32 ();  	case 3:  		return ReadInt64 ();  	case 4:  		return ReadUInt16 ();  	case 5:  		return ReadUInt32 ();  	case 6:  		return ReadUInt64 ();  	case 7:  		return ReadBoolean ();  	case 8:  		return ReadSingle ();  	case 9:  		return ReadDouble ();  	case 10:  		return ReadDateTime ();  	case 11:  		return ReadString ();  	default:  		return null;  	}  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadDynamic,The following statement contains a magic number: if (ReadByte () == 1) {  	string stringType = "System." + ReadString ();  	Type type = Type.GetType (stringType);  	switch (SupportedTypes.Map [type]) {  	case 0:  		return ReadByte ();  	case 1:  		return ReadInt16 ();  	case 2:  		return ReadInt32 ();  	case 3:  		return ReadInt64 ();  	case 4:  		return ReadUInt16 ();  	case 5:  		return ReadUInt32 ();  	case 6:  		return ReadUInt64 ();  	case 7:  		return ReadBoolean ();  	case 8:  		return ReadSingle ();  	case 9:  		return ReadDouble ();  	case 10:  		return ReadDateTime ();  	case 11:  		return ReadString ();  	default:  		return null;  	}  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadDynamic,The following statement contains a magic number: if (ReadByte () == 1) {  	string stringType = "System." + ReadString ();  	Type type = Type.GetType (stringType);  	switch (SupportedTypes.Map [type]) {  	case 0:  		return ReadByte ();  	case 1:  		return ReadInt16 ();  	case 2:  		return ReadInt32 ();  	case 3:  		return ReadInt64 ();  	case 4:  		return ReadUInt16 ();  	case 5:  		return ReadUInt32 ();  	case 6:  		return ReadUInt64 ();  	case 7:  		return ReadBoolean ();  	case 8:  		return ReadSingle ();  	case 9:  		return ReadDouble ();  	case 10:  		return ReadDateTime ();  	case 11:  		return ReadString ();  	default:  		return null;  	}  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadDynamic,The following statement contains a magic number: if (ReadByte () == 1) {  	string stringType = "System." + ReadString ();  	Type type = Type.GetType (stringType);  	switch (SupportedTypes.Map [type]) {  	case 0:  		return ReadByte ();  	case 1:  		return ReadInt16 ();  	case 2:  		return ReadInt32 ();  	case 3:  		return ReadInt64 ();  	case 4:  		return ReadUInt16 ();  	case 5:  		return ReadUInt32 ();  	case 6:  		return ReadUInt64 ();  	case 7:  		return ReadBoolean ();  	case 8:  		return ReadSingle ();  	case 9:  		return ReadDouble ();  	case 10:  		return ReadDateTime ();  	case 11:  		return ReadString ();  	default:  		return null;  	}  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadDynamic,The following statement contains a magic number: if (ReadByte () == 1) {  	string stringType = "System." + ReadString ();  	Type type = Type.GetType (stringType);  	switch (SupportedTypes.Map [type]) {  	case 0:  		return ReadByte ();  	case 1:  		return ReadInt16 ();  	case 2:  		return ReadInt32 ();  	case 3:  		return ReadInt64 ();  	case 4:  		return ReadUInt16 ();  	case 5:  		return ReadUInt32 ();  	case 6:  		return ReadUInt64 ();  	case 7:  		return ReadBoolean ();  	case 8:  		return ReadSingle ();  	case 9:  		return ReadDouble ();  	case 10:  		return ReadDateTime ();  	case 11:  		return ReadString ();  	default:  		return null;  	}  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadDynamic,The following statement contains a magic number: if (ReadByte () == 1) {  	string stringType = "System." + ReadString ();  	Type type = Type.GetType (stringType);  	switch (SupportedTypes.Map [type]) {  	case 0:  		return ReadByte ();  	case 1:  		return ReadInt16 ();  	case 2:  		return ReadInt32 ();  	case 3:  		return ReadInt64 ();  	case 4:  		return ReadUInt16 ();  	case 5:  		return ReadUInt32 ();  	case 6:  		return ReadUInt64 ();  	case 7:  		return ReadBoolean ();  	case 8:  		return ReadSingle ();  	case 9:  		return ReadDouble ();  	case 10:  		return ReadDateTime ();  	case 11:  		return ReadString ();  	default:  		return null;  	}  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadDynamic,The following statement contains a magic number: if (ReadByte () == 1) {  	string stringType = "System." + ReadString ();  	Type type = Type.GetType (stringType);  	switch (SupportedTypes.Map [type]) {  	case 0:  		return ReadByte ();  	case 1:  		return ReadInt16 ();  	case 2:  		return ReadInt32 ();  	case 3:  		return ReadInt64 ();  	case 4:  		return ReadUInt16 ();  	case 5:  		return ReadUInt32 ();  	case 6:  		return ReadUInt64 ();  	case 7:  		return ReadBoolean ();  	case 8:  		return ReadSingle ();  	case 9:  		return ReadDouble ();  	case 10:  		return ReadDateTime ();  	case 11:  		return ReadString ();  	default:  		return null;  	}  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadDynamic,The following statement contains a magic number: if (ReadByte () == 1) {  	string stringType = "System." + ReadString ();  	Type type = Type.GetType (stringType);  	switch (SupportedTypes.Map [type]) {  	case 0:  		return ReadByte ();  	case 1:  		return ReadInt16 ();  	case 2:  		return ReadInt32 ();  	case 3:  		return ReadInt64 ();  	case 4:  		return ReadUInt16 ();  	case 5:  		return ReadUInt32 ();  	case 6:  		return ReadUInt64 ();  	case 7:  		return ReadBoolean ();  	case 8:  		return ReadSingle ();  	case 9:  		return ReadDouble ();  	case 10:  		return ReadDateTime ();  	case 11:  		return ReadString ();  	default:  		return null;  	}  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadDynamic,The following statement contains a magic number: if (ReadByte () == 1) {  	string stringType = "System." + ReadString ();  	Type type = Type.GetType (stringType);  	switch (SupportedTypes.Map [type]) {  	case 0:  		return ReadByte ();  	case 1:  		return ReadInt16 ();  	case 2:  		return ReadInt32 ();  	case 3:  		return ReadInt64 ();  	case 4:  		return ReadUInt16 ();  	case 5:  		return ReadUInt32 ();  	case 6:  		return ReadUInt64 ();  	case 7:  		return ReadBoolean ();  	case 8:  		return ReadSingle ();  	case 9:  		return ReadDouble ();  	case 10:  		return ReadDateTime ();  	case 11:  		return ReadString ();  	default:  		return null;  	}  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadDynamic,The following statement contains a magic number: if (ReadByte () == 1) {  	string stringType = "System." + ReadString ();  	Type type = Type.GetType (stringType);  	switch (SupportedTypes.Map [type]) {  	case 0:  		return ReadByte ();  	case 1:  		return ReadInt16 ();  	case 2:  		return ReadInt32 ();  	case 3:  		return ReadInt64 ();  	case 4:  		return ReadUInt16 ();  	case 5:  		return ReadUInt32 ();  	case 6:  		return ReadUInt64 ();  	case 7:  		return ReadBoolean ();  	case 8:  		return ReadSingle ();  	case 9:  		return ReadDouble ();  	case 10:  		return ReadDateTime ();  	case 11:  		return ReadString ();  	default:  		return null;  	}  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadDynamic,The following statement contains a magic number: switch (SupportedTypes.Map [type]) {  case 0:  	return ReadByte ();  case 1:  	return ReadInt16 ();  case 2:  	return ReadInt32 ();  case 3:  	return ReadInt64 ();  case 4:  	return ReadUInt16 ();  case 5:  	return ReadUInt32 ();  case 6:  	return ReadUInt64 ();  case 7:  	return ReadBoolean ();  case 8:  	return ReadSingle ();  case 9:  	return ReadDouble ();  case 10:  	return ReadDateTime ();  case 11:  	return ReadString ();  default:  	return null;  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadDynamic,The following statement contains a magic number: switch (SupportedTypes.Map [type]) {  case 0:  	return ReadByte ();  case 1:  	return ReadInt16 ();  case 2:  	return ReadInt32 ();  case 3:  	return ReadInt64 ();  case 4:  	return ReadUInt16 ();  case 5:  	return ReadUInt32 ();  case 6:  	return ReadUInt64 ();  case 7:  	return ReadBoolean ();  case 8:  	return ReadSingle ();  case 9:  	return ReadDouble ();  case 10:  	return ReadDateTime ();  case 11:  	return ReadString ();  default:  	return null;  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadDynamic,The following statement contains a magic number: switch (SupportedTypes.Map [type]) {  case 0:  	return ReadByte ();  case 1:  	return ReadInt16 ();  case 2:  	return ReadInt32 ();  case 3:  	return ReadInt64 ();  case 4:  	return ReadUInt16 ();  case 5:  	return ReadUInt32 ();  case 6:  	return ReadUInt64 ();  case 7:  	return ReadBoolean ();  case 8:  	return ReadSingle ();  case 9:  	return ReadDouble ();  case 10:  	return ReadDateTime ();  case 11:  	return ReadString ();  default:  	return null;  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadDynamic,The following statement contains a magic number: switch (SupportedTypes.Map [type]) {  case 0:  	return ReadByte ();  case 1:  	return ReadInt16 ();  case 2:  	return ReadInt32 ();  case 3:  	return ReadInt64 ();  case 4:  	return ReadUInt16 ();  case 5:  	return ReadUInt32 ();  case 6:  	return ReadUInt64 ();  case 7:  	return ReadBoolean ();  case 8:  	return ReadSingle ();  case 9:  	return ReadDouble ();  case 10:  	return ReadDateTime ();  case 11:  	return ReadString ();  default:  	return null;  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadDynamic,The following statement contains a magic number: switch (SupportedTypes.Map [type]) {  case 0:  	return ReadByte ();  case 1:  	return ReadInt16 ();  case 2:  	return ReadInt32 ();  case 3:  	return ReadInt64 ();  case 4:  	return ReadUInt16 ();  case 5:  	return ReadUInt32 ();  case 6:  	return ReadUInt64 ();  case 7:  	return ReadBoolean ();  case 8:  	return ReadSingle ();  case 9:  	return ReadDouble ();  case 10:  	return ReadDateTime ();  case 11:  	return ReadString ();  default:  	return null;  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadDynamic,The following statement contains a magic number: switch (SupportedTypes.Map [type]) {  case 0:  	return ReadByte ();  case 1:  	return ReadInt16 ();  case 2:  	return ReadInt32 ();  case 3:  	return ReadInt64 ();  case 4:  	return ReadUInt16 ();  case 5:  	return ReadUInt32 ();  case 6:  	return ReadUInt64 ();  case 7:  	return ReadBoolean ();  case 8:  	return ReadSingle ();  case 9:  	return ReadDouble ();  case 10:  	return ReadDateTime ();  case 11:  	return ReadString ();  default:  	return null;  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadDynamic,The following statement contains a magic number: switch (SupportedTypes.Map [type]) {  case 0:  	return ReadByte ();  case 1:  	return ReadInt16 ();  case 2:  	return ReadInt32 ();  case 3:  	return ReadInt64 ();  case 4:  	return ReadUInt16 ();  case 5:  	return ReadUInt32 ();  case 6:  	return ReadUInt64 ();  case 7:  	return ReadBoolean ();  case 8:  	return ReadSingle ();  case 9:  	return ReadDouble ();  case 10:  	return ReadDateTime ();  case 11:  	return ReadString ();  default:  	return null;  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadDynamic,The following statement contains a magic number: switch (SupportedTypes.Map [type]) {  case 0:  	return ReadByte ();  case 1:  	return ReadInt16 ();  case 2:  	return ReadInt32 ();  case 3:  	return ReadInt64 ();  case 4:  	return ReadUInt16 ();  case 5:  	return ReadUInt32 ();  case 6:  	return ReadUInt64 ();  case 7:  	return ReadBoolean ();  case 8:  	return ReadSingle ();  case 9:  	return ReadDouble ();  case 10:  	return ReadDateTime ();  case 11:  	return ReadString ();  default:  	return null;  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadDynamic,The following statement contains a magic number: switch (SupportedTypes.Map [type]) {  case 0:  	return ReadByte ();  case 1:  	return ReadInt16 ();  case 2:  	return ReadInt32 ();  case 3:  	return ReadInt64 ();  case 4:  	return ReadUInt16 ();  case 5:  	return ReadUInt32 ();  case 6:  	return ReadUInt64 ();  case 7:  	return ReadBoolean ();  case 8:  	return ReadSingle ();  case 9:  	return ReadDouble ();  case 10:  	return ReadDateTime ();  case 11:  	return ReadString ();  default:  	return null;  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,ReadDynamic,The following statement contains a magic number: switch (SupportedTypes.Map [type]) {  case 0:  	return ReadByte ();  case 1:  	return ReadInt16 ();  case 2:  	return ReadInt32 ();  case 3:  	return ReadInt64 ();  case 4:  	return ReadUInt16 ();  case 5:  	return ReadUInt32 ();  case 6:  	return ReadUInt64 ();  case 7:  	return ReadBoolean ();  case 8:  	return ReadSingle ();  case 9:  	return ReadDouble ();  case 10:  	return ReadDateTime ();  case 11:  	return ReadString ();  default:  	return null;  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,FormatBuffer,The following statement contains a magic number: for (int i = 0; i < whole; ++i' byteIndex += 16) {  	StringBuilder bytes = new StringBuilder (49);  	StringBuilder chars = new StringBuilder (16);  	for (int j = 0; j < 16; ++j) {  		int c = input.ReadByte ();  		bytes.Append (c.ToString ("X2"));  		if (j != 7) {  			bytes.Append (' ');  		}  		else {  			bytes.Append ("  ");  		}  		if (c >= 0x20 && c < 0x80) {  			chars.Append ((char)c);  		}  		else {  			chars.Append ('.');  		}  	}  	output.Write (byteIndex.ToString ("X4"));  	output.Write ("   ");  	output.Write (bytes.ToString ());  	output.Write ("  ");  	output.WriteLine (chars.ToString ());  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,FormatBuffer,The following statement contains a magic number: for (int i = 0; i < whole; ++i' byteIndex += 16) {  	StringBuilder bytes = new StringBuilder (49);  	StringBuilder chars = new StringBuilder (16);  	for (int j = 0; j < 16; ++j) {  		int c = input.ReadByte ();  		bytes.Append (c.ToString ("X2"));  		if (j != 7) {  			bytes.Append (' ');  		}  		else {  			bytes.Append ("  ");  		}  		if (c >= 0x20 && c < 0x80) {  			chars.Append ((char)c);  		}  		else {  			chars.Append ('.');  		}  	}  	output.Write (byteIndex.ToString ("X4"));  	output.Write ("   ");  	output.Write (bytes.ToString ());  	output.Write ("  ");  	output.WriteLine (chars.ToString ());  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,FormatBuffer,The following statement contains a magic number: for (int i = 0; i < whole; ++i' byteIndex += 16) {  	StringBuilder bytes = new StringBuilder (49);  	StringBuilder chars = new StringBuilder (16);  	for (int j = 0; j < 16; ++j) {  		int c = input.ReadByte ();  		bytes.Append (c.ToString ("X2"));  		if (j != 7) {  			bytes.Append (' ');  		}  		else {  			bytes.Append ("  ");  		}  		if (c >= 0x20 && c < 0x80) {  			chars.Append ((char)c);  		}  		else {  			chars.Append ('.');  		}  	}  	output.Write (byteIndex.ToString ("X4"));  	output.Write ("   ");  	output.Write (bytes.ToString ());  	output.Write ("  ");  	output.WriteLine (chars.ToString ());  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,FormatBuffer,The following statement contains a magic number: for (int i = 0; i < whole; ++i' byteIndex += 16) {  	StringBuilder bytes = new StringBuilder (49);  	StringBuilder chars = new StringBuilder (16);  	for (int j = 0; j < 16; ++j) {  		int c = input.ReadByte ();  		bytes.Append (c.ToString ("X2"));  		if (j != 7) {  			bytes.Append (' ');  		}  		else {  			bytes.Append ("  ");  		}  		if (c >= 0x20 && c < 0x80) {  			chars.Append ((char)c);  		}  		else {  			chars.Append ('.');  		}  	}  	output.Write (byteIndex.ToString ("X4"));  	output.Write ("   ");  	output.Write (bytes.ToString ());  	output.Write ("  ");  	output.WriteLine (chars.ToString ());  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,FormatBuffer,The following statement contains a magic number: for (int i = 0; i < whole; ++i' byteIndex += 16) {  	StringBuilder bytes = new StringBuilder (49);  	StringBuilder chars = new StringBuilder (16);  	for (int j = 0; j < 16; ++j) {  		int c = input.ReadByte ();  		bytes.Append (c.ToString ("X2"));  		if (j != 7) {  			bytes.Append (' ');  		}  		else {  			bytes.Append ("  ");  		}  		if (c >= 0x20 && c < 0x80) {  			chars.Append ((char)c);  		}  		else {  			chars.Append ('.');  		}  	}  	output.Write (byteIndex.ToString ("X4"));  	output.Write ("   ");  	output.Write (bytes.ToString ());  	output.Write ("  ");  	output.WriteLine (chars.ToString ());  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,FormatBuffer,The following statement contains a magic number: byteIndex += 16
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,FormatBuffer,The following statement contains a magic number: for (int j = 0; j < 16; ++j) {  	int c = input.ReadByte ();  	bytes.Append (c.ToString ("X2"));  	if (j != 7) {  		bytes.Append (' ');  	}  	else {  		bytes.Append ("  ");  	}  	if (c >= 0x20 && c < 0x80) {  		chars.Append ((char)c);  	}  	else {  		chars.Append ('.');  	}  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,FormatBuffer,The following statement contains a magic number: for (int j = 0; j < 16; ++j) {  	int c = input.ReadByte ();  	bytes.Append (c.ToString ("X2"));  	if (j != 7) {  		bytes.Append (' ');  	}  	else {  		bytes.Append ("  ");  	}  	if (c >= 0x20 && c < 0x80) {  		chars.Append ((char)c);  	}  	else {  		chars.Append ('.');  	}  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,FormatBuffer,The following statement contains a magic number: if (j != 7) {  	bytes.Append (' ');  }  else {  	bytes.Append ("  ");  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,FormatBuffer,The following statement contains a magic number: if (rem != 0) {  	StringBuilder bytes = new StringBuilder (49);  	StringBuilder chars = new StringBuilder (rem);  	for (int j = 0; j < 16; ++j) {  		if (j < rem) {  			int c = input.ReadByte ();  			bytes.Append (c.ToString ("X2"));  			if (j != 7) {  				bytes.Append (' ');  			}  			else {  				bytes.Append ("  ");  			}  			if (c >= 0x20 && c < 0x80) {  				chars.Append ((char)c);  			}  			else {  				chars.Append ('.');  			}  		}  		else {  			bytes.Append ("   ");  		}  	}  	output.Write (byteIndex.ToString ("X4"));  	output.Write ("   ");  	output.Write (bytes.ToString ());  	output.Write ("  ");  	output.WriteLine (chars.ToString ());  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,FormatBuffer,The following statement contains a magic number: if (rem != 0) {  	StringBuilder bytes = new StringBuilder (49);  	StringBuilder chars = new StringBuilder (rem);  	for (int j = 0; j < 16; ++j) {  		if (j < rem) {  			int c = input.ReadByte ();  			bytes.Append (c.ToString ("X2"));  			if (j != 7) {  				bytes.Append (' ');  			}  			else {  				bytes.Append ("  ");  			}  			if (c >= 0x20 && c < 0x80) {  				chars.Append ((char)c);  			}  			else {  				chars.Append ('.');  			}  		}  		else {  			bytes.Append ("   ");  		}  	}  	output.Write (byteIndex.ToString ("X4"));  	output.Write ("   ");  	output.Write (bytes.ToString ());  	output.Write ("  ");  	output.WriteLine (chars.ToString ());  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,FormatBuffer,The following statement contains a magic number: if (rem != 0) {  	StringBuilder bytes = new StringBuilder (49);  	StringBuilder chars = new StringBuilder (rem);  	for (int j = 0; j < 16; ++j) {  		if (j < rem) {  			int c = input.ReadByte ();  			bytes.Append (c.ToString ("X2"));  			if (j != 7) {  				bytes.Append (' ');  			}  			else {  				bytes.Append ("  ");  			}  			if (c >= 0x20 && c < 0x80) {  				chars.Append ((char)c);  			}  			else {  				chars.Append ('.');  			}  		}  		else {  			bytes.Append ("   ");  		}  	}  	output.Write (byteIndex.ToString ("X4"));  	output.Write ("   ");  	output.Write (bytes.ToString ());  	output.Write ("  ");  	output.WriteLine (chars.ToString ());  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,FormatBuffer,The following statement contains a magic number: for (int j = 0; j < 16; ++j) {  	if (j < rem) {  		int c = input.ReadByte ();  		bytes.Append (c.ToString ("X2"));  		if (j != 7) {  			bytes.Append (' ');  		}  		else {  			bytes.Append ("  ");  		}  		if (c >= 0x20 && c < 0x80) {  			chars.Append ((char)c);  		}  		else {  			chars.Append ('.');  		}  	}  	else {  		bytes.Append ("   ");  	}  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,FormatBuffer,The following statement contains a magic number: for (int j = 0; j < 16; ++j) {  	if (j < rem) {  		int c = input.ReadByte ();  		bytes.Append (c.ToString ("X2"));  		if (j != 7) {  			bytes.Append (' ');  		}  		else {  			bytes.Append ("  ");  		}  		if (c >= 0x20 && c < 0x80) {  			chars.Append ((char)c);  		}  		else {  			chars.Append ('.');  		}  	}  	else {  		bytes.Append ("   ");  	}  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,FormatBuffer,The following statement contains a magic number: if (j < rem) {  	int c = input.ReadByte ();  	bytes.Append (c.ToString ("X2"));  	if (j != 7) {  		bytes.Append (' ');  	}  	else {  		bytes.Append ("  ");  	}  	if (c >= 0x20 && c < 0x80) {  		chars.Append ((char)c);  	}  	else {  		chars.Append ('.');  	}  }  else {  	bytes.Append ("   ");  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,FormatBuffer,The following statement contains a magic number: if (j != 7) {  	bytes.Append (' ');  }  else {  	bytes.Append ("  ");  }  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [0] = (byte)(value >> 8);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: fStream.Write (m_Buffer' 0' 2);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [0] = (byte)(value >> 8);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: fStream.Write (m_Buffer' 0' 2);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [0] = (byte)(value >> 24);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [1] = (byte)(value >> 16);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [2] = (byte)(value >> 8);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [2] = (byte)(value >> 8);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [3] = (byte)value;  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: fStream.Write (m_Buffer' 0' 4);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [0] = (byte)(value >> 24);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [1] = (byte)(value >> 16);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [2] = (byte)(value >> 8);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [2] = (byte)(value >> 8);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [3] = (byte)value;  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: fStream.Write (m_Buffer' 0' 4);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [0] = (byte)(value >> 56);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [1] = (byte)(value >> 48);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [2] = (byte)(value >> 40);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [2] = (byte)(value >> 40);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [3] = (byte)(value >> 32);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [3] = (byte)(value >> 32);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [4] = (byte)(value >> 24);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [4] = (byte)(value >> 24);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [5] = (byte)(value >> 16);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [5] = (byte)(value >> 16);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [6] = (byte)(value >> 8);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [6] = (byte)(value >> 8);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [7] = (byte)value;  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: fStream.Write (m_Buffer' 0' 8);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [0] = (byte)(value >> 56);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [1] = (byte)(value >> 48);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [2] = (byte)(value >> 40);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [2] = (byte)(value >> 40);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [3] = (byte)(value >> 32);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [3] = (byte)(value >> 32);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [4] = (byte)(value >> 24);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [4] = (byte)(value >> 24);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [5] = (byte)(value >> 16);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [5] = (byte)(value >> 16);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [6] = (byte)(value >> 8);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [6] = (byte)(value >> 8);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: m_Buffer [7] = (byte)value;  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: fStream.Write (m_Buffer' 0' 8);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Write,The following statement contains a magic number: Write (BitConverter.GetBytes (value)' 0' 4);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,WriteDynamic,The following statement contains a magic number: switch (SupportedTypes.Map [type]) {  case 0:  	Write ((byte)1);  	Write (typeName);  	Write ((byte)value);  	break;  case 1:  	Write ((byte)1);  	Write (typeName);  	Write ((Int16)value);  	break;  case 2:  	Write ((byte)1);  	Write (typeName);  	Write ((Int32)value);  	break;  case 3:  	Write ((byte)1);  	Write (typeName);  	Write ((Int64)value);  	break;  case 4:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt16)value);  	break;  case 5:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt32)value);  	break;  case 6:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt64)value);  	break;  case 7:  	Write ((byte)1);  	Write (typeName);  	Write ((Boolean)value);  	break;  case 8:  	Write ((byte)1);  	Write (typeName);  	Write ((Single)value);  	break;  case 9:  	Write ((byte)1);  	Write (typeName);  	Write ((Double)value);  	break;  case 10:  	Write ((byte)1);  	Write (typeName);  	Write ((DateTime)value);  	break;  case 11:  	Write ((byte)1);  	Write (typeName);  	Write ((String)value);  	break;  default:  	// Not supported  	Write ((byte)0);  	return;  }  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,WriteDynamic,The following statement contains a magic number: switch (SupportedTypes.Map [type]) {  case 0:  	Write ((byte)1);  	Write (typeName);  	Write ((byte)value);  	break;  case 1:  	Write ((byte)1);  	Write (typeName);  	Write ((Int16)value);  	break;  case 2:  	Write ((byte)1);  	Write (typeName);  	Write ((Int32)value);  	break;  case 3:  	Write ((byte)1);  	Write (typeName);  	Write ((Int64)value);  	break;  case 4:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt16)value);  	break;  case 5:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt32)value);  	break;  case 6:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt64)value);  	break;  case 7:  	Write ((byte)1);  	Write (typeName);  	Write ((Boolean)value);  	break;  case 8:  	Write ((byte)1);  	Write (typeName);  	Write ((Single)value);  	break;  case 9:  	Write ((byte)1);  	Write (typeName);  	Write ((Double)value);  	break;  case 10:  	Write ((byte)1);  	Write (typeName);  	Write ((DateTime)value);  	break;  case 11:  	Write ((byte)1);  	Write (typeName);  	Write ((String)value);  	break;  default:  	// Not supported  	Write ((byte)0);  	return;  }  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,WriteDynamic,The following statement contains a magic number: switch (SupportedTypes.Map [type]) {  case 0:  	Write ((byte)1);  	Write (typeName);  	Write ((byte)value);  	break;  case 1:  	Write ((byte)1);  	Write (typeName);  	Write ((Int16)value);  	break;  case 2:  	Write ((byte)1);  	Write (typeName);  	Write ((Int32)value);  	break;  case 3:  	Write ((byte)1);  	Write (typeName);  	Write ((Int64)value);  	break;  case 4:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt16)value);  	break;  case 5:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt32)value);  	break;  case 6:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt64)value);  	break;  case 7:  	Write ((byte)1);  	Write (typeName);  	Write ((Boolean)value);  	break;  case 8:  	Write ((byte)1);  	Write (typeName);  	Write ((Single)value);  	break;  case 9:  	Write ((byte)1);  	Write (typeName);  	Write ((Double)value);  	break;  case 10:  	Write ((byte)1);  	Write (typeName);  	Write ((DateTime)value);  	break;  case 11:  	Write ((byte)1);  	Write (typeName);  	Write ((String)value);  	break;  default:  	// Not supported  	Write ((byte)0);  	return;  }  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,WriteDynamic,The following statement contains a magic number: switch (SupportedTypes.Map [type]) {  case 0:  	Write ((byte)1);  	Write (typeName);  	Write ((byte)value);  	break;  case 1:  	Write ((byte)1);  	Write (typeName);  	Write ((Int16)value);  	break;  case 2:  	Write ((byte)1);  	Write (typeName);  	Write ((Int32)value);  	break;  case 3:  	Write ((byte)1);  	Write (typeName);  	Write ((Int64)value);  	break;  case 4:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt16)value);  	break;  case 5:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt32)value);  	break;  case 6:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt64)value);  	break;  case 7:  	Write ((byte)1);  	Write (typeName);  	Write ((Boolean)value);  	break;  case 8:  	Write ((byte)1);  	Write (typeName);  	Write ((Single)value);  	break;  case 9:  	Write ((byte)1);  	Write (typeName);  	Write ((Double)value);  	break;  case 10:  	Write ((byte)1);  	Write (typeName);  	Write ((DateTime)value);  	break;  case 11:  	Write ((byte)1);  	Write (typeName);  	Write ((String)value);  	break;  default:  	// Not supported  	Write ((byte)0);  	return;  }  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,WriteDynamic,The following statement contains a magic number: switch (SupportedTypes.Map [type]) {  case 0:  	Write ((byte)1);  	Write (typeName);  	Write ((byte)value);  	break;  case 1:  	Write ((byte)1);  	Write (typeName);  	Write ((Int16)value);  	break;  case 2:  	Write ((byte)1);  	Write (typeName);  	Write ((Int32)value);  	break;  case 3:  	Write ((byte)1);  	Write (typeName);  	Write ((Int64)value);  	break;  case 4:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt16)value);  	break;  case 5:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt32)value);  	break;  case 6:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt64)value);  	break;  case 7:  	Write ((byte)1);  	Write (typeName);  	Write ((Boolean)value);  	break;  case 8:  	Write ((byte)1);  	Write (typeName);  	Write ((Single)value);  	break;  case 9:  	Write ((byte)1);  	Write (typeName);  	Write ((Double)value);  	break;  case 10:  	Write ((byte)1);  	Write (typeName);  	Write ((DateTime)value);  	break;  case 11:  	Write ((byte)1);  	Write (typeName);  	Write ((String)value);  	break;  default:  	// Not supported  	Write ((byte)0);  	return;  }  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,WriteDynamic,The following statement contains a magic number: switch (SupportedTypes.Map [type]) {  case 0:  	Write ((byte)1);  	Write (typeName);  	Write ((byte)value);  	break;  case 1:  	Write ((byte)1);  	Write (typeName);  	Write ((Int16)value);  	break;  case 2:  	Write ((byte)1);  	Write (typeName);  	Write ((Int32)value);  	break;  case 3:  	Write ((byte)1);  	Write (typeName);  	Write ((Int64)value);  	break;  case 4:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt16)value);  	break;  case 5:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt32)value);  	break;  case 6:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt64)value);  	break;  case 7:  	Write ((byte)1);  	Write (typeName);  	Write ((Boolean)value);  	break;  case 8:  	Write ((byte)1);  	Write (typeName);  	Write ((Single)value);  	break;  case 9:  	Write ((byte)1);  	Write (typeName);  	Write ((Double)value);  	break;  case 10:  	Write ((byte)1);  	Write (typeName);  	Write ((DateTime)value);  	break;  case 11:  	Write ((byte)1);  	Write (typeName);  	Write ((String)value);  	break;  default:  	// Not supported  	Write ((byte)0);  	return;  }  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,WriteDynamic,The following statement contains a magic number: switch (SupportedTypes.Map [type]) {  case 0:  	Write ((byte)1);  	Write (typeName);  	Write ((byte)value);  	break;  case 1:  	Write ((byte)1);  	Write (typeName);  	Write ((Int16)value);  	break;  case 2:  	Write ((byte)1);  	Write (typeName);  	Write ((Int32)value);  	break;  case 3:  	Write ((byte)1);  	Write (typeName);  	Write ((Int64)value);  	break;  case 4:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt16)value);  	break;  case 5:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt32)value);  	break;  case 6:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt64)value);  	break;  case 7:  	Write ((byte)1);  	Write (typeName);  	Write ((Boolean)value);  	break;  case 8:  	Write ((byte)1);  	Write (typeName);  	Write ((Single)value);  	break;  case 9:  	Write ((byte)1);  	Write (typeName);  	Write ((Double)value);  	break;  case 10:  	Write ((byte)1);  	Write (typeName);  	Write ((DateTime)value);  	break;  case 11:  	Write ((byte)1);  	Write (typeName);  	Write ((String)value);  	break;  default:  	// Not supported  	Write ((byte)0);  	return;  }  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,WriteDynamic,The following statement contains a magic number: switch (SupportedTypes.Map [type]) {  case 0:  	Write ((byte)1);  	Write (typeName);  	Write ((byte)value);  	break;  case 1:  	Write ((byte)1);  	Write (typeName);  	Write ((Int16)value);  	break;  case 2:  	Write ((byte)1);  	Write (typeName);  	Write ((Int32)value);  	break;  case 3:  	Write ((byte)1);  	Write (typeName);  	Write ((Int64)value);  	break;  case 4:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt16)value);  	break;  case 5:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt32)value);  	break;  case 6:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt64)value);  	break;  case 7:  	Write ((byte)1);  	Write (typeName);  	Write ((Boolean)value);  	break;  case 8:  	Write ((byte)1);  	Write (typeName);  	Write ((Single)value);  	break;  case 9:  	Write ((byte)1);  	Write (typeName);  	Write ((Double)value);  	break;  case 10:  	Write ((byte)1);  	Write (typeName);  	Write ((DateTime)value);  	break;  case 11:  	Write ((byte)1);  	Write (typeName);  	Write ((String)value);  	break;  default:  	// Not supported  	Write ((byte)0);  	return;  }  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,WriteDynamic,The following statement contains a magic number: switch (SupportedTypes.Map [type]) {  case 0:  	Write ((byte)1);  	Write (typeName);  	Write ((byte)value);  	break;  case 1:  	Write ((byte)1);  	Write (typeName);  	Write ((Int16)value);  	break;  case 2:  	Write ((byte)1);  	Write (typeName);  	Write ((Int32)value);  	break;  case 3:  	Write ((byte)1);  	Write (typeName);  	Write ((Int64)value);  	break;  case 4:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt16)value);  	break;  case 5:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt32)value);  	break;  case 6:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt64)value);  	break;  case 7:  	Write ((byte)1);  	Write (typeName);  	Write ((Boolean)value);  	break;  case 8:  	Write ((byte)1);  	Write (typeName);  	Write ((Single)value);  	break;  case 9:  	Write ((byte)1);  	Write (typeName);  	Write ((Double)value);  	break;  case 10:  	Write ((byte)1);  	Write (typeName);  	Write ((DateTime)value);  	break;  case 11:  	Write ((byte)1);  	Write (typeName);  	Write ((String)value);  	break;  default:  	// Not supported  	Write ((byte)0);  	return;  }  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,WriteDynamic,The following statement contains a magic number: switch (SupportedTypes.Map [type]) {  case 0:  	Write ((byte)1);  	Write (typeName);  	Write ((byte)value);  	break;  case 1:  	Write ((byte)1);  	Write (typeName);  	Write ((Int16)value);  	break;  case 2:  	Write ((byte)1);  	Write (typeName);  	Write ((Int32)value);  	break;  case 3:  	Write ((byte)1);  	Write (typeName);  	Write ((Int64)value);  	break;  case 4:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt16)value);  	break;  case 5:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt32)value);  	break;  case 6:  	Write ((byte)1);  	Write (typeName);  	Write ((UInt64)value);  	break;  case 7:  	Write ((byte)1);  	Write (typeName);  	Write ((Boolean)value);  	break;  case 8:  	Write ((byte)1);  	Write (typeName);  	Write ((Single)value);  	break;  case 9:  	Write ((byte)1);  	Write (typeName);  	Write ((Double)value);  	break;  case 10:  	Write ((byte)1);  	Write (typeName);  	Write ((DateTime)value);  	break;  case 11:  	Write ((byte)1);  	Write (typeName);  	Write ((String)value);  	break;  default:  	// Not supported  	Write ((byte)0);  	return;  }  
Magic Number,Spike.Network,SupportedTypes,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,SupportedTypes,The following statement contains a magic number: Map.Add (typeof(Int32)' 2);  
Magic Number,Spike.Network,SupportedTypes,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,SupportedTypes,The following statement contains a magic number: Map.Add (typeof(Int64)' 3);  
Magic Number,Spike.Network,SupportedTypes,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,SupportedTypes,The following statement contains a magic number: Map.Add (typeof(UInt16)' 4);  
Magic Number,Spike.Network,SupportedTypes,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,SupportedTypes,The following statement contains a magic number: Map.Add (typeof(UInt32)' 5);  
Magic Number,Spike.Network,SupportedTypes,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,SupportedTypes,The following statement contains a magic number: Map.Add (typeof(UInt64)' 6);  
Magic Number,Spike.Network,SupportedTypes,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,SupportedTypes,The following statement contains a magic number: Map.Add (typeof(Boolean)' 7);  
Magic Number,Spike.Network,SupportedTypes,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,SupportedTypes,The following statement contains a magic number: Map.Add (typeof(Single)' 8);  
Magic Number,Spike.Network,SupportedTypes,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,SupportedTypes,The following statement contains a magic number: Map.Add (typeof(Double)' 9);  
Magic Number,Spike.Network,SupportedTypes,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,SupportedTypes,The following statement contains a magic number: Map.Add (typeof(DateTime)' 10);  
Magic Number,Spike.Network,SupportedTypes,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,SupportedTypes,The following statement contains a magic number: Map.Add (typeof(String)' 11);  
Missing Default,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Seek,The following switch statement is missing a default case: switch (origin) {  case SeekOrigin.Begin:  	Index = offset;  	break;  case SeekOrigin.Current:  	Index += offset;  	break;  case SeekOrigin.End:  	Index = Size - offset;  	break;  }  
Missing Default,Spike.Network,OperationReader,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,Read,The following switch statement is missing a default case: switch (operationKey) {  case "01562224":  	CheckInform packet01562224 = new CheckInform ();  	packet01562224.Read (reader);  	return packet01562224;  case "26792C94":  	PingInform packet26792C94 = new PingInform ();  	packet26792C94.Read (reader);  	return packet26792C94;  case "33E7FBD1":  	GetServerTimeInform packet33E7FBD1 = new GetServerTimeInform ();  	packet33E7FBD1.Read (reader);  	return packet33E7FBD1;  case "3E05ECEE":  	GetInform packet3E05ECEE = new GetInform ();  	packet3E05ECEE.Read (reader);  	return packet3E05ECEE;  case "4AC51818":  	RevokeCredentialsInform packet4AC51818 = new RevokeCredentialsInform ();  	packet4AC51818.Read (reader);  	return packet4AC51818;  case "8D98E9FC":  	SupplyCredentialsInform packet8D98E9FC = new SupplyCredentialsInform ();  	packet8D98E9FC.Read (reader);  	return packet8D98E9FC;  case "B22E7270":  	GetAllInform packetB22E7270 = new GetAllInform ();  	packetB22E7270.Read (reader);  	return packetB22E7270;  case "BA220D80":  	EventInform packetBA220D80 = new EventInform ();  	packetBA220D80.Read (reader);  	return packetBA220D80;  }  
Missing Default,Spike.Network,TcpChannel,C:\repos\Kelindar_spike-bench\Stress.Client\spike-sdk.csharp.src.cs,OnReceive,The following switch statement is missing a default case: switch (e.Operation) {  case "01562224":  	if ((fDispatchInformOnlyOnRequest && fRequestedCheckInform > 0) || !fDispatchInformOnlyOnRequest) {  		// Mask the request as terminated and dispatch the event  		fRequestedCheckInform--;  		OnCheckInform (e.Packet as CheckInform);  	}  	return;  case "26792C94":  	if ((fDispatchInformOnlyOnRequest && fRequestedPingInform > 0) || !fDispatchInformOnlyOnRequest) {  		// Mask the request as terminated and dispatch the event  		fRequestedPingInform--;  		OnPingInform (e.Packet as PingInform);  	}  	return;  case "33E7FBD1":  	if ((fDispatchInformOnlyOnRequest && fRequestedGetServerTimeInform > 0) || !fDispatchInformOnlyOnRequest) {  		// Mask the request as terminated and dispatch the event  		fRequestedGetServerTimeInform--;  		OnGetServerTimeInform (e.Packet as GetServerTimeInform);  	}  	return;  case "3E05ECEE":  	if ((fDispatchInformOnlyOnRequest && fRequestedGetInform > 0) || !fDispatchInformOnlyOnRequest) {  		// Mask the request as terminated and dispatch the event  		fRequestedGetInform--;  		OnGetInform (e.Packet as GetInform);  	}  	return;  case "4AC51818":  	if ((fDispatchInformOnlyOnRequest && fRequestedRevokeCredentialsInform > 0) || !fDispatchInformOnlyOnRequest) {  		// Mask the request as terminated and dispatch the event  		fRequestedRevokeCredentialsInform--;  		OnRevokeCredentialsInform (e.Packet as RevokeCredentialsInform);  	}  	return;  case "8D98E9FC":  	if ((fDispatchInformOnlyOnRequest && fRequestedSupplyCredentialsInform > 0) || !fDispatchInformOnlyOnRequest) {  		// Mask the request as terminated and dispatch the event  		fRequestedSupplyCredentialsInform--;  		OnSupplyCredentialsInform (e.Packet as SupplyCredentialsInform);  	}  	return;  case "B22E7270":  	if ((fDispatchInformOnlyOnRequest && fRequestedGetAllInform > 0) || !fDispatchInformOnlyOnRequest) {  		// Mask the request as terminated and dispatch the event  		fRequestedGetAllInform--;  		OnGetAllInform (e.Packet as GetAllInform);  	}  	return;  case "BA220D80":  	OnEventInform (e.Packet as EventInform);  	return;  }  
