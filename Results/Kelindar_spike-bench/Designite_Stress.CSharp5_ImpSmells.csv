Implementation smell,Namespace,Class,File,Method,Description
Long Method,Spike.Network,TcpChannel,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\TcpChannel.cs,OnReceive,The method has 120 lines of code.
Complex Method,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,Cyclomatic complexity of the method is 18
Complex Method,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_decompress,Cyclomatic complexity of the method is 11
Complex Method,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadDynamicType,Cyclomatic complexity of the method is 13
Complex Method,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Write,Cyclomatic complexity of the method is 13
Complex Method,Spike.Network,TcpChannel,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\TcpChannel.cs,OnReceive,Cyclomatic complexity of the method is 38
Long Parameter List,Spike.Network,TcpChannel,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\TcpChannel.cs,SupplyCredentials,The method has 5 parameters.
Long Parameter List,Spike.Network,TcpChannelBase,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\TcpChannelBase.cs,Connect,The method has 6 parameters.
Long Parameter List,Stress.CSharp5,Program,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Program.cs,Main,The method has 12 parameters.
Long Statement,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The length of the statement  "			if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) { " is 230.
Long Statement,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,Begin,The length of the statement  "		var uncompressedSize = packer.lzf_decompress (compressedBuffer' compressedBuffer.Length' uncompressedBuffer' uncompressedBuffer.Length); " is 136.
Long Statement,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadUInt32,The length of the statement  "	return (uint)(this.Buffer [this.Offset++] << 24 | (this.Buffer [this.Offset++] << 16) | (this.Buffer [this.Offset++] << 8) | (this.Buffer [this.Offset++])); " is 156.
Long Statement,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadInt32,The length of the statement  "	return this.Buffer [this.Offset++] << 24 | (this.Buffer [this.Offset++] << 16) | (this.Buffer [this.Offset++] << 8) | (this.Buffer [this.Offset++]); " is 148.
Long Statement,Spike.Network,TcpChannelBase,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\TcpChannelBase.cs,Connect,The length of the statement  "			var sslStream = new SslStream (new NetworkStream (this.TcpSocket)' false' (sender' certificate' chain' sslPolicyErrors) => true); " is 129.
Complex Conditional,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The conditional expression  "(off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]"  is complex.
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,crc32,The following statement contains a magic number: return crc_32_tab [(OldCRC & 0xff) ^ NewData] ^ (OldCRC >> 8);  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,FRST,The following statement contains a magic number: return (UInt32)(((Array [ptr]) << 8) | Array [ptr + 1]);  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,NEXT,The following statement contains a magic number: return ((v) << 8) | Array [ptr + 2];  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,NEXT,The following statement contains a magic number: return ((v) << 8) | Array [ptr + 2];  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,IDX,The following statement contains a magic number: return ((h ^ (h << 5)) >> (int)(((3 * 8 - HLOG)) - h * 5) & (HSIZE - 1));  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,IDX,The following statement contains a magic number: return ((h ^ (h << 5)) >> (int)(((3 * 8 - HLOG)) - h * 5) & (HSIZE - 1));  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,IDX,The following statement contains a magic number: return ((h ^ (h << 5)) >> (int)(((3 * 8 - HLOG)) - h * 5) & (HSIZE - 1));  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,IDX,The following statement contains a magic number: return ((h ^ (h << 5)) >> (int)(((3 * 8 - HLOG)) - h * 5) & (HSIZE - 1));  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: for (c = 0; c < 1 << 14; c++) {  	htab [c] = 0;  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < in_len - 2) {  		hval = NEXT (hval' in_data' iidx);  		hslot = IDX (hval);  		reference = htab [hslot];  		htab [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  			/* match found at *reference++ */UInt32 len = 2;  			UInt32 maxlen = (UInt32)in_len - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= out_len)  				return 0;  			do  				len++;  			while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  			if (lit != 0) {  				out_data [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					out_data [oidx++] = in_data [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				out_data [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  				out_data [oidx++] = (byte)(len - 7);  			}  			out_data [oidx++] = (byte)off;  			iidx += len - 1;  			hval = FRST (in_data' iidx);  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == in_len)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= out_len)  			return 0;  		out_data [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < in_len - 2) {  		hval = NEXT (hval' in_data' iidx);  		hslot = IDX (hval);  		reference = htab [hslot];  		htab [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  			/* match found at *reference++ */UInt32 len = 2;  			UInt32 maxlen = (UInt32)in_len - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= out_len)  				return 0;  			do  				len++;  			while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  			if (lit != 0) {  				out_data [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					out_data [oidx++] = in_data [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				out_data [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  				out_data [oidx++] = (byte)(len - 7);  			}  			out_data [oidx++] = (byte)off;  			iidx += len - 1;  			hval = FRST (in_data' iidx);  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == in_len)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= out_len)  			return 0;  		out_data [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < in_len - 2) {  		hval = NEXT (hval' in_data' iidx);  		hslot = IDX (hval);  		reference = htab [hslot];  		htab [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  			/* match found at *reference++ */UInt32 len = 2;  			UInt32 maxlen = (UInt32)in_len - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= out_len)  				return 0;  			do  				len++;  			while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  			if (lit != 0) {  				out_data [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					out_data [oidx++] = in_data [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				out_data [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  				out_data [oidx++] = (byte)(len - 7);  			}  			out_data [oidx++] = (byte)off;  			iidx += len - 1;  			hval = FRST (in_data' iidx);  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == in_len)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= out_len)  			return 0;  		out_data [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < in_len - 2) {  		hval = NEXT (hval' in_data' iidx);  		hslot = IDX (hval);  		reference = htab [hslot];  		htab [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  			/* match found at *reference++ */UInt32 len = 2;  			UInt32 maxlen = (UInt32)in_len - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= out_len)  				return 0;  			do  				len++;  			while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  			if (lit != 0) {  				out_data [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					out_data [oidx++] = in_data [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				out_data [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  				out_data [oidx++] = (byte)(len - 7);  			}  			out_data [oidx++] = (byte)off;  			iidx += len - 1;  			hval = FRST (in_data' iidx);  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == in_len)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= out_len)  			return 0;  		out_data [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < in_len - 2) {  		hval = NEXT (hval' in_data' iidx);  		hslot = IDX (hval);  		reference = htab [hslot];  		htab [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  			/* match found at *reference++ */UInt32 len = 2;  			UInt32 maxlen = (UInt32)in_len - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= out_len)  				return 0;  			do  				len++;  			while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  			if (lit != 0) {  				out_data [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					out_data [oidx++] = in_data [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				out_data [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  				out_data [oidx++] = (byte)(len - 7);  			}  			out_data [oidx++] = (byte)off;  			iidx += len - 1;  			hval = FRST (in_data' iidx);  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == in_len)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= out_len)  			return 0;  		out_data [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < in_len - 2) {  		hval = NEXT (hval' in_data' iidx);  		hslot = IDX (hval);  		reference = htab [hslot];  		htab [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  			/* match found at *reference++ */UInt32 len = 2;  			UInt32 maxlen = (UInt32)in_len - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= out_len)  				return 0;  			do  				len++;  			while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  			if (lit != 0) {  				out_data [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					out_data [oidx++] = in_data [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				out_data [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  				out_data [oidx++] = (byte)(len - 7);  			}  			out_data [oidx++] = (byte)off;  			iidx += len - 1;  			hval = FRST (in_data' iidx);  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == in_len)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= out_len)  			return 0;  		out_data [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < in_len - 2) {  		hval = NEXT (hval' in_data' iidx);  		hslot = IDX (hval);  		reference = htab [hslot];  		htab [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  			/* match found at *reference++ */UInt32 len = 2;  			UInt32 maxlen = (UInt32)in_len - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= out_len)  				return 0;  			do  				len++;  			while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  			if (lit != 0) {  				out_data [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					out_data [oidx++] = in_data [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				out_data [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  				out_data [oidx++] = (byte)(len - 7);  			}  			out_data [oidx++] = (byte)off;  			iidx += len - 1;  			hval = FRST (in_data' iidx);  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == in_len)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= out_len)  			return 0;  		out_data [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < in_len - 2) {  		hval = NEXT (hval' in_data' iidx);  		hslot = IDX (hval);  		reference = htab [hslot];  		htab [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  			/* match found at *reference++ */UInt32 len = 2;  			UInt32 maxlen = (UInt32)in_len - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= out_len)  				return 0;  			do  				len++;  			while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  			if (lit != 0) {  				out_data [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					out_data [oidx++] = in_data [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				out_data [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  				out_data [oidx++] = (byte)(len - 7);  			}  			out_data [oidx++] = (byte)off;  			iidx += len - 1;  			hval = FRST (in_data' iidx);  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == in_len)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= out_len)  			return 0;  		out_data [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < in_len - 2) {  		hval = NEXT (hval' in_data' iidx);  		hslot = IDX (hval);  		reference = htab [hslot];  		htab [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  			/* match found at *reference++ */UInt32 len = 2;  			UInt32 maxlen = (UInt32)in_len - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= out_len)  				return 0;  			do  				len++;  			while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  			if (lit != 0) {  				out_data [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					out_data [oidx++] = in_data [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				out_data [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  				out_data [oidx++] = (byte)(len - 7);  			}  			out_data [oidx++] = (byte)off;  			iidx += len - 1;  			hval = FRST (in_data' iidx);  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == in_len)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= out_len)  			return 0;  		out_data [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < in_len - 2) {  		hval = NEXT (hval' in_data' iidx);  		hslot = IDX (hval);  		reference = htab [hslot];  		htab [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  			/* match found at *reference++ */UInt32 len = 2;  			UInt32 maxlen = (UInt32)in_len - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= out_len)  				return 0;  			do  				len++;  			while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  			if (lit != 0) {  				out_data [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					out_data [oidx++] = in_data [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				out_data [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  				out_data [oidx++] = (byte)(len - 7);  			}  			out_data [oidx++] = (byte)off;  			iidx += len - 1;  			hval = FRST (in_data' iidx);  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == in_len)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= out_len)  			return 0;  		out_data [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < in_len - 2) {  		hval = NEXT (hval' in_data' iidx);  		hslot = IDX (hval);  		reference = htab [hslot];  		htab [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  			/* match found at *reference++ */UInt32 len = 2;  			UInt32 maxlen = (UInt32)in_len - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= out_len)  				return 0;  			do  				len++;  			while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  			if (lit != 0) {  				out_data [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					out_data [oidx++] = in_data [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				out_data [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  				out_data [oidx++] = (byte)(len - 7);  			}  			out_data [oidx++] = (byte)off;  			iidx += len - 1;  			hval = FRST (in_data' iidx);  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == in_len)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= out_len)  			return 0;  		out_data [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < in_len - 2) {  		hval = NEXT (hval' in_data' iidx);  		hslot = IDX (hval);  		reference = htab [hslot];  		htab [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  			/* match found at *reference++ */UInt32 len = 2;  			UInt32 maxlen = (UInt32)in_len - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= out_len)  				return 0;  			do  				len++;  			while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  			if (lit != 0) {  				out_data [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					out_data [oidx++] = in_data [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				out_data [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  				out_data [oidx++] = (byte)(len - 7);  			}  			out_data [oidx++] = (byte)off;  			iidx += len - 1;  			hval = FRST (in_data' iidx);  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == in_len)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= out_len)  			return 0;  		out_data [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < in_len - 2) {  		hval = NEXT (hval' in_data' iidx);  		hslot = IDX (hval);  		reference = htab [hslot];  		htab [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  			/* match found at *reference++ */UInt32 len = 2;  			UInt32 maxlen = (UInt32)in_len - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= out_len)  				return 0;  			do  				len++;  			while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  			if (lit != 0) {  				out_data [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					out_data [oidx++] = in_data [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				out_data [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  				out_data [oidx++] = (byte)(len - 7);  			}  			out_data [oidx++] = (byte)off;  			iidx += len - 1;  			hval = FRST (in_data' iidx);  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == in_len)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= out_len)  			return 0;  		out_data [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < in_len - 2) {  		hval = NEXT (hval' in_data' iidx);  		hslot = IDX (hval);  		reference = htab [hslot];  		htab [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  			/* match found at *reference++ */UInt32 len = 2;  			UInt32 maxlen = (UInt32)in_len - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= out_len)  				return 0;  			do  				len++;  			while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  			if (lit != 0) {  				out_data [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					out_data [oidx++] = in_data [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				out_data [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  				out_data [oidx++] = (byte)(len - 7);  			}  			out_data [oidx++] = (byte)off;  			iidx += len - 1;  			hval = FRST (in_data' iidx);  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			hval = NEXT (hval' in_data' iidx);  			htab [IDX (hval)] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == in_len)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= out_len)  			return 0;  		out_data [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if (iidx < in_len - 2) {  	hval = NEXT (hval' in_data' iidx);  	hslot = IDX (hval);  	reference = htab [hslot];  	htab [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  		/* match found at *reference++ */UInt32 len = 2;  		UInt32 maxlen = (UInt32)in_len - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= out_len)  			return 0;  		do  			len++;  		while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  		if (lit != 0) {  			out_data [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				out_data [oidx++] = in_data [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			out_data [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  			out_data [oidx++] = (byte)(len - 7);  		}  		out_data [oidx++] = (byte)off;  		iidx += len - 1;  		hval = FRST (in_data' iidx);  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == in_len)  	break;  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if (iidx < in_len - 2) {  	hval = NEXT (hval' in_data' iidx);  	hslot = IDX (hval);  	reference = htab [hslot];  	htab [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  		/* match found at *reference++ */UInt32 len = 2;  		UInt32 maxlen = (UInt32)in_len - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= out_len)  			return 0;  		do  			len++;  		while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  		if (lit != 0) {  			out_data [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				out_data [oidx++] = in_data [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			out_data [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  			out_data [oidx++] = (byte)(len - 7);  		}  		out_data [oidx++] = (byte)off;  		iidx += len - 1;  		hval = FRST (in_data' iidx);  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == in_len)  	break;  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if (iidx < in_len - 2) {  	hval = NEXT (hval' in_data' iidx);  	hslot = IDX (hval);  	reference = htab [hslot];  	htab [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  		/* match found at *reference++ */UInt32 len = 2;  		UInt32 maxlen = (UInt32)in_len - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= out_len)  			return 0;  		do  			len++;  		while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  		if (lit != 0) {  			out_data [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				out_data [oidx++] = in_data [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			out_data [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  			out_data [oidx++] = (byte)(len - 7);  		}  		out_data [oidx++] = (byte)off;  		iidx += len - 1;  		hval = FRST (in_data' iidx);  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == in_len)  	break;  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if (iidx < in_len - 2) {  	hval = NEXT (hval' in_data' iidx);  	hslot = IDX (hval);  	reference = htab [hslot];  	htab [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  		/* match found at *reference++ */UInt32 len = 2;  		UInt32 maxlen = (UInt32)in_len - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= out_len)  			return 0;  		do  			len++;  		while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  		if (lit != 0) {  			out_data [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				out_data [oidx++] = in_data [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			out_data [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  			out_data [oidx++] = (byte)(len - 7);  		}  		out_data [oidx++] = (byte)off;  		iidx += len - 1;  		hval = FRST (in_data' iidx);  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == in_len)  	break;  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if (iidx < in_len - 2) {  	hval = NEXT (hval' in_data' iidx);  	hslot = IDX (hval);  	reference = htab [hslot];  	htab [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  		/* match found at *reference++ */UInt32 len = 2;  		UInt32 maxlen = (UInt32)in_len - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= out_len)  			return 0;  		do  			len++;  		while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  		if (lit != 0) {  			out_data [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				out_data [oidx++] = in_data [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			out_data [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  			out_data [oidx++] = (byte)(len - 7);  		}  		out_data [oidx++] = (byte)off;  		iidx += len - 1;  		hval = FRST (in_data' iidx);  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == in_len)  	break;  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if (iidx < in_len - 2) {  	hval = NEXT (hval' in_data' iidx);  	hslot = IDX (hval);  	reference = htab [hslot];  	htab [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  		/* match found at *reference++ */UInt32 len = 2;  		UInt32 maxlen = (UInt32)in_len - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= out_len)  			return 0;  		do  			len++;  		while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  		if (lit != 0) {  			out_data [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				out_data [oidx++] = in_data [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			out_data [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  			out_data [oidx++] = (byte)(len - 7);  		}  		out_data [oidx++] = (byte)off;  		iidx += len - 1;  		hval = FRST (in_data' iidx);  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == in_len)  	break;  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if (iidx < in_len - 2) {  	hval = NEXT (hval' in_data' iidx);  	hslot = IDX (hval);  	reference = htab [hslot];  	htab [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  		/* match found at *reference++ */UInt32 len = 2;  		UInt32 maxlen = (UInt32)in_len - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= out_len)  			return 0;  		do  			len++;  		while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  		if (lit != 0) {  			out_data [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				out_data [oidx++] = in_data [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			out_data [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  			out_data [oidx++] = (byte)(len - 7);  		}  		out_data [oidx++] = (byte)off;  		iidx += len - 1;  		hval = FRST (in_data' iidx);  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == in_len)  	break;  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if (iidx < in_len - 2) {  	hval = NEXT (hval' in_data' iidx);  	hslot = IDX (hval);  	reference = htab [hslot];  	htab [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  		/* match found at *reference++ */UInt32 len = 2;  		UInt32 maxlen = (UInt32)in_len - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= out_len)  			return 0;  		do  			len++;  		while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  		if (lit != 0) {  			out_data [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				out_data [oidx++] = in_data [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			out_data [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  			out_data [oidx++] = (byte)(len - 7);  		}  		out_data [oidx++] = (byte)off;  		iidx += len - 1;  		hval = FRST (in_data' iidx);  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == in_len)  	break;  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if (iidx < in_len - 2) {  	hval = NEXT (hval' in_data' iidx);  	hslot = IDX (hval);  	reference = htab [hslot];  	htab [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  		/* match found at *reference++ */UInt32 len = 2;  		UInt32 maxlen = (UInt32)in_len - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= out_len)  			return 0;  		do  			len++;  		while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  		if (lit != 0) {  			out_data [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				out_data [oidx++] = in_data [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			out_data [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  			out_data [oidx++] = (byte)(len - 7);  		}  		out_data [oidx++] = (byte)off;  		iidx += len - 1;  		hval = FRST (in_data' iidx);  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == in_len)  	break;  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if (iidx < in_len - 2) {  	hval = NEXT (hval' in_data' iidx);  	hslot = IDX (hval);  	reference = htab [hslot];  	htab [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  		/* match found at *reference++ */UInt32 len = 2;  		UInt32 maxlen = (UInt32)in_len - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= out_len)  			return 0;  		do  			len++;  		while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  		if (lit != 0) {  			out_data [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				out_data [oidx++] = in_data [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			out_data [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  			out_data [oidx++] = (byte)(len - 7);  		}  		out_data [oidx++] = (byte)off;  		iidx += len - 1;  		hval = FRST (in_data' iidx);  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == in_len)  	break;  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if (iidx < in_len - 2) {  	hval = NEXT (hval' in_data' iidx);  	hslot = IDX (hval);  	reference = htab [hslot];  	htab [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  		/* match found at *reference++ */UInt32 len = 2;  		UInt32 maxlen = (UInt32)in_len - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= out_len)  			return 0;  		do  			len++;  		while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  		if (lit != 0) {  			out_data [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				out_data [oidx++] = in_data [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			out_data [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  			out_data [oidx++] = (byte)(len - 7);  		}  		out_data [oidx++] = (byte)off;  		iidx += len - 1;  		hval = FRST (in_data' iidx);  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == in_len)  	break;  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if (iidx < in_len - 2) {  	hval = NEXT (hval' in_data' iidx);  	hslot = IDX (hval);  	reference = htab [hslot];  	htab [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  		/* match found at *reference++ */UInt32 len = 2;  		UInt32 maxlen = (UInt32)in_len - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= out_len)  			return 0;  		do  			len++;  		while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  		if (lit != 0) {  			out_data [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				out_data [oidx++] = in_data [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			out_data [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  			out_data [oidx++] = (byte)(len - 7);  		}  		out_data [oidx++] = (byte)off;  		iidx += len - 1;  		hval = FRST (in_data' iidx);  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == in_len)  	break;  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if (iidx < in_len - 2) {  	hval = NEXT (hval' in_data' iidx);  	hslot = IDX (hval);  	reference = htab [hslot];  	htab [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  		/* match found at *reference++ */UInt32 len = 2;  		UInt32 maxlen = (UInt32)in_len - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= out_len)  			return 0;  		do  			len++;  		while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  		if (lit != 0) {  			out_data [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				out_data [oidx++] = in_data [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			out_data [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  			out_data [oidx++] = (byte)(len - 7);  		}  		out_data [oidx++] = (byte)off;  		iidx += len - 1;  		hval = FRST (in_data' iidx);  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == in_len)  	break;  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if (iidx < in_len - 2) {  	hval = NEXT (hval' in_data' iidx);  	hslot = IDX (hval);  	reference = htab [hslot];  	htab [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  		/* match found at *reference++ */UInt32 len = 2;  		UInt32 maxlen = (UInt32)in_len - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= out_len)  			return 0;  		do  			len++;  		while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  		if (lit != 0) {  			out_data [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				out_data [oidx++] = in_data [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			out_data [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  			out_data [oidx++] = (byte)(len - 7);  		}  		out_data [oidx++] = (byte)off;  		iidx += len - 1;  		hval = FRST (in_data' iidx);  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		hval = NEXT (hval' in_data' iidx);  		htab [IDX (hval)] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == in_len)  	break;  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  	/* match found at *reference++ */UInt32 len = 2;  	UInt32 maxlen = (UInt32)in_len - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= out_len)  		return 0;  	do  		len++;  	while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  	if (lit != 0) {  		out_data [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		out_data [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  		out_data [oidx++] = (byte)(len - 7);  	}  	out_data [oidx++] = (byte)off;  	iidx += len - 1;  	hval = FRST (in_data' iidx);  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  	/* match found at *reference++ */UInt32 len = 2;  	UInt32 maxlen = (UInt32)in_len - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= out_len)  		return 0;  	do  		len++;  	while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  	if (lit != 0) {  		out_data [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		out_data [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  		out_data [oidx++] = (byte)(len - 7);  	}  	out_data [oidx++] = (byte)off;  	iidx += len - 1;  	hval = FRST (in_data' iidx);  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  	/* match found at *reference++ */UInt32 len = 2;  	UInt32 maxlen = (UInt32)in_len - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= out_len)  		return 0;  	do  		len++;  	while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  	if (lit != 0) {  		out_data [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		out_data [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  		out_data [oidx++] = (byte)(len - 7);  	}  	out_data [oidx++] = (byte)off;  	iidx += len - 1;  	hval = FRST (in_data' iidx);  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  	/* match found at *reference++ */UInt32 len = 2;  	UInt32 maxlen = (UInt32)in_len - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= out_len)  		return 0;  	do  		len++;  	while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  	if (lit != 0) {  		out_data [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		out_data [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  		out_data [oidx++] = (byte)(len - 7);  	}  	out_data [oidx++] = (byte)off;  	iidx += len - 1;  	hval = FRST (in_data' iidx);  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  	/* match found at *reference++ */UInt32 len = 2;  	UInt32 maxlen = (UInt32)in_len - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= out_len)  		return 0;  	do  		len++;  	while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  	if (lit != 0) {  		out_data [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		out_data [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  		out_data [oidx++] = (byte)(len - 7);  	}  	out_data [oidx++] = (byte)off;  	iidx += len - 1;  	hval = FRST (in_data' iidx);  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  	/* match found at *reference++ */UInt32 len = 2;  	UInt32 maxlen = (UInt32)in_len - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= out_len)  		return 0;  	do  		len++;  	while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  	if (lit != 0) {  		out_data [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		out_data [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  		out_data [oidx++] = (byte)(len - 7);  	}  	out_data [oidx++] = (byte)off;  	iidx += len - 1;  	hval = FRST (in_data' iidx);  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  	/* match found at *reference++ */UInt32 len = 2;  	UInt32 maxlen = (UInt32)in_len - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= out_len)  		return 0;  	do  		len++;  	while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  	if (lit != 0) {  		out_data [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		out_data [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  		out_data [oidx++] = (byte)(len - 7);  	}  	out_data [oidx++] = (byte)off;  	iidx += len - 1;  	hval = FRST (in_data' iidx);  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  	/* match found at *reference++ */UInt32 len = 2;  	UInt32 maxlen = (UInt32)in_len - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= out_len)  		return 0;  	do  		len++;  	while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  	if (lit != 0) {  		out_data [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		out_data [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  		out_data [oidx++] = (byte)(len - 7);  	}  	out_data [oidx++] = (byte)off;  	iidx += len - 1;  	hval = FRST (in_data' iidx);  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  	/* match found at *reference++ */UInt32 len = 2;  	UInt32 maxlen = (UInt32)in_len - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= out_len)  		return 0;  	do  		len++;  	while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  	if (lit != 0) {  		out_data [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		out_data [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  		out_data [oidx++] = (byte)(len - 7);  	}  	out_data [oidx++] = (byte)off;  	iidx += len - 1;  	hval = FRST (in_data' iidx);  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  	/* match found at *reference++ */UInt32 len = 2;  	UInt32 maxlen = (UInt32)in_len - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= out_len)  		return 0;  	do  		len++;  	while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  	if (lit != 0) {  		out_data [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		out_data [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  		out_data [oidx++] = (byte)(len - 7);  	}  	out_data [oidx++] = (byte)off;  	iidx += len - 1;  	hval = FRST (in_data' iidx);  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  	/* match found at *reference++ */UInt32 len = 2;  	UInt32 maxlen = (UInt32)in_len - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= out_len)  		return 0;  	do  		len++;  	while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  	if (lit != 0) {  		out_data [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		out_data [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  		out_data [oidx++] = (byte)(len - 7);  	}  	out_data [oidx++] = (byte)off;  	iidx += len - 1;  	hval = FRST (in_data' iidx);  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  	/* match found at *reference++ */UInt32 len = 2;  	UInt32 maxlen = (UInt32)in_len - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= out_len)  		return 0;  	do  		len++;  	while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  	if (lit != 0) {  		out_data [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		out_data [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  		out_data [oidx++] = (byte)(len - 7);  	}  	out_data [oidx++] = (byte)off;  	iidx += len - 1;  	hval = FRST (in_data' iidx);  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < in_len && reference > 0 && in_data [reference + 0] == in_data [iidx + 0] && in_data [reference + 1] == in_data [iidx + 1] && in_data [reference + 2] == in_data [iidx + 2]) {  	/* match found at *reference++ */UInt32 len = 2;  	UInt32 maxlen = (UInt32)in_len - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= out_len)  		return 0;  	do  		len++;  	while (len < maxlen && in_data [reference + len] == in_data [iidx + len]);  	if (lit != 0) {  		out_data [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			out_data [oidx++] = in_data [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		out_data [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  		out_data [oidx++] = (byte)(len - 7);  	}  	out_data [oidx++] = (byte)off;  	iidx += len - 1;  	hval = FRST (in_data' iidx);  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	hval = NEXT (hval' in_data' iidx);  	htab [IDX (hval)] = iidx;  	iidx++;  	continue;  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if (oidx + lit + 1 + 3 >= out_len)  	return 0;  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: len -= 2;  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if (len < 7) {  	out_data [oidx++] = (byte)((off >> 8) + (len << 5));  }  else {  	out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  	out_data [oidx++] = (byte)(len - 7);  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if (len < 7) {  	out_data [oidx++] = (byte)((off >> 8) + (len << 5));  }  else {  	out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  	out_data [oidx++] = (byte)(len - 7);  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if (len < 7) {  	out_data [oidx++] = (byte)((off >> 8) + (len << 5));  }  else {  	out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  	out_data [oidx++] = (byte)(len - 7);  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if (len < 7) {  	out_data [oidx++] = (byte)((off >> 8) + (len << 5));  }  else {  	out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  	out_data [oidx++] = (byte)(len - 7);  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if (len < 7) {  	out_data [oidx++] = (byte)((off >> 8) + (len << 5));  }  else {  	out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  	out_data [oidx++] = (byte)(len - 7);  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if (len < 7) {  	out_data [oidx++] = (byte)((off >> 8) + (len << 5));  }  else {  	out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  	out_data [oidx++] = (byte)(len - 7);  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: if (len < 7) {  	out_data [oidx++] = (byte)((off >> 8) + (len << 5));  }  else {  	out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  	out_data [oidx++] = (byte)(len - 7);  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: out_data [oidx++] = (byte)((off >> 8) + (len << 5));  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: out_data [oidx++] = (byte)((off >> 8) + (len << 5));  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: out_data [oidx++] = (byte)((off >> 8) + (7 << 5));  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_compress,The following statement contains a magic number: out_data [oidx++] = (byte)(len - 7);  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_decompress,The following statement contains a magic number: do {  	UInt32 ctrl = in_data [iidx++];  	if (ctrl < (1 << 5))/* literal run */ {  		ctrl++;  		if (oidx + ctrl > out_len) {  			//SET_ERRNO (E2BIG);  			return 0;  		}  		do  			out_data [oidx++] = in_data [iidx++];  		while ((--ctrl) != 0);  	}  	else/* back reference */ {  		UInt32 len = ctrl >> 5;  		int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  		if (len == 7)  			len += in_data [iidx++];  		reference -= in_data [iidx++];  		if (oidx + len + 2 > out_len) {  			//SET_ERRNO (E2BIG);  			return 0;  		}  		if (reference < 0) {  			//SET_ERRNO (EINVAL);  			return 0;  		}  		out_data [oidx++] = out_data [reference++];  		out_data [oidx++] = out_data [reference++];  		do  			out_data [oidx++] = out_data [reference++];  		while ((--len) != 0);  	}  }  while (iidx < in_len);  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_decompress,The following statement contains a magic number: do {  	UInt32 ctrl = in_data [iidx++];  	if (ctrl < (1 << 5))/* literal run */ {  		ctrl++;  		if (oidx + ctrl > out_len) {  			//SET_ERRNO (E2BIG);  			return 0;  		}  		do  			out_data [oidx++] = in_data [iidx++];  		while ((--ctrl) != 0);  	}  	else/* back reference */ {  		UInt32 len = ctrl >> 5;  		int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  		if (len == 7)  			len += in_data [iidx++];  		reference -= in_data [iidx++];  		if (oidx + len + 2 > out_len) {  			//SET_ERRNO (E2BIG);  			return 0;  		}  		if (reference < 0) {  			//SET_ERRNO (EINVAL);  			return 0;  		}  		out_data [oidx++] = out_data [reference++];  		out_data [oidx++] = out_data [reference++];  		do  			out_data [oidx++] = out_data [reference++];  		while ((--len) != 0);  	}  }  while (iidx < in_len);  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_decompress,The following statement contains a magic number: do {  	UInt32 ctrl = in_data [iidx++];  	if (ctrl < (1 << 5))/* literal run */ {  		ctrl++;  		if (oidx + ctrl > out_len) {  			//SET_ERRNO (E2BIG);  			return 0;  		}  		do  			out_data [oidx++] = in_data [iidx++];  		while ((--ctrl) != 0);  	}  	else/* back reference */ {  		UInt32 len = ctrl >> 5;  		int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  		if (len == 7)  			len += in_data [iidx++];  		reference -= in_data [iidx++];  		if (oidx + len + 2 > out_len) {  			//SET_ERRNO (E2BIG);  			return 0;  		}  		if (reference < 0) {  			//SET_ERRNO (EINVAL);  			return 0;  		}  		out_data [oidx++] = out_data [reference++];  		out_data [oidx++] = out_data [reference++];  		do  			out_data [oidx++] = out_data [reference++];  		while ((--len) != 0);  	}  }  while (iidx < in_len);  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_decompress,The following statement contains a magic number: do {  	UInt32 ctrl = in_data [iidx++];  	if (ctrl < (1 << 5))/* literal run */ {  		ctrl++;  		if (oidx + ctrl > out_len) {  			//SET_ERRNO (E2BIG);  			return 0;  		}  		do  			out_data [oidx++] = in_data [iidx++];  		while ((--ctrl) != 0);  	}  	else/* back reference */ {  		UInt32 len = ctrl >> 5;  		int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  		if (len == 7)  			len += in_data [iidx++];  		reference -= in_data [iidx++];  		if (oidx + len + 2 > out_len) {  			//SET_ERRNO (E2BIG);  			return 0;  		}  		if (reference < 0) {  			//SET_ERRNO (EINVAL);  			return 0;  		}  		out_data [oidx++] = out_data [reference++];  		out_data [oidx++] = out_data [reference++];  		do  			out_data [oidx++] = out_data [reference++];  		while ((--len) != 0);  	}  }  while (iidx < in_len);  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_decompress,The following statement contains a magic number: do {  	UInt32 ctrl = in_data [iidx++];  	if (ctrl < (1 << 5))/* literal run */ {  		ctrl++;  		if (oidx + ctrl > out_len) {  			//SET_ERRNO (E2BIG);  			return 0;  		}  		do  			out_data [oidx++] = in_data [iidx++];  		while ((--ctrl) != 0);  	}  	else/* back reference */ {  		UInt32 len = ctrl >> 5;  		int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  		if (len == 7)  			len += in_data [iidx++];  		reference -= in_data [iidx++];  		if (oidx + len + 2 > out_len) {  			//SET_ERRNO (E2BIG);  			return 0;  		}  		if (reference < 0) {  			//SET_ERRNO (EINVAL);  			return 0;  		}  		out_data [oidx++] = out_data [reference++];  		out_data [oidx++] = out_data [reference++];  		do  			out_data [oidx++] = out_data [reference++];  		while ((--len) != 0);  	}  }  while (iidx < in_len);  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_decompress,The following statement contains a magic number: if (ctrl < (1 << 5))/* literal run */ {  	ctrl++;  	if (oidx + ctrl > out_len) {  		//SET_ERRNO (E2BIG);  		return 0;  	}  	do  		out_data [oidx++] = in_data [iidx++];  	while ((--ctrl) != 0);  }  else/* back reference */ {  	UInt32 len = ctrl >> 5;  	int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  	if (len == 7)  		len += in_data [iidx++];  	reference -= in_data [iidx++];  	if (oidx + len + 2 > out_len) {  		//SET_ERRNO (E2BIG);  		return 0;  	}  	if (reference < 0) {  		//SET_ERRNO (EINVAL);  		return 0;  	}  	out_data [oidx++] = out_data [reference++];  	out_data [oidx++] = out_data [reference++];  	do  		out_data [oidx++] = out_data [reference++];  	while ((--len) != 0);  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_decompress,The following statement contains a magic number: if (ctrl < (1 << 5))/* literal run */ {  	ctrl++;  	if (oidx + ctrl > out_len) {  		//SET_ERRNO (E2BIG);  		return 0;  	}  	do  		out_data [oidx++] = in_data [iidx++];  	while ((--ctrl) != 0);  }  else/* back reference */ {  	UInt32 len = ctrl >> 5;  	int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  	if (len == 7)  		len += in_data [iidx++];  	reference -= in_data [iidx++];  	if (oidx + len + 2 > out_len) {  		//SET_ERRNO (E2BIG);  		return 0;  	}  	if (reference < 0) {  		//SET_ERRNO (EINVAL);  		return 0;  	}  	out_data [oidx++] = out_data [reference++];  	out_data [oidx++] = out_data [reference++];  	do  		out_data [oidx++] = out_data [reference++];  	while ((--len) != 0);  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_decompress,The following statement contains a magic number: if (ctrl < (1 << 5))/* literal run */ {  	ctrl++;  	if (oidx + ctrl > out_len) {  		//SET_ERRNO (E2BIG);  		return 0;  	}  	do  		out_data [oidx++] = in_data [iidx++];  	while ((--ctrl) != 0);  }  else/* back reference */ {  	UInt32 len = ctrl >> 5;  	int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  	if (len == 7)  		len += in_data [iidx++];  	reference -= in_data [iidx++];  	if (oidx + len + 2 > out_len) {  		//SET_ERRNO (E2BIG);  		return 0;  	}  	if (reference < 0) {  		//SET_ERRNO (EINVAL);  		return 0;  	}  	out_data [oidx++] = out_data [reference++];  	out_data [oidx++] = out_data [reference++];  	do  		out_data [oidx++] = out_data [reference++];  	while ((--len) != 0);  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_decompress,The following statement contains a magic number: if (ctrl < (1 << 5))/* literal run */ {  	ctrl++;  	if (oidx + ctrl > out_len) {  		//SET_ERRNO (E2BIG);  		return 0;  	}  	do  		out_data [oidx++] = in_data [iidx++];  	while ((--ctrl) != 0);  }  else/* back reference */ {  	UInt32 len = ctrl >> 5;  	int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  	if (len == 7)  		len += in_data [iidx++];  	reference -= in_data [iidx++];  	if (oidx + len + 2 > out_len) {  		//SET_ERRNO (E2BIG);  		return 0;  	}  	if (reference < 0) {  		//SET_ERRNO (EINVAL);  		return 0;  	}  	out_data [oidx++] = out_data [reference++];  	out_data [oidx++] = out_data [reference++];  	do  		out_data [oidx++] = out_data [reference++];  	while ((--len) != 0);  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_decompress,The following statement contains a magic number: if (ctrl < (1 << 5))/* literal run */ {  	ctrl++;  	if (oidx + ctrl > out_len) {  		//SET_ERRNO (E2BIG);  		return 0;  	}  	do  		out_data [oidx++] = in_data [iidx++];  	while ((--ctrl) != 0);  }  else/* back reference */ {  	UInt32 len = ctrl >> 5;  	int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  	if (len == 7)  		len += in_data [iidx++];  	reference -= in_data [iidx++];  	if (oidx + len + 2 > out_len) {  		//SET_ERRNO (E2BIG);  		return 0;  	}  	if (reference < 0) {  		//SET_ERRNO (EINVAL);  		return 0;  	}  	out_data [oidx++] = out_data [reference++];  	out_data [oidx++] = out_data [reference++];  	do  		out_data [oidx++] = out_data [reference++];  	while ((--len) != 0);  }  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_decompress,The following statement contains a magic number: if (len == 7)  	len += in_data [iidx++];  
Magic Number,Spike.Network,CLZF,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\LZF.cs,lzf_decompress,The following statement contains a magic number: if (oidx + len + 2 > out_len) {  	//SET_ERRNO (E2BIG);  	return 0;  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,Begin,The following statement contains a magic number: if (compressed) {  	var compressedBuffer = new byte[this.Length - 8];  	var uncompressedBuffer = new byte[this.Capacity];  	System.Buffer.BlockCopy (this.Buffer' 8' compressedBuffer' 0' compressedBuffer.Length);  	var packer = new CLZF ();  	var uncompressedSize = packer.lzf_decompress (compressedBuffer' compressedBuffer.Length' uncompressedBuffer' uncompressedBuffer.Length);  	System.Buffer.BlockCopy (uncompressedBuffer' 0' this.Buffer' 8' uncompressedSize);  	this.Length = uncompressedSize + 8;  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,Begin,The following statement contains a magic number: if (compressed) {  	var compressedBuffer = new byte[this.Length - 8];  	var uncompressedBuffer = new byte[this.Capacity];  	System.Buffer.BlockCopy (this.Buffer' 8' compressedBuffer' 0' compressedBuffer.Length);  	var packer = new CLZF ();  	var uncompressedSize = packer.lzf_decompress (compressedBuffer' compressedBuffer.Length' uncompressedBuffer' uncompressedBuffer.Length);  	System.Buffer.BlockCopy (uncompressedBuffer' 0' this.Buffer' 8' uncompressedSize);  	this.Length = uncompressedSize + 8;  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,Begin,The following statement contains a magic number: if (compressed) {  	var compressedBuffer = new byte[this.Length - 8];  	var uncompressedBuffer = new byte[this.Capacity];  	System.Buffer.BlockCopy (this.Buffer' 8' compressedBuffer' 0' compressedBuffer.Length);  	var packer = new CLZF ();  	var uncompressedSize = packer.lzf_decompress (compressedBuffer' compressedBuffer.Length' uncompressedBuffer' uncompressedBuffer.Length);  	System.Buffer.BlockCopy (uncompressedBuffer' 0' this.Buffer' 8' uncompressedSize);  	this.Length = uncompressedSize + 8;  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,Begin,The following statement contains a magic number: if (compressed) {  	var compressedBuffer = new byte[this.Length - 8];  	var uncompressedBuffer = new byte[this.Capacity];  	System.Buffer.BlockCopy (this.Buffer' 8' compressedBuffer' 0' compressedBuffer.Length);  	var packer = new CLZF ();  	var uncompressedSize = packer.lzf_decompress (compressedBuffer' compressedBuffer.Length' uncompressedBuffer' uncompressedBuffer.Length);  	System.Buffer.BlockCopy (uncompressedBuffer' 0' this.Buffer' 8' uncompressedSize);  	this.Length = uncompressedSize + 8;  }  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,Begin,The following statement contains a magic number: System.Buffer.BlockCopy (this.Buffer' 8' compressedBuffer' 0' compressedBuffer.Length);  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,Begin,The following statement contains a magic number: System.Buffer.BlockCopy (uncompressedBuffer' 0' this.Buffer' 8' uncompressedSize);  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,Begin,The following statement contains a magic number: this.Length = uncompressedSize + 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadUInt16,The following statement contains a magic number: return (ushort)((this.Buffer [this.Offset++] << 8) | this.Buffer [this.Offset++]);  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadInt16,The following statement contains a magic number: return (short)((this.Buffer [this.Offset++] << 8) | this.Buffer [this.Offset++]);  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadUInt32,The following statement contains a magic number: return (uint)(this.Buffer [this.Offset++] << 24 | (this.Buffer [this.Offset++] << 16) | (this.Buffer [this.Offset++] << 8) | (this.Buffer [this.Offset++]));  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadUInt32,The following statement contains a magic number: return (uint)(this.Buffer [this.Offset++] << 24 | (this.Buffer [this.Offset++] << 16) | (this.Buffer [this.Offset++] << 8) | (this.Buffer [this.Offset++]));  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadUInt32,The following statement contains a magic number: return (uint)(this.Buffer [this.Offset++] << 24 | (this.Buffer [this.Offset++] << 16) | (this.Buffer [this.Offset++] << 8) | (this.Buffer [this.Offset++]));  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadInt32,The following statement contains a magic number: return this.Buffer [this.Offset++] << 24 | (this.Buffer [this.Offset++] << 16) | (this.Buffer [this.Offset++] << 8) | (this.Buffer [this.Offset++]);  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadInt32,The following statement contains a magic number: return this.Buffer [this.Offset++] << 24 | (this.Buffer [this.Offset++] << 16) | (this.Buffer [this.Offset++] << 8) | (this.Buffer [this.Offset++]);  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadInt32,The following statement contains a magic number: return this.Buffer [this.Offset++] << 24 | (this.Buffer [this.Offset++] << 16) | (this.Buffer [this.Offset++] << 8) | (this.Buffer [this.Offset++]);  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadUInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadUInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadUInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadUInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadUInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadUInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadUInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadInt64,The following statement contains a magic number: value <<= 8;  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Flush,The following statement contains a magic number: if (compressed && this.Offset > 8) {  	// TODO: This should be seriously improved  	var packer = new CLZF ();  	var uncompressedBytes = new byte[this.Offset - 8];  	System.Buffer.BlockCopy (this.Buffer' 8' uncompressedBytes' 0' uncompressedBytes.Length);  	var compressedBytes = new byte[this.Capacity];  	var size = packer.lzf_compress (uncompressedBytes' uncompressedBytes.Length' compressedBytes' compressedBytes.Length);  	System.Buffer.BlockCopy (compressedBytes' 0' this.Buffer' 8' size);  	// Update the new offset  	this.Offset = size + 8;  }  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Flush,The following statement contains a magic number: if (compressed && this.Offset > 8) {  	// TODO: This should be seriously improved  	var packer = new CLZF ();  	var uncompressedBytes = new byte[this.Offset - 8];  	System.Buffer.BlockCopy (this.Buffer' 8' uncompressedBytes' 0' uncompressedBytes.Length);  	var compressedBytes = new byte[this.Capacity];  	var size = packer.lzf_compress (uncompressedBytes' uncompressedBytes.Length' compressedBytes' compressedBytes.Length);  	System.Buffer.BlockCopy (compressedBytes' 0' this.Buffer' 8' size);  	// Update the new offset  	this.Offset = size + 8;  }  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Flush,The following statement contains a magic number: if (compressed && this.Offset > 8) {  	// TODO: This should be seriously improved  	var packer = new CLZF ();  	var uncompressedBytes = new byte[this.Offset - 8];  	System.Buffer.BlockCopy (this.Buffer' 8' uncompressedBytes' 0' uncompressedBytes.Length);  	var compressedBytes = new byte[this.Capacity];  	var size = packer.lzf_compress (uncompressedBytes' uncompressedBytes.Length' compressedBytes' compressedBytes.Length);  	System.Buffer.BlockCopy (compressedBytes' 0' this.Buffer' 8' size);  	// Update the new offset  	this.Offset = size + 8;  }  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Flush,The following statement contains a magic number: if (compressed && this.Offset > 8) {  	// TODO: This should be seriously improved  	var packer = new CLZF ();  	var uncompressedBytes = new byte[this.Offset - 8];  	System.Buffer.BlockCopy (this.Buffer' 8' uncompressedBytes' 0' uncompressedBytes.Length);  	var compressedBytes = new byte[this.Capacity];  	var size = packer.lzf_compress (uncompressedBytes' uncompressedBytes.Length' compressedBytes' compressedBytes.Length);  	System.Buffer.BlockCopy (compressedBytes' 0' this.Buffer' 8' size);  	// Update the new offset  	this.Offset = size + 8;  }  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Flush,The following statement contains a magic number: if (compressed && this.Offset > 8) {  	// TODO: This should be seriously improved  	var packer = new CLZF ();  	var uncompressedBytes = new byte[this.Offset - 8];  	System.Buffer.BlockCopy (this.Buffer' 8' uncompressedBytes' 0' uncompressedBytes.Length);  	var compressedBytes = new byte[this.Capacity];  	var size = packer.lzf_compress (uncompressedBytes' uncompressedBytes.Length' compressedBytes' compressedBytes.Length);  	System.Buffer.BlockCopy (compressedBytes' 0' this.Buffer' 8' size);  	// Update the new offset  	this.Offset = size + 8;  }  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Flush,The following statement contains a magic number: System.Buffer.BlockCopy (this.Buffer' 8' uncompressedBytes' 0' uncompressedBytes.Length);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Flush,The following statement contains a magic number: System.Buffer.BlockCopy (compressedBytes' 0' this.Buffer' 8' size);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Flush,The following statement contains a magic number: this.Offset = size + 8;  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Flush,The following statement contains a magic number: this.Buffer [0] = ((byte)(length >> 24));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Flush,The following statement contains a magic number: this.Buffer [1] = ((byte)(length >> 16));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Flush,The following statement contains a magic number: this.Buffer [2] = ((byte)(length >> 8));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Flush,The following statement contains a magic number: this.Buffer [2] = ((byte)(length >> 8));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Flush,The following statement contains a magic number: this.Buffer [3] = ((byte)length);  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Begin,The following statement contains a magic number: this.Offset = 4;  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Write,The following statement contains a magic number: Write ((byte)(value >> 8));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Write,The following statement contains a magic number: Write ((byte)(value >> 8));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Write,The following statement contains a magic number: Write ((byte)(value >> 24));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Write,The following statement contains a magic number: Write ((byte)(value >> 16));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Write,The following statement contains a magic number: Write ((byte)(value >> 8));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Write,The following statement contains a magic number: Write ((byte)(value >> 24));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Write,The following statement contains a magic number: Write ((byte)(value >> 16));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Write,The following statement contains a magic number: Write ((byte)(value >> 8));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Write,The following statement contains a magic number: Write ((byte)(value >> 56));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Write,The following statement contains a magic number: Write ((byte)(value >> 48));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Write,The following statement contains a magic number: Write ((byte)(value >> 40));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Write,The following statement contains a magic number: Write ((byte)(value >> 32));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Write,The following statement contains a magic number: Write ((byte)(value >> 24));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Write,The following statement contains a magic number: Write ((byte)(value >> 16));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Write,The following statement contains a magic number: Write ((byte)(value >> 8));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Write,The following statement contains a magic number: Write ((byte)(value >> 56));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Write,The following statement contains a magic number: Write ((byte)(value >> 48));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Write,The following statement contains a magic number: Write ((byte)(value >> 40));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Write,The following statement contains a magic number: Write ((byte)(value >> 32));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Write,The following statement contains a magic number: Write ((byte)(value >> 24));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Write,The following statement contains a magic number: Write ((byte)(value >> 16));  
Magic Number,Spike.Network,PacketWriter,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketWriter.cs,Write,The following statement contains a magic number: Write ((byte)(value >> 8));  
Magic Number,Stress.CSharp5,Program,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Program.cs,Main,The following statement contains a magic number: Task.Run (async () => await Server.Connect ("127.0.0.1"' 8002));  
Missing Default,Spike.Network,PacketReader,C:\repos\Kelindar_spike-bench\Stress.CSharp5\Network\PacketReader.cs,ReadDynamicType,The following switch statement is missing a default case: switch (ReadString ()) {  case "Byte":  	return ReadByte ();  case "UInt16":  	return ReadUInt16 ();  case "Int16":  	return ReadInt16 ();  case "UInt32":  	return ReadUInt32 ();  case "Int32":  	return ReadInt32 ();  case "UInt64":  	return ReadUInt64 ();  case "Int64":  	return ReadInt64 ();  case "Single":  	return ReadSingle ();  case "Double":  	return ReadDouble ();  case "Boolean":  	return ReadBoolean ();  case "String":  	return ReadString ();  case "DateTime":  	return ReadDateTime ();  }  
