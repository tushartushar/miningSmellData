Implementation smell,Namespace,Class,File,Method,Description
Long Method,kOS.Safe.Compilation,OpcodeCall,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\Opcode.cs,StaticExecute,The method has 146 lines of code.
Long Method,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,PreProcessUserFunctionStatement,The method has 102 lines of code.
Long Method,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitNode,The method has 203 lines of code.
Long Method,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitRunStatement,The method has 109 lines of code.
Long Method,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseinstruction,The method has 136 lines of code.
Long Method,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_parameter_clause,The method has 131 lines of code.
Long Method,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_stmt,The method has 129 lines of code.
Long Method,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserun_stmt,The method has 108 lines of code.
Long Method,kOS.Safe.Compilation.KS,ParseNode,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\ParseTree.cs,Eval,The method has 208 lines of code.
Long Method,kOS.Safe.Compilation.KS,Scanner,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Scanner.cs,Scanner,The method has 257 lines of code.
Long Method,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The method has 125 lines of code.
Long Method,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The method has 125 lines of code.
Long Method,kOS.Safe.Screen,ScreenSnapShot,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Screen\ScreenSnapshot.cs,DiffFrom,The method has 109 lines of code.
Long Method,Reflection,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The method has 125 lines of code.
Complex Method,kOS.Safe.Compilation,Calculator,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\Calculator.cs,GetCalculator,Cyclomatic complexity of the method is 13
Complex Method,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,UnPack,Cyclomatic complexity of the method is 8
Complex Method,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,ReadOpcodeList,Cyclomatic complexity of the method is 9
Complex Method,kOS.Safe.Compilation,OpcodeCall,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\Opcode.cs,StaticExecute,Cyclomatic complexity of the method is 19
Complex Method,kOS.Safe.Compilation,OpcodeReturn,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\Opcode.cs,Execute,Cyclomatic complexity of the method is 8
Complex Method,kOS.Safe.Compilation,ProgramBuilder,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\ProgramBuilder.cs,ReplaceLabels,Cyclomatic complexity of the method is 11
Complex Method,kOS.Safe.Encapsulation,PIDLoop,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\PIDLoop.cs,Update,Cyclomatic complexity of the method is 12
Complex Method,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,RearrangeLoopFromNode,Cyclomatic complexity of the method is 9
Complex Method,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,PreProcessUserFunctionStatement,Cyclomatic complexity of the method is 12
Complex Method,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitSuffix,Cyclomatic complexity of the method is 11
Complex Method,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,HasParameterStmtNested,Cyclomatic complexity of the method is 8
Complex Method,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitRunStatement,Cyclomatic complexity of the method is 8
Complex Method,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitLazyGlobalDirective,Cyclomatic complexity of the method is 9
Complex Method,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseif_stmt,Cyclomatic complexity of the method is 8
Complex Method,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseprint_stmt,Cyclomatic complexity of the method is 8
Complex Method,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_parameter_clause,Cyclomatic complexity of the method is 11
Complex Method,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserun_stmt,Cyclomatic complexity of the method is 11
Complex Method,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parselist_stmt,Cyclomatic complexity of the method is 8
Complex Method,kOS.Safe.Encapsulation.Suffixes,DelegateSuffixResult,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Suffixes\DelegateSuffixResult.cs,Invoke,Cyclomatic complexity of the method is 13
Complex Method,kOS.Safe.Execution,CPU,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Execution\CPU.cs,Boot,Cyclomatic complexity of the method is 9
Complex Method,kOS.Safe.Execution,CPU,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Execution\CPU.cs,KOSFixedUpdate,Cyclomatic complexity of the method is 12
Complex Method,kOS.Safe.Execution,ProgramContext,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Execution\ProgramContext.cs,GetCodeFragment,Cyclomatic complexity of the method is 8
Complex Method,kOS.Safe.Function,FunctionLoad,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Function\Misc.cs,Execute,Cyclomatic complexity of the method is 13
Complex Method,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,Cyclomatic complexity of the method is 9
Complex Method,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,IsNumeric,Cyclomatic complexity of the method is 12
Complex Method,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,Cyclomatic complexity of the method is 9
Complex Method,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,IsNumeric,Cyclomatic complexity of the method is 12
Complex Method,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,Cyclomatic complexity of the method is 16
Complex Method,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,Cyclomatic complexity of the method is 16
Complex Method,kOS.Safe.Persistence,PersistenceUtilities,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Persistence\PersistenceUtilities.cs,CookedFilename,Cyclomatic complexity of the method is 9
Complex Method,kOS.Safe.Screen,ScreenSnapShot,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Screen\ScreenSnapshot.cs,DiffFrom,Cyclomatic complexity of the method is 11
Complex Method,kOS.Safe.Screen,SubBuffer,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Screen\SubBuffer.cs,ResizeBuffer,Cyclomatic complexity of the method is 8
Complex Method,kOS.Safe.Utilities,AssemblyWalkAttribute,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Utilities\AssemblyWalkAttribute.cs,WalkAssembly,Cyclomatic complexity of the method is 9
Complex Method,kOS.Safe.Utilities,MovingAverage,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Utilities\MovingAverage.cs,Update,Cyclomatic complexity of the method is 9
Complex Method,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,Cyclomatic complexity of the method is 9
Complex Method,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,IsNumeric,Cyclomatic complexity of the method is 12
Complex Method,Reflection,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,Cyclomatic complexity of the method is 16
Long Parameter List,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,ReadOpcodeList,The method has 5 parameters. Parameters: reader' codeStartPos' prefix' arguments' argIndexSize
Long Parameter List,kOS.Safe.Compilation,Script,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\Script.cs,Compile,The method has 5 parameters. Parameters: filePath' startLineNum' scriptText' contextId' options
Long Parameter List,kOS.Safe.Encapsulation,PIDLoop,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\PIDLoop.cs,PIDLoop,The method has 6 parameters. Parameters: kp' ki' kd' maxoutput' minoutput' extraUnwind
Long Parameter List,kOS.Safe.Encapsulation,PIDLoop,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\PIDLoop.cs,Update,The method has 5 parameters. Parameters: sampleTime' input' setpoint' minOutput' maxOutput
Long Parameter List,kOS.Safe.Compilation.KS,KSScript,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\KSScript.cs,Compile,The method has 5 parameters. Parameters: filePath' startLineNum' scriptText' contextId' options
Long Parameter List,kOS.Safe.Compilation.KS,ParseError,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\ParseTree.cs,ParseError,The method has 7 parameters. Parameters: message' code' file' line' col' pos' length
Long Parameter List,kOS.Safe.Encapsulation.Suffixes,ClampSetSuffix<TValue>,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Suffixes\ClampSetSuffix.cs,ClampSetSuffix,The method has 6 parameters. Parameters: getter' setter' min' max' stepIncrement' description
Long Parameter List,kOS.Safe.Encapsulation.Suffixes,ClampSetSuffix<TValue>,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Suffixes\ClampSetSuffix.cs,ClampSetSuffix,The method has 5 parameters. Parameters: getter' setter' min' max' description
Long Parameter List,kOS.Safe.Encapsulation.Suffixes,ConfigKey,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Suffixes\ConfigKey.cs,ConfigKey,The method has 7 parameters. Parameters: stringKey' alias' name' defaultValue' min' max' type
Long Parameter List,kOS.Safe.Execution,YieldFinishedCompile,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Execution\YieldFinishedCompile.cs,YieldFinishedCompile,The method has 5 parameters. Parameters: scriptPath' lineNumber' fileContent' contextIdentifier' compilerOptions
Long Parameter List,kOS.Safe.Execution,YieldFinishedCompile,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Execution\YieldFinishedCompile.cs,RunScript,The method has 5 parameters. Parameters: scriptPath' lineNumber' fileContent' contextIdentifier' compilerOptions
Long Parameter List,kOS.Safe.Execution,YieldFinishedCompile,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Execution\YieldFinishedCompile.cs,LoadScript,The method has 5 parameters. Parameters: scriptPath' lineNumber' fileContent' contextIdentifier' compilerOptions
Long Parameter List,kOS.Safe.Execution,YieldFinishedCompile,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Execution\YieldFinishedCompile.cs,CompileScriptToFile,The method has 6 parameters. Parameters: scriptPath' lineNumber' fileContent' compilerOptions' storageVolume' storagePath
Long Parameter List,kOS.Safe.Utilities,SafeHouse,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Utilities\SafeHouse.cs,Init,The method has 5 parameters. Parameters: config' versionInfo' docURL' isWindows' archiveFolder
Long Identifier,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitActualFunction,The length of the parameter rememberCompilingSetDestination is 31.
Long Identifier,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,,The length of the parameter boilerplateLoadAndRunEntryLabel is 31.
Long Identifier,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,,The length of the parameter _currentJsonSerializerStrategy is 30.
Long Identifier,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,,The length of the parameter _currentJsonSerializerStrategy is 30.
Long Identifier,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,,The length of the parameter ArrayConstructorParameterTypes is 30.
Long Identifier,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,,The length of the parameter ArrayConstructorParameterTypes is 30.
Long Identifier,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,,The length of the parameter _currentJsonSerializerStrategy is 30.
Long Identifier,Reflection,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,,The length of the parameter ArrayConstructorParameterTypes is 30.
Long Statement,kOS.Safe.Compilation,Calculator,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\Calculator.cs,GetCalculator,The length of the statement  "            throw new NotImplementedException(string.Format("Can't operate types {0} and {1}"' operandPair.Left.GetType()' operandPair.Right.GetType())); " is 141.
Long Statement,kOS.Safe.Compilation,CalculatorStructure,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CalculatorStructure.cs,TryCoerceImplicit,The length of the statement  "            MethodInfo convert2 = pair.LeftType.GetMethod("op_Implicit"' FLAGS | BindingFlags.ExactBinding' null' new[] { pair.RightType }' null); " is 134.
Long Statement,kOS.Safe.Compilation,CalculatorStructure,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CalculatorStructure.cs,TryCoerceImplicit,The length of the statement  "            MethodInfo convert1 = pair.RightType.GetMethod("op_Implicit"' FLAGS | BindingFlags.ExactBinding' null' new[] { pair.LeftType }' null); " is 134.
Long Statement,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,ReadSomeBinaryPrimitive,The length of the statement  "            if      (cSharpType == typeof(PseudoNull)) { /* do nothing.  for a null the type byte code is enough - no further data. */ } " is 124.
Long Statement,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,ReadSomeBinaryPrimitive,The length of the statement  "            else if (cSharpType == typeof(KOSArgMarkerType)) returnValue = new KOSArgMarkerType(); // no packed data - just make a default one. " is 131.
Long Statement,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,PostReadProcessing,The length of the statement  "                        ++opIndex; // First opIndex is called 1' not 0.  This matches the behavior of Compiler.cs's AddOpcode()'s call to GetNextIndex(). " is 129.
Long Statement,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,ReadOpcodeList,The length of the statement  "                            !((string)val).StartsWith("@LR") // Do not re-assign calls to the LoadRunner global label that resides outside this KSM file. " is 125.
Long Statement,kOS.Safe.Compilation,OpcodeLabelReset,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\Opcode.cs,Execute,The length of the statement  "            throw new InvalidOperationException("Attempt to execute OpcodeNonNumericLabel. This type of Opcode should have been replaced before execution.\n"); " is 147.
Long Statement,kOS.Safe.Compilation,OpcodeMathNegate,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\Opcode.cs,Execute,The length of the statement  "            MethodInfo negateMe = t.GetMethod("op_UnaryNegation"' BindingFlags.FlattenHierarchy |BindingFlags.Static | BindingFlags.Public); " is 128.
Long Statement,kOS.Safe.Compilation,OpcodeReturn,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\Opcode.cs,Execute,The length of the statement  "                        string.Format("Something is wrong with the stack - no arg bottom mark when doing a return.  This is an internal problem with kOS") " is 130.
Long Statement,kOS.Safe.Compilation,OpcodePushRelocateLater,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\Opcode.cs,Execute,The length of the statement  "            throw new InvalidOperationException("Attempt to execute OpcodePushRelocateLater. This type of Opcode should have been replaced before execution.\n"); " is 149.
Long Statement,kOS.Safe.Compilation,OpcodePushDelegateRelocateLater,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\Opcode.cs,PopulateFromMLFields,The length of the statement  "                throw new Exception("Saved field in ML file for OpcodePushDelegateRelocatelater seems to be missing.  Version mismatch?"); " is 122.
Long Statement,kOS.Safe.Compilation,ProgramBuilder,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\ProgramBuilder.cs,BuildBoilerplateLoader,The length of the statement  "            boilerplate.Add(new OpcodePush(true) {Label = nextLabel' SourcePath = path}); // the flag that tells load() to abort early if it's already loaded: " is 146.
Long Statement,kOS.Safe.Compilation,ProgramBuilder,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\ProgramBuilder.cs,BuildBoilerplateLoader,The length of the statement  "            boilerplate.Add(new OpcodePop() {Label = nextLabel' SourcePath = path}); // onsume the entry point that load() returned. We won't be calling it. " is 144.
Long Statement,kOS.Safe.Compilation,ProgramBuilder,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\ProgramBuilder.cs,GetEntryPointLabel,The length of the statement  "            List<Opcode> codeSection = linkedObject.InitializationCode.Count > 0 ? linkedObject.InitializationCode : linkedObject.MainCode; " is 127.
Long Statement,kOS.Safe.Compilation,ProgramBuilder,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\ProgramBuilder.cs,ReplaceLabels,The length of the statement  "                            "ProgramBuilder.ReplaceLabels: Cannot add label {0}' label already exists.  Opcode: {1}"' program[index].Label' program[index].ToString())); " is 140.
Long Statement,kOS.Safe.Exceptions,KOSArgumentMismatchException,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Exceptions\KOSArgumentMismatchException.cs,BuildTerseMessage,The length of the statement  "            var expectedDisplay = (expected.Any() ? String.Join("' "' new List<int>(expected).ConvertAll(i => i.ToString()).ToArray()) : "no"); " is 131.
Long Statement,kOS.Safe.Exceptions,KOSParseException,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Exceptions\KOSParseException.cs,BuildVerboseMessageFromTPGError,The length of the statement  "            contextSnippet = contextSnippet.Insert((tpgErr.Position + tpgErr.Length + markStart.Length) - (posAbove+1)' new String(markStop)); " is 130.
Long Statement,kOS.Safe.Encapsulation,Lexicon,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Lexicon.cs,InitalizeSuffixes,The length of the statement  "            AddSuffix("LENGTH"' new NoArgsSuffix<ScalarValue>(() => internalDictionary.Count' "Returns the number of elements in the collection")); " is 135.
Long Statement,kOS.Safe.Encapsulation,Lexicon,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Lexicon.cs,InitalizeSuffixes,The length of the statement  "            AddSuffix("REMOVE"' new OneArgsSuffix<BooleanValue' Structure>(one => Remove(one)' "Removes the value at the given key")); " is 122.
Long Statement,kOS.Safe.Encapsulation,Lexicon,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Lexicon.cs,InitalizeSuffixes,The length of the statement  "            AddSuffix("ADD"' new TwoArgsSuffix<Structure' Structure>(Add' "Adds a new item to the lexicon' will error if the key already exists")); " is 135.
Long Statement,kOS.Safe.Encapsulation,Lexicon,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Lexicon.cs,InitalizeSuffixes,The length of the statement  "            AddSuffix("DUMP"' new NoArgsSuffix<StringValue>(() => ToString()' "Serializes the collection to a string for printing")); " is 121.
Long Statement,kOS.Safe.Encapsulation,Lexicon,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Lexicon.cs,InitalizeSuffixes,The length of the statement  "            AddSuffix(new[] { "CASESENSITIVE"' "CASE" }' new SetSuffix<BooleanValue>(() => caseSensitive' SetCaseSensitivity' "Lets you get/set the case sensitivity on the collection' changing sensitivity will clear the collection")); " is 222.
Long Statement,kOS.Safe.Encapsulation,Lexicon,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Lexicon.cs,LoadDump,The length of the statement  "                internalDictionary.Add(Structure.FromPrimitiveWithAssert(values[2 * i])' Structure.FromPrimitiveWithAssert(values[2 * i + 1])); " is 127.
Long Statement,kOS.Safe.Encapsulation,ListValue<T>,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\ListValue.cs,ListInitializeSuffixes,The length of the statement  "            AddSuffix("ADD"'      new OneArgsSuffix<T>                  (toAdd => Collection.Add(toAdd)' Resources.ListAddDescription)); " is 124.
Long Statement,kOS.Safe.Encapsulation,ScalarValue,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\ScalarValue.cs,Create,The length of the statement  "            throw new KOSException(string.Format("Failed to set scalar value.  Passed type {0}' expected Double or Int"' value.GetType().Name)); " is 132.
Long Statement,kOS.Safe.Encapsulation,Structure,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Structure.cs,GetKOSInheritance,The length of the statement  "                    if (kOSname != prevKosName) // skip extra iterations where we mash parent C# types and child C# types into the same KOS type. " is 125.
Long Statement,kOS.Safe.Encapsulation,Structure,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Structure.cs,ToString,The length of the statement  "            return KOSNomenclature.GetKOSName(GetType()) + ": \"\""; // print as the KOSNomenclature string name' will look like: Structure: "" " is 131.
Long Statement,kOS.Safe.Encapsulation,Structure,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Structure.cs,FromPrimitive,The length of the statement  "                return value; // If a null exists' let it pass through so it will bomb elsewhere' not here in FromPrimitive() where the exception message would be obtuse. " is 154.
Long Statement,kOS.Safe.Encapsulation,Structure,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Structure.cs,FromPrimitiveWithAssert,The length of the statement  "                    string.Format("Internal Error.  Contact the kOS developers with the phrase 'impossible FromPrimitiveWithAssert({0}) was attempted'.\nAlso include the output log if you can."' " is 174.
Long Statement,kOS.Safe.Encapsulation,StringValue,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\StringValue.cs,SetIndex,The length of the statement  "            throw new KOSException("Strings are immutable; they can not be modified using the syntax \"SET string[1] TO 'a'\"' etc."); " is 122.
Long Statement,kOS.Safe.Encapsulation,StringValue,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\StringValue.cs,SetIndex,The length of the statement  "            throw new KOSException("Strings are immutable; they can not be modified using the syntax \"SET string[1] TO 'a'\"' etc."); " is 122.
Long Statement,kOS.Safe.Encapsulation,StringValue,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\StringValue.cs,StringInitializeSuffixes,The length of the statement  "            // Aliased "IndexOf" with "Find" to match "FindAt" (since IndexOfAt doesn't make sense' but I wanted to stick with common/C# names when possible) " is 145.
Long Statement,kOS.Safe.Encapsulation,TerminalStruct,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\TerminalStruct.cs,NotifyMeOfResize,The length of the statement  "                List<Structure> argList = new List<Structure>(new Structure[] {(ScalarIntValue)sb.ColumnCount' (ScalarIntValue)sb.RowCount}); " is 125.
Long Statement,kOS.Safe.Encapsulation,TerminalStruct,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\TerminalStruct.cs,NotifyMeOfResize,The length of the statement  "            return 0; // being told about the resize allows a resizer to choose to scroll the window.  We won't give that power to the script code. " is 135.
Long Statement,kOS.Safe.Encapsulation,TerminalStruct,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\TerminalStruct.cs,InitializeSuffixes,The length of the statement  "            // AddSuffix("ISOPEN"' new SetSuffix<BooleanValue>(() => IsOpen' Isopen = value' "true=open' false=closed.  You can set it to open/close the window.")); " is 152.
Long Statement,kOS.Safe.Encapsulation,TerminalStruct,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\TerminalStruct.cs,InitializeSuffixes,The length of the statement  "                                                               "Get or Set the number of columns on the screen.  Value is limited to the range [" + MINCOLUMNS + "'" + MAXCOLUMNS + "]")); " is 123.
Long Statement,kOS.Safe.Encapsulation,UserDelegate,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\UserDelegate.cs,IsDead,The length of the statement  "            return (weakProgContext != null) && // If this is still null then we got called during the constructor and this doesn't count yet. " is 130.
Long Statement,kOS.Safe.Encapsulation,UserDelegate,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\UserDelegate.cs,CaptureClosure,The length of the statement  "                Closure = new List<VariableScope>(); // make sure it exists as an empty list so we don't have to have 'if null' checks everwywhere. " is 131.
Long Statement,kOS.Safe.Encapsulation,UserDelegate,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\UserDelegate.cs,Equals,The length of the statement  "            return object.Equals(this.ProgContext' other.ProgContext) && this.EntryPoint == other.EntryPoint && object.Equals(this.Closure' other.Closure); " is 143.
Long Statement,kOS.Safe.Encapsulation,EnumerableValue<T;TE>,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\EnumerableValue.cs,InitializeEnumerableSuffixes,The length of the statement  "            AddSuffix("REVERSEITERATOR"' new NoArgsSuffix<Enumerator>(() => new Enumerator(Enumerable.Reverse(InnerEnumerable).GetEnumerator()))); " is 134.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,IdentifyUserFunctions,The length of the statement  "                context.UserFunctions.GetUserFunction(funcIdentifier' storageType == StorageModifier.GLOBAL ? (Int16)0 : GetContainingScopeId(node)' node); " is 139.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,PreProcessUserFunctionStatement,The length of the statement  "            needImplicitReturn = true; // Locks always need an implicit return.  Functions might not if all paths have an explicit one. " is 123.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,PreProcessUserFunctionStatement,The length of the statement  "                if (isLock) // locks need to behave as if they had braces even though they don't - so they get lexical scope ids for closure reasons: " is 133.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,PreProcessUserFunctionStatement,The length of the statement  "                if (isLock) // locks need to behave as if they had braces even though they don't - so they get lexical scope ids for closure reasons: " is 133.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,PreProcessUserFunctionStatement,The length of the statement  "                        AddOpcode(new OpcodePush(0)); // Functions must push a dummy return val when making implicit returns. Locks already leave an expr atop the stack. " is 145.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,PreProcessUserFunctionStatement,The length of the statement  "                userFuncObject.ScopeNode = GetContainingBlockNode(node); // This limits the scope of the function to the instruction_block the DEFINE was in. " is 141.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,BuildSystemTrigger,The length of the statement  "            lastLine = -1; // special flag telling the error handler that these opcodes came from the system itself' when reporting the error " is 129.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,TraverseScopeBranch,The length of the statement  "                case TokenType.declare_lock_clause: // here because the lock body needs a scope in order to work with closures.  The scope remembers the lexical id. " is 148.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitStartStatement,The length of the statement  "                VisitNode(node.Nodes[i]); // nextBraceIsFunction state would get incorrectly inherited by my children here if it wasn't turned off up above. " is 140.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitExpr,The length of the statement  "                    AddOpcode(new OpcodePush(0)); // Functions must push a dummy return val when making implicit returns. Locks already leave an expr atop the stack. " is 145.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitShortCircuitBoolean,The length of the statement  "                    if (nodeIndex > 0) // After each term' insert the branch test (which consumes the expr from the stack regardless of if it branches): " is 132.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitSuffix,The length of the statement  "                // The remaining terms are a chain of function_trailers "(...)" and array_trailers "[...]" or "#.." in any arbitrary order: " is 123.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitInstructionBlock,The length of the statement  "                VisitNode(node.Nodes[i]); // nextBraceIsFunction state would get incorrectly inherited by my children here if it wasn't turned off up above. " is 140.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,AddFunctionJumpVars,The length of the statement  "                        item.ScopeNode == node &&                              // Preprocessing found this function here in this set of scope braces. " is 125.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,AddFunctionJumpVars,The length of the statement  "                        ((! isFileScope) || context.UserFunctions.IsNew(item)));  // If global' ensure it's not from a previously compiled script's global scope. " is 137.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitWaitStatement,The length of the statement  "                AddOpcode(new OpcodeWait());                               // Avoid busy polling.  Even a WAIT 0 still forces 1 fixedupdate 'tick'. " is 131.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,GetStorageModifierForDeclare,The length of the statement  "                throw new KOSCommandInvalidHereException(location' "GLOBAL"' "in a parameter declaration"' "in a variable declaration"); " is 120.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitRunStatement,The length of the statement  "            AddOpcode(new OpcodePush(new KOSArgMarkerType())); // regardless of whether it's called directly or indirectly' we still need at least one. " is 139.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitRunStatement,The length of the statement  "                // Note: it is not an error that there are two Pop's here:  There are two levels of return value - one from the program run " is 123.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitRunStatement,The length of the statement  "                AddOpcode(new OpcodePop()); // ditch the program exit's dummy return value for now - maybe we can use it in a later version. " is 124.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitRebootStatement,The length of the statement  "            AddOpcode(new OpcodePop()); // all functions now return a value even if we ignore it.  Not sure it matters in the case of reboot() though. " is 138.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitShutdownStatement,The length of the statement  "            AddOpcode(new OpcodePop()); // all functions now return a value even if we ignore it.  Not sure it matters in the case of shutdown() though. " is 140.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitDirective,The length of the statement  "                throw new KOSCompileException(new LineCol(lastLine' lastColumn)' "Kerboscript compiler directive ('@') without a keyword after it."); " is 133.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitDirective,The length of the statement  "                    throw new KOSCompileException(new LineCol(lastLine' lastColumn)' "Kerboscript compiler directive @"+directiveNode.Nodes[1].Text+" is unknown."); " is 144.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitLazyGlobalDirective,The length of the statement  "                throw new KOSCompileException(new LineCol(lastLine' lastColumn)' "Kerboscript compiler directive @LAZYGLOBAL requires an ON or an OFF keyword."); " is 145.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitLazyGlobalDirective,The length of the statement  "                int myInstructionIndex = ancestor.Nodes.IndexOf(myInstructionContainer); // would be an expensive walk - except this should only exist once' near the top. " is 154.
Long Statement,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitLazyGlobalDirective,The length of the statement  "                allowLazyGlobal = true; // this is the default anyway' so this is just here for completeness in case we change the default. " is 123.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,ParseStart,The length of the statement  "            tok = scanner.LookAhead(TokenType.EOI' TokenType.SET' TokenType.IF' TokenType.UNTIL' TokenType.FROM' TokenType.UNLOCK' TokenType.PRINT' TokenType.ON' TokenType.TOGGLE' TokenType.WAIT' TokenType.WHEN' TokenType.STAGE' TokenType.CLEARSCREEN' TokenType.ADD' TokenType.REMOVE' TokenType.LOG' TokenType.BREAK' TokenType.PRESERVE' TokenType.PARAMETER' TokenType.FUNCTION' TokenType.LOCK' TokenType.DECLARE' TokenType.LOCAL' TokenType.GLOBAL' TokenType.RETURN' TokenType.SWITCH' TokenType.COPY' TokenType.RENAME' TokenType.DELETE' TokenType.EDIT' TokenType.RUN' TokenType.RUNPATH' TokenType.RUNONCEPATH' TokenType.COMPILE' TokenType.LIST' TokenType.REBOOT' TokenType.SHUTDOWN' TokenType.FOR' TokenType.UNSET' TokenType.CURLYOPEN' TokenType.INTEGER' TokenType.DOUBLE' TokenType.TRUEFALSE' TokenType.IDENTIFIER' TokenType.FILEIDENT' TokenType.BRACKETOPEN' TokenType.STRING' TokenType.ATSIGN); // ZeroOrMore Rule " is 902.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,ParseStart,The length of the statement  "            tok = scanner.LookAhead(TokenType.EOI' TokenType.SET' TokenType.IF' TokenType.UNTIL' TokenType.FROM' TokenType.UNLOCK' TokenType.PRINT' TokenType.ON' TokenType.TOGGLE' TokenType.WAIT' TokenType.WHEN' TokenType.STAGE' TokenType.CLEARSCREEN' TokenType.ADD' TokenType.REMOVE' TokenType.LOG' TokenType.BREAK' TokenType.PRESERVE' TokenType.PARAMETER' TokenType.FUNCTION' TokenType.LOCK' TokenType.DECLARE' TokenType.LOCAL' TokenType.GLOBAL' TokenType.RETURN' TokenType.SWITCH' TokenType.COPY' TokenType.RENAME' TokenType.DELETE' TokenType.EDIT' TokenType.RUN' TokenType.RUNPATH' TokenType.RUNONCEPATH' TokenType.COMPILE' TokenType.LIST' TokenType.REBOOT' TokenType.SHUTDOWN' TokenType.FOR' TokenType.UNSET' TokenType.CURLYOPEN' TokenType.INTEGER' TokenType.DOUBLE' TokenType.TRUEFALSE' TokenType.IDENTIFIER' TokenType.FILEIDENT' TokenType.BRACKETOPEN' TokenType.STRING' TokenType.ATSIGN); // ZeroOrMore Rule " is 902.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,ParseStart,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOF.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseinstruction_block,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.CURLYOPEN.ToString()' 0x1001' tok)); " is 152.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseinstruction_block,The length of the statement  "            tok = scanner.LookAhead(TokenType.EOI' TokenType.SET' TokenType.IF' TokenType.UNTIL' TokenType.FROM' TokenType.UNLOCK' TokenType.PRINT' TokenType.ON' TokenType.TOGGLE' TokenType.WAIT' TokenType.WHEN' TokenType.STAGE' TokenType.CLEARSCREEN' TokenType.ADD' TokenType.REMOVE' TokenType.LOG' TokenType.BREAK' TokenType.PRESERVE' TokenType.PARAMETER' TokenType.FUNCTION' TokenType.LOCK' TokenType.DECLARE' TokenType.LOCAL' TokenType.GLOBAL' TokenType.RETURN' TokenType.SWITCH' TokenType.COPY' TokenType.RENAME' TokenType.DELETE' TokenType.EDIT' TokenType.RUN' TokenType.RUNPATH' TokenType.RUNONCEPATH' TokenType.COMPILE' TokenType.LIST' TokenType.REBOOT' TokenType.SHUTDOWN' TokenType.FOR' TokenType.UNSET' TokenType.CURLYOPEN' TokenType.INTEGER' TokenType.DOUBLE' TokenType.TRUEFALSE' TokenType.IDENTIFIER' TokenType.FILEIDENT' TokenType.BRACKETOPEN' TokenType.STRING' TokenType.ATSIGN); // ZeroOrMore Rule " is 902.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseinstruction_block,The length of the statement  "            tok = scanner.LookAhead(TokenType.EOI' TokenType.SET' TokenType.IF' TokenType.UNTIL' TokenType.FROM' TokenType.UNLOCK' TokenType.PRINT' TokenType.ON' TokenType.TOGGLE' TokenType.WAIT' TokenType.WHEN' TokenType.STAGE' TokenType.CLEARSCREEN' TokenType.ADD' TokenType.REMOVE' TokenType.LOG' TokenType.BREAK' TokenType.PRESERVE' TokenType.PARAMETER' TokenType.FUNCTION' TokenType.LOCK' TokenType.DECLARE' TokenType.LOCAL' TokenType.GLOBAL' TokenType.RETURN' TokenType.SWITCH' TokenType.COPY' TokenType.RENAME' TokenType.DELETE' TokenType.EDIT' TokenType.RUN' TokenType.RUNPATH' TokenType.RUNONCEPATH' TokenType.COMPILE' TokenType.LIST' TokenType.REBOOT' TokenType.SHUTDOWN' TokenType.FOR' TokenType.UNSET' TokenType.CURLYOPEN' TokenType.INTEGER' TokenType.DOUBLE' TokenType.TRUEFALSE' TokenType.IDENTIFIER' TokenType.FILEIDENT' TokenType.BRACKETOPEN' TokenType.STRING' TokenType.ATSIGN); // ZeroOrMore Rule " is 902.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseinstruction_block,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.CURLYCLOSE.ToString()' 0x1001' tok)); " is 153.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseinstruction,The length of the statement  "            tok = scanner.LookAhead(TokenType.EOI' TokenType.SET' TokenType.IF' TokenType.UNTIL' TokenType.FROM' TokenType.UNLOCK' TokenType.PRINT' TokenType.ON' TokenType.TOGGLE' TokenType.WAIT' TokenType.WHEN' TokenType.STAGE' TokenType.CLEARSCREEN' TokenType.ADD' TokenType.REMOVE' TokenType.LOG' TokenType.BREAK' TokenType.PRESERVE' TokenType.PARAMETER' TokenType.FUNCTION' TokenType.LOCK' TokenType.DECLARE' TokenType.LOCAL' TokenType.GLOBAL' TokenType.RETURN' TokenType.SWITCH' TokenType.COPY' TokenType.RENAME' TokenType.DELETE' TokenType.EDIT' TokenType.RUN' TokenType.RUNPATH' TokenType.RUNONCEPATH' TokenType.COMPILE' TokenType.LIST' TokenType.REBOOT' TokenType.SHUTDOWN' TokenType.FOR' TokenType.UNSET' TokenType.CURLYOPEN' TokenType.INTEGER' TokenType.DOUBLE' TokenType.TRUEFALSE' TokenType.IDENTIFIER' TokenType.FILEIDENT' TokenType.BRACKETOPEN' TokenType.STRING' TokenType.ATSIGN); // Choice Rule " is 898.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseinstruction,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected EOI' SET' IF' UNTIL' FROM' UNLOCK' PRINT' ON' TOGGLE' WAIT' WHEN' STAGE' CLEARSCREEN' ADD' REMOVE' LOG' BREAK' PRESERVE' PARAMETER' FUNCTION' LOCK' DECLARE' LOCAL' GLOBAL' RETURN' SWITCH' COPY' RENAME' DELETE' EDIT' RUN' RUNPATH' RUNONCEPATH' COMPILE' LIST' REBOOT' SHUTDOWN' FOR' UNSET' CURLYOPEN' INTEGER' DOUBLE' TRUEFALSE' IDENTIFIER' FILEIDENT' BRACKETOPEN' STRING' or ATSIGN."' 0x0002' tok)); " is 500.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parselazyglobal_directive,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.ATSIGN.ToString()' 0x1001' tok)); " is 149.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parselazyglobal_directive,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.LAZYGLOBAL.ToString()' 0x1001' tok)); " is 153.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parselazyglobal_directive,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseempty_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseset_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.SET.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseset_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.TO.ToString()' 0x1001' tok)); " is 145.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseset_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseif_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.IF.ToString()' 0x1001' tok)); " is 145.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseif_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseif_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.ELSE.ToString()' 0x1001' tok)); " is 147.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseif_stmt,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseuntil_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.UNTIL.ToString()' 0x1001' tok)); " is 148.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseuntil_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsefromloop_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.FROM.ToString()' 0x1001' tok)); " is 147.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsefromloop_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.UNTIL.ToString()' 0x1001' tok)); " is 148.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsefromloop_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.STEP.ToString()' 0x1001' tok)); " is 147.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsefromloop_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.DO.ToString()' 0x1001' tok)); " is 145.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsefromloop_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseunlock_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.UNLOCK.ToString()' 0x1001' tok)); " is 149.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseunlock_stmt,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.IDENTIFIER.ToString()' 0x1001' tok)); " is 153.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseunlock_stmt,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.ALL.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseunlock_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected IDENTIFIER or ALL."' 0x0002' tok)); " is 137.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseunlock_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseprint_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.PRINT.ToString()' 0x1001' tok)); " is 148.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseprint_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.AT.ToString()' 0x1001' tok)); " is 145.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseprint_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString()' 0x1001' tok)); " is 154.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseprint_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.COMMA.ToString()' 0x1001' tok)); " is 148.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseprint_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString()' 0x1001' tok)); " is 155.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseprint_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseon_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.ON.ToString()' 0x1001' tok)); " is 145.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseon_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsetoggle_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.TOGGLE.ToString()' 0x1001' tok)); " is 149.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsetoggle_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsewait_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.WAIT.ToString()' 0x1001' tok)); " is 147.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsewait_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.UNTIL.ToString()' 0x1001' tok)); " is 148.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsewait_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsewhen_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.WHEN.ToString()' 0x1001' tok)); " is 147.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsewhen_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.THEN.ToString()' 0x1001' tok)); " is 147.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsewhen_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseonoff_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseonoff_trailer,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.ON.ToString()' 0x1001' tok)); " is 145.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseonoff_trailer,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.OFF.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseonoff_trailer,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected ON or OFF."' 0x0002' tok)); " is 129.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsestage_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.STAGE.ToString()' 0x1001' tok)); " is 148.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsestage_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseclear_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.CLEARSCREEN.ToString()' 0x1001' tok)); " is 154.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseclear_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseadd_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.ADD.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseadd_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseremove_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.REMOVE.ToString()' 0x1001' tok)); " is 149.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseremove_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parselog_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.LOG.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parselog_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.TO.ToString()' 0x1001' tok)); " is 145.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parselog_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsebreak_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.BREAK.ToString()' 0x1001' tok)); " is 148.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsebreak_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsepreserve_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.PRESERVE.ToString()' 0x1001' tok)); " is 151.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsepreserve_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_identifier_clause,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.IDENTIFIER.ToString()' 0x1001' tok)); " is 153.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_identifier_clause,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.TO.ToString()' 0x1001' tok)); " is 145.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_identifier_clause,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.IS.ToString()' 0x1001' tok)); " is 145.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_identifier_clause,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected TO or IS."' 0x0002' tok)); " is 128.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_identifier_clause,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_parameter_clause,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.PARAMETER.ToString()' 0x1001' tok)); " is 152.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_parameter_clause,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.IDENTIFIER.ToString()' 0x1001' tok)); " is 153.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_parameter_clause,The length of the statement  "                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.TO.ToString()' 0x1001' tok)); " is 145.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_parameter_clause,The length of the statement  "                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.IS.ToString()' 0x1001' tok)); " is 145.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_parameter_clause,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected TO or IS."' 0x0002' tok)); " is 128.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_parameter_clause,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.COMMA.ToString()' 0x1001' tok)); " is 148.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_parameter_clause,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.IDENTIFIER.ToString()' 0x1001' tok)); " is 153.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_parameter_clause,The length of the statement  "                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.TO.ToString()' 0x1001' tok)); " is 145.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_parameter_clause,The length of the statement  "                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.IS.ToString()' 0x1001' tok)); " is 145.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_parameter_clause,The length of the statement  "                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected TO or IS."' 0x0002' tok)); " is 128.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_parameter_clause,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_function_clause,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.FUNCTION.ToString()' 0x1001' tok)); " is 151.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_function_clause,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.IDENTIFIER.ToString()' 0x1001' tok)); " is 153.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_function_clause,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_lock_clause,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.LOCK.ToString()' 0x1001' tok)); " is 147.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_lock_clause,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.IDENTIFIER.ToString()' 0x1001' tok)); " is 153.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_lock_clause,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.TO.ToString()' 0x1001' tok)); " is 145.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_lock_clause,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_stmt,The length of the statement  "            tok = scanner.LookAhead(TokenType.PARAMETER' TokenType.FUNCTION' TokenType.LOCK' TokenType.DECLARE' TokenType.LOCAL' TokenType.GLOBAL); // Choice Rule " is 150.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_stmt,The length of the statement  "                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.DECLARE.ToString()' 0x1001' tok)); " is 150.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_stmt,The length of the statement  "                                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.LOCAL.ToString()' 0x1001' tok)); " is 148.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_stmt,The length of the statement  "                                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.GLOBAL.ToString()' 0x1001' tok)); " is 149.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_stmt,The length of the statement  "                                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected LOCAL or GLOBAL."' 0x0002' tok)); " is 135.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_stmt,The length of the statement  "                                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.LOCAL.ToString()' 0x1001' tok)); " is 148.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_stmt,The length of the statement  "                                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.GLOBAL.ToString()' 0x1001' tok)); " is 149.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_stmt,The length of the statement  "                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected LOCAL or GLOBAL."' 0x0002' tok)); " is 135.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_stmt,The length of the statement  "                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected DECLARE' LOCAL' or GLOBAL."' 0x0002' tok)); " is 145.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_stmt,The length of the statement  "                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected PARAMETER' FUNCTION' IDENTIFIER' or LOCK."' 0x0002' tok)); " is 160.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected PARAMETER' FUNCTION' LOCK' DECLARE' LOCAL' or GLOBAL."' 0x0002' tok)); " is 172.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsereturn_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.RETURN.ToString()' 0x1001' tok)); " is 149.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsereturn_stmt,The length of the statement  "            tok = scanner.LookAhead(TokenType.PLUSMINUS' TokenType.NOT' TokenType.DEFINED' TokenType.INTEGER' TokenType.DOUBLE' TokenType.TRUEFALSE' TokenType.IDENTIFIER' TokenType.FILEIDENT' TokenType.BRACKETOPEN' TokenType.STRING' TokenType.CURLYOPEN); // Option Rule " is 257.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsereturn_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseswitch_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.SWITCH.ToString()' 0x1001' tok)); " is 149.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseswitch_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.TO.ToString()' 0x1001' tok)); " is 145.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseswitch_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsecopy_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.COPY.ToString()' 0x1001' tok)); " is 147.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsecopy_stmt,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.FROM.ToString()' 0x1001' tok)); " is 147.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsecopy_stmt,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.TO.ToString()' 0x1001' tok)); " is 145.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsecopy_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected FROM or TO."' 0x0002' tok)); " is 130.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsecopy_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserename_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.RENAME.ToString()' 0x1001' tok)); " is 149.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserename_stmt,The length of the statement  "                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.VOLUME.ToString()' 0x1001' tok)); " is 149.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserename_stmt,The length of the statement  "                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.FILE.ToString()' 0x1001' tok)); " is 147.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserename_stmt,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected VOLUME or FILE."' 0x0002' tok)); " is 134.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserename_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.TO.ToString()' 0x1001' tok)); " is 145.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserename_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedelete_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.DELETE.ToString()' 0x1001' tok)); " is 149.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedelete_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.FROM.ToString()' 0x1001' tok)); " is 147.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedelete_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseedit_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EDIT.ToString()' 0x1001' tok)); " is 147.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseedit_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserun_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.RUN.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserun_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.ONCE.ToString()' 0x1001' tok)); " is 147.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserun_stmt,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.FILEIDENT.ToString()' 0x1001' tok)); " is 152.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserun_stmt,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.STRING.ToString()' 0x1001' tok)); " is 149.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserun_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected FILEIDENT or STRING."' 0x0002' tok)); " is 139.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserun_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString()' 0x1001' tok)); " is 154.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserun_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString()' 0x1001' tok)); " is 155.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserun_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.ON.ToString()' 0x1001' tok)); " is 145.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserun_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserunpath_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.RUNPATH.ToString()' 0x1001' tok)); " is 150.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserunpath_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString()' 0x1001' tok)); " is 154.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserunpath_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.COMMA.ToString()' 0x1001' tok)); " is 148.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserunpath_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString()' 0x1001' tok)); " is 155.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserunpath_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserunoncepath_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.RUNONCEPATH.ToString()' 0x1001' tok)); " is 154.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserunoncepath_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString()' 0x1001' tok)); " is 154.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserunoncepath_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.COMMA.ToString()' 0x1001' tok)); " is 148.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserunoncepath_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString()' 0x1001' tok)); " is 155.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parserunoncepath_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsecompile_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.COMPILE.ToString()' 0x1001' tok)); " is 150.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsecompile_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.TO.ToString()' 0x1001' tok)); " is 145.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsecompile_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parselist_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.LIST.ToString()' 0x1001' tok)); " is 147.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parselist_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.IDENTIFIER.ToString()' 0x1001' tok)); " is 153.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parselist_stmt,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.IN.ToString()' 0x1001' tok)); " is 145.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parselist_stmt,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.IDENTIFIER.ToString()' 0x1001' tok)); " is 153.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parselist_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsereboot_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.REBOOT.ToString()' 0x1001' tok)); " is 149.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsereboot_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseshutdown_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.SHUTDOWN.ToString()' 0x1001' tok)); " is 151.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseshutdown_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsefor_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.FOR.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsefor_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.IDENTIFIER.ToString()' 0x1001' tok)); " is 153.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsefor_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.IN.ToString()' 0x1001' tok)); " is 145.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsefor_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseunset_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.UNSET.ToString()' 0x1001' tok)); " is 148.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseunset_stmt,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.IDENTIFIER.ToString()' 0x1001' tok)); " is 153.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseunset_stmt,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.ALL.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseunset_stmt,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected IDENTIFIER or ALL."' 0x0002' tok)); " is 137.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseunset_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsearglist,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.COMMA.ToString()' 0x1001' tok)); " is 148.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseexpr,The length of the statement  "            tok = scanner.LookAhead(TokenType.PLUSMINUS' TokenType.NOT' TokenType.DEFINED' TokenType.INTEGER' TokenType.DOUBLE' TokenType.TRUEFALSE' TokenType.IDENTIFIER' TokenType.FILEIDENT' TokenType.BRACKETOPEN' TokenType.STRING' TokenType.CURLYOPEN); // Choice Rule " is 257.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseexpr,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected PLUSMINUS' NOT' DEFINED' INTEGER' DOUBLE' TRUEFALSE' IDENTIFIER' FILEIDENT' BRACKETOPEN' STRING' or CURLYOPEN."' 0x0002' tok)); " is 229.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseor_expr,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.OR.ToString()' 0x1001' tok)); " is 145.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseand_expr,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.AND.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsecompare_expr,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.COMPARATOR.ToString()' 0x1001' tok)); " is 153.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsearith_expr,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.PLUSMINUS.ToString()' 0x1001' tok)); " is 152.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsemultdiv_expr,The length of the statement  "                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.MULT.ToString()' 0x1001' tok)); " is 147.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsemultdiv_expr,The length of the statement  "                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.DIV.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsemultdiv_expr,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected MULT or DIV."' 0x0002' tok)); " is 131.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseunary_expr,The length of the statement  "                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.PLUSMINUS.ToString()' 0x1001' tok)); " is 152.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseunary_expr,The length of the statement  "                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.NOT.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseunary_expr,The length of the statement  "                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.DEFINED.ToString()' 0x1001' tok)); " is 150.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseunary_expr,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected PLUSMINUS' NOT' or DEFINED."' 0x0002' tok)); " is 146.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsefactor,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.POWER.ToString()' 0x1001' tok)); " is 148.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsesuffix_trailer,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.COLON.ToString()' 0x1001' tok)); " is 148.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsesuffixterm,The length of the statement  "            tok = scanner.LookAhead(TokenType.BRACKETOPEN' TokenType.ATSIGN' TokenType.ARRAYINDEX' TokenType.SQUAREOPEN); // ZeroOrMore Rule " is 128.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsesuffixterm,The length of the statement  "            tok = scanner.LookAhead(TokenType.BRACKETOPEN' TokenType.ATSIGN' TokenType.ARRAYINDEX' TokenType.SQUAREOPEN); // ZeroOrMore Rule " is 128.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsesuffixterm_trailer,The length of the statement  "            tok = scanner.LookAhead(TokenType.BRACKETOPEN' TokenType.ATSIGN' TokenType.ARRAYINDEX' TokenType.SQUAREOPEN); // Choice Rule " is 124.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsesuffixterm_trailer,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected BRACKETOPEN' ATSIGN' ARRAYINDEX' or SQUAREOPEN."' 0x0002' tok)); " is 166.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsefunction_trailer,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString()' 0x1001' tok)); " is 154.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsefunction_trailer,The length of the statement  "                    tok = scanner.LookAhead(TokenType.PLUSMINUS' TokenType.NOT' TokenType.DEFINED' TokenType.INTEGER' TokenType.DOUBLE' TokenType.TRUEFALSE' TokenType.IDENTIFIER' TokenType.FILEIDENT' TokenType.BRACKETOPEN' TokenType.STRING' TokenType.CURLYOPEN); // Option Rule " is 257.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsefunction_trailer,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString()' 0x1001' tok)); " is 155.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsefunction_trailer,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.ATSIGN.ToString()' 0x1001' tok)); " is 149.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsefunction_trailer,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected BRACKETOPEN or ATSIGN."' 0x0002' tok)); " is 141.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsearray_trailer,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.ARRAYINDEX.ToString()' 0x1001' tok)); " is 153.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsearray_trailer,The length of the statement  "                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.IDENTIFIER.ToString()' 0x1001' tok)); " is 153.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsearray_trailer,The length of the statement  "                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.INTEGER.ToString()' 0x1001' tok)); " is 150.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsearray_trailer,The length of the statement  "                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected IDENTIFIER or INTEGER."' 0x0002' tok)); " is 141.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsearray_trailer,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.SQUAREOPEN.ToString()' 0x1001' tok)); " is 153.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsearray_trailer,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.SQUARECLOSE.ToString()' 0x1001' tok)); " is 154.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsearray_trailer,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected ARRAYINDEX or SQUAREOPEN."' 0x0002' tok)); " is 144.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseatom,The length of the statement  "            tok = scanner.LookAhead(TokenType.INTEGER' TokenType.DOUBLE' TokenType.TRUEFALSE' TokenType.IDENTIFIER' TokenType.FILEIDENT' TokenType.BRACKETOPEN' TokenType.STRING); // Choice Rule " is 181.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseatom,The length of the statement  "                    tok = scanner.LookAhead(TokenType.INTEGER' TokenType.DOUBLE' TokenType.TRUEFALSE' TokenType.IDENTIFIER' TokenType.FILEIDENT' TokenType.BRACKETOPEN); // Choice Rule " is 163.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseatom,The length of the statement  "                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.TRUEFALSE.ToString()' 0x1001' tok)); " is 152.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseatom,The length of the statement  "                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.IDENTIFIER.ToString()' 0x1001' tok)); " is 153.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseatom,The length of the statement  "                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.FILEIDENT.ToString()' 0x1001' tok)); " is 152.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseatom,The length of the statement  "                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString()' 0x1001' tok)); " is 154.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseatom,The length of the statement  "                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString()' 0x1001' tok)); " is 155.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseatom,The length of the statement  "                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected INTEGER' DOUBLE' TRUEFALSE' IDENTIFIER' FILEIDENT' or BRACKETOPEN."' 0x0002' tok)); " is 185.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseatom,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.STRING.ToString()' 0x1001' tok)); " is 149.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseatom,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected INTEGER' DOUBLE' TRUEFALSE' IDENTIFIER' FILEIDENT' BRACKETOPEN' or STRING."' 0x0002' tok)); " is 193.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsesci_number,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.E.ToString()' 0x1001' tok)); " is 144.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsesci_number,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.PLUSMINUS.ToString()' 0x1001' tok)); " is 152.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsesci_number,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.INTEGER.ToString()' 0x1001' tok)); " is 150.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsenumber,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.INTEGER.ToString()' 0x1001' tok)); " is 150.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsenumber,The length of the statement  "                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.DOUBLE.ToString()' 0x1001' tok)); " is 149.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsenumber,The length of the statement  "                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected INTEGER or DOUBLE."' 0x0002' tok)); " is 137.
Long Statement,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseidentifier_led_stmt,The length of the statement  "                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n"' "") + "' found. Expected " + TokenType.EOI.ToString()' 0x1001' tok)); " is 146.
Long Statement,kOS.Safe.Encapsulation.Suffixes,DelegateSuffixResult,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Suffixes\DelegateSuffixResult.cs,Invoke,The length of the statement  "                        throw new Exception(string.Format("Argument {0}({1}) to method {2} should be {3} instead of {4}."' (delInfo.Parameters.Length - i)' arg' delInfo.Name' paramType.Name' argType)); " is 177.
Long Statement,kOS.Safe.Encapsulation.Suffixes,SetSuffix<TValue>,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Suffixes\SetSuffix.cs,Set,The length of the statement  "                Structure newValue = Structure.FromPrimitiveWithAssert(value);  // Handles converting built in types to Structures that Convert.ChangeType() can't. " is 147.
Long Statement,kOS.Safe.Execution,CPU,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Execution\CPU.cs,SaveAndClearPointers,The length of the statement  "            var pointers = new List<KeyValuePair<string' Variable>>(globalVariables.Locals.Where(entry => StringUtil.EndsWith(entry.Key' "*"))); " is 132.
Long Statement,kOS.Safe.Execution,CPU,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Execution\CPU.cs,RestorePointers,The length of the statement  "            SafeHouse.Logger.Log(string.Format("Deleting {0} pointers and restoring {1} pointers"' deletedPointers' restoredPointers)); " is 123.
Long Statement,kOS.Safe.Execution,CPU,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Execution\CPU.cs,BreakExecution,The length of the statement  "            SafeHouse.Logger.Log(string.Format("Breaking Execution {0} Contexts: {1}"' manual ? "Manually" : "Automatically"' contexts.Count)); " is 131.
Long Statement,kOS.Safe.Execution,CPU,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Execution\CPU.cs,BreakExecution,The length of the statement  "                    shared.SoundMaker.StopAllVoices(); // stop voices if execution was manually broken' but not if the program ends normally " is 120.
Long Statement,kOS.Safe.Execution,CPU,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Execution\CPU.cs,ProcessTriggers,The length of the statement  "                        // Reverse-push the closure's scope record' if there is one' just after the function return context got put on the stack. " is 121.
Long Statement,kOS.Safe.Execution,CPU,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Execution\CPU.cs,ProcessTriggers,The length of the statement  "                            for (int argIndex = trigger.Args.Count - 1; argIndex >= 0 ; --argIndex) // TODO test with more than 1 arg to see if this is the right order! " is 140.
Long Statement,kOS.Safe.Execution,CPU,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Execution\CPU.cs,ContinueExecution,The length of the statement  "            executeLog.Remove(0' executeLog.Length); // In .net 2.0' StringBuilder had no Clear()' which is what this is simulating. " is 120.
Long Statement,kOS.Safe.Execution,CPU,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Execution\CPU.cs,ExecuteInstruction,The length of the statement  "                executeLog.Append(string.Format("Executing Opcode {0:0000}/{1:0000} {2} {3}\n"' context.InstructionPointer' context.Program.Count' opcode.Label' opcode)); " is 154.
Long Statement,kOS.Safe.Execution,CPU,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Execution\CPU.cs,StatisticsDump,The length of the statement  "            sb.Append(string.Format("{0}{0}{0}{0}Most Mainline instructions in one update: {0}{1}\n"' delimiter' maxMainlineInstructionsSoFar)); " is 132.
Long Statement,kOS.Safe.Execution,ProgramContext,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Execution\ProgramContext.cs,GetCodeFragment,The length of the statement  "            profileFragment.Add(string.Format(PROFILE_FORMAT_STR' codeFragment[0].PadRight(longestLength)' "Total ms"' "Count"' "Average ms")); " is 131.
Long Statement,kOS.Safe.Execution,ProgramContext,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Execution\ProgramContext.cs,GetCodeFragment,The length of the statement  "            profileFragment.Add(string.Format(PROFILE_FORMAT_STR' codeFragment[1].PadRight(longestLength)' "========"' "====="' "==========")); " is 131.
Long Statement,kOS.Safe.Execution,Stack,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Execution\Stack.cs,PeekCheckArgument,The length of the statement  "                throw new KOSYouShouldNeverSeeThisException("Somewhere the kOS developers are still using a negative stack peek instead of PeekCheckScope"); " is 140.
Long Statement,kOS.Safe.Execution,Stack,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Execution\Stack.cs,dumpItem,The length of the statement  "                    builder.AppendFormat("            local var {0} is {1} with value = {2}"' entry.Key' KOSNomenclature.GetKOSName(entry.Value.GetType())' entry.Value); " is 149.
Long Statement,kOS.Safe.Execution,SubroutineContext,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Execution\SurboutineContext.cs,ToString,The length of the statement  "            return string.Format("SubroutineContext: {{CameFromInstPtr {0}' {1}TriggerPointer {2}}}"' CameFromInstPtr' (IsCancelled ? "(cancelled) " : "")' Trigger); " is 153.
Long Statement,kOS.Safe.Function,SafeFunctionBase,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Function\SafeFunctionBase.cs,GetFuncName,The length of the statement  "            string funcName = "<unknown function name>"; // hopefully this cannot ever get seen by the user because of the next lines. " is 122.
Long Statement,kOS.Safe.Function,SafeFunctionBase,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Function\SafeFunctionBase.cs,GetFuncName,The length of the statement  "            FunctionAttribute attr = (FunctionAttribute)GetType().GetCustomAttributes(typeof(FunctionAttribute)' true).FirstOrDefault(); " is 124.
Long Statement,kOS.Safe.Function,FunctionLoad,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Function\Misc.cs,Execute,The length of the statement  "            VolumeFile file = volume.Open(path' !justCompiling) as VolumeFile; // if running' look for KSM first.  If compiling look for KS first. " is 134.
Long Statement,kOS.Safe.Function,FunctionLoad,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Function\Misc.cs,Execute,The length of the statement  "                    shared.Cpu.YieldProgram(YieldFinishedCompile.CompileScriptToFile(path' 1' fileContent.String' options' volume' outPath)); " is 121.
Long Statement,kOS.Safe.Function,FunctionRenameFileDeprecated,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Function\Persistence.cs,Execute,The length of the statement  "                string.Format("WARNING: RENAME FILE {0} TO {1} is deprecated as of kOS v1.0.0.  Use MOVEPATH(\"{2}\"' \"{3}\") instead."' " is 121.
Long Statement,kOS.Safe.Function,FunctionRenameVolumeDeprecated,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Function\Persistence.cs,Execute,The length of the statement  "                string.Format("WARNING: RENAME VOLUME {0} TO {1} is deprecated as of kOS v1.0.0.  Use SET VOLUME({2}):NAME TO \"{3}\" instead."' " is 128.
Long Statement,kOS.Safe.Function,FunctionReadJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Function\Persistence.cs,Execute,The length of the statement  "            Structure read = new SafeSerializationMgr(shared).Deserialize(volumeFile.ReadAll().String' JsonFormatter.ReaderInstance) as SerializableStructure; " is 146.
Long Statement,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The length of the statement  "                            if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint))) " is 130.
Long Statement,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The length of the statement  "                                    if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint)) " is 163.
Long Statement,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseNumber,The length of the statement  "            if (str.IndexOf("."' StringComparison.OrdinalIgnoreCase) != -1 || str.IndexOf("e"' StringComparison.OrdinalIgnoreCase) != -1) " is 125.
Long Statement,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseNumber,The length of the statement  "                success = double.TryParse(new string(json' index' charLength)' NumberStyles.Any' CultureInfo.InvariantCulture' out number); " is 123.
Long Statement,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseNumber,The length of the statement  "                success = long.TryParse(new string(json' index' charLength)' NumberStyles.Any' CultureInfo.InvariantCulture' out number); " is 121.
Long Statement,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The length of the statement  "                if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e') " is 127.
Long Statement,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The length of the statement  "                            if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint))) " is 130.
Long Statement,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The length of the statement  "                                    if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint)) " is 163.
Long Statement,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseNumber,The length of the statement  "            if (str.IndexOf("."' StringComparison.OrdinalIgnoreCase) != -1 || str.IndexOf("e"' StringComparison.OrdinalIgnoreCase) != -1) " is 125.
Long Statement,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseNumber,The length of the statement  "                success = double.TryParse(new string(json' index' charLength)' NumberStyles.Any' CultureInfo.InvariantCulture' out number); " is 123.
Long Statement,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseNumber,The length of the statement  "                success = long.TryParse(new string(json' index' charLength)' NumberStyles.Any' CultureInfo.InvariantCulture' out number); " is 121.
Long Statement,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The length of the statement  "                if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e') " is 127.
Long Statement,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,SetterValueFactory,The length of the statement  "            IDictionary<string' KeyValuePair<Type' ReflectionUtils.SetDelegate>> result = new Dictionary<string' KeyValuePair<Type' ReflectionUtils.SetDelegate>>(); " is 152.
Long Statement,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,SetterValueFactory,The length of the statement  "                    result[MapClrMemberNameToJsonFieldName(propertyInfo.Name)] = new KeyValuePair<Type' ReflectionUtils.SetDelegate>(propertyInfo.PropertyType' ReflectionUtils.GetSetMethod(propertyInfo)); " is 184.
Long Statement,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,SetterValueFactory,The length of the statement  "                result[MapClrMemberNameToJsonFieldName(fieldInfo.Name)] = new KeyValuePair<Type' ReflectionUtils.SetDelegate>(fieldInfo.FieldType' ReflectionUtils.GetSetMethod(fieldInfo)); " is 172.
Long Statement,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The length of the statement  "                    if (type == typeof(DateTime) || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(DateTime))) " is 127.
Long Statement,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The length of the statement  "                        return DateTime.ParseExact(str' Iso8601Format' CultureInfo.InvariantCulture' DateTimeStyles.AssumeUniversal | DateTimeStyles.AdjustToUniversal); " is 144.
Long Statement,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The length of the statement  "                    if (type == typeof(DateTimeOffset) || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(DateTimeOffset))) " is 139.
Long Statement,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The length of the statement  "                        return DateTimeOffset.ParseExact(str' Iso8601Format' CultureInfo.InvariantCulture' DateTimeStyles.AssumeUniversal | DateTimeStyles.AdjustToUniversal); " is 150.
Long Statement,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The length of the statement  "                obj = type == typeof(int) || type == typeof(long) || type == typeof(double) || type == typeof(float) || type == typeof(bool) || type == typeof(decimal) || type == typeof(byte) || type == typeof(short) " is 200.
Long Statement,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The length of the statement  "                        else if (ReflectionUtils.IsTypeGenericeCollectionInterface(type) || ReflectionUtils.IsAssignableFrom(typeof(IList)' type)) " is 122.
Long Statement,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The length of the statement  "                            list = (IList)(ConstructorCache[type] ?? ConstructorCache[typeof(List<>).MakeGenericType(innerType)])(jsonObject.Count); " is 120.
Long Statement,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,SetterValueFactory,The length of the statement  "            IDictionary<string' KeyValuePair<Type' ReflectionUtils.SetDelegate>> result = new Dictionary<string' KeyValuePair<Type' ReflectionUtils.SetDelegate>>(); " is 152.
Long Statement,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,SetterValueFactory,The length of the statement  "                    result[MapClrMemberNameToJsonFieldName(propertyInfo.Name)] = new KeyValuePair<Type' ReflectionUtils.SetDelegate>(propertyInfo.PropertyType' ReflectionUtils.GetSetMethod(propertyInfo)); " is 184.
Long Statement,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,SetterValueFactory,The length of the statement  "                result[MapClrMemberNameToJsonFieldName(fieldInfo.Name)] = new KeyValuePair<Type' ReflectionUtils.SetDelegate>(fieldInfo.FieldType' ReflectionUtils.GetSetMethod(fieldInfo)); " is 172.
Long Statement,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The length of the statement  "                    if (type == typeof(DateTime) || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(DateTime))) " is 127.
Long Statement,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The length of the statement  "                        return DateTime.ParseExact(str' Iso8601Format' CultureInfo.InvariantCulture' DateTimeStyles.AssumeUniversal | DateTimeStyles.AdjustToUniversal); " is 144.
Long Statement,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The length of the statement  "                    if (type == typeof(DateTimeOffset) || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(DateTimeOffset))) " is 139.
Long Statement,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The length of the statement  "                        return DateTimeOffset.ParseExact(str' Iso8601Format' CultureInfo.InvariantCulture' DateTimeStyles.AssumeUniversal | DateTimeStyles.AdjustToUniversal); " is 150.
Long Statement,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The length of the statement  "                obj = type == typeof(int) || type == typeof(long) || type == typeof(double) || type == typeof(float) || type == typeof(bool) || type == typeof(decimal) || type == typeof(byte) || type == typeof(short) " is 200.
Long Statement,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The length of the statement  "                        else if (ReflectionUtils.IsTypeGenericeCollectionInterface(type) || ReflectionUtils.IsAssignableFrom(typeof(IList)' type)) " is 122.
Long Statement,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The length of the statement  "                            list = (IList)(ConstructorCache[type] ?? ConstructorCache[typeof(List<>).MakeGenericType(innerType)])(jsonObject.Count); " is 120.
Long Statement,kOS.Safe,ReflectionUtils,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ToNullableType,The length of the statement  "                return obj == null ? null : Convert.ChangeType(obj' Nullable.GetUnderlyingType(nullableType)' CultureInfo.InvariantCulture); " is 124.
Long Statement,kOS.Safe,ReflectionUtils,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,GetGetMethodByExpression,The length of the statement  "                UnaryExpression instanceCast = (!IsValueType(propertyInfo.DeclaringType)) ? Expression.TypeAs(instance' propertyInfo.DeclaringType) : Expression.Convert(instance' propertyInfo.DeclaringType); " is 191.
Long Statement,kOS.Safe,ReflectionUtils,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,GetGetMethodByExpression,The length of the statement  "                Func<object' object> compiled = Expression.Lambda<Func<object' object>>(Expression.TypeAs(Expression.Call(instanceCast' getMethodInfo)' typeof(object))' instance).Compile(); " is 173.
Long Statement,kOS.Safe,ReflectionUtils,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,GetSetMethodByExpression,The length of the statement  "                UnaryExpression instanceCast = (!IsValueType(propertyInfo.DeclaringType)) ? Expression.TypeAs(instance' propertyInfo.DeclaringType) : Expression.Convert(instance' propertyInfo.DeclaringType); " is 191.
Long Statement,kOS.Safe,ReflectionUtils,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,GetSetMethodByExpression,The length of the statement  "                UnaryExpression valueCast = (!IsValueType(propertyInfo.PropertyType)) ? Expression.TypeAs(value' propertyInfo.PropertyType) : Expression.Convert(value' propertyInfo.PropertyType); " is 179.
Long Statement,kOS.Safe,ReflectionUtils,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,GetSetMethodByExpression,The length of the statement  "                Action<object' object> compiled = Expression.Lambda<Action<object' object>>(Expression.Call(instanceCast' setMethodInfo' valueCast)' new ParameterExpression[] { instance' value }).Compile(); " is 190.
Long Statement,kOS.Safe,ReflectionUtils,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,GetSetMethodByExpression,The length of the statement  "                    Assign(Expression.Field(Expression.Convert(instance' fieldInfo.DeclaringType)' fieldInfo)' Expression.Convert(value' fieldInfo.FieldType))' instance' value).Compile(); " is 167.
Long Statement,kOS.Safe,ReflectionUtils,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ToNullableType,The length of the statement  "                return obj == null ? null : Convert.ChangeType(obj' Nullable.GetUnderlyingType(nullableType)' CultureInfo.InvariantCulture); " is 124.
Long Statement,kOS.Safe,ReflectionUtils,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,GetGetMethodByExpression,The length of the statement  "                UnaryExpression instanceCast = (!IsValueType(propertyInfo.DeclaringType)) ? Expression.TypeAs(instance' propertyInfo.DeclaringType) : Expression.Convert(instance' propertyInfo.DeclaringType); " is 191.
Long Statement,kOS.Safe,ReflectionUtils,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,GetGetMethodByExpression,The length of the statement  "                Func<object' object> compiled = Expression.Lambda<Func<object' object>>(Expression.TypeAs(Expression.Call(instanceCast' getMethodInfo)' typeof(object))' instance).Compile(); " is 173.
Long Statement,kOS.Safe,ReflectionUtils,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,GetSetMethodByExpression,The length of the statement  "                UnaryExpression instanceCast = (!IsValueType(propertyInfo.DeclaringType)) ? Expression.TypeAs(instance' propertyInfo.DeclaringType) : Expression.Convert(instance' propertyInfo.DeclaringType); " is 191.
Long Statement,kOS.Safe,ReflectionUtils,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,GetSetMethodByExpression,The length of the statement  "                UnaryExpression valueCast = (!IsValueType(propertyInfo.PropertyType)) ? Expression.TypeAs(value' propertyInfo.PropertyType) : Expression.Convert(value' propertyInfo.PropertyType); " is 179.
Long Statement,kOS.Safe,ReflectionUtils,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,GetSetMethodByExpression,The length of the statement  "                Action<object' object> compiled = Expression.Lambda<Action<object' object>>(Expression.Call(instanceCast' setMethodInfo' valueCast)' new ParameterExpression[] { instance' value }).Compile(); " is 190.
Long Statement,kOS.Safe,ReflectionUtils,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,GetSetMethodByExpression,The length of the statement  "                    Assign(Expression.Field(Expression.Convert(instance' fieldInfo.DeclaringType)' fieldInfo)' Expression.Convert(value' fieldInfo.FieldType))' instance' value).Compile(); " is 167.
Long Statement,kOS.Safe,PathValue,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Persistence\PathValue.cs,InitializeSuffixes,The length of the statement  "            AddSuffix("SEGMENTS"' new Suffix<ListValue>(() => new ListValue(Path.Segments.Select((s) => (Structure)new StringValue(s))))); " is 126.
Long Statement,kOS.Safe.Persistence,Archive,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Persistence\Archive.cs,Open,The length of the statement  "                    VolumePath filePath = VolumePath.FromString(fileSystemInfo.FullName.Substring(ArchiveFolder.Length).Replace(Path.DirectorySeparatorChar' VolumePath.PathSeparator)); " is 164.
Long Statement,kOS.Safe.Persistence,PersistenceUtilities,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Persistence\PersistenceUtilities.cs,IdentifyCategory,The length of the statement  "                bool isAscii = firstFour.All(b => b == (byte)'\n' || b == (byte)'\t' || b == (byte)'\r' || (b >= (byte)32 && b <= (byte)127)); " is 126.
Long Statement,kOS.Safe.Persistence,PersistenceUtilities,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Persistence\PersistenceUtilities.cs,CookedFilename,The length of the statement  "            if (lastDotIndex == lastSlashIndex + 1) // lastSlashIndex == -1 if no slashes so this also covers just passing in ".foo". " is 121.
Long Statement,kOS.Safe.Persistence,PersistenceUtilities,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Persistence\PersistenceUtilities.cs,CookedFilename,The length of the statement  "            if (lastDotIndex < 0 || lastDotIndex < lastSlashIndex) // If no dot in the tail part of the filename after any potential directory separators. " is 142.
Long Statement,kOS.Safe.Persistence,PersistenceUtilities,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Persistence\PersistenceUtilities.cs,DecodeLine,The length of the statement  "                    inputPos = semicolonPos; // skip to the end of the encoding section' as if everything between '&' and ';' was one char of input. " is 128.
Long Statement,kOS.Safe.Persistence,GlobalPath,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Persistence\GlobalPath.cs,ChangeExtension,The length of the statement  "                throw new KOSInvalidPathException("This path points to the root directory' you can't change its extension"' this.ToString()); " is 125.
Long Statement,kOS.Safe.Screen,ScreenBuffer,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Screen\ScreenBuffer.cs,GetBuffer,The length of the statement  "            int extraPadRows = Math.Max(0' (topRow + RowCount) - buffer.Count); // When screen extends past the buffer bottom.' this is needed to prevent GetRange() exception. " is 163.
Long Statement,kOS.Safe.Screen,ScreenBuffer,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Screen\ScreenBuffer.cs,DebugDump,The length of the statement  "            sb.Append("DebugDump ScreenBuffer: RowCount=" + RowCount + "' ColumnCount=" + ColumnCount + "' topRow=" + topRow + "' buffer.count=" + buffer.Count + "\n"); " is 156.
Long Statement,kOS.Safe.Screen,SubBuffer,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Screen\SubBuffer.cs,ResizeBuffer,The length of the statement  "            // Reset the subbuffer row size since the new size might have had to grow (i.e. shrinking the width of a 80 col to 60 col so wrap text added a row.) " is 148.
Long Statement,kOS.Safe.Screen,SubBuffer,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Screen\SubBuffer.cs,ResizeBuffer,The length of the statement  "            // Because Buffer is readonly' copy the data from newBuffer into it rather than just resetting the reference to newBuffer: " is 122.
Long Statement,kOS.Safe.Screen,TextEditor,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Screen\TextEditor.cs,RemoveChar,The length of the statement  "                    MarkRowsDirty(LineSubBuffer.PositionRow' LineSubBuffer.RowCount); // just in case removing it reduces the number of subbuffer lines. " is 132.
Long Statement,kOS.Safe.Utilities,AssemblyWalkAttribute,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Utilities\AssemblyWalkAttribute.cs,LoadWalkAttribute,The length of the statement  "                                string message = string.Format("Found AssemblyWalkAttribute on type {0} but the specified StaticRegisterMethod does not accept parameters of types {1} and Type"' " is 161.
Long Statement,kOS.Safe.Utilities,AssemblyWalkAttribute,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Utilities\AssemblyWalkAttribute.cs,LoadWalkAttribute,The length of the statement  "                                string message = string.Format("Found AssemblyWalkAttribute on type {0} but the specified StaticRegisterMethod does not accept parameters of type Type"' " is 152.
Long Statement,kOS.Safe.Utilities,AssemblyWalkAttribute,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Utilities\AssemblyWalkAttribute.cs,LoadWalkAttribute,The length of the statement  "                            string message = string.Format("Found AssemblyWalkAttribute on type {0} but the specified StaticWalkMethod does not accept zero parameters"' " is 140.
Long Statement,kOS.Safe.Utilities,AssemblyWalkAttribute,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Utilities\AssemblyWalkAttribute.cs,LoadWalkAttribute,The length of the statement  "                        string message = string.Format("Found AssemblyWalkAttribute on type {0} but neither StaticRegisterMethod nor StaticWalkMethod are specified"' " is 141.
Long Statement,kOS.Safe.Utilities,AssemblyWalkAttribute,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Utilities\AssemblyWalkAttribute.cs,WalkAssembly,The length of the statement  "                        var managerRegisterMethod = managerType.GetMethod(walkAttribute.StaticRegisterMethod' BindingFlags.Static | BindingFlags.Public); " is 129.
Long Statement,kOS.Safe.Utilities,AssemblyWalkAttribute,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Utilities\AssemblyWalkAttribute.cs,WalkAssembly,The length of the statement  "                                            string message = string.Format("Attribute {0} found on type {1}' but type does not implement the required interface {2}"' " is 121.
Long Statement,kOS.Safe.Utilities,AssemblyWalkAttribute,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Utilities\AssemblyWalkAttribute.cs,WalkAssembly,The length of the statement  "                                            string message = string.Format("Attribute {0} found on type {1}' but type does not inherrit from the required type {2}"' " is 120.
Long Statement,kOS.Safe.Utilities,Debug,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Utilities\Debug.cs,GetCodeFragment,The length of the statement  "            codeFragment.Add(string.Format(FORMAT_STR' "File"' "Line"' "Col"' "IP  "' "Label  "' "opcode"' "operand"' "Destination" )); " is 123.
Long Statement,kOS.Safe.Utilities,Debug,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Utilities\Debug.cs,GetCodeFragment,The length of the statement  "            codeFragment.Add(string.Format(FORMAT_STR' "----"' "----"' "---"' "----"' "-------"' "---------------------"' ""' "" )); " is 120.
Long Statement,kOS.Safe.Utilities,KOSNomenclature,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Utilities\KOSNomenclature.cs,PopulateType,The length of the statement  "                    string msg = "kOS developer error: name clash in KOSNomenclature: two mappings from C# class " + t.FullName + " found."; " is 120.
Long Statement,kOS.Safe.Utilities,KOSNomenclature,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Utilities\KOSNomenclature.cs,PopulateType,The length of the statement  "                    string msg = "kOS developer error: name clash in KOSNomenclature: two mappings from KOS name " + attrib.KOSName + " found."; " is 124.
Long Statement,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The length of the statement  "                            if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint))) " is 130.
Long Statement,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The length of the statement  "                                    if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint)) " is 163.
Long Statement,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseNumber,The length of the statement  "            if (str.IndexOf("."' StringComparison.OrdinalIgnoreCase) != -1 || str.IndexOf("e"' StringComparison.OrdinalIgnoreCase) != -1) " is 125.
Long Statement,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseNumber,The length of the statement  "                success = double.TryParse(new string(json' index' charLength)' NumberStyles.Any' CultureInfo.InvariantCulture' out number); " is 123.
Long Statement,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseNumber,The length of the statement  "                success = long.TryParse(new string(json' index' charLength)' NumberStyles.Any' CultureInfo.InvariantCulture' out number); " is 121.
Long Statement,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The length of the statement  "                if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e') " is 127.
Long Statement,Reflection,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,SetterValueFactory,The length of the statement  "            IDictionary<string' KeyValuePair<Type' ReflectionUtils.SetDelegate>> result = new Dictionary<string' KeyValuePair<Type' ReflectionUtils.SetDelegate>>(); " is 152.
Long Statement,Reflection,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,SetterValueFactory,The length of the statement  "                    result[MapClrMemberNameToJsonFieldName(propertyInfo.Name)] = new KeyValuePair<Type' ReflectionUtils.SetDelegate>(propertyInfo.PropertyType' ReflectionUtils.GetSetMethod(propertyInfo)); " is 184.
Long Statement,Reflection,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,SetterValueFactory,The length of the statement  "                result[MapClrMemberNameToJsonFieldName(fieldInfo.Name)] = new KeyValuePair<Type' ReflectionUtils.SetDelegate>(fieldInfo.FieldType' ReflectionUtils.GetSetMethod(fieldInfo)); " is 172.
Long Statement,Reflection,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The length of the statement  "                    if (type == typeof(DateTime) || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(DateTime))) " is 127.
Long Statement,Reflection,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The length of the statement  "                        return DateTime.ParseExact(str' Iso8601Format' CultureInfo.InvariantCulture' DateTimeStyles.AssumeUniversal | DateTimeStyles.AdjustToUniversal); " is 144.
Long Statement,Reflection,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The length of the statement  "                    if (type == typeof(DateTimeOffset) || (ReflectionUtils.IsNullableType(type) && Nullable.GetUnderlyingType(type) == typeof(DateTimeOffset))) " is 139.
Long Statement,Reflection,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The length of the statement  "                        return DateTimeOffset.ParseExact(str' Iso8601Format' CultureInfo.InvariantCulture' DateTimeStyles.AssumeUniversal | DateTimeStyles.AdjustToUniversal); " is 150.
Long Statement,Reflection,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The length of the statement  "                obj = type == typeof(int) || type == typeof(long) || type == typeof(double) || type == typeof(float) || type == typeof(bool) || type == typeof(decimal) || type == typeof(byte) || type == typeof(short) " is 200.
Long Statement,Reflection,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The length of the statement  "                        else if (ReflectionUtils.IsTypeGenericeCollectionInterface(type) || ReflectionUtils.IsAssignableFrom(typeof(IList)' type)) " is 122.
Long Statement,Reflection,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The length of the statement  "                            list = (IList)(ConstructorCache[type] ?? ConstructorCache[typeof(List<>).MakeGenericType(innerType)])(jsonObject.Count); " is 120.
Long Statement,Reflection,ReflectionUtils,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ToNullableType,The length of the statement  "                return obj == null ? null : Convert.ChangeType(obj' Nullable.GetUnderlyingType(nullableType)' CultureInfo.InvariantCulture); " is 124.
Long Statement,Reflection,ReflectionUtils,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,GetGetMethodByExpression,The length of the statement  "                UnaryExpression instanceCast = (!IsValueType(propertyInfo.DeclaringType)) ? Expression.TypeAs(instance' propertyInfo.DeclaringType) : Expression.Convert(instance' propertyInfo.DeclaringType); " is 191.
Long Statement,Reflection,ReflectionUtils,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,GetGetMethodByExpression,The length of the statement  "                Func<object' object> compiled = Expression.Lambda<Func<object' object>>(Expression.TypeAs(Expression.Call(instanceCast' getMethodInfo)' typeof(object))' instance).Compile(); " is 173.
Long Statement,Reflection,ReflectionUtils,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,GetSetMethodByExpression,The length of the statement  "                UnaryExpression instanceCast = (!IsValueType(propertyInfo.DeclaringType)) ? Expression.TypeAs(instance' propertyInfo.DeclaringType) : Expression.Convert(instance' propertyInfo.DeclaringType); " is 191.
Long Statement,Reflection,ReflectionUtils,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,GetSetMethodByExpression,The length of the statement  "                UnaryExpression valueCast = (!IsValueType(propertyInfo.PropertyType)) ? Expression.TypeAs(value' propertyInfo.PropertyType) : Expression.Convert(value' propertyInfo.PropertyType); " is 179.
Long Statement,Reflection,ReflectionUtils,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,GetSetMethodByExpression,The length of the statement  "                Action<object' object> compiled = Expression.Lambda<Action<object' object>>(Expression.Call(instanceCast' setMethodInfo' valueCast)' new ParameterExpression[] { instance' value }).Compile(); " is 190.
Long Statement,Reflection,ReflectionUtils,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,GetSetMethodByExpression,The length of the statement  "                    Assign(Expression.Field(Expression.Convert(instance' fieldInfo.DeclaringType)' fieldInfo)' Expression.Convert(value' fieldInfo.FieldType))' instance' value).Compile(); " is 167.
Complex Conditional,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,ReadOpcodeList,The conditional expression  "val is string &&                              ((string)val).StartsWith("@") &&                              (((string)val).Length > 1) &&                              !((string)val).StartsWith("@LR")"  is complex.
Complex Conditional,kOS.Safe.Encapsulation,LexiconComparer<TI>,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Lexicon.cs,Equals,The conditional expression  "(x is string || x is StringValue) && (y is string || y is StringValue)"  is complex.
Complex Conditional,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,FindVarIdentifierEndNode,The conditional expression  "thisChild.Token.Type == TokenType.suffix_trailer ||                  thisChild.Token.Type == TokenType.suffix ||                   thisChild.Token.Type == TokenType.suffixterm ||                   thisChild.Token.Type == TokenType.suffixterm_trailer ||                   thisChild.Token.Type == TokenType.array_trailer ||                  thisChild.Token.Type == TokenType.function_trailer"  is complex.
Complex Conditional,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VarIdentifierEndsWithIndex,The conditional expression  "thisChild.Token.Type == TokenType.suffix_trailer ||                     thisChild.Token.Type == TokenType.suffix ||                      thisChild.Token.Type == TokenType.suffixterm ||                      thisChild.Token.Type == TokenType.suffixterm_trailer ||                      thisChild.Token.Type == TokenType.array_trailer ||                     thisChild.Token.Type == TokenType.function_trailer"  is complex.
Complex Conditional,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,ParseStart,The conditional expression  "tok.Type == TokenType.EOI                  || tok.Type == TokenType.SET                  || tok.Type == TokenType.IF                  || tok.Type == TokenType.UNTIL                  || tok.Type == TokenType.FROM                  || tok.Type == TokenType.UNLOCK                  || tok.Type == TokenType.PRINT                  || tok.Type == TokenType.ON                  || tok.Type == TokenType.TOGGLE                  || tok.Type == TokenType.WAIT                  || tok.Type == TokenType.WHEN                  || tok.Type == TokenType.STAGE                  || tok.Type == TokenType.CLEARSCREEN                  || tok.Type == TokenType.ADD                  || tok.Type == TokenType.REMOVE                  || tok.Type == TokenType.LOG                  || tok.Type == TokenType.BREAK                  || tok.Type == TokenType.PRESERVE                  || tok.Type == TokenType.PARAMETER                  || tok.Type == TokenType.FUNCTION                  || tok.Type == TokenType.LOCK                  || tok.Type == TokenType.DECLARE                  || tok.Type == TokenType.LOCAL                  || tok.Type == TokenType.GLOBAL                  || tok.Type == TokenType.RETURN                  || tok.Type == TokenType.SWITCH                  || tok.Type == TokenType.COPY                  || tok.Type == TokenType.RENAME                  || tok.Type == TokenType.DELETE                  || tok.Type == TokenType.EDIT                  || tok.Type == TokenType.RUN                  || tok.Type == TokenType.RUNPATH                  || tok.Type == TokenType.RUNONCEPATH                  || tok.Type == TokenType.COMPILE                  || tok.Type == TokenType.LIST                  || tok.Type == TokenType.REBOOT                  || tok.Type == TokenType.SHUTDOWN                  || tok.Type == TokenType.FOR                  || tok.Type == TokenType.UNSET                  || tok.Type == TokenType.CURLYOPEN                  || tok.Type == TokenType.INTEGER                  || tok.Type == TokenType.DOUBLE                  || tok.Type == TokenType.TRUEFALSE                  || tok.Type == TokenType.IDENTIFIER                  || tok.Type == TokenType.FILEIDENT                  || tok.Type == TokenType.BRACKETOPEN                  || tok.Type == TokenType.STRING                  || tok.Type == TokenType.ATSIGN"  is complex.
Complex Conditional,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parseinstruction_block,The conditional expression  "tok.Type == TokenType.EOI                  || tok.Type == TokenType.SET                  || tok.Type == TokenType.IF                  || tok.Type == TokenType.UNTIL                  || tok.Type == TokenType.FROM                  || tok.Type == TokenType.UNLOCK                  || tok.Type == TokenType.PRINT                  || tok.Type == TokenType.ON                  || tok.Type == TokenType.TOGGLE                  || tok.Type == TokenType.WAIT                  || tok.Type == TokenType.WHEN                  || tok.Type == TokenType.STAGE                  || tok.Type == TokenType.CLEARSCREEN                  || tok.Type == TokenType.ADD                  || tok.Type == TokenType.REMOVE                  || tok.Type == TokenType.LOG                  || tok.Type == TokenType.BREAK                  || tok.Type == TokenType.PRESERVE                  || tok.Type == TokenType.PARAMETER                  || tok.Type == TokenType.FUNCTION                  || tok.Type == TokenType.LOCK                  || tok.Type == TokenType.DECLARE                  || tok.Type == TokenType.LOCAL                  || tok.Type == TokenType.GLOBAL                  || tok.Type == TokenType.RETURN                  || tok.Type == TokenType.SWITCH                  || tok.Type == TokenType.COPY                  || tok.Type == TokenType.RENAME                  || tok.Type == TokenType.DELETE                  || tok.Type == TokenType.EDIT                  || tok.Type == TokenType.RUN                  || tok.Type == TokenType.RUNPATH                  || tok.Type == TokenType.RUNONCEPATH                  || tok.Type == TokenType.COMPILE                  || tok.Type == TokenType.LIST                  || tok.Type == TokenType.REBOOT                  || tok.Type == TokenType.SHUTDOWN                  || tok.Type == TokenType.FOR                  || tok.Type == TokenType.UNSET                  || tok.Type == TokenType.CURLYOPEN                  || tok.Type == TokenType.INTEGER                  || tok.Type == TokenType.DOUBLE                  || tok.Type == TokenType.TRUEFALSE                  || tok.Type == TokenType.IDENTIFIER                  || tok.Type == TokenType.FILEIDENT                  || tok.Type == TokenType.BRACKETOPEN                  || tok.Type == TokenType.STRING                  || tok.Type == TokenType.ATSIGN"  is complex.
Complex Conditional,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsereturn_stmt,The conditional expression  "tok.Type == TokenType.PLUSMINUS                  || tok.Type == TokenType.NOT                  || tok.Type == TokenType.DEFINED                  || tok.Type == TokenType.INTEGER                  || tok.Type == TokenType.DOUBLE                  || tok.Type == TokenType.TRUEFALSE                  || tok.Type == TokenType.IDENTIFIER                  || tok.Type == TokenType.FILEIDENT                  || tok.Type == TokenType.BRACKETOPEN                  || tok.Type == TokenType.STRING                  || tok.Type == TokenType.CURLYOPEN"  is complex.
Complex Conditional,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsesuffixterm,The conditional expression  "tok.Type == TokenType.BRACKETOPEN                  || tok.Type == TokenType.ATSIGN                  || tok.Type == TokenType.ARRAYINDEX                  || tok.Type == TokenType.SQUAREOPEN"  is complex.
Complex Conditional,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsefunction_trailer,The conditional expression  "tok.Type == TokenType.PLUSMINUS                          || tok.Type == TokenType.NOT                          || tok.Type == TokenType.DEFINED                          || tok.Type == TokenType.INTEGER                          || tok.Type == TokenType.DOUBLE                          || tok.Type == TokenType.TRUEFALSE                          || tok.Type == TokenType.IDENTIFIER                          || tok.Type == TokenType.FILEIDENT                          || tok.Type == TokenType.BRACKETOPEN                          || tok.Type == TokenType.STRING                          || tok.Type == TokenType.CURLYOPEN"  is complex.
Complex Conditional,kOS.Safe.Compilation.KS,Scanner,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Scanner.cs,LookAhead,The conditional expression  "m.Success && m.Index == startpos && ((m.Length > len) || (scantokens[i] < index && m.Length == len ))"  is complex.
Complex Conditional,kOS.Safe.Execution,CPU,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Execution\CPU.cs,GetValue,The conditional expression  "identifier == null ||                  identifier.Length <= 1 ||                  identifier[0] != '$' ||                  identifier[1] == '<'"  is complex.
Complex Conditional,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e'"  is complex.
Complex Conditional,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e'"  is complex.
Complex Conditional,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l'"  is complex.
Complex Conditional,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e'"  is complex.
Complex Conditional,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e'"  is complex.
Complex Conditional,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l'"  is complex.
Complex Conditional,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The conditional expression  "(valueIsLong && type == typeof(long)) || (valueIsDouble && type == typeof(double))"  is complex.
Complex Conditional,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The conditional expression  "(valueIsDouble && type != typeof(double)) || (valueIsLong && type != typeof(long))"  is complex.
Complex Conditional,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The conditional expression  "(valueIsLong && type == typeof(long)) || (valueIsDouble && type == typeof(double))"  is complex.
Complex Conditional,kOS.Safe,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The conditional expression  "(valueIsDouble && type != typeof(double)) || (valueIsLong && type != typeof(long))"  is complex.
Complex Conditional,kOS.Safe.Persistence,GlobalPath,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Persistence\GlobalPath.cs,ValidateVolumeId,The conditional expression  "!(volumeId is int || volumeId is string) || (volumeId is string && String.IsNullOrEmpty(volumeId as string))"  is complex.
Complex Conditional,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e'"  is complex.
Complex Conditional,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e'"  is complex.
Complex Conditional,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The conditional expression  "json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l'"  is complex.
Complex Conditional,Reflection,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The conditional expression  "(valueIsLong && type == typeof(long)) || (valueIsDouble && type == typeof(double))"  is complex.
Complex Conditional,Reflection,PocoJsonSerializerStrategy,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,DeserializeObject,The conditional expression  "(valueIsDouble && type != typeof(double)) || (valueIsLong && type != typeof(long))"  is complex.
Magic Number,kOS.Safe.Compilation,Calculator,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\Calculator.cs,GetCalculator,The following statement contains a magic number: if (scalarCount == 2) return calculatorScalar ?? (calculatorScalar = new CalculatorScalar());
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,InitTypeData,The following statement contains a magic number: AddTypeData(2' typeof(byte));
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,InitTypeData,The following statement contains a magic number: AddTypeData(3' typeof(Int16));
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,InitTypeData,The following statement contains a magic number: AddTypeData(4' typeof(Int32));
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,InitTypeData,The following statement contains a magic number: AddTypeData(5' typeof(float));
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,InitTypeData,The following statement contains a magic number: AddTypeData(6' typeof(double));
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,InitTypeData,The following statement contains a magic number: AddTypeData(7' typeof(string));
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,InitTypeData,The following statement contains a magic number: AddTypeData(8' typeof(KOSArgMarkerType));
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,InitTypeData,The following statement contains a magic number: AddTypeData(9' typeof(ScalarIntValue));
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,InitTypeData,The following statement contains a magic number: AddTypeData(10' typeof(ScalarDoubleValue));
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,InitTypeData,The following statement contains a magic number: AddTypeData(11' typeof(BooleanValue));
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,InitTypeData,The following statement contains a magic number: AddTypeData(12' typeof(StringValue));
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,FewestBytesToHold,The following statement contains a magic number: return  (maxValue <= 0x100) ? 1 :                      (maxValue <= 0x10000) ? 2 :                      (maxValue <= 0x1000000) ? 3 :                      (maxValue <= 0x100000000) ? 4 :                      (maxValue <= 0x10000000000) ? 5 :                      (maxValue <= 0x1000000000000) ? 6 :                      (maxValue <= 0x100000000000000) ? 7 : 8 ;
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,FewestBytesToHold,The following statement contains a magic number: return  (maxValue <= 0x100) ? 1 :                      (maxValue <= 0x10000) ? 2 :                      (maxValue <= 0x1000000) ? 3 :                      (maxValue <= 0x100000000) ? 4 :                      (maxValue <= 0x10000000000) ? 5 :                      (maxValue <= 0x1000000000000) ? 6 :                      (maxValue <= 0x100000000000000) ? 7 : 8 ;
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,FewestBytesToHold,The following statement contains a magic number: return  (maxValue <= 0x100) ? 1 :                      (maxValue <= 0x10000) ? 2 :                      (maxValue <= 0x1000000) ? 3 :                      (maxValue <= 0x100000000) ? 4 :                      (maxValue <= 0x10000000000) ? 5 :                      (maxValue <= 0x1000000000000) ? 6 :                      (maxValue <= 0x100000000000000) ? 7 : 8 ;
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,FewestBytesToHold,The following statement contains a magic number: return  (maxValue <= 0x100) ? 1 :                      (maxValue <= 0x10000) ? 2 :                      (maxValue <= 0x1000000) ? 3 :                      (maxValue <= 0x100000000) ? 4 :                      (maxValue <= 0x10000000000) ? 5 :                      (maxValue <= 0x1000000000000) ? 6 :                      (maxValue <= 0x100000000000000) ? 7 : 8 ;
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,FewestBytesToHold,The following statement contains a magic number: return  (maxValue <= 0x100) ? 1 :                      (maxValue <= 0x10000) ? 2 :                      (maxValue <= 0x1000000) ? 3 :                      (maxValue <= 0x100000000) ? 4 :                      (maxValue <= 0x10000000000) ? 5 :                      (maxValue <= 0x1000000000000) ? 6 :                      (maxValue <= 0x100000000000000) ? 7 : 8 ;
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,FewestBytesToHold,The following statement contains a magic number: return  (maxValue <= 0x100) ? 1 :                      (maxValue <= 0x10000) ? 2 :                      (maxValue <= 0x1000000) ? 3 :                      (maxValue <= 0x100000000) ? 4 :                      (maxValue <= 0x10000000000) ? 5 :                      (maxValue <= 0x1000000000000) ? 6 :                      (maxValue <= 0x100000000000000) ? 7 : 8 ;
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,FewestBytesToHold,The following statement contains a magic number: return  (maxValue <= 0x100) ? 1 :                      (maxValue <= 0x10000) ? 2 :                      (maxValue <= 0x1000000) ? 3 :                      (maxValue <= 0x100000000) ? 4 :                      (maxValue <= 0x10000000000) ? 5 :                      (maxValue <= 0x1000000000000) ? 6 :                      (maxValue <= 0x100000000000000) ? 7 : 8 ;
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,EncodeNumberToNBytes,The following statement contains a magic number: for (int bNum = 0; bNum < numBytes ; ++bNum)              {                  int bytesToShift = (numBytes-bNum) - 1;                  // This ends up being big-endian.  Dunno if that's the standard'                  // but as long as the reading back is consistent it's fine:                  returnValue[bNum] = (byte)( (number>>((bytesToShift)*8)) & 0xff);              }
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,DecodeNumberFromBytes,The following statement contains a magic number: for (int bNum = 0; bNum < numBytes ; ++bNum)              {                  int bytesToShift = (numBytes-bNum) - 1;                  // Read it back assuming it's big-endian' because that's how EncodeNumberToNBytes does it:                  returnValue += ((ulong)encodedForm[bNum]) << (bytesToShift*8);              }
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,Pack,The following statement contains a magic number: argumentPack = new byte[8];
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,Pack,The following statement contains a magic number: for (int index = 0 ; index < program.Count ; ++index)  // --.    This can be replaced with a              {                                                      //   |--- foreach.  I do it this way so I                  CodePart codePart = program[index];                // --'    can print the index in debugging.                    var codeBuff = new List<byte>();                    int indexSoFar = allCodeBuff.Count + codeBuff.Count;                  codeBuff.Add((byte)'%');                  codeBuff.Add((byte)'F');                  byte[] packedCode = PackCode(codePart.FunctionsCode' numArgIndexBytes' indexSoFar+2);                  codeBuff.AddRange(packedCode);                    indexSoFar = allCodeBuff.Count + codeBuff.Count;                  codeBuff.Add((byte)'%');                  codeBuff.Add((byte)'I');                  packedCode = PackCode(codePart.InitializationCode' numArgIndexBytes' indexSoFar+2);                  codeBuff.AddRange(packedCode);                    indexSoFar = allCodeBuff.Count + codeBuff.Count;                  codeBuff.Add((byte)'%');                  codeBuff.Add((byte)'M');                  packedCode = PackCode(codePart.MainCode' numArgIndexBytes' indexSoFar+2);                  codeBuff.AddRange(packedCode);                    allCodeBuff.AddRange(codeBuff);              }
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,Pack,The following statement contains a magic number: for (int index = 0 ; index < program.Count ; ++index)  // --.    This can be replaced with a              {                                                      //   |--- foreach.  I do it this way so I                  CodePart codePart = program[index];                // --'    can print the index in debugging.                    var codeBuff = new List<byte>();                    int indexSoFar = allCodeBuff.Count + codeBuff.Count;                  codeBuff.Add((byte)'%');                  codeBuff.Add((byte)'F');                  byte[] packedCode = PackCode(codePart.FunctionsCode' numArgIndexBytes' indexSoFar+2);                  codeBuff.AddRange(packedCode);                    indexSoFar = allCodeBuff.Count + codeBuff.Count;                  codeBuff.Add((byte)'%');                  codeBuff.Add((byte)'I');                  packedCode = PackCode(codePart.InitializationCode' numArgIndexBytes' indexSoFar+2);                  codeBuff.AddRange(packedCode);                    indexSoFar = allCodeBuff.Count + codeBuff.Count;                  codeBuff.Add((byte)'%');                  codeBuff.Add((byte)'M');                  packedCode = PackCode(codePart.MainCode' numArgIndexBytes' indexSoFar+2);                  codeBuff.AddRange(packedCode);                    allCodeBuff.AddRange(codeBuff);              }
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,Pack,The following statement contains a magic number: for (int index = 0 ; index < program.Count ; ++index)  // --.    This can be replaced with a              {                                                      //   |--- foreach.  I do it this way so I                  CodePart codePart = program[index];                // --'    can print the index in debugging.                    var codeBuff = new List<byte>();                    int indexSoFar = allCodeBuff.Count + codeBuff.Count;                  codeBuff.Add((byte)'%');                  codeBuff.Add((byte)'F');                  byte[] packedCode = PackCode(codePart.FunctionsCode' numArgIndexBytes' indexSoFar+2);                  codeBuff.AddRange(packedCode);                    indexSoFar = allCodeBuff.Count + codeBuff.Count;                  codeBuff.Add((byte)'%');                  codeBuff.Add((byte)'I');                  packedCode = PackCode(codePart.InitializationCode' numArgIndexBytes' indexSoFar+2);                  codeBuff.AddRange(packedCode);                    indexSoFar = allCodeBuff.Count + codeBuff.Count;                  codeBuff.Add((byte)'%');                  codeBuff.Add((byte)'M');                  packedCode = PackCode(codePart.MainCode' numArgIndexBytes' indexSoFar+2);                  codeBuff.AddRange(packedCode);                    allCodeBuff.AddRange(codeBuff);              }
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,PackedArgumentLocation,The following statement contains a magic number: const int LABEL_OFFSET = 3;
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,AddByteChunkToArgumentPack,The following statement contains a magic number: if (newLogicalLength > argumentPack.Length)              {                  // Increase to double current size or if current size is too small or zero                  // so doubling it doesn't help' then incrase to hold new logical length:                  var newBiggerPack = new byte[ Math.Max(argumentPack.Length*2' newLogicalLength) ];                  if (argumentPackLogicalLength > 0)                  {                      Array.Copy(argumentPack'newBiggerPack'argumentPackLogicalLength);                  }                  argumentPack = newBiggerPack;              }
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,UnPack,The following statement contains a magic number: byte[] firstFour = reader.ReadBytes(4);
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,UnPack,The following statement contains a magic number: if (firstFour.SequenceEqual(PersistenceUtilities.GzipHeader))              {                  reader.Close();                    var zipStream = new GZipInputStream(new MemoryStream(content));                  var decompressedStream = new MemoryStream();                  var buffer = new byte[4096];                  int read;                  while ((read = zipStream.Read(buffer' 0' buffer.Length)) > 0)                  {                      decompressedStream.Write(buffer' 0' read);                  }                  decompressedStream.Seek(0' SeekOrigin.Begin);                  reader = new BinaryReader(decompressedStream);                    firstFour = reader.ReadBytes(4);              }
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,UnPack,The following statement contains a magic number: if (firstFour.SequenceEqual(PersistenceUtilities.GzipHeader))              {                  reader.Close();                    var zipStream = new GZipInputStream(new MemoryStream(content));                  var decompressedStream = new MemoryStream();                  var buffer = new byte[4096];                  int read;                  while ((read = zipStream.Read(buffer' 0' buffer.Length)) > 0)                  {                      decompressedStream.Write(buffer' 0' read);                  }                  decompressedStream.Seek(0' SeekOrigin.Begin);                  reader = new BinaryReader(decompressedStream);                    firstFour = reader.ReadBytes(4);              }
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,UnPack,The following statement contains a magic number: while (reader.BaseStream.Position < reader.BaseStream.Length)              {                  // In principle' the delimiter should *always* be the next byte when this loop starts and                  // the following loop should just read that one character:                  while (reader.BaseStream.Position < reader.BaseStream.Length && reader.ReadByte() != (byte)(ByteCode.DELIMITER))                  {                  }                                    if (reader.BaseStream.Position >= reader.BaseStream.Length)                      continue;                                    byte sectionTypeId = reader.ReadByte();                  switch (sectionTypeId)                  {                      case (byte)'F':                          // new CodePart's always start with the function header:                          var nextPart = new CodePart();                          program.Add(nextPart);                          // If this is the very first code we've ever encountered in the file' remember its position:                          if (codeStart == 0)                              codeStart = (int)(reader.BaseStream.Position - 2); // start is where the ByteCode.DELIMITER of the first section is.                            program[program.Count-1].FunctionsCode = ReadOpcodeList(reader' codeStart' prefix' arguments' argIndexSize);                          break;                      case (byte)'I':                          program[program.Count-1].InitializationCode = ReadOpcodeList(reader' codeStart' prefix' arguments' argIndexSize);                          break;                      case (byte)'M':                          program[program.Count-1].MainCode = ReadOpcodeList(reader' codeStart' prefix' arguments' argIndexSize);                          break;                      case (byte)'D':                          lineMap = new DebugLineMap(reader);                          break;                  }              }
Magic Number,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,ReadArgumentPack,The following statement contains a magic number: byte[] header = reader.ReadBytes(2);
Magic Number,kOS.Safe.Compilation,OpcodeCall,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\Opcode.cs,StaticExecute,The following statement contains a magic number: if (functionPointer is string || functionPointer is StringValue)              {                  string functionName = functionPointer.ToString();                  if (StringUtil.EndsWith(functionName' "()"))                      functionName = functionName.Substring(0' functionName.Length - 2);                  if (!(cpu.BuiltInExists(functionName)))                  {                      // It is not a built-in' so instead get its value as a user function pointer variable' despite                      // the fact that it's being called AS IF it was direct.                      if (!StringUtil.EndsWith(functionName' "*")) functionName = functionName + "*";                      if (!StringUtil.StartsWith(functionName' "$")) functionName = "$" + functionName;                      functionPointer = cpu.GetValue(functionName);                  }              }
Magic Number,kOS.Safe.Compilation,OpcodeCall,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\Opcode.cs,StaticExecute,The following statement contains a magic number: if (functionPointer is int || functionPointer is ScalarValue)              {                  CpuUtility.ReverseStackArgs(cpu' direct);                  var contextRecord = new SubroutineContext(cpu.InstructionPointer+1);                  newIP = Convert.ToInt32(functionPointer);                                    cpu.PushScopeStack(contextRecord);                  if (userDelegate != null)                  {                      cpu.AssertValidDelegateCall(userDelegate);                      // Reverse-push the closure's scope record' just after the function return context got put on the stack.                      for (int i = userDelegate.Closure.Count - 1 ; i >= 0 ; --i)                          cpu.PushScopeStack(userDelegate.Closure[i]);                  }              }              else if (functionPointer is string)              {                  // Built-ins don't need to dereference the stack values because they                  // don't leave the scope - they're not implemented that way.  But later we                  // might want to change that.                  var name = functionPointer as string;                  string functionName = name;                  if (StringUtil.EndsWith(functionName' "()"))                      functionName = functionName.Substring(0' functionName.Length - 2);                  cpu.CallBuiltinFunction(functionName);                    // If this was indirect' we need to consume the thing under the return value.                  // as that was the indirect BuiltInDelegate:                  if ((! direct) && builtinDel != null)                  {                      object topThing = cpu.PopArgumentStack();                      cpu.PopArgumentStack(); // remove BuiltInDelegate object.                      cpu.PushArgumentStack(topThing); // put return value back.                  }              }              else if (functionPointer is ISuffixResult)              {                  var result = (ISuffixResult) functionPointer;                    if (!result.HasValue)                  {                      result.Invoke(cpu);                  }                    delegateReturn = result.Value;              }              else if (functionPointer is NoDelegate)              {                  delegateReturn = ((NoDelegate)functionPointer).CallWithArgsPushedAlready();              }              // TODO:erendrake This else if is likely never used anymore              else if (functionPointer is Delegate)              {                  throw new KOSYouShouldNeverSeeThisException("OpcodeCall unexpected function pointer delegate");              }              else              {                  throw new KOSNotInvokableException(functionPointer);              }
Magic Number,kOS.Safe.Compilation,OpcodePushScope,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\Opcode.cs,PopulateFromMLFields,The following statement contains a magic number: if (fields == null || fields.Count<2)                  throw new Exception("Saved field in ML file for OpcodePushScope seems to be missing.  Version mismatch?");
Magic Number,kOS.Safe.Compilation,OpcodePushDelegate,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\Opcode.cs,PopulateFromMLFields,The following statement contains a magic number: if (fields == null || fields.Count<2)                  throw new Exception("Saved field in ML file for OpcodePushDelegate seems to be missing.  Version mismatch?");
Magic Number,kOS.Safe.Compilation,ProgramBuilder,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\ProgramBuilder.cs,BuildBoilerplateLoader,The following statement contains a magic number: boilerplate.Add(new OpcodePushScope(-999'0) {Label = nextLabel' SourcePath = path});
Magic Number,kOS.Safe.Exceptions,KOSParseException,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Exceptions\KOSParseException.cs,BuildTerseMessageFromTPGError,The following statement contains a magic number: const int LINE_SIZE = 50;
Magic Number,kOS.Safe.Exceptions,KOSParseException,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Exceptions\KOSParseException.cs,BuildTerseMessageFromTPGError,The following statement contains a magic number: int minStartIndex = Math.Max(tpgErr.Position - 40' 0);
Magic Number,kOS.Safe.Exceptions,KOSParseException,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Exceptions\KOSParseException.cs,BuildVerboseMessageFromTPGError,The following statement contains a magic number: char[] markStart = { (char)26 };
Magic Number,kOS.Safe.Exceptions,KOSParseException,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Exceptions\KOSParseException.cs,BuildVerboseMessageFromTPGError,The following statement contains a magic number: char[] markStop = { (char)27 };
Magic Number,kOS.Safe.Exceptions,KOSParseException,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Exceptions\KOSParseException.cs,BuildVerboseMessageFromTPGError,The following statement contains a magic number: for (int eolnToGo = 2 ; posAbove >= 0 && eolnToGo > 0 ; --posAbove)                  if (scriptText[posAbove] == '\n')                      --eolnToGo;
Magic Number,kOS.Safe.Exceptions,KOSParseException,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Exceptions\KOSParseException.cs,BuildVerboseMessageFromTPGError,The following statement contains a magic number: for (int eolnToGo = 2 ; posBelow < scriptText.Length && eolnToGo > 0 ; ++posBelow)                  if (scriptText[posBelow] == '\n')                      --eolnToGo;
Magic Number,kOS.Safe.Encapsulation,ConstantValue,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\ConstantValue.cs,ConstantValue,The following statement contains a magic number: AddGlobalSuffix<ConstantValue>("G"' new StaticSuffix<ScalarValue>(() => 6.67384*Math.Pow(10'-11)));
Magic Number,kOS.Safe.Encapsulation,ConstantValue,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\ConstantValue.cs,ConstantValue,The following statement contains a magic number: AddGlobalSuffix<ConstantValue>("G"' new StaticSuffix<ScalarValue>(() => 6.67384*Math.Pow(10'-11)));
Magic Number,kOS.Safe.Encapsulation,ConstantValue,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\ConstantValue.cs,ConstantValue,The following statement contains a magic number: AddGlobalSuffix<ConstantValue>("G"' new StaticSuffix<ScalarValue>(() => 6.67384*Math.Pow(10'-11)));
Magic Number,kOS.Safe.Encapsulation,ConstantValue,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\ConstantValue.cs,ConstantValue,The following statement contains a magic number: AddGlobalSuffix<ConstantValue>("C"' new StaticSuffix<ScalarValue>(() => 299792458.0' "Speed of light in m/s"));
Magic Number,kOS.Safe.Encapsulation,ConstantValue,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\ConstantValue.cs,ConstantValue,The following statement contains a magic number: AddGlobalSuffix<ConstantValue>("ATMTOKPA"' new StaticSuffix<ScalarValue>(() => 101.325' "atmospheres to kiloPascals" ));
Magic Number,kOS.Safe.Encapsulation,ConstantValue,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\ConstantValue.cs,ConstantValue,The following statement contains a magic number: AddGlobalSuffix<ConstantValue>("DEGTORAD"' new StaticSuffix<ScalarValue>(() => 0.01745329251994329576923690768489' "degrees to radians"));
Magic Number,kOS.Safe.Encapsulation,ConstantValue,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\ConstantValue.cs,ConstantValue,The following statement contains a magic number: AddGlobalSuffix<ConstantValue>("RADTODEG"' new StaticSuffix<ScalarValue>(() => 57.295779513082320876798154814105' "radians to degrees"));
Magic Number,kOS.Safe.Encapsulation,Lexicon,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Lexicon.cs,FillWithEnumerableValues,The following statement contains a magic number: if (values.Count() % 2 == 1) {                  throw new KOSException("Lexicon constructor expects an even number of arguments or a single enumerable type");              }
Magic Number,kOS.Safe.Encapsulation,Lexicon,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Lexicon.cs,FillWithEnumerableValues,The following statement contains a magic number: values.Select((value' index) => new {Index = index' Value = value})                  .GroupBy(x => x.Index / 2).ForEach(g => internalDictionary[g.ElementAt(0).Value] = g.ElementAt(1).Value);
Magic Number,kOS.Safe.Encapsulation,Lexicon,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Lexicon.cs,LoadDump,The following statement contains a magic number: for (int i = 0; 2 * i < values.Count; i++)              {                  internalDictionary.Add(Structure.FromPrimitiveWithAssert(values[2 * i])' Structure.FromPrimitiveWithAssert(values[2 * i + 1]));              }
Magic Number,kOS.Safe.Encapsulation,Lexicon,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Lexicon.cs,LoadDump,The following statement contains a magic number: for (int i = 0; 2 * i < values.Count; i++)              {                  internalDictionary.Add(Structure.FromPrimitiveWithAssert(values[2 * i])' Structure.FromPrimitiveWithAssert(values[2 * i + 1]));              }
Magic Number,kOS.Safe.Encapsulation,Lexicon,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Lexicon.cs,LoadDump,The following statement contains a magic number: for (int i = 0; 2 * i < values.Count; i++)              {                  internalDictionary.Add(Structure.FromPrimitiveWithAssert(values[2 * i])' Structure.FromPrimitiveWithAssert(values[2 * i + 1]));              }
Magic Number,kOS.Safe.Encapsulation,PIDLoop,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\PIDLoop.cs,Update,The following statement contains a magic number: if (LastSampleTime < sampleTime)              {                  double dt = sampleTime - LastSampleTime;                  if (Ki != 0)                  {                      if (ExtraUnwind)                      {                          if (Math.Sign(error) != Math.Sign(ErrorSum))                          {                              if (!unWinding)                              {                                  Ki *= 2;                                  unWinding = true;                              }                          }                          else if (unWinding)                          {                              Ki /= 2;                              unWinding = false;                          }                      }                      iTerm = ITerm + error * dt * Ki;                  }                  ChangeRate = (input - Input) / dt;                  if (Kd != 0)                  {                      dTerm = -ChangeRate * Kd;                  }              }              else              {                  dTerm = DTerm;                  iTerm = ITerm;              }
Magic Number,kOS.Safe.Encapsulation,PIDLoop,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\PIDLoop.cs,Update,The following statement contains a magic number: if (LastSampleTime < sampleTime)              {                  double dt = sampleTime - LastSampleTime;                  if (Ki != 0)                  {                      if (ExtraUnwind)                      {                          if (Math.Sign(error) != Math.Sign(ErrorSum))                          {                              if (!unWinding)                              {                                  Ki *= 2;                                  unWinding = true;                              }                          }                          else if (unWinding)                          {                              Ki /= 2;                              unWinding = false;                          }                      }                      iTerm = ITerm + error * dt * Ki;                  }                  ChangeRate = (input - Input) / dt;                  if (Kd != 0)                  {                      dTerm = -ChangeRate * Kd;                  }              }              else              {                  dTerm = DTerm;                  iTerm = ITerm;              }
Magic Number,kOS.Safe.Encapsulation,PIDLoopConstructor,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\PIDLoop.cs,Execute,The following statement contains a magic number: switch (args)                  {                      case 0:                          this.ReturnValue = new PIDLoop();                          break;                      case 1:                          kp = GetDouble(PopValueAssert(shared));                          this.ReturnValue = new PIDLoop(kp' 0' 0);                          break;                      case 3:                          kd = GetDouble(PopValueAssert(shared));                          ki = GetDouble(PopValueAssert(shared));                          kp = GetDouble(PopValueAssert(shared));                          this.ReturnValue = new PIDLoop(kp' ki' kd);                          break;                      case 5:                          maxoutput = GetDouble(PopValueAssert(shared));                          minoutput = GetDouble(PopValueAssert(shared));                          kd = GetDouble(PopValueAssert(shared));                          ki = GetDouble(PopValueAssert(shared));                          kp = GetDouble(PopValueAssert(shared));                          this.ReturnValue = new PIDLoop(kp' ki' kd' maxoutput' minoutput);                          break;                      default:                          throw new KOSArgumentMismatchException(new[] { 0' 1' 3' 5 }' args);                  }
Magic Number,kOS.Safe.Encapsulation,PIDLoopConstructor,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\PIDLoop.cs,Execute,The following statement contains a magic number: switch (args)                  {                      case 0:                          this.ReturnValue = new PIDLoop();                          break;                      case 1:                          kp = GetDouble(PopValueAssert(shared));                          this.ReturnValue = new PIDLoop(kp' 0' 0);                          break;                      case 3:                          kd = GetDouble(PopValueAssert(shared));                          ki = GetDouble(PopValueAssert(shared));                          kp = GetDouble(PopValueAssert(shared));                          this.ReturnValue = new PIDLoop(kp' ki' kd);                          break;                      case 5:                          maxoutput = GetDouble(PopValueAssert(shared));                          minoutput = GetDouble(PopValueAssert(shared));                          kd = GetDouble(PopValueAssert(shared));                          ki = GetDouble(PopValueAssert(shared));                          kp = GetDouble(PopValueAssert(shared));                          this.ReturnValue = new PIDLoop(kp' ki' kd' maxoutput' minoutput);                          break;                      default:                          throw new KOSArgumentMismatchException(new[] { 0' 1' 3' 5 }' args);                  }
Magic Number,kOS.Safe.Encapsulation,PIDLoopConstructor,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\PIDLoop.cs,Execute,The following statement contains a magic number: switch (args)                  {                      case 0:                          this.ReturnValue = new PIDLoop();                          break;                      case 1:                          kp = GetDouble(PopValueAssert(shared));                          this.ReturnValue = new PIDLoop(kp' 0' 0);                          break;                      case 3:                          kd = GetDouble(PopValueAssert(shared));                          ki = GetDouble(PopValueAssert(shared));                          kp = GetDouble(PopValueAssert(shared));                          this.ReturnValue = new PIDLoop(kp' ki' kd);                          break;                      case 5:                          maxoutput = GetDouble(PopValueAssert(shared));                          minoutput = GetDouble(PopValueAssert(shared));                          kd = GetDouble(PopValueAssert(shared));                          ki = GetDouble(PopValueAssert(shared));                          kp = GetDouble(PopValueAssert(shared));                          this.ReturnValue = new PIDLoop(kp' ki' kd' maxoutput' minoutput);                          break;                      default:                          throw new KOSArgumentMismatchException(new[] { 0' 1' 3' 5 }' args);                  }
Magic Number,kOS.Safe.Encapsulation,PIDLoopConstructor,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\PIDLoop.cs,Execute,The following statement contains a magic number: switch (args)                  {                      case 0:                          this.ReturnValue = new PIDLoop();                          break;                      case 1:                          kp = GetDouble(PopValueAssert(shared));                          this.ReturnValue = new PIDLoop(kp' 0' 0);                          break;                      case 3:                          kd = GetDouble(PopValueAssert(shared));                          ki = GetDouble(PopValueAssert(shared));                          kp = GetDouble(PopValueAssert(shared));                          this.ReturnValue = new PIDLoop(kp' ki' kd);                          break;                      case 5:                          maxoutput = GetDouble(PopValueAssert(shared));                          minoutput = GetDouble(PopValueAssert(shared));                          kd = GetDouble(PopValueAssert(shared));                          ki = GetDouble(PopValueAssert(shared));                          kp = GetDouble(PopValueAssert(shared));                          this.ReturnValue = new PIDLoop(kp' ki' kd' maxoutput' minoutput);                          break;                      default:                          throw new KOSArgumentMismatchException(new[] { 0' 1' 3' 5 }' args);                  }
Magic Number,kOS.Safe.Encapsulation,TerminalStruct,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\TerminalStruct.cs,InitializeSuffixes,The following statement contains a magic number: AddSuffix("CHARWIDTH"' new ClampSetSuffix<ScalarValue>(() => Shared.Screen.CharacterPixelWidth'                                                                     CannotSetWidth'                                                                     MINCHARPIXELS'                                                                     MAXCHARPIXELS'                                                                     2'                                                                     "Character width on in-game terminal screen in pixels"));
Magic Number,kOS.Safe.Encapsulation,TerminalStruct,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\TerminalStruct.cs,InitializeSuffixes,The following statement contains a magic number: AddSuffix("CHARHEIGHT"' new ClampSetSuffix<ScalarValue>(() => Shared.Screen.CharacterPixelHeight'                                                                      value => Shared.Screen.CharacterPixelHeight = (int)value'                                                                      MINCHARPIXELS'                                                                      MAXCHARPIXELS'                                                                      2'                                                                      "Character height on in-game terminal screen in pixels"));
Magic Number,kOS.Safe.Encapsulation,UserDelegate,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\UserDelegate.cs,GetHashCode,The following statement contains a magic number: unchecked {                  if (ProgContext != null)                      hashCode += 1000000007 * ProgContext.GetHashCode();                  hashCode += 1000000009 * EntryPoint.GetHashCode();                  if (Closure != null)                      hashCode += 1000000021 * Closure.GetHashCode();              }
Magic Number,kOS.Safe.Encapsulation,UserDelegate,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\UserDelegate.cs,GetHashCode,The following statement contains a magic number: unchecked {                  if (ProgContext != null)                      hashCode += 1000000007 * ProgContext.GetHashCode();                  hashCode += 1000000009 * EntryPoint.GetHashCode();                  if (Closure != null)                      hashCode += 1000000021 * Closure.GetHashCode();              }
Magic Number,kOS.Safe.Encapsulation,UserDelegate,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\UserDelegate.cs,GetHashCode,The following statement contains a magic number: unchecked {                  if (ProgContext != null)                      hashCode += 1000000007 * ProgContext.GetHashCode();                  hashCode += 1000000009 * EntryPoint.GetHashCode();                  if (Closure != null)                      hashCode += 1000000021 * Closure.GetHashCode();              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,RearrangeLoopFromNode,The following statement contains a magic number: for( int index = 0 ; index < node.Nodes.Count - 1 ; index += 2 )              {                  switch (node.Nodes[index].Token.Type)                  {                      case TokenType.FROM:                          initBlock = node.Nodes[index+1];                          break;                      case TokenType.UNTIL:                          untilTokenNode = node.Nodes[index];                          checkExpression = node.Nodes[index+1];                          break;                      case TokenType.STEP:                          stepBlock = node.Nodes[index+1];                          break;                      case TokenType.DO:                          doBlock = node.Nodes[index+1];                          break;                      // no default because anything else is a syntax error and it won't even get as far as this method in that case.                  }              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,PreProcessOnStatement,The following statement contains a magic number: branchToBody.Distance = 3;
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,PreProcessOnStatement,The following statement contains a magic number: VisitNode(node.Nodes[2]);
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,PreProcessWhenStatement,The following statement contains a magic number: branchToBody.Distance = 3;
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,PreProcessWhenStatement,The following statement contains a magic number: VisitNode(node.Nodes[3]);
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,IdentifyUserFunctions,The following statement contains a magic number: if (isLock)              {                  funcIdentifier = lastSubNode.Nodes[1].Token.Text;                  bodyNode = lastSubNode.Nodes[3];              }              else if (IsDefineFunctionStatement(node))              {                  funcIdentifier = lastSubNode.Nodes[1].Token.Text;                  bodyNode = lastSubNode.Nodes[2];              }              else                  return;
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,IdentifyUserFunctions,The following statement contains a magic number: if (isLock)              {                  funcIdentifier = lastSubNode.Nodes[1].Token.Text;                  bodyNode = lastSubNode.Nodes[3];              }              else if (IsDefineFunctionStatement(node))              {                  funcIdentifier = lastSubNode.Nodes[1].Token.Text;                  bodyNode = lastSubNode.Nodes[2];              }              else                  return;
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,PreProcessUserFunctionStatement,The following statement contains a magic number: if (isLock)              {                  userFuncIdentifier = lastSubNode.Nodes[1].Token.Text; // The IDENT of: LOCK IDENT TO EXPR.                  bodyNode = lastSubNode.Nodes[3]; // The EXPR of: LOCK IDENT TO EXPR.                  needImplicitArgBottom = true;              }              else if (isDefFunc)              {                  userFuncIdentifier = lastSubNode.Nodes[1].Token.Text; // The IDENT of: DEFINE FUNCTION IDENT INSTRUCTION_BLOCK.                  bodyNode = lastSubNode.Nodes[2]; // The INSTRUCTION_BLOCK of: DEFINE FUNCTION IDENT INSTRUCTION_BLOCK.              }              else                  return;
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,PreProcessUserFunctionStatement,The following statement contains a magic number: if (isLock)              {                  userFuncIdentifier = lastSubNode.Nodes[1].Token.Text; // The IDENT of: LOCK IDENT TO EXPR.                  bodyNode = lastSubNode.Nodes[3]; // The EXPR of: LOCK IDENT TO EXPR.                  needImplicitArgBottom = true;              }              else if (isDefFunc)              {                  userFuncIdentifier = lastSubNode.Nodes[1].Token.Text; // The IDENT of: DEFINE FUNCTION IDENT INSTRUCTION_BLOCK.                  bodyNode = lastSubNode.Nodes[2]; // The INSTRUCTION_BLOCK of: DEFINE FUNCTION IDENT INSTRUCTION_BLOCK.              }              else                  return;
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,PreProcessUserFunctionStatement,The following statement contains a magic number: if (isLock && !userFuncObject.IsInitialized())              {                  currentCodeSection = userFuncObject.InitializationCode;                    if (userFuncObject.IsSystemLock())                  {                      AddOpcode(new OpcodePush(userFuncObject.ScopelessPointerIdentifier));                      AddOpcode(new OpcodeExists());                      var branch = new OpcodeBranchIfTrue();                      branch.Distance = 4;                      AddOpcode(branch);                      AddOpcode(new OpcodePushRelocateLater(null)' userFuncObject.DefaultLabel);                      AddOpcode(new OpcodeStore(userFuncObject.ScopelessPointerIdentifier));                  }                  else                  {                      // initialization code - unfortunately the lock implementation presumed global namespace                      // and insisted on inserting an initialization block in front of the entire program to set up                      // the GLOBAL lock value.  This assumption was thorny to remove' so for now' we'll make the init                      // code consist of a dummy NOP until a better solution can be found.  Note this does put a NOP                      // into the code PER LOCK.  Which is silly.  It's because lockObject.IsInitialized() doesn't                      // know how to tell the difference between initialization code that's deliberately empty versus                      // initialization code being empty because the lock has never been set up properly yet.                      AddOpcode(new OpcodeNOP());                  }                    // build default dummy function to be used when this is a LOCK:                  currentCodeSection = userFuncObject.GetUserFunctionOpcodes(0);                  AddOpcode(new OpcodeArgBottom()).Label = userFuncObject.DefaultLabel;;                  AddOpcode(new OpcodePush("$" + userFuncObject.ScopelessIdentifier));                  AddOpcode(new OpcodeReturn(0));              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,BuildSystemTrigger,The following statement contains a magic number: proceedOkay.Distance = 3;
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,TraverseScopeBranch,The following statement contains a magic number: switch (node.Token.Type)              {                  // List all the types of parse node that open a new variable scope here:                  // ---------------------------------------------------------------------                  case TokenType.Start: // Here because all programs start with an outer scope block                  case TokenType.for_stmt: // Here because it wraps the body inside an outer scope that holds the for-iterator variable.                  case TokenType.declare_lock_clause: // here because the lock body needs a scope in order to work with closures.  The scope remembers the lexical id.                  case TokenType.instruction_block:                        ++braceNestLevel;                      Int16 parentId = ( (scopeStack.Count == 0) ? (Int16)0 : scopeStack.Last() );                      scopeStack.Add(++context.MaxScopeIdSoFar);                      ParseNode mapNode = node;                      if (node.Token.Type == TokenType.declare_lock_clause)                      {                          // use the expression of: LOCK foo TO expr EOI as the holder of the scope'                          // not the lock statement itself.  Thus the foo being locked is in the outer                          // scope and only the expression is in a nested scope:                          mapNode = node.Nodes[node.Nodes.Count - 2];                      }                      scopeMap[mapNode] = new Scope(context.MaxScopeIdSoFar' parentId' braceNestLevel);                                            foreach (ParseNode childNode in mapNode.Nodes)                          TraverseScopeBranch(childNode);                                            --braceNestLevel;                      if (scopeStack.Count > 0)                          scopeStack.RemoveAt(scopeStack.Count-1);                      break;                                        // Some Compiler directives affect variable scope rules:                  case TokenType.lazyglobal_directive:                      VisitLazyGlobalDirective(node);                      break;                                        default:                      foreach (ParseNode childNode in node.Nodes)                            TraverseScopeBranch(childNode);                      break;                                  }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitExpressionChain,The following statement contains a magic number: if (node.Nodes.Count > 1)              {                  // it should always be odd' two arguments and one operator                  if ((node.Nodes.Count % 2) != 1) return;                    VisitNode(node.Nodes[0]); // pushes lefthand side on stack.                    int nodeIndex = 2;                  while (nodeIndex < node.Nodes.Count)                  {                      VisitNode(node.Nodes[nodeIndex]); // pushes righthand side on stack.                      nodeIndex -= 1;                      VisitNode(node.Nodes[nodeIndex]); // operator' i.e '*'' '+'' '-'' '/'' etc.                      nodeIndex += 3; // Move to the next term over (if there's more than 2 terms in the chain).                        // If there are more terms to process' then the value that the operation leaves behind on the stack                      // from operating on these two terms will become the 'lefthand side' for the next iteration of this loop.                  }              }              else if (node.Nodes.Count == 1)              {                  VisitNode(node.Nodes[0]); // This ParseNode isn't *realy* an expression of binary operators' because                                            // the regex chain of "zero or more" righthand terms.. had zero such terms.                                            // So just delve in deeper to compile whatever part of speech it is further down.              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitExpressionChain,The following statement contains a magic number: if (node.Nodes.Count > 1)              {                  // it should always be odd' two arguments and one operator                  if ((node.Nodes.Count % 2) != 1) return;                    VisitNode(node.Nodes[0]); // pushes lefthand side on stack.                    int nodeIndex = 2;                  while (nodeIndex < node.Nodes.Count)                  {                      VisitNode(node.Nodes[nodeIndex]); // pushes righthand side on stack.                      nodeIndex -= 1;                      VisitNode(node.Nodes[nodeIndex]); // operator' i.e '*'' '+'' '-'' '/'' etc.                      nodeIndex += 3; // Move to the next term over (if there's more than 2 terms in the chain).                        // If there are more terms to process' then the value that the operation leaves behind on the stack                      // from operating on these two terms will become the 'lefthand side' for the next iteration of this loop.                  }              }              else if (node.Nodes.Count == 1)              {                  VisitNode(node.Nodes[0]); // This ParseNode isn't *realy* an expression of binary operators' because                                            // the regex chain of "zero or more" righthand terms.. had zero such terms.                                            // So just delve in deeper to compile whatever part of speech it is further down.              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitExpressionChain,The following statement contains a magic number: if (node.Nodes.Count > 1)              {                  // it should always be odd' two arguments and one operator                  if ((node.Nodes.Count % 2) != 1) return;                    VisitNode(node.Nodes[0]); // pushes lefthand side on stack.                    int nodeIndex = 2;                  while (nodeIndex < node.Nodes.Count)                  {                      VisitNode(node.Nodes[nodeIndex]); // pushes righthand side on stack.                      nodeIndex -= 1;                      VisitNode(node.Nodes[nodeIndex]); // operator' i.e '*'' '+'' '-'' '/'' etc.                      nodeIndex += 3; // Move to the next term over (if there's more than 2 terms in the chain).                        // If there are more terms to process' then the value that the operation leaves behind on the stack                      // from operating on these two terms will become the 'lefthand side' for the next iteration of this loop.                  }              }              else if (node.Nodes.Count == 1)              {                  VisitNode(node.Nodes[0]); // This ParseNode isn't *realy* an expression of binary operators' because                                            // the regex chain of "zero or more" righthand terms.. had zero such terms.                                            // So just delve in deeper to compile whatever part of speech it is further down.              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitShortCircuitBoolean,The following statement contains a magic number: if (node.Nodes.Count > 1)              {                  // it should always be odd' two arguments and one operator                  if ((node.Nodes.Count % 2) != 1) return;                    // Determine if this is a chain of ANDs or a chain or ORs.  The parser will                  // never mix ANDs and ORs into the same ParseNode level.  We are guaranteed                  // that all the operators in this chain match the first operator in the chain:                  // That guarantee is important.  Without it' we can't do short-circuiting like this                  // because you can't short-circuit a mix of AND and OR at the same precedence.                  TokenType operation = node.Nodes[1].Token.Type; // Guaranteed to be either TokenType.AND or TokenType.OR                                    // For remembering the instruction pointers from which short-circuit branch jumps came:                  List<int> shortCircuitFromIndeces = new List<int>();                                    int nodeIndex = 0;                  while (nodeIndex < node.Nodes.Count)                  {                      if (nodeIndex > 0) // After each term' insert the branch test (which consumes the expr from the stack regardless of if it branches):                      {                         shortCircuitFromIndeces.Add(currentCodeSection.Count());                         if (operation == TokenType.AND)                             AddOpcode(new OpcodeBranchIfFalse());                         else if (operation == TokenType.OR)                             AddOpcode(new OpcodeBranchIfTrue());                         else                             throw new KOSException("Assertion check:  Broken kerboscript compiler (VisitShortCircuitBoolean).  See kOS devs");                      }                                            VisitNode(node.Nodes[nodeIndex]); // pushes the next term onto the stack.                      nodeIndex += 2; // Skip the operator' moving to the next term over.                  }                  // If it gets to the end of all that and it still hasn't aborted' then the whole expression's                  // Boolean value is just the value of its lastmost term' that's already gotten pushed atop the stack.                  // Leave the lastmost term there' and just skip ahead past the short-circuit landing target:                  OpcodeBranchJump skipShortCircuitTarget = new OpcodeBranchJump();                  skipShortCircuitTarget.Distance = 2; // Hardcoded +2 jump distance skips the upcoming OpcodePush and just lands on                                                       // whatever comes next after this VisitNode.  Avoids using DestinationLabel                                                       // for later relocation because it would be messy to reassign this label later                                                       // in whatever VisitNode happens to come up next' when that could be anything.                  AddOpcode(skipShortCircuitTarget);                                    // Build the instruction all the short circuit checks will jump to if aborting partway through.                  // (AND's abort when they're false.  OR's abort when they're true.)                  AddOpcode(operation == TokenType.AND ? new OpcodePush(false) : new OpcodePush(true));                  string shortCircuitTargetLabel = currentCodeSection[currentCodeSection.Count()-1].Label;                                    // Retroactively re-assign the jump labels of all the short circuit branch operations:                  foreach (int index in shortCircuitFromIndeces)                  {                      currentCodeSection[index].DestinationLabel = shortCircuitTargetLabel;                  }              }              else if (node.Nodes.Count == 1)              {                  VisitNode(node.Nodes[0]); // This ParseNode isn't *realy* an expression of AND or OR operators' because                                            // the regex chain of "zero or more" righthand terms.. had zero such terms.                                            // So just delve in deeper to compile whatever part of speech it is further down.              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitShortCircuitBoolean,The following statement contains a magic number: if (node.Nodes.Count > 1)              {                  // it should always be odd' two arguments and one operator                  if ((node.Nodes.Count % 2) != 1) return;                    // Determine if this is a chain of ANDs or a chain or ORs.  The parser will                  // never mix ANDs and ORs into the same ParseNode level.  We are guaranteed                  // that all the operators in this chain match the first operator in the chain:                  // That guarantee is important.  Without it' we can't do short-circuiting like this                  // because you can't short-circuit a mix of AND and OR at the same precedence.                  TokenType operation = node.Nodes[1].Token.Type; // Guaranteed to be either TokenType.AND or TokenType.OR                                    // For remembering the instruction pointers from which short-circuit branch jumps came:                  List<int> shortCircuitFromIndeces = new List<int>();                                    int nodeIndex = 0;                  while (nodeIndex < node.Nodes.Count)                  {                      if (nodeIndex > 0) // After each term' insert the branch test (which consumes the expr from the stack regardless of if it branches):                      {                         shortCircuitFromIndeces.Add(currentCodeSection.Count());                         if (operation == TokenType.AND)                             AddOpcode(new OpcodeBranchIfFalse());                         else if (operation == TokenType.OR)                             AddOpcode(new OpcodeBranchIfTrue());                         else                             throw new KOSException("Assertion check:  Broken kerboscript compiler (VisitShortCircuitBoolean).  See kOS devs");                      }                                            VisitNode(node.Nodes[nodeIndex]); // pushes the next term onto the stack.                      nodeIndex += 2; // Skip the operator' moving to the next term over.                  }                  // If it gets to the end of all that and it still hasn't aborted' then the whole expression's                  // Boolean value is just the value of its lastmost term' that's already gotten pushed atop the stack.                  // Leave the lastmost term there' and just skip ahead past the short-circuit landing target:                  OpcodeBranchJump skipShortCircuitTarget = new OpcodeBranchJump();                  skipShortCircuitTarget.Distance = 2; // Hardcoded +2 jump distance skips the upcoming OpcodePush and just lands on                                                       // whatever comes next after this VisitNode.  Avoids using DestinationLabel                                                       // for later relocation because it would be messy to reassign this label later                                                       // in whatever VisitNode happens to come up next' when that could be anything.                  AddOpcode(skipShortCircuitTarget);                                    // Build the instruction all the short circuit checks will jump to if aborting partway through.                  // (AND's abort when they're false.  OR's abort when they're true.)                  AddOpcode(operation == TokenType.AND ? new OpcodePush(false) : new OpcodePush(true));                  string shortCircuitTargetLabel = currentCodeSection[currentCodeSection.Count()-1].Label;                                    // Retroactively re-assign the jump labels of all the short circuit branch operations:                  foreach (int index in shortCircuitFromIndeces)                  {                      currentCodeSection[index].DestinationLabel = shortCircuitTargetLabel;                  }              }              else if (node.Nodes.Count == 1)              {                  VisitNode(node.Nodes[0]); // This ParseNode isn't *realy* an expression of AND or OR operators' because                                            // the regex chain of "zero or more" righthand terms.. had zero such terms.                                            // So just delve in deeper to compile whatever part of speech it is further down.              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitShortCircuitBoolean,The following statement contains a magic number: if (node.Nodes.Count > 1)              {                  // it should always be odd' two arguments and one operator                  if ((node.Nodes.Count % 2) != 1) return;                    // Determine if this is a chain of ANDs or a chain or ORs.  The parser will                  // never mix ANDs and ORs into the same ParseNode level.  We are guaranteed                  // that all the operators in this chain match the first operator in the chain:                  // That guarantee is important.  Without it' we can't do short-circuiting like this                  // because you can't short-circuit a mix of AND and OR at the same precedence.                  TokenType operation = node.Nodes[1].Token.Type; // Guaranteed to be either TokenType.AND or TokenType.OR                                    // For remembering the instruction pointers from which short-circuit branch jumps came:                  List<int> shortCircuitFromIndeces = new List<int>();                                    int nodeIndex = 0;                  while (nodeIndex < node.Nodes.Count)                  {                      if (nodeIndex > 0) // After each term' insert the branch test (which consumes the expr from the stack regardless of if it branches):                      {                         shortCircuitFromIndeces.Add(currentCodeSection.Count());                         if (operation == TokenType.AND)                             AddOpcode(new OpcodeBranchIfFalse());                         else if (operation == TokenType.OR)                             AddOpcode(new OpcodeBranchIfTrue());                         else                             throw new KOSException("Assertion check:  Broken kerboscript compiler (VisitShortCircuitBoolean).  See kOS devs");                      }                                            VisitNode(node.Nodes[nodeIndex]); // pushes the next term onto the stack.                      nodeIndex += 2; // Skip the operator' moving to the next term over.                  }                  // If it gets to the end of all that and it still hasn't aborted' then the whole expression's                  // Boolean value is just the value of its lastmost term' that's already gotten pushed atop the stack.                  // Leave the lastmost term there' and just skip ahead past the short-circuit landing target:                  OpcodeBranchJump skipShortCircuitTarget = new OpcodeBranchJump();                  skipShortCircuitTarget.Distance = 2; // Hardcoded +2 jump distance skips the upcoming OpcodePush and just lands on                                                       // whatever comes next after this VisitNode.  Avoids using DestinationLabel                                                       // for later relocation because it would be messy to reassign this label later                                                       // in whatever VisitNode happens to come up next' when that could be anything.                  AddOpcode(skipShortCircuitTarget);                                    // Build the instruction all the short circuit checks will jump to if aborting partway through.                  // (AND's abort when they're false.  OR's abort when they're true.)                  AddOpcode(operation == TokenType.AND ? new OpcodePush(false) : new OpcodePush(true));                  string shortCircuitTargetLabel = currentCodeSection[currentCodeSection.Count()-1].Label;                                    // Retroactively re-assign the jump labels of all the short circuit branch operations:                  foreach (int index in shortCircuitFromIndeces)                  {                      currentCodeSection[index].DestinationLabel = shortCircuitTargetLabel;                  }              }              else if (node.Nodes.Count == 1)              {                  VisitNode(node.Nodes[0]); // This ParseNode isn't *realy* an expression of AND or OR operators' because                                            // the regex chain of "zero or more" righthand terms.. had zero such terms.                                            // So just delve in deeper to compile whatever part of speech it is further down.              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitArgList,The following statement contains a magic number: while (nodeIndex < node.Nodes.Count)              {                  VisitNode(node.Nodes[nodeIndex]);                  nodeIndex += 2;              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitArgListReversed,The following statement contains a magic number: while (nodeIndex >= 0)              {                  VisitNode(node.Nodes[nodeIndex]);                  nodeIndex -= 2;              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitActualArray,The following statement contains a magic number: while (nodeIndex < trailerNode.Nodes.Count)              {                  // Skip two tokens instead of one between dimensions if using the "[]" syntax:                  if (trailerNode.Nodes[nodeIndex].Token.Type == TokenType.SQUAREOPEN)                  {                      ++nodeIndex;                  }                    // Temporarily turn off these flags while evaluating the expression inside                  // the array index square brackets.  These flags apply to this outer containing                  // thing' the array access' not to the expression in the index brackets:                  bool rememberIdentIsSuffix = identifierIsSuffix;                  identifierIsSuffix = false;                  bool rememberCompSetDest = compilingSetDestination;                  compilingSetDestination = false;                                    VisitNode(trailerNode.Nodes[nodeIndex]); // pushes the result of expression inside square brackets.                    compilingSetDestination = rememberCompSetDest;                  identifierIsSuffix = rememberIdentIsSuffix;                    // Two ways to check if this is the last index (i.e. the 'k' in arr[i][j][k]')'                  // depending on whether using the "#" syntax or the "[..]" syntax:                  bool isLastIndex = false;                  var previousNodeType = trailerNode.Nodes[nodeIndex - 1].Token.Type;                  switch (previousNodeType)                  {                      case TokenType.ARRAYINDEX:                          isLastIndex = (nodeIndex == trailerNode.Nodes.Count - 1);                          break;                      case TokenType.SQUAREOPEN:                          isLastIndex = (nodeIndex == trailerNode.Nodes.Count - 2);                          break;                  }                    // when we are setting a member value we need to leave                  // the last object and the last index in the stack                  // the only exception is when we are setting a suffix of the indexed value                  bool atEnd = IsLastmostTrailerInTerm(node);                  if (!(compilingSetDestination && isLastIndex) || (!atEnd))                  {                      AddOpcode(new OpcodeGetIndex());                  }                    nodeIndex += 2;              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitActualArray,The following statement contains a magic number: while (nodeIndex < trailerNode.Nodes.Count)              {                  // Skip two tokens instead of one between dimensions if using the "[]" syntax:                  if (trailerNode.Nodes[nodeIndex].Token.Type == TokenType.SQUAREOPEN)                  {                      ++nodeIndex;                  }                    // Temporarily turn off these flags while evaluating the expression inside                  // the array index square brackets.  These flags apply to this outer containing                  // thing' the array access' not to the expression in the index brackets:                  bool rememberIdentIsSuffix = identifierIsSuffix;                  identifierIsSuffix = false;                  bool rememberCompSetDest = compilingSetDestination;                  compilingSetDestination = false;                                    VisitNode(trailerNode.Nodes[nodeIndex]); // pushes the result of expression inside square brackets.                    compilingSetDestination = rememberCompSetDest;                  identifierIsSuffix = rememberIdentIsSuffix;                    // Two ways to check if this is the last index (i.e. the 'k' in arr[i][j][k]')'                  // depending on whether using the "#" syntax or the "[..]" syntax:                  bool isLastIndex = false;                  var previousNodeType = trailerNode.Nodes[nodeIndex - 1].Token.Type;                  switch (previousNodeType)                  {                      case TokenType.ARRAYINDEX:                          isLastIndex = (nodeIndex == trailerNode.Nodes.Count - 1);                          break;                      case TokenType.SQUAREOPEN:                          isLastIndex = (nodeIndex == trailerNode.Nodes.Count - 2);                          break;                  }                    // when we are setting a member value we need to leave                  // the last object and the last index in the stack                  // the only exception is when we are setting a suffix of the indexed value                  bool atEnd = IsLastmostTrailerInTerm(node);                  if (!(compilingSetDestination && isLastIndex) || (!atEnd))                  {                      AddOpcode(new OpcodeGetIndex());                  }                    nodeIndex += 2;              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitSetStatement,The following statement contains a magic number: ProcessSetOperation(node.Nodes[1]' node.Nodes[3]);
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitIfStatement,The following statement contains a magic number: VisitNode(node.Nodes[2]);
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitIfStatement,The following statement contains a magic number: if (node.Nodes.Count < 5)              {                  // No ELSE exists.                  // Jump to after the IF BODY if false:                  branchToFalse.DestinationLabel = GetNextLabel(false);                  addBranchDestination = true;              }              else              {                  // The IF statement has an ELSE clause.                    // Jump past the ELSE body from the end of the IF body:                  Opcode branchPastElse = AddOpcode(new OpcodeBranchJump());                  // This is where the ELSE clause starts:                  branchToFalse.DestinationLabel = GetNextLabel(false);                  // The else body might be at index 4 or 5 depending on if there was an optional EOI.                  int elseBodyIndex = node.Nodes[4].Token.Type == TokenType.ELSE ? 5 : 4;                  VisitNode(node.Nodes[elseBodyIndex]);                  // End of Else body label:                  branchPastElse.DestinationLabel = GetNextLabel(false);                  addBranchDestination = true;              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitIfStatement,The following statement contains a magic number: if (node.Nodes.Count < 5)              {                  // No ELSE exists.                  // Jump to after the IF BODY if false:                  branchToFalse.DestinationLabel = GetNextLabel(false);                  addBranchDestination = true;              }              else              {                  // The IF statement has an ELSE clause.                    // Jump past the ELSE body from the end of the IF body:                  Opcode branchPastElse = AddOpcode(new OpcodeBranchJump());                  // This is where the ELSE clause starts:                  branchToFalse.DestinationLabel = GetNextLabel(false);                  // The else body might be at index 4 or 5 depending on if there was an optional EOI.                  int elseBodyIndex = node.Nodes[4].Token.Type == TokenType.ELSE ? 5 : 4;                  VisitNode(node.Nodes[elseBodyIndex]);                  // End of Else body label:                  branchPastElse.DestinationLabel = GetNextLabel(false);                  addBranchDestination = true;              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitIfStatement,The following statement contains a magic number: if (node.Nodes.Count < 5)              {                  // No ELSE exists.                  // Jump to after the IF BODY if false:                  branchToFalse.DestinationLabel = GetNextLabel(false);                  addBranchDestination = true;              }              else              {                  // The IF statement has an ELSE clause.                    // Jump past the ELSE body from the end of the IF body:                  Opcode branchPastElse = AddOpcode(new OpcodeBranchJump());                  // This is where the ELSE clause starts:                  branchToFalse.DestinationLabel = GetNextLabel(false);                  // The else body might be at index 4 or 5 depending on if there was an optional EOI.                  int elseBodyIndex = node.Nodes[4].Token.Type == TokenType.ELSE ? 5 : 4;                  VisitNode(node.Nodes[elseBodyIndex]);                  // End of Else body label:                  branchPastElse.DestinationLabel = GetNextLabel(false);                  addBranchDestination = true;              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitIfStatement,The following statement contains a magic number: if (node.Nodes.Count < 5)              {                  // No ELSE exists.                  // Jump to after the IF BODY if false:                  branchToFalse.DestinationLabel = GetNextLabel(false);                  addBranchDestination = true;              }              else              {                  // The IF statement has an ELSE clause.                    // Jump past the ELSE body from the end of the IF body:                  Opcode branchPastElse = AddOpcode(new OpcodeBranchJump());                  // This is where the ELSE clause starts:                  branchToFalse.DestinationLabel = GetNextLabel(false);                  // The else body might be at index 4 or 5 depending on if there was an optional EOI.                  int elseBodyIndex = node.Nodes[4].Token.Type == TokenType.ELSE ? 5 : 4;                  VisitNode(node.Nodes[elseBodyIndex]);                  // End of Else body label:                  branchPastElse.DestinationLabel = GetNextLabel(false);                  addBranchDestination = true;              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitUntilStatement,The following statement contains a magic number: VisitNode(node.Nodes[2]);
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,HasParameterStmtNested,The following statement contains a magic number: if (node.Token.Type == TokenType.declare_parameter_clause)              {                  // found one' double check that we don't have an undefaulted param after a defaulted one while we're at it:                  // The logic counts backward here.                  for (int i = node.Nodes.Count-2 ; i > 0 ; i -= 2)                  {                      // If this is an expression' then we have a defaultable optional arg.                      // else we have a mandatory arg.                      TokenType tType = node.Nodes[i].Token.Type;                      bool isOptionalParam = (tType == TokenType.expr);                      if (isOptionalParam)                      {                          if (sawMandatoryParam)                          {                              LineCol location = GetLineCol(node);                              throw new KOSDefaultParamNotAtEndException(location);                          }                            i -= 2; // skip back a bit further to pass over the extra terms a defaulter has.                      }                      else                      {                          sawMandatoryParam = true;                      }                  }                                    return true;              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,HasParameterStmtNested,The following statement contains a magic number: if (node.Token.Type == TokenType.declare_parameter_clause)              {                  // found one' double check that we don't have an undefaulted param after a defaulted one while we're at it:                  // The logic counts backward here.                  for (int i = node.Nodes.Count-2 ; i > 0 ; i -= 2)                  {                      // If this is an expression' then we have a defaultable optional arg.                      // else we have a mandatory arg.                      TokenType tType = node.Nodes[i].Token.Type;                      bool isOptionalParam = (tType == TokenType.expr);                      if (isOptionalParam)                      {                          if (sawMandatoryParam)                          {                              LineCol location = GetLineCol(node);                              throw new KOSDefaultParamNotAtEndException(location);                          }                            i -= 2; // skip back a bit further to pass over the extra terms a defaulter has.                      }                      else                      {                          sawMandatoryParam = true;                      }                  }                                    return true;              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,HasParameterStmtNested,The following statement contains a magic number: if (node.Token.Type == TokenType.declare_parameter_clause)              {                  // found one' double check that we don't have an undefaulted param after a defaulted one while we're at it:                  // The logic counts backward here.                  for (int i = node.Nodes.Count-2 ; i > 0 ; i -= 2)                  {                      // If this is an expression' then we have a defaultable optional arg.                      // else we have a mandatory arg.                      TokenType tType = node.Nodes[i].Token.Type;                      bool isOptionalParam = (tType == TokenType.expr);                      if (isOptionalParam)                      {                          if (sawMandatoryParam)                          {                              LineCol location = GetLineCol(node);                              throw new KOSDefaultParamNotAtEndException(location);                          }                            i -= 2; // skip back a bit further to pass over the extra terms a defaulter has.                      }                      else                      {                          sawMandatoryParam = true;                      }                  }                                    return true;              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitLockStatement,The following statement contains a magic number: int expressionHash = ConcatenateNodes(node.Nodes[3]).GetHashCode();
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitWaitStatement,The following statement contains a magic number: if (node.Nodes.Count == 3)              {                  // For commands of the form:  WAIT N. where N is a number:                  VisitNode(node.Nodes[1]);                  AddOpcode(new OpcodeWait());              }              else              {                  // For commands of the form:  WAIT UNTIL expr. where expr is any boolean expression:                  Opcode waitLoopStart = AddOpcode(new OpcodePush(0));       // Loop start: Gives OpcodeWait an argument of zero.                  AddOpcode(new OpcodeWait());                               // Avoid busy polling.  Even a WAIT 0 still forces 1 fixedupdate 'tick'.                  VisitNode(node.Nodes[2]);                                  // Inserts instructions here to evaluate the expression                  AddOpcode(new OpcodeBranchIfFalse()' waitLoopStart.Label); // Repeat the loop as long as expression is false.                  // Falls through to whatever comes next when expression is true.              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitWaitStatement,The following statement contains a magic number: if (node.Nodes.Count == 3)              {                  // For commands of the form:  WAIT N. where N is a number:                  VisitNode(node.Nodes[1]);                  AddOpcode(new OpcodeWait());              }              else              {                  // For commands of the form:  WAIT UNTIL expr. where expr is any boolean expression:                  Opcode waitLoopStart = AddOpcode(new OpcodePush(0));       // Loop start: Gives OpcodeWait an argument of zero.                  AddOpcode(new OpcodeWait());                               // Avoid busy polling.  Even a WAIT 0 still forces 1 fixedupdate 'tick'.                  VisitNode(node.Nodes[2]);                                  // Inserts instructions here to evaluate the expression                  AddOpcode(new OpcodeBranchIfFalse()' waitLoopStart.Label); // Repeat the loop as long as expression is false.                  // Falls through to whatever comes next when expression is true.              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitDeclareStatement,The following statement contains a magic number: if (lastSubNode.Token.Type == TokenType.declare_identifier_clause)              {                  VisitNode(lastSubNode.Nodes[2]);                  AddOpcode(CreateAppropriateStoreCode(whereToStore' true' "$" + GetIdentifierText(lastSubNode.Nodes[0])));              }                            // If the declare statement is of the form:              //    DECLARE PARAMETER ident.              // or              //    DECLARE PARAMETER ident IS expr.              // or              //    DECLARE PARAMETER ident'ident'ident...              // or              //    DECLARE PARAMETER ident'ident'ident IS expr' ident IS EXPR...              else if (lastSubNode.Token.Type == TokenType.declare_parameter_clause)              {                  for (int i = 1 ; i < lastSubNode.Nodes.Count ; i += 2)                  {                      bool hasInit = ( i < lastSubNode.Nodes.Count - 2 &&                                      ( lastSubNode.Nodes[i+1].Token.Type == TokenType.IS ||                                       lastSubNode.Nodes[i+1].Token.Type == TokenType.TO )                                     );                      ParseNode initExpressionNode = hasInit ? lastSubNode.Nodes[i+2] : null;                      VisitDeclareOneParameter(whereToStore' lastSubNode.Nodes[i]' initExpressionNode);                      if (hasInit)                      {                          i += 2; // skip the "TO expr" part when looking for the next param.                      }                  }              }                            // If the declare statement is of the form:              //    DECLARE [GLOBAL|LOCAL] LOCK FOO TO expr.              else if (lastSubNode.Token.Type == TokenType.declare_lock_clause)              {                  VisitLockStatement(lastSubNode' whereToStore);              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitDeclareStatement,The following statement contains a magic number: if (lastSubNode.Token.Type == TokenType.declare_identifier_clause)              {                  VisitNode(lastSubNode.Nodes[2]);                  AddOpcode(CreateAppropriateStoreCode(whereToStore' true' "$" + GetIdentifierText(lastSubNode.Nodes[0])));              }                            // If the declare statement is of the form:              //    DECLARE PARAMETER ident.              // or              //    DECLARE PARAMETER ident IS expr.              // or              //    DECLARE PARAMETER ident'ident'ident...              // or              //    DECLARE PARAMETER ident'ident'ident IS expr' ident IS EXPR...              else if (lastSubNode.Token.Type == TokenType.declare_parameter_clause)              {                  for (int i = 1 ; i < lastSubNode.Nodes.Count ; i += 2)                  {                      bool hasInit = ( i < lastSubNode.Nodes.Count - 2 &&                                      ( lastSubNode.Nodes[i+1].Token.Type == TokenType.IS ||                                       lastSubNode.Nodes[i+1].Token.Type == TokenType.TO )                                     );                      ParseNode initExpressionNode = hasInit ? lastSubNode.Nodes[i+2] : null;                      VisitDeclareOneParameter(whereToStore' lastSubNode.Nodes[i]' initExpressionNode);                      if (hasInit)                      {                          i += 2; // skip the "TO expr" part when looking for the next param.                      }                  }              }                            // If the declare statement is of the form:              //    DECLARE [GLOBAL|LOCAL] LOCK FOO TO expr.              else if (lastSubNode.Token.Type == TokenType.declare_lock_clause)              {                  VisitLockStatement(lastSubNode' whereToStore);              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitDeclareStatement,The following statement contains a magic number: if (lastSubNode.Token.Type == TokenType.declare_identifier_clause)              {                  VisitNode(lastSubNode.Nodes[2]);                  AddOpcode(CreateAppropriateStoreCode(whereToStore' true' "$" + GetIdentifierText(lastSubNode.Nodes[0])));              }                            // If the declare statement is of the form:              //    DECLARE PARAMETER ident.              // or              //    DECLARE PARAMETER ident IS expr.              // or              //    DECLARE PARAMETER ident'ident'ident...              // or              //    DECLARE PARAMETER ident'ident'ident IS expr' ident IS EXPR...              else if (lastSubNode.Token.Type == TokenType.declare_parameter_clause)              {                  for (int i = 1 ; i < lastSubNode.Nodes.Count ; i += 2)                  {                      bool hasInit = ( i < lastSubNode.Nodes.Count - 2 &&                                      ( lastSubNode.Nodes[i+1].Token.Type == TokenType.IS ||                                       lastSubNode.Nodes[i+1].Token.Type == TokenType.TO )                                     );                      ParseNode initExpressionNode = hasInit ? lastSubNode.Nodes[i+2] : null;                      VisitDeclareOneParameter(whereToStore' lastSubNode.Nodes[i]' initExpressionNode);                      if (hasInit)                      {                          i += 2; // skip the "TO expr" part when looking for the next param.                      }                  }              }                            // If the declare statement is of the form:              //    DECLARE [GLOBAL|LOCAL] LOCK FOO TO expr.              else if (lastSubNode.Token.Type == TokenType.declare_lock_clause)              {                  VisitLockStatement(lastSubNode' whereToStore);              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitDeclareStatement,The following statement contains a magic number: if (lastSubNode.Token.Type == TokenType.declare_identifier_clause)              {                  VisitNode(lastSubNode.Nodes[2]);                  AddOpcode(CreateAppropriateStoreCode(whereToStore' true' "$" + GetIdentifierText(lastSubNode.Nodes[0])));              }                            // If the declare statement is of the form:              //    DECLARE PARAMETER ident.              // or              //    DECLARE PARAMETER ident IS expr.              // or              //    DECLARE PARAMETER ident'ident'ident...              // or              //    DECLARE PARAMETER ident'ident'ident IS expr' ident IS EXPR...              else if (lastSubNode.Token.Type == TokenType.declare_parameter_clause)              {                  for (int i = 1 ; i < lastSubNode.Nodes.Count ; i += 2)                  {                      bool hasInit = ( i < lastSubNode.Nodes.Count - 2 &&                                      ( lastSubNode.Nodes[i+1].Token.Type == TokenType.IS ||                                       lastSubNode.Nodes[i+1].Token.Type == TokenType.TO )                                     );                      ParseNode initExpressionNode = hasInit ? lastSubNode.Nodes[i+2] : null;                      VisitDeclareOneParameter(whereToStore' lastSubNode.Nodes[i]' initExpressionNode);                      if (hasInit)                      {                          i += 2; // skip the "TO expr" part when looking for the next param.                      }                  }              }                            // If the declare statement is of the form:              //    DECLARE [GLOBAL|LOCAL] LOCK FOO TO expr.              else if (lastSubNode.Token.Type == TokenType.declare_lock_clause)              {                  VisitLockStatement(lastSubNode' whereToStore);              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitDeclareStatement,The following statement contains a magic number: if (lastSubNode.Token.Type == TokenType.declare_identifier_clause)              {                  VisitNode(lastSubNode.Nodes[2]);                  AddOpcode(CreateAppropriateStoreCode(whereToStore' true' "$" + GetIdentifierText(lastSubNode.Nodes[0])));              }                            // If the declare statement is of the form:              //    DECLARE PARAMETER ident.              // or              //    DECLARE PARAMETER ident IS expr.              // or              //    DECLARE PARAMETER ident'ident'ident...              // or              //    DECLARE PARAMETER ident'ident'ident IS expr' ident IS EXPR...              else if (lastSubNode.Token.Type == TokenType.declare_parameter_clause)              {                  for (int i = 1 ; i < lastSubNode.Nodes.Count ; i += 2)                  {                      bool hasInit = ( i < lastSubNode.Nodes.Count - 2 &&                                      ( lastSubNode.Nodes[i+1].Token.Type == TokenType.IS ||                                       lastSubNode.Nodes[i+1].Token.Type == TokenType.TO )                                     );                      ParseNode initExpressionNode = hasInit ? lastSubNode.Nodes[i+2] : null;                      VisitDeclareOneParameter(whereToStore' lastSubNode.Nodes[i]' initExpressionNode);                      if (hasInit)                      {                          i += 2; // skip the "TO expr" part when looking for the next param.                      }                  }              }                            // If the declare statement is of the form:              //    DECLARE [GLOBAL|LOCAL] LOCK FOO TO expr.              else if (lastSubNode.Token.Type == TokenType.declare_lock_clause)              {                  VisitLockStatement(lastSubNode' whereToStore);              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitPrintStatement,The following statement contains a magic number: if (node.Nodes.Count == 3)              {                  AddOpcode(new OpcodePush(new KOSArgMarkerType()));                  VisitNode(node.Nodes[1]);                  AddOpcode(new OpcodeCall("print()"));                  AddOpcode(new OpcodePop()); // all functions now return a value even if it's a dummy we ignore.              }              else              {                  AddOpcode(new OpcodePush(new KOSArgMarkerType()));                  VisitNode(node.Nodes[1]);                  VisitNode(node.Nodes[4]);                  VisitNode(node.Nodes[6]);                  AddOpcode(new OpcodeCall("printat()"));                  AddOpcode(new OpcodePop()); // all functions now return a value even if it's a dummy we ignore.              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitPrintStatement,The following statement contains a magic number: if (node.Nodes.Count == 3)              {                  AddOpcode(new OpcodePush(new KOSArgMarkerType()));                  VisitNode(node.Nodes[1]);                  AddOpcode(new OpcodeCall("print()"));                  AddOpcode(new OpcodePop()); // all functions now return a value even if it's a dummy we ignore.              }              else              {                  AddOpcode(new OpcodePush(new KOSArgMarkerType()));                  VisitNode(node.Nodes[1]);                  VisitNode(node.Nodes[4]);                  VisitNode(node.Nodes[6]);                  AddOpcode(new OpcodeCall("printat()"));                  AddOpcode(new OpcodePop()); // all functions now return a value even if it's a dummy we ignore.              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitPrintStatement,The following statement contains a magic number: if (node.Nodes.Count == 3)              {                  AddOpcode(new OpcodePush(new KOSArgMarkerType()));                  VisitNode(node.Nodes[1]);                  AddOpcode(new OpcodeCall("print()"));                  AddOpcode(new OpcodePop()); // all functions now return a value even if it's a dummy we ignore.              }              else              {                  AddOpcode(new OpcodePush(new KOSArgMarkerType()));                  VisitNode(node.Nodes[1]);                  VisitNode(node.Nodes[4]);                  VisitNode(node.Nodes[6]);                  AddOpcode(new OpcodeCall("printat()"));                  AddOpcode(new OpcodePop()); // all functions now return a value even if it's a dummy we ignore.              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitRunStatement,The following statement contains a magic number: if (stmt_type == TokenType.RUN)              {                  // RUN FILEIDENT BRACKETOPEN arglist? BRACKETCLOSE (ON expr)? EOI                  // 0th 1st       2nd         3rd      4th          5th 6th    7th                   hasOnce = false;  // for now.  Will change later if it's present.                                progNameIndex = 1;                  argListIndex = 3;                  volumeIndex = 3; // if argList is missing.  Will increment later if argList is present.              }              else if (stmt_type == TokenType.RUNPATH)              {                  // RUNPATH BRACKETOPEN expr (COMMA arglist)? BRACKETCLOSE EOI                  // 0th     1st         2nd   3rd   4th       5th          6th                  hasOnce = false;                  progNameIndex = 2;                  argListIndex = 4;                  volumeIndex = -99; //archaic syntax we're not supporting anymore.              }              else if (stmt_type == TokenType.RUNONCEPATH)              {                  // RUNONCEPATH BRACKETOPEN expr (COMMA arglist)? BRACKETCLOSE EOI                  // 0th         1st         2nd   3rd   4th       5th          6th                  hasOnce = true;                  progNameIndex = 2;                  argListIndex = 4;                  volumeIndex = -99; //archaic syntax we're not supporting anymore.              }              else              {                  // This "cannot happen".  It's here to remove warnings about using unintialized values.                  throw new KOSYouShouldNeverSeeThisException("kRISC.tpg file does not agree with VisitRunStatement() in Compiler.cs.");              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitRunStatement,The following statement contains a magic number: if (stmt_type == TokenType.RUN)              {                  // RUN FILEIDENT BRACKETOPEN arglist? BRACKETCLOSE (ON expr)? EOI                  // 0th 1st       2nd         3rd      4th          5th 6th    7th                   hasOnce = false;  // for now.  Will change later if it's present.                                progNameIndex = 1;                  argListIndex = 3;                  volumeIndex = 3; // if argList is missing.  Will increment later if argList is present.              }              else if (stmt_type == TokenType.RUNPATH)              {                  // RUNPATH BRACKETOPEN expr (COMMA arglist)? BRACKETCLOSE EOI                  // 0th     1st         2nd   3rd   4th       5th          6th                  hasOnce = false;                  progNameIndex = 2;                  argListIndex = 4;                  volumeIndex = -99; //archaic syntax we're not supporting anymore.              }              else if (stmt_type == TokenType.RUNONCEPATH)              {                  // RUNONCEPATH BRACKETOPEN expr (COMMA arglist)? BRACKETCLOSE EOI                  // 0th         1st         2nd   3rd   4th       5th          6th                  hasOnce = true;                  progNameIndex = 2;                  argListIndex = 4;                  volumeIndex = -99; //archaic syntax we're not supporting anymore.              }              else              {                  // This "cannot happen".  It's here to remove warnings about using unintialized values.                  throw new KOSYouShouldNeverSeeThisException("kRISC.tpg file does not agree with VisitRunStatement() in Compiler.cs.");              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitRunStatement,The following statement contains a magic number: if (stmt_type == TokenType.RUN)              {                  // RUN FILEIDENT BRACKETOPEN arglist? BRACKETCLOSE (ON expr)? EOI                  // 0th 1st       2nd         3rd      4th          5th 6th    7th                   hasOnce = false;  // for now.  Will change later if it's present.                                progNameIndex = 1;                  argListIndex = 3;                  volumeIndex = 3; // if argList is missing.  Will increment later if argList is present.              }              else if (stmt_type == TokenType.RUNPATH)              {                  // RUNPATH BRACKETOPEN expr (COMMA arglist)? BRACKETCLOSE EOI                  // 0th     1st         2nd   3rd   4th       5th          6th                  hasOnce = false;                  progNameIndex = 2;                  argListIndex = 4;                  volumeIndex = -99; //archaic syntax we're not supporting anymore.              }              else if (stmt_type == TokenType.RUNONCEPATH)              {                  // RUNONCEPATH BRACKETOPEN expr (COMMA arglist)? BRACKETCLOSE EOI                  // 0th         1st         2nd   3rd   4th       5th          6th                  hasOnce = true;                  progNameIndex = 2;                  argListIndex = 4;                  volumeIndex = -99; //archaic syntax we're not supporting anymore.              }              else              {                  // This "cannot happen".  It's here to remove warnings about using unintialized values.                  throw new KOSYouShouldNeverSeeThisException("kRISC.tpg file does not agree with VisitRunStatement() in Compiler.cs.");              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitRunStatement,The following statement contains a magic number: if (stmt_type == TokenType.RUN)              {                  // RUN FILEIDENT BRACKETOPEN arglist? BRACKETCLOSE (ON expr)? EOI                  // 0th 1st       2nd         3rd      4th          5th 6th    7th                   hasOnce = false;  // for now.  Will change later if it's present.                                progNameIndex = 1;                  argListIndex = 3;                  volumeIndex = 3; // if argList is missing.  Will increment later if argList is present.              }              else if (stmt_type == TokenType.RUNPATH)              {                  // RUNPATH BRACKETOPEN expr (COMMA arglist)? BRACKETCLOSE EOI                  // 0th     1st         2nd   3rd   4th       5th          6th                  hasOnce = false;                  progNameIndex = 2;                  argListIndex = 4;                  volumeIndex = -99; //archaic syntax we're not supporting anymore.              }              else if (stmt_type == TokenType.RUNONCEPATH)              {                  // RUNONCEPATH BRACKETOPEN expr (COMMA arglist)? BRACKETCLOSE EOI                  // 0th         1st         2nd   3rd   4th       5th          6th                  hasOnce = true;                  progNameIndex = 2;                  argListIndex = 4;                  volumeIndex = -99; //archaic syntax we're not supporting anymore.              }              else              {                  // This "cannot happen".  It's here to remove warnings about using unintialized values.                  throw new KOSYouShouldNeverSeeThisException("kRISC.tpg file does not agree with VisitRunStatement() in Compiler.cs.");              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitRunStatement,The following statement contains a magic number: if (stmt_type == TokenType.RUN)              {                  // RUN FILEIDENT BRACKETOPEN arglist? BRACKETCLOSE (ON expr)? EOI                  // 0th 1st       2nd         3rd      4th          5th 6th    7th                   hasOnce = false;  // for now.  Will change later if it's present.                                progNameIndex = 1;                  argListIndex = 3;                  volumeIndex = 3; // if argList is missing.  Will increment later if argList is present.              }              else if (stmt_type == TokenType.RUNPATH)              {                  // RUNPATH BRACKETOPEN expr (COMMA arglist)? BRACKETCLOSE EOI                  // 0th     1st         2nd   3rd   4th       5th          6th                  hasOnce = false;                  progNameIndex = 2;                  argListIndex = 4;                  volumeIndex = -99; //archaic syntax we're not supporting anymore.              }              else if (stmt_type == TokenType.RUNONCEPATH)              {                  // RUNONCEPATH BRACKETOPEN expr (COMMA arglist)? BRACKETCLOSE EOI                  // 0th         1st         2nd   3rd   4th       5th          6th                  hasOnce = true;                  progNameIndex = 2;                  argListIndex = 4;                  volumeIndex = -99; //archaic syntax we're not supporting anymore.              }              else              {                  // This "cannot happen".  It's here to remove warnings about using unintialized values.                  throw new KOSYouShouldNeverSeeThisException("kRISC.tpg file does not agree with VisitRunStatement() in Compiler.cs.");              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitRunStatement,The following statement contains a magic number: if (stmt_type == TokenType.RUN)              {                  // RUN FILEIDENT BRACKETOPEN arglist? BRACKETCLOSE (ON expr)? EOI                  // 0th 1st       2nd         3rd      4th          5th 6th    7th                   hasOnce = false;  // for now.  Will change later if it's present.                                progNameIndex = 1;                  argListIndex = 3;                  volumeIndex = 3; // if argList is missing.  Will increment later if argList is present.              }              else if (stmt_type == TokenType.RUNPATH)              {                  // RUNPATH BRACKETOPEN expr (COMMA arglist)? BRACKETCLOSE EOI                  // 0th     1st         2nd   3rd   4th       5th          6th                  hasOnce = false;                  progNameIndex = 2;                  argListIndex = 4;                  volumeIndex = -99; //archaic syntax we're not supporting anymore.              }              else if (stmt_type == TokenType.RUNONCEPATH)              {                  // RUNONCEPATH BRACKETOPEN expr (COMMA arglist)? BRACKETCLOSE EOI                  // 0th         1st         2nd   3rd   4th       5th          6th                  hasOnce = true;                  progNameIndex = 2;                  argListIndex = 4;                  volumeIndex = -99; //archaic syntax we're not supporting anymore.              }              else              {                  // This "cannot happen".  It's here to remove warnings about using unintialized values.                  throw new KOSYouShouldNeverSeeThisException("kRISC.tpg file does not agree with VisitRunStatement() in Compiler.cs.");              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitRunStatement,The following statement contains a magic number: if (stmt_type == TokenType.RUN)              {                  // RUN FILEIDENT BRACKETOPEN arglist? BRACKETCLOSE (ON expr)? EOI                  // 0th 1st       2nd         3rd      4th          5th 6th    7th                   hasOnce = false;  // for now.  Will change later if it's present.                                progNameIndex = 1;                  argListIndex = 3;                  volumeIndex = 3; // if argList is missing.  Will increment later if argList is present.              }              else if (stmt_type == TokenType.RUNPATH)              {                  // RUNPATH BRACKETOPEN expr (COMMA arglist)? BRACKETCLOSE EOI                  // 0th     1st         2nd   3rd   4th       5th          6th                  hasOnce = false;                  progNameIndex = 2;                  argListIndex = 4;                  volumeIndex = -99; //archaic syntax we're not supporting anymore.              }              else if (stmt_type == TokenType.RUNONCEPATH)              {                  // RUNONCEPATH BRACKETOPEN expr (COMMA arglist)? BRACKETCLOSE EOI                  // 0th         1st         2nd   3rd   4th       5th          6th                  hasOnce = true;                  progNameIndex = 2;                  argListIndex = 4;                  volumeIndex = -99; //archaic syntax we're not supporting anymore.              }              else              {                  // This "cannot happen".  It's here to remove warnings about using unintialized values.                  throw new KOSYouShouldNeverSeeThisException("kRISC.tpg file does not agree with VisitRunStatement() in Compiler.cs.");              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitRunStatement,The following statement contains a magic number: if (stmt_type == TokenType.RUN)              {                  // RUN FILEIDENT BRACKETOPEN arglist? BRACKETCLOSE (ON expr)? EOI                  // 0th 1st       2nd         3rd      4th          5th 6th    7th                   hasOnce = false;  // for now.  Will change later if it's present.                                progNameIndex = 1;                  argListIndex = 3;                  volumeIndex = 3; // if argList is missing.  Will increment later if argList is present.              }              else if (stmt_type == TokenType.RUNPATH)              {                  // RUNPATH BRACKETOPEN expr (COMMA arglist)? BRACKETCLOSE EOI                  // 0th     1st         2nd   3rd   4th       5th          6th                  hasOnce = false;                  progNameIndex = 2;                  argListIndex = 4;                  volumeIndex = -99; //archaic syntax we're not supporting anymore.              }              else if (stmt_type == TokenType.RUNONCEPATH)              {                  // RUNONCEPATH BRACKETOPEN expr (COMMA arglist)? BRACKETCLOSE EOI                  // 0th         1st         2nd   3rd   4th       5th          6th                  hasOnce = true;                  progNameIndex = 2;                  argListIndex = 4;                  volumeIndex = -99; //archaic syntax we're not supporting anymore.              }              else              {                  // This "cannot happen".  It's here to remove warnings about using unintialized values.                  throw new KOSYouShouldNeverSeeThisException("kRISC.tpg file does not agree with VisitRunStatement() in Compiler.cs.");              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitRunStatement,The following statement contains a magic number: if (node.Nodes.Count > argListIndex && node.Nodes[argListIndex].Token.Type == TokenType.arglist)              {                  // Run args need to get pushed to the stack in the opposite order to how                  // function args do' because they pass through two levels of OpcodeCall' and                  // thus get reversed twice' whereas function args only get reversed once:                  VisitArgListReversed(node.Nodes[argListIndex]);                  volumeIndex += 3;              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitCompileStatement,The following statement contains a magic number: if (node.Nodes.Count > 3)              {                  // It has a "TO outputfile" clause:                  VisitNode(node.Nodes[3]);              }              else              {                  // It lacks a "TO outputfile" clause' so put a dummy string there for it to                  // detect later during the "load()" function as a flag telling it to                  // calculate the output name:                  AddOpcode(new OpcodePush("-default-compile-out-"));              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitCompileStatement,The following statement contains a magic number: if (node.Nodes.Count > 3)              {                  // It has a "TO outputfile" clause:                  VisitNode(node.Nodes[3]);              }              else              {                  // It lacks a "TO outputfile" clause' so put a dummy string there for it to                  // detect later during the "load()" function as a flag telling it to                  // calculate the output name:                  AddOpcode(new OpcodePush("-default-compile-out-"));              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitSwitchStatement,The following statement contains a magic number: VisitNode(node.Nodes[2]);
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitCopyStatement,The following statement contains a magic number: AddOpcode(new OpcodePush(node.Nodes[2].Token.Type == TokenType.FROM ? "from" : "to"));
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitCopyStatement,The following statement contains a magic number: VisitNode(node.Nodes[3]);
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitRenameStatement,The following statement contains a magic number: int oldNameIndex = 2;
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitRenameStatement,The following statement contains a magic number: int newNameIndex = 4;
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitRenameStatement,The following statement contains a magic number: if (node.Nodes.Count == 5)              {                  oldNameIndex--;                  newNameIndex--;                  AddOpcode(new OpcodePush("file"));                  renameFile = true;              }              else              {                  renameFile = node.Nodes[1].Token.Type == TokenType.FILE;                  AddOpcode(new OpcodePush(renameFile ? "file" : "volume"));              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitDeleteStatement,The following statement contains a magic number: if (node.Nodes.Count == 5)                  VisitNode(node.Nodes[3]);              else                  AddOpcode(new OpcodePush(null));
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitDeleteStatement,The following statement contains a magic number: if (node.Nodes.Count == 5)                  VisitNode(node.Nodes[3]);              else                  AddOpcode(new OpcodePush(null));
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitListStatement,The following statement contains a magic number: bool hasIn = hasIdentifier && (node.Nodes[2].Token.Type == TokenType.IN);
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitListStatement,The following statement contains a magic number: if (hasIn)              {                  // destination variable                  string varName = "$" + GetIdentifierText(node.Nodes[3]);                  // list type                  AddOpcode(new OpcodePush(new KOSArgMarkerType()));                  VisitNode(node.Nodes[1]);                  // build list                  AddOpcode(new OpcodeCall("buildlist()"));                  if (allowLazyGlobal)                      AddOpcode(new OpcodeStore(varName));                  else                      AddOpcode(new OpcodeStoreExist(varName));              }              else              {                  AddOpcode(new OpcodePush(new KOSArgMarkerType()));                  // list type                  if (hasIdentifier)                      VisitNode(node.Nodes[1]);                  else                      AddOpcode(new OpcodePush("files"));                  // print list                  AddOpcode(new OpcodeCall("printlist()"));                  AddOpcode(new OpcodePop()); // all functions now return a value even if it's a dummy we ignore.              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitLogStatement,The following statement contains a magic number: VisitNode(node.Nodes[3]);
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitReturnStatement,The following statement contains a magic number: if (node.Nodes.Count > 2)              {                  VisitNode(node.Nodes[1]);              }              else              {                  AddOpcode(new OpcodePush(0));              }
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitForStatement,The following statement contains a magic number: string iteratorIdentifier = "$" + GetIdentifierText(node.Nodes[3]) + "-iterator";
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitForStatement,The following statement contains a magic number: VisitNode(node.Nodes[3]);
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitForStatement,The following statement contains a magic number: VisitNode(node.Nodes[4]);
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitDirective,The following statement contains a magic number: if (directiveNode.Nodes.Count < 2)                  throw new KOSCompileException(new LineCol(lastLine' lastColumn)' "Kerboscript compiler directive ('@') without a keyword after it.");
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitLazyGlobalDirective,The following statement contains a magic number: if (node.Nodes.Count < 3 || node.Nodes[2].Token.Type != TokenType.onoff_trailer)                  throw new KOSCompileException(new LineCol(lastLine' lastColumn)' "Kerboscript compiler directive @LAZYGLOBAL requires an ON or an OFF keyword.");
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitLazyGlobalDirective,The following statement contains a magic number: if (node.Nodes.Count < 3 || node.Nodes[2].Token.Type != TokenType.onoff_trailer)                  throw new KOSCompileException(new LineCol(lastLine' lastColumn)' "Kerboscript compiler directive @LAZYGLOBAL requires an ON or an OFF keyword.");
Magic Number,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitLazyGlobalDirective,The following statement contains a magic number: ParseNode onOffValue = node.Nodes[2].Nodes[0];
Magic Number,kOS.Safe.Compilation.KS,ParseTree,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\ParseTree.cs,PrintNode,The following statement contains a magic number: foreach (ParseNode n in node.Nodes)                  PrintNode(sb' n' indent + 2);
Magic Number,kOS.Safe.Encapsulation.Suffixes,ClampSetSuffix<TValue>,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Suffixes\ClampSetSuffix.cs,Set,The following statement contains a magic number: base.Set(System.Math.Abs(stepIncrement) < 0.0001                  ? KOSMath.Clamp(dblValue' min' max)                  : KOSMath.ClampToIndent(dblValue' min' max' stepIncrement));
Magic Number,kOS.Safe.Encapsulation.Suffixes,ThreeArgsSuffix<TReturn;TParam;TParam2;TParam3>,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Suffixes\ThreeArgsSuffix.cs,Call,The following statement contains a magic number: return (TReturn)del((TParam)args[0]' (TParam2)args[1]' (TParam3)args[2]);
Magic Number,kOS.Safe.Encapsulation.Suffixes,ThreeArgsSuffix<TParam;TParam2;TParam3>,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Encapsulation\Suffixes\ThreeArgsSuffix.cs,Call,The following statement contains a magic number: del((TParam)args[0]' (TParam2)args[1]' (TParam3)args[2]);
Magic Number,kOS.Safe.Execution,ProgramContext,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Execution\ProgramContext.cs,GetCodeFragment,The following statement contains a magic number: for (int index = start; index <= stop; index++)              {                  if (index >= 0 && index < Program.Count)                  {                      long totalTicks = Program[index].ProfileTicksElapsed;                      int  count = Program[index].ProfileExecutionCount;                      string thisLine = string.Format(                          PROFILE_FORMAT_STR'                          codeFragment[2 + (index-start)].PadRight(longestLength)'                          (totalTicks*1000D) / System.Diagnostics.Stopwatch.Frequency'                          count'                          ((totalTicks*1000D) / count) / System.Diagnostics.Stopwatch.Frequency                         );                      profileFragment.Add(thisLine);                  }              }
Magic Number,kOS.Safe.Function,SafeFunctionBase,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Function\SafeFunctionBase.cs,DegreesToRadians,The following statement contains a magic number: return degrees * Math.PI / 180;
Magic Number,kOS.Safe.Function,SafeFunctionBase,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Function\SafeFunctionBase.cs,RadiansToDegrees,The following statement contains a magic number: return radians * 180 / Math.PI;
Magic Number,kOS.Safe.Function,FunctionRound,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Function\Math.cs,Execute,The following statement contains a magic number: switch (argCount)              {              case 1:                  decimals = 0;                  break;              case 2:                  decimals = GetInt(PopValueAssert(shared));                  break;              default:                  throw new KOSArgumentMismatchException(new []{1'2}' argCount);              }
Magic Number,kOS.Safe.Function,FunctionRound,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Function\Math.cs,Execute,The following statement contains a magic number: switch (argCount)              {              case 1:                  decimals = 0;                  break;              case 2:                  decimals = GetInt(PopValueAssert(shared));                  break;              default:                  throw new KOSArgumentMismatchException(new []{1'2}' argCount);              }
Magic Number,kOS.Safe.Function,FunctionRange,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Function\Suffixed.cs,Execute,The following statement contains a magic number: switch (argCount)              {                  case 1:                      to = GetInt(PopStructureAssertEncapsulated(shared));                      break;                  case 2:                      to = GetInt(PopStructureAssertEncapsulated(shared));                      from = GetInt(PopStructureAssertEncapsulated(shared));                      break;                  case 3:                      step = GetInt(PopStructureAssertEncapsulated(shared));                      to = GetInt(PopStructureAssertEncapsulated(shared));                      from = GetInt(PopStructureAssertEncapsulated(shared));                      break;                  default:                      throw new KOSArgumentMismatchException(new int[] { 1' 2' 3 }' argCount' "Thrown from function RANGE()");              }
Magic Number,kOS.Safe.Function,FunctionRange,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Function\Suffixed.cs,Execute,The following statement contains a magic number: switch (argCount)              {                  case 1:                      to = GetInt(PopStructureAssertEncapsulated(shared));                      break;                  case 2:                      to = GetInt(PopStructureAssertEncapsulated(shared));                      from = GetInt(PopStructureAssertEncapsulated(shared));                      break;                  case 3:                      step = GetInt(PopStructureAssertEncapsulated(shared));                      to = GetInt(PopStructureAssertEncapsulated(shared));                      from = GetInt(PopStructureAssertEncapsulated(shared));                      break;                  default:                      throw new KOSArgumentMismatchException(new int[] { 1' 2' 3 }' argCount' "Thrown from function RANGE()");              }
Magic Number,kOS.Safe.Function,FunctionRange,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Function\Suffixed.cs,Execute,The following statement contains a magic number: switch (argCount)              {                  case 1:                      to = GetInt(PopStructureAssertEncapsulated(shared));                      break;                  case 2:                      to = GetInt(PopStructureAssertEncapsulated(shared));                      from = GetInt(PopStructureAssertEncapsulated(shared));                      break;                  case 3:                      step = GetInt(PopStructureAssertEncapsulated(shared));                      to = GetInt(PopStructureAssertEncapsulated(shared));                      from = GetInt(PopStructureAssertEncapsulated(shared));                      break;                  default:                      throw new KOSArgumentMismatchException(new int[] { 1' 2' 3 }' argCount' "Thrown from function RANGE()");              }
Magic Number,kOS.Safe.Function,FunctionRange,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Function\Suffixed.cs,Execute,The following statement contains a magic number: switch (argCount)              {                  case 1:                      to = GetInt(PopStructureAssertEncapsulated(shared));                      break;                  case 2:                      to = GetInt(PopStructureAssertEncapsulated(shared));                      from = GetInt(PopStructureAssertEncapsulated(shared));                      break;                  case 3:                      step = GetInt(PopStructureAssertEncapsulated(shared));                      to = GetInt(PopStructureAssertEncapsulated(shared));                      from = GetInt(PopStructureAssertEncapsulated(shared));                      break;                  default:                      throw new KOSArgumentMismatchException(new int[] { 1' 2' 3 }' argCount' "Thrown from function RANGE()");              }
Magic Number,kOS.Safe.Function,FunctionAngleDiff,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Function\Trigonometry.cs,Execute,The following statement contains a magic number: double result = KOSMath.DegreeFix( ang2 - ang1' -180 );
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,SimpleJson,The following statement contains a magic number: EscapeTable = new char[93];
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,EscapeToJavascriptString,The following statement contains a magic number: for (int i = 0; i < jsonString.Length; )              {                  c = jsonString[i++];                    if (c == '\\')                  {                      int remainingLength = jsonString.Length - i;                      if (remainingLength >= 2)                      {                          char lookahead = jsonString[i];                          if (lookahead == '\\')                          {                              sb.Append('\\');                              ++i;                          }                          else if (lookahead == '"')                          {                              sb.Append("\"");                              ++i;                          }                          else if (lookahead == 't')                          {                              sb.Append('\t');                              ++i;                          }                          else if (lookahead == 'b')                          {                              sb.Append('\b');                              ++i;                          }                          else if (lookahead == 'n')                          {                              sb.Append('\n');                              ++i;                          }                          else if (lookahead == 'r')                          {                              sb.Append('\r');                              ++i;                          }                      }                  }                  else                  {                      sb.Append(c);                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ConvertFromUtf32,The following statement contains a magic number: return new string(new char[] { (char)((utf32 >> 10) + 0xD800)' (char)(utf32 % 0x0400 + 0xDC00) });
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,SimpleJson,The following statement contains a magic number: EscapeTable = new char[93];
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,EscapeToJavascriptString,The following statement contains a magic number: for (int i = 0; i < jsonString.Length; )              {                  c = jsonString[i++];                    if (c == '\\')                  {                      int remainingLength = jsonString.Length - i;                      if (remainingLength >= 2)                      {                          char lookahead = jsonString[i];                          if (lookahead == '\\')                          {                              sb.Append('\\');                              ++i;                          }                          else if (lookahead == '"')                          {                              sb.Append("\"");                              ++i;                          }                          else if (lookahead == 't')                          {                              sb.Append('\t');                              ++i;                          }                          else if (lookahead == 'b')                          {                              sb.Append('\b');                              ++i;                          }                          else if (lookahead == 'n')                          {                              sb.Append('\n');                              ++i;                          }                          else if (lookahead == 'r')                          {                              sb.Append('\r');                              ++i;                          }                      }                  }                  else                  {                      sb.Append(c);                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ConvertFromUtf32,The following statement contains a magic number: return new string(new char[] { (char)((utf32 >> 10) + 0xD800)' (char)(utf32 % 0x0400 + 0xDC00) });
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,kOS.Safe.Persistence,Archive,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Persistence\Archive.cs,RequiredPower,The following statement contains a magic number: const int MULTIPLIER = 5;
Magic Number,kOS.Safe.Persistence,PersistenceUtilities,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Persistence\PersistenceUtilities.cs,IdentifyCategory,The following statement contains a magic number: var firstFour = new byte[4];
Magic Number,kOS.Safe.Persistence,PersistenceUtilities,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Persistence\PersistenceUtilities.cs,IdentifyCategory,The following statement contains a magic number: int atMostFour = System.Math.Min(4' firstBytes.Length);
Magic Number,kOS.Safe.Persistence,PersistenceUtilities,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Persistence\PersistenceUtilities.cs,IdentifyCategory,The following statement contains a magic number: var returnCat = atMostFour < 4 ? FileCategory.TOOSHORT : FileCategory.BINARY;
Magic Number,kOS.Safe.Persistence,PersistenceUtilities,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Persistence\PersistenceUtilities.cs,IdentifyCategory,The following statement contains a magic number: if (firstFour.SequenceEqual(CompiledObject.MagicId) || firstFour.SequenceEqual(GzipHeader))              {                  returnCat = FileCategory.KSM;              }              else              {                  bool isAscii = firstFour.All(b => b == (byte)'\n' || b == (byte)'\t' || b == (byte)'\r' || (b >= (byte)32 && b <= (byte)127));                  if (isAscii)                      returnCat = FileCategory.ASCII;              }
Magic Number,kOS.Safe.Persistence,PersistenceUtilities,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Persistence\PersistenceUtilities.cs,IdentifyCategory,The following statement contains a magic number: if (firstFour.SequenceEqual(CompiledObject.MagicId) || firstFour.SequenceEqual(GzipHeader))              {                  returnCat = FileCategory.KSM;              }              else              {                  bool isAscii = firstFour.All(b => b == (byte)'\n' || b == (byte)'\t' || b == (byte)'\r' || (b >= (byte)32 && b <= (byte)127));                  if (isAscii)                      returnCat = FileCategory.ASCII;              }
Magic Number,kOS.Safe.Persistence,PersistenceUtilities,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Persistence\PersistenceUtilities.cs,DecodeLine,The following statement contains a magic number: for (int inputPos = 0; inputPos < input.Length; ++inputPos)              {                  char ch = input[inputPos];                  if (ch == '&')                  {                      // The reason for catching all these exception cases is because people might use this                      // new code to try to read files that the old buggy code wrote out incorrectly:                      if (input[inputPos + 1] != '#')                          throw new KOSPersistenceException("Improperly encoded saved file contains '&' without '#'");                      int semicolonPos = input.IndexOf(';'' inputPos);                      if (semicolonPos < 0)                          throw new KOSPersistenceException("Improperly encoded saved file contains '&' without closing ';'");                      int charOrdinal;                      if (!int.TryParse(input.Substring(inputPos + 2' semicolonPos - (inputPos + 2))' out charOrdinal))                          throw new KOSPersistenceException("Improperly encoded saved file contains non-digits between the '&#' and the ';'");                      output.Append((char)charOrdinal);                      inputPos = semicolonPos; // skip to the end of the encoding section' as if everything between '&' and ';' was one char of input.                  }                  else                  {                      output.Append(ch);                  }              }
Magic Number,kOS.Safe.Persistence,PersistenceUtilities,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Persistence\PersistenceUtilities.cs,DecodeLine,The following statement contains a magic number: for (int inputPos = 0; inputPos < input.Length; ++inputPos)              {                  char ch = input[inputPos];                  if (ch == '&')                  {                      // The reason for catching all these exception cases is because people might use this                      // new code to try to read files that the old buggy code wrote out incorrectly:                      if (input[inputPos + 1] != '#')                          throw new KOSPersistenceException("Improperly encoded saved file contains '&' without '#'");                      int semicolonPos = input.IndexOf(';'' inputPos);                      if (semicolonPos < 0)                          throw new KOSPersistenceException("Improperly encoded saved file contains '&' without closing ';'");                      int charOrdinal;                      if (!int.TryParse(input.Substring(inputPos + 2' semicolonPos - (inputPos + 2))' out charOrdinal))                          throw new KOSPersistenceException("Improperly encoded saved file contains non-digits between the '&#' and the ';'");                      output.Append((char)charOrdinal);                      inputPos = semicolonPos; // skip to the end of the encoding section' as if everything between '&' and ';' was one char of input.                  }                  else                  {                      output.Append(ch);                  }              }
Magic Number,kOS.Safe.Persistence,PersistenceUtilities,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Persistence\PersistenceUtilities.cs,DecodeBase64ToBinary,The following statement contains a magic number: using (var inputStream = new MemoryStream(inputBuffer))              {                  // mono requires an installed zlib library for GZipStream to work :(                  //using (var zipStream = new GZipStream(inputStream' CompressionMode.Decompress))                  using (var zipStream = new GZipInputStream(inputStream))                  {                      using (var decompressedStream = new MemoryStream())                      {                          var buffer = new byte[4096];                          int read;                            while ((read = zipStream.Read(buffer' 0' buffer.Length)) > 0)                          {                              decompressedStream.Write(buffer' 0' read);                          }                            return decompressedStream.ToArray();                      }                  }              }
Magic Number,kOS.Safe.Persistence,GlobalPath,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Persistence\GlobalPath.cs,GetHashCode,The following statement contains a magic number: return 13 * VolumeId.GetHashCode() + base.GetHashCode();
Magic Number,kOS.Safe.Screen,ScreenBuffer,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Screen\ScreenBuffer.cs,DebugDump,The following statement contains a magic number: for (int i = 0; i < buffer.Count; ++i)              {                  sb.Append(" line " + i + " = [");                  for (int j = 0; j < buffer[i].Length; ++j)                  {                      char ch = buffer[i][j];                      sb.Append((int)ch < 32 ? (" \\" + (int)ch) : (" " + ch));                  }                  sb.Append("]\n");              }
Magic Number,kOS.Safe.Screen,SubBuffer,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Screen\SubBuffer.cs,DebugDump,The following statement contains a magic number: for (int i = 0; i < Buffer.Count ; ++i)              {                  sb.Append(" line "+i+" = [");                  for (int j = 0 ; j < Buffer[i].Length ; ++j)                  {                      char ch = Buffer[i][j];                      sb.Append((int)ch < 32 ? (" \\"+(int)ch) : (" "+ch) );                  }                  sb.Append("]\n");              }
Magic Number,kOS.Safe.Screen,TextEditor,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Screen\TextEditor.cs,Type,The following statement contains a magic number: switch ((int)ch)              {                  case 8:  // backspace                      if (TryMoveCursor(-1)) RemoveChar();                      break;                  case 13:  // enter                      NewLine();                      break;                  case 7:                  case (char)UnicodeCommand.BEEP:                      ++base.BeepsPending;                      break;                  default:                      InsertChar(ch);                      break;              }
Magic Number,kOS.Safe.Screen,TextEditor,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Screen\TextEditor.cs,Type,The following statement contains a magic number: switch ((int)ch)              {                  case 8:  // backspace                      if (TryMoveCursor(-1)) RemoveChar();                      break;                  case 13:  // enter                      NewLine();                      break;                  case 7:                  case (char)UnicodeCommand.BEEP:                      ++base.BeepsPending;                      break;                  default:                      InsertChar(ch);                      break;              }
Magic Number,kOS.Safe.Screen,TextEditor,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Screen\TextEditor.cs,Type,The following statement contains a magic number: switch ((int)ch)              {                  case 8:  // backspace                      if (TryMoveCursor(-1)) RemoveChar();                      break;                  case 13:  // enter                      NewLine();                      break;                  case 7:                  case (char)UnicodeCommand.BEEP:                      ++base.BeepsPending;                      break;                  default:                      InsertChar(ch);                      break;              }
Magic Number,kOS.Safe.Screen,TextEditor,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Screen\TextEditor.cs,SpecialKey,The following statement contains a magic number: switch (key)              {                  case (char)UnicodeCommand.LEFTCURSORONE:                      TryMoveCursor(-1);                      break;                  case (char)UnicodeCommand.RIGHTCURSORONE:                      TryMoveCursor(1);                      break;                  case (char)0x0001: // control-A' same as home key                  case (char)UnicodeCommand.HOMECURSOR:                      LineCursorIndex = 0;                      UpdateSubBufferCursor();                      break;                  case (char)0x0005: // control-E' same as end key                  case (char)UnicodeCommand.ENDCURSOR:                      LineCursorIndex = LineBuilder.Length;                      UpdateSubBufferCursor();                      break;                  case (char)UnicodeCommand.DELETERIGHT:                      RemoveChar();                      break;                  case (char)UnicodeCommand.PAGEUPCURSOR:                      ScrollVertical(-10);                      break;                  case (char)UnicodeCommand.PAGEDOWNCURSOR:                      ScrollVertical(10);                      break;                  case (char)0x007:                  case (char)UnicodeCommand.BEEP:                      ++base.BeepsPending;                      break;                  default:                      gotUsed = false;                      break;              }
Magic Number,kOS.Safe.Screen,TextEditor,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Screen\TextEditor.cs,SpecialKey,The following statement contains a magic number: switch (key)              {                  case (char)UnicodeCommand.LEFTCURSORONE:                      TryMoveCursor(-1);                      break;                  case (char)UnicodeCommand.RIGHTCURSORONE:                      TryMoveCursor(1);                      break;                  case (char)0x0001: // control-A' same as home key                  case (char)UnicodeCommand.HOMECURSOR:                      LineCursorIndex = 0;                      UpdateSubBufferCursor();                      break;                  case (char)0x0005: // control-E' same as end key                  case (char)UnicodeCommand.ENDCURSOR:                      LineCursorIndex = LineBuilder.Length;                      UpdateSubBufferCursor();                      break;                  case (char)UnicodeCommand.DELETERIGHT:                      RemoveChar();                      break;                  case (char)UnicodeCommand.PAGEUPCURSOR:                      ScrollVertical(-10);                      break;                  case (char)UnicodeCommand.PAGEDOWNCURSOR:                      ScrollVertical(10);                      break;                  case (char)0x007:                  case (char)UnicodeCommand.BEEP:                      ++base.BeepsPending;                      break;                  default:                      gotUsed = false;                      break;              }
Magic Number,kOS.Safe.Utilities,MovingAverage,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Utilities\MovingAverage.cs,MovingAverage,The following statement contains a magic number: SampleLimit = 30;
Magic Number,kOS.Safe.Utilities,KOSMath,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Utilities\kosMath.cs,DegreeFix,The following statement contains a magic number: double rangeEnd = rangeStart + 360.0;
Magic Number,kOS.Safe.Utilities,KOSMath,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Utilities\kosMath.cs,DegreeFix,The following statement contains a magic number: while (outAngle > rangeEnd)                  outAngle -= 360.0;
Magic Number,kOS.Safe.Utilities,KOSMath,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Utilities\kosMath.cs,DegreeFix,The following statement contains a magic number: while (outAngle < rangeStart)                  outAngle += 360.0;
Magic Number,kOS.Safe.Serialization,TerminalFormatter,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Serialization\TerminalFormatter.cs,WriteIndented,The following statement contains a magic number: if (dump.Count == 1 && dump.ContainsKey(Dump.Items)) {                  // special handling for enumerables                  List<object> list = dump[Dump.Items] as List<object>;                  printedDump = list.Select((x' i) => new { Item = x' Index = (object)i })                      .ToDictionary(x => x.Index' x => x.Item);              } else if (dump.Count == 1 && dump.ContainsKey(Dump.Entries)) {                  // special handling for lexicons                  List<object> list = dump[Dump.Entries] as List<object>;                    printedDump = new Dictionary<object' object>();                    for (int i = 0; 2 * i < list.Count; i++)                  {                      printedDump[list[2 * i]] = list[2 * i + 1];                  }              } else {                  printedDump = dump;              }
Magic Number,kOS.Safe.Serialization,TerminalFormatter,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Serialization\TerminalFormatter.cs,WriteIndented,The following statement contains a magic number: if (dump.Count == 1 && dump.ContainsKey(Dump.Items)) {                  // special handling for enumerables                  List<object> list = dump[Dump.Items] as List<object>;                  printedDump = list.Select((x' i) => new { Item = x' Index = (object)i })                      .ToDictionary(x => x.Index' x => x.Item);              } else if (dump.Count == 1 && dump.ContainsKey(Dump.Entries)) {                  // special handling for lexicons                  List<object> list = dump[Dump.Entries] as List<object>;                    printedDump = new Dictionary<object' object>();                    for (int i = 0; 2 * i < list.Count; i++)                  {                      printedDump[list[2 * i]] = list[2 * i + 1];                  }              } else {                  printedDump = dump;              }
Magic Number,kOS.Safe.Serialization,TerminalFormatter,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Serialization\TerminalFormatter.cs,WriteIndented,The following statement contains a magic number: if (dump.Count == 1 && dump.ContainsKey(Dump.Items)) {                  // special handling for enumerables                  List<object> list = dump[Dump.Items] as List<object>;                  printedDump = list.Select((x' i) => new { Item = x' Index = (object)i })                      .ToDictionary(x => x.Index' x => x.Item);              } else if (dump.Count == 1 && dump.ContainsKey(Dump.Entries)) {                  // special handling for lexicons                  List<object> list = dump[Dump.Entries] as List<object>;                    printedDump = new Dictionary<object' object>();                    for (int i = 0; 2 * i < list.Count; i++)                  {                      printedDump[list[2 * i]] = list[2 * i + 1];                  }              } else {                  printedDump = dump;              }
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,SimpleJson,The following statement contains a magic number: EscapeTable = new char[93];
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,EscapeToJavascriptString,The following statement contains a magic number: for (int i = 0; i < jsonString.Length; )              {                  c = jsonString[i++];                    if (c == '\\')                  {                      int remainingLength = jsonString.Length - i;                      if (remainingLength >= 2)                      {                          char lookahead = jsonString[i];                          if (lookahead == '\\')                          {                              sb.Append('\\');                              ++i;                          }                          else if (lookahead == '"')                          {                              sb.Append("\"");                              ++i;                          }                          else if (lookahead == 't')                          {                              sb.Append('\t');                              ++i;                          }                          else if (lookahead == 'b')                          {                              sb.Append('\b');                              ++i;                          }                          else if (lookahead == 'n')                          {                              sb.Append('\n');                              ++i;                          }                          else if (lookahead == 'r')                          {                              sb.Append('\r');                              ++i;                          }                      }                  }                  else                  {                      sb.Append(c);                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseString,The following statement contains a magic number: while (!complete)              {                  if (index == json.Length)                      break;                    c = json[index++];                  if (c == '"')                  {                      complete = true;                      break;                  }                  else if (c == '\\')                  {                      if (index == json.Length)                          break;                      c = json[index++];                      if (c == '"')                          s.Append('"');                      else if (c == '\\')                          s.Append('\\');                      else if (c == '/')                          s.Append('/');                      else if (c == 'b')                          s.Append('\b');                      else if (c == 'f')                          s.Append('\f');                      else if (c == 'n')                          s.Append('\n');                      else if (c == 'r')                          s.Append('\r');                      else if (c == 't')                          s.Append('\t');                      else if (c == 'u')                      {                          int remainingLength = json.Length - index;                          if (remainingLength >= 4)                          {                              // parse the 32 bit hex into an integer codepoint                              uint codePoint;                              if (!(success = UInt32.TryParse(new string(json' index' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out codePoint)))                                  return "";                                // convert the integer codepoint to a unicode char and add to string                              if (0xD800 <= codePoint && codePoint <= 0xDBFF)  // if high surrogate                              {                                  index += 4; // skip 4 chars                                  remainingLength = json.Length - index;                                  if (remainingLength >= 6)                                  {                                      uint lowCodePoint;                                      if (new string(json' index' 2) == "\\u" && UInt32.TryParse(new string(json' index + 2' 4)' NumberStyles.HexNumber' CultureInfo.InvariantCulture' out lowCodePoint))                                      {                                          if (0xDC00 <= lowCodePoint && lowCodePoint <= 0xDFFF)    // if low surrogate                                          {                                              s.Append((char)codePoint);                                              s.Append((char)lowCodePoint);                                              index += 6; // skip 6 chars                                              continue;                                          }                                      }                                  }                                  success = false;    // invalid surrogate pair                                  return "";                              }                              s.Append(ConvertFromUtf32((int)codePoint));                              // skip 4 chars                              index += 4;                          }                          else                              break;                      }                  }                  else                      s.Append(c);              }
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ConvertFromUtf32,The following statement contains a magic number: return new string(new char[] { (char)((utf32 >> 10) + 0xD800)' (char)(utf32 % 0x0400 + 0xDC00) });
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 5)              {                  if (json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')                  {                      index += 5;                      return TOKEN_FALSE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')                  {                      index += 4;                      return TOKEN_TRUE;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Magic Number,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following statement contains a magic number: if (remainingLength >= 4)              {                  if (json[index] == 'n' && json[index + 1] == 'u' && json[index + 2] == 'l' && json[index + 3] == 'l')                  {                      index += 4;                      return TOKEN_NULL;                  }              }
Duplicate Code,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_parameter_clause,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 65)' (79' 129))
Duplicate Code,kOS.Safe.Compilation.KS,Parser,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Parser.cs,Parsedeclare_stmt,The method contains a code clone-set at the following line numbers (starting from the method definition): ((44' 70)' (75' 101))
Missing Default,kOS.Safe.Compilation,CompiledObject,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\CompiledObject.cs,UnPack,The following switch statement is missing a default case: switch (sectionTypeId)                  {                      case (byte)'F':                          // new CodePart's always start with the function header:                          var nextPart = new CodePart();                          program.Add(nextPart);                          // If this is the very first code we've ever encountered in the file' remember its position:                          if (codeStart == 0)                              codeStart = (int)(reader.BaseStream.Position - 2); // start is where the ByteCode.DELIMITER of the first section is.                            program[program.Count-1].FunctionsCode = ReadOpcodeList(reader' codeStart' prefix' arguments' argIndexSize);                          break;                      case (byte)'I':                          program[program.Count-1].InitializationCode = ReadOpcodeList(reader' codeStart' prefix' arguments' argIndexSize);                          break;                      case (byte)'M':                          program[program.Count-1].MainCode = ReadOpcodeList(reader' codeStart' prefix' arguments' argIndexSize);                          break;                      case (byte)'D':                          lineMap = new DebugLineMap(reader);                          break;                  }
Missing Default,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,RearrangeLoopFromNode,The following switch statement is missing a default case: switch (node.Nodes[index].Token.Type)                  {                      case TokenType.FROM:                          initBlock = node.Nodes[index+1];                          break;                      case TokenType.UNTIL:                          untilTokenNode = node.Nodes[index];                          checkExpression = node.Nodes[index+1];                          break;                      case TokenType.STEP:                          stepBlock = node.Nodes[index+1];                          break;                      case TokenType.DO:                          doBlock = node.Nodes[index+1];                          break;                      // no default because anything else is a syntax error and it won't even get as far as this method in that case.                  }
Missing Default,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,PreProcessStatements,The following switch statement is missing a default case: switch (node.Token.Type)              {                  // statements that can have a lock inside                  case TokenType.Start:                  case TokenType.instruction_block:                  case TokenType.instruction:                  case TokenType.if_stmt:                  case TokenType.fromloop_stmt:                  case TokenType.until_stmt:                  case TokenType.for_stmt:                  case TokenType.declare_function_clause:                  case TokenType.declare_stmt:                      PreProcessChildNodes(node);                      break;                  case TokenType.on_stmt:                      PreProcessChildNodes(node);                      PreProcessOnStatement(node);                      break;                  case TokenType.when_stmt:                      PreProcessChildNodes(node);                      PreProcessWhenStatement(node);                      break;              }
Missing Default,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitNode,The following switch statement is missing a default case: switch (node.Token.Type)              {                  case TokenType.Start:                      VisitStartStatement(node);                      break;                  case TokenType.instruction:                      VisitChildNodes(node);                      break;                  case TokenType.instruction_block:                      VisitInstructionBlock(node);                      break;                  case TokenType.set_stmt:                      VisitSetStatement(node);                      break;                  case TokenType.if_stmt:                      VisitIfStatement(node);                      break;                  case TokenType.until_stmt:                      VisitUntilStatement(node);                      break;                  case TokenType.fromloop_stmt:                      VisitChildNodes(node); // The loopfrom should have been altered by now' in RearrangeParseNodes().                      break;                  case TokenType.return_stmt:                      VisitReturnStatement(node);                      break;                  case TokenType.unlock_stmt:                      VisitUnlockStatement(node);                      break;                  case TokenType.print_stmt:                      VisitPrintStatement(node);                      break;                  case TokenType.on_stmt:                      VisitOnStatement(node);                      break;                  case TokenType.toggle_stmt:                      VisitToggleStatement(node);                      break;                  case TokenType.wait_stmt:                      VisitWaitStatement(node);                      break;                  case TokenType.when_stmt:                      VisitWhenStatement(node);                      break;                  case TokenType.onoff_trailer:                      VisitOnOffTrailer(node);                      break;                  case TokenType.stage_stmt:                      VisitStageStatement(node);                      break;                  case TokenType.clear_stmt:                      VisitClearStatement(node);                      break;                  case TokenType.add_stmt:                      VisitAddStatement(node);                      break;                  case TokenType.remove_stmt:                      VisitRemoveStatement(node);                      break;                  case TokenType.log_stmt:                      VisitLogStatement(node);                      break;                  case TokenType.break_stmt:                      VisitBreakStatement(node);                      break;                  case TokenType.preserve_stmt:                      VisitPreserveStatement(node);                      break;                  case TokenType.declare_stmt:                      VisitDeclareStatement(node);                      break;                  case TokenType.switch_stmt:                      VisitSwitchStatement(node);                      break;                  case TokenType.copy_stmt:                      VisitCopyStatement(node);                      break;                  case TokenType.rename_stmt:                      VisitRenameStatement(node);                      break;                  case TokenType.delete_stmt:                      VisitDeleteStatement(node);                      break;                  case TokenType.edit_stmt:                      VisitEditStatement(node);                      break;                  case TokenType.run_stmt:                  case TokenType.runpath_stmt:                  case TokenType.runoncepath_stmt:                      VisitRunStatement(node);                      break;                  case TokenType.compile_stmt:                      VisitCompileStatement(node);                      break;                  case TokenType.list_stmt:                      VisitListStatement(node);                      break;                  case TokenType.reboot_stmt:                      VisitRebootStatement(node);                      break;                  case TokenType.shutdown_stmt:                      VisitShutdownStatement(node);                      break;                  case TokenType.for_stmt:                      VisitForStatement(node);                      break;                  case TokenType.unset_stmt:                      VisitUnsetStatement(node);                      break;                  case TokenType.arglist:                      VisitArgList(node);                      break;                  case TokenType.compare_expr: // for issue #20                  case TokenType.arith_expr:                  case TokenType.multdiv_expr:                  case TokenType.factor:                      VisitExpressionChain(node);                      break;                  case TokenType.expr:                      VisitExpr(node);                      break;                  case TokenType.or_expr:                  case TokenType.and_expr:                      VisitShortCircuitBoolean(node);                      break;                  case TokenType.suffix:                      VisitSuffix(node);                      break;                  case TokenType.unary_expr:                      VisitUnaryExpression(node);                      break;                  case TokenType.atom:                      VisitAtom(node);                      break;                  case TokenType.sci_number:                      VisitSciNumber(node);                      break;                  case TokenType.number:                      VisitNumber(node);                      break;                  case TokenType.INTEGER:                      VisitInteger(node);                      break;                  case TokenType.DOUBLE:                      VisitDouble(node);                      break;                  case TokenType.PLUSMINUS:                      VisitPlusMinus(node);                      break;                  case TokenType.MULT:                      VisitMult(node);                      break;                  case TokenType.DIV:                      VisitDiv(node);                      break;                  case TokenType.POWER:                      VisitPower(node);                      break;                  case TokenType.varidentifier:                      VisitVarIdentifier(node);                      break;                  // This never gets called anymore' but it's left here as                  // a comment so future programmers who search for it will                  // find this comment and realized that it's not an error                  // for it to be missing.  It's missing-ness is deliberate:                  // case TokenType.suffixterm:                  //    VisitSuffixTerm(node);                  //    break;                  case TokenType.IDENTIFIER:                      VisitIdentifier(node);                      break;                  case TokenType.FILEIDENT:                      VisitFileIdent(node);                      break;                  case TokenType.STRING:                      VisitString(node);                      break;                  case TokenType.TRUEFALSE:                      VisitTrueFalse(node);                      break;                  case TokenType.COMPARATOR:                      VisitComparator(node);                      break;                  case TokenType.AND:                      VisitAnd(node);                      break;                  case TokenType.OR:                      VisitOr(node);                      break;                  case TokenType.identifier_led_stmt:                      VisitIdentifierLedStatement(node);                      break;                  case TokenType.identifier_led_expr:                      VisitIdentifierLedExpression(node);                      break;                  case TokenType.directive:                      VisitDirective(node);                      break;              }
Missing Default,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitActualArray,The following switch statement is missing a default case: switch (previousNodeType)                  {                      case TokenType.ARRAYINDEX:                          isLastIndex = (nodeIndex == trailerNode.Nodes.Count - 1);                          break;                      case TokenType.SQUAREOPEN:                          isLastIndex = (nodeIndex == trailerNode.Nodes.Count - 2);                          break;                  }
Missing Default,kOS.Safe.Compilation.KS,Compiler,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\Compiler.cs,VisitComparator,The following switch statement is missing a default case: switch (node.Token.Text)              {                  case ">":                      AddOpcode(new OpcodeCompareGT());                      break;                  case "<":                      AddOpcode(new OpcodeCompareLT());                      break;                  case ">=":                      AddOpcode(new OpcodeCompareGTE());                      break;                  case "<=":                      AddOpcode(new OpcodeCompareLTE());                      break;                  case "<>":                      AddOpcode(new OpcodeCompareNE());                      break;                  case "=":                      AddOpcode(new OpcodeCompareEqual());                      break;              }
Missing Default,kOS.Safe.Compilation.KS,KSScript,C:\repos\KSP-KOS_KOS\src\kOS.Safe\Compilation\KS\KSScript.cs,IsCommandComplete,The following switch statement is missing a default case: switch (curChar)                  {                      // Track if we are in a string literal that didn't close'                      // and make sure it's not a string literal inside a comment'                      // because those don't count:                      case '\"':                          if (! inCommentToEoln)                              inQuotes = !(inQuotes);                          break;                      case '/':                          if (prevChar == '/' && !inQuotes )                              inCommentToEoln = true;                          break;                      case '\n':                      case '\r':                          inCommentToEoln = false;                          break;                  }
Missing Default,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseValue,The following switch statement is missing a default case: switch (LookAhead(json' index))              {                  case TOKEN_STRING:                      return ParseString(json' ref index' ref success);                  case TOKEN_NUMBER:                      return ParseNumber(json' ref index' ref success);                  case TOKEN_CURLY_OPEN:                      return ParseObject(json' ref index' ref success);                  case TOKEN_SQUARED_OPEN:                      return ParseArray(json' ref index' ref success);                  case TOKEN_TRUE:                      NextToken(json' ref index);                      return true;                  case TOKEN_FALSE:                      NextToken(json' ref index);                      return false;                  case TOKEN_NULL:                      NextToken(json' ref index);                      return null;                  case TOKEN_NONE:                      break;              }
Missing Default,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following switch statement is missing a default case: switch (c)              {                  case '{':                      return TOKEN_CURLY_OPEN;                  case '}':                      return TOKEN_CURLY_CLOSE;                  case '[':                      return TOKEN_SQUARED_OPEN;                  case ']':                      return TOKEN_SQUARED_CLOSE;                  case ''':                      return TOKEN_COMMA;                  case '"':                      return TOKEN_STRING;                  case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                      return TOKEN_NUMBER;                  case ':':                      return TOKEN_COLON;              }
Missing Default,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseValue,The following switch statement is missing a default case: switch (LookAhead(json' index))              {                  case TOKEN_STRING:                      return ParseString(json' ref index' ref success);                  case TOKEN_NUMBER:                      return ParseNumber(json' ref index' ref success);                  case TOKEN_CURLY_OPEN:                      return ParseObject(json' ref index' ref success);                  case TOKEN_SQUARED_OPEN:                      return ParseArray(json' ref index' ref success);                  case TOKEN_TRUE:                      NextToken(json' ref index);                      return true;                  case TOKEN_FALSE:                      NextToken(json' ref index);                      return false;                  case TOKEN_NULL:                      NextToken(json' ref index);                      return null;                  case TOKEN_NONE:                      break;              }
Missing Default,kOS.Safe,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following switch statement is missing a default case: switch (c)              {                  case '{':                      return TOKEN_CURLY_OPEN;                  case '}':                      return TOKEN_CURLY_CLOSE;                  case '[':                      return TOKEN_SQUARED_OPEN;                  case ']':                      return TOKEN_SQUARED_CLOSE;                  case ''':                      return TOKEN_COMMA;                  case '"':                      return TOKEN_STRING;                  case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                      return TOKEN_NUMBER;                  case ':':                      return TOKEN_COLON;              }
Missing Default,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,ParseValue,The following switch statement is missing a default case: switch (LookAhead(json' index))              {                  case TOKEN_STRING:                      return ParseString(json' ref index' ref success);                  case TOKEN_NUMBER:                      return ParseNumber(json' ref index' ref success);                  case TOKEN_CURLY_OPEN:                      return ParseObject(json' ref index' ref success);                  case TOKEN_SQUARED_OPEN:                      return ParseArray(json' ref index' ref success);                  case TOKEN_TRUE:                      NextToken(json' ref index);                      return true;                  case TOKEN_FALSE:                      NextToken(json' ref index);                      return false;                  case TOKEN_NULL:                      NextToken(json' ref index);                      return null;                  case TOKEN_NONE:                      break;              }
Missing Default,Reflection,SimpleJson,C:\repos\KSP-KOS_KOS\src\kOS.Safe\SimpleJson.cs,NextToken,The following switch statement is missing a default case: switch (c)              {                  case '{':                      return TOKEN_CURLY_OPEN;                  case '}':                      return TOKEN_CURLY_CLOSE;                  case '[':                      return TOKEN_SQUARED_OPEN;                  case ']':                      return TOKEN_SQUARED_CLOSE;                  case ''':                      return TOKEN_COMMA;                  case '"':                      return TOKEN_STRING;                  case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                  case '-':                      return TOKEN_NUMBER;                  case ':':                      return TOKEN_COLON;              }
